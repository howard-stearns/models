var HighFidelityAudio;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../.nvm/versions/node/v14.15.4/lib/node_modules/wrtc/lib/browser.js":
/*!***************************************************************************!*\
  !*** ../.nvm/versions/node/v14.15.4/lib/node_modules/wrtc/lib/browser.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {



exports.MediaStream = window.MediaStream;
exports.MediaStreamTrack = window.MediaStreamTrack;
exports.RTCDataChannel = window.RTCDataChannel;
exports.RTCDataChannelEvent = window.RTCDataChannelEvent;
exports.RTCDtlsTransport = window.RTCDtlsTransport;
exports.RTCIceCandidate = window.RTCIceCandidate;
exports.RTCIceTransport = window.RTCIceTransport;
exports.RTCPeerConnection = window.RTCPeerConnection;
exports.RTCPeerConnectionIceEvent = window.RTCPeerConnectionIceEvent;
exports.RTCRtpReceiver = window.RTCRtpReceiver;
exports.RTCRtpSender = window.RTCRtpSender;
exports.RTCRtpTransceiver = window.RTCRtpTransceiver;
exports.RTCSctpTransport = window.RTCSctpTransport;
exports.RTCSessionDescription = window.RTCSessionDescription;
exports.getUserMedia = window.getUserMedia;
exports.mediaDevices = navigator.mediaDevices;


/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/***/ ((module, exports) => {



// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof global !== 'undefined') { return global; }
	throw new Error('unable to locate global object');
}

var global = getGlobal();

module.exports = exports = global.fetch;

// Needed for TypeScript and Webpack.
if (global.fetch) {
	exports.default = global.fetch.bind(global);
}

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;

/***/ }),

/***/ "./node_modules/pako/dist/pako.esm.mjs":
/*!*********************************************!*\
  !*** ./node_modules/pako/dist/pako.esm.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "Deflate": () => (/* binding */ Deflate_1$1),
/* harmony export */   "Inflate": () => (/* binding */ Inflate_1$1),
/* harmony export */   "constants": () => (/* binding */ constants_1),
/* harmony export */   "deflate": () => (/* binding */ deflate_1$2),
/* harmony export */   "deflateRaw": () => (/* binding */ deflateRaw_1$1),
/* harmony export */   "gzip": () => (/* binding */ gzip_1$1),
/* harmony export */   "inflate": () => (/* binding */ inflate_1$2),
/* harmony export */   "inflateRaw": () => (/* binding */ inflateRaw_1$1),
/* harmony export */   "ungzip": () => (/* binding */ ungzip_1)
/* harmony export */ });

/*! pako 2.0.3 https://github.com/nodeca/pako @license (MIT AND Zlib) */
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH    = 3;
const MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS      = 256;
/* number of literal bytes 0..255 */

const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES       = 30;
/* number of distance codes */

const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

const MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) =>
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  const next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
const copy_block = (s, buf, len, header) =>
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
  s.pending += len;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) =>
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) =>
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let lx = 0;         /* running index in l_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) =>
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let black_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
const _tr_flush_block = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally = (s, dist, lc) =>
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //let out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
};

var _tr_init_1  = _tr_init;
var _tr_stored_block_1 = _tr_stored_block;
var _tr_flush_block_1  = _tr_flush_block;
var _tr_tally_1 = _tr_tally;
var _tr_align_1 = _tr_align;

var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init: _tr_init$1, _tr_stored_block: _tr_stored_block$1, _tr_flush_block: _tr_flush_block$1, _tr_tally: _tr_tally$1, _tr_align: _tr_align$1 } = trees;




/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK,
  Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,
  Z_DEFAULT_COMPRESSION,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED: Z_FIXED$1, Z_DEFAULT_STRATEGY,
  Z_UNKNOWN: Z_UNKNOWN$1,
  Z_DEFLATED
} = constants;

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS$1      = 256;
/* number of literal bytes 0..255 */
const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES$1       = 30;
/* number of distance codes */
const BL_CODES$1      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
/* maximum heap size */
const MAX_BITS$1  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const MIN_LOOKAHEAD = (MAX_MATCH$1 + MIN_MATCH$1 + 1);

const PRESET_DICT = 0x20;

const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
};

const zero$1 = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};


/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block$1(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH$1;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH$1 - (strend - scan);
    scan = strend - MAX_MATCH$1;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH$1) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH$1) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
const deflate_stored = (s, flush) => {

  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  let max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    const max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
};

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH$1) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH$1) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally$1(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH$1) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally$1(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH$1 - 1)) ? s.strstart : MIN_MATCH$1 - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH$1) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH$1 - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH$1 - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH$1;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally$1(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH$1 - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH$1) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH$1;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH$1 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH$1) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally$1(s, 1, s.match_length - MIN_MATCH$1);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally$1(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally$1(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero$1(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE$1 * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES$1 + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES$1 + 1) * 2);
  zero$1(this.dyn_ltree);
  zero$1(this.dyn_dtree);
  zero$1(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES$1 + 1);  /* heap used to build the Huffman trees */
  zero$1(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES$1 + 1); //uch depth[2*L_CODES+1];
  zero$1(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


const deflateResetKeep = (strm) => {

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN$1;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  _tr_init$1(s);
  return Z_OK;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED$1) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
};


const deflate = (strm, flush) => {

  let beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  const s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      let header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      let level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align$1(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block$1(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero$1(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
};


const deflateEnd = (strm) => {

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  const status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero$1(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH$1) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH$1 - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH$1 - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
};


var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2 = deflate;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/

var deflate_1 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo: deflateInfo
};

const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

var assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
var flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};

var common = {
	assign: assign,
	flattenChunks: flattenChunks
};

// String encode/decode helpers


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = (str) => {
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
var buf2string = (buf, max) => {
  let i, out;
  const len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream;

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$1,
  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_DEFLATED: Z_DEFLATED$1
} = constants;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION$1,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY$1
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;

  let status = deflate_1.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK$1) {
    throw new Error(messages[status]);
  }

  if (opt.header) {
    deflate_1.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = deflate_1.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK$1) {
      throw new Error(messages[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = deflate_1.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END$1) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$1;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$1) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate$1(input, options) {
  const deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}


var Deflate_1 = Deflate;
var deflate_2$1 = deflate$1;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var constants$1 = constants;

var deflate_1$1 = {
	Deflate: Deflate_1,
	deflate: deflate_2$1,
	deflateRaw: deflateRaw_1,
	gzip: gzip_1,
	constants: constants$1
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD = 30;       /* got a data error -- remain here until reset */
const TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES = 0;
const LENS = 1;
const DISTS = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
  let base_index = 0;
//  let shoextra;    /* extra bits table to use */
  let end;                    /* use base and extra for symbol > end */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;
  let extra_index = 0;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.






const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$2, Z_BLOCK: Z_BLOCK$1, Z_TREES,
  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2, Z_NEED_DICT, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR, Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFLATED: Z_DEFLATED$2
} = constants;


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 1;       /* i: waiting for magic header */
const    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
const    TIME = 3;       /* i: waiting for modification time (gzip) */
const    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 5;      /* i: waiting for extra length (gzip) */
const    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
const    NAME = 7;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
const    HCRC = 9;       /* i: waiting for header crc (gzip) */
const    DICTID = 10;    /* i: waiting for dictionary check value */
const    DICT = 11;      /* waiting for inflateSetDictionary() call */
const        TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 14;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 17;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 18;   /* i: waiting for code length code lengths */
const        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 20;      /* i: same as LEN below, but only first time in */
const            LEN = 21;       /* i: waiting for length/lit/eob code */
const            LENEXT = 22;    /* i: waiting for length extra bits */
const            DIST = 23;      /* i: waiting for distance code */
const            DISTEXT = 24;   /* i: waiting for distance extra bits */
const            MATCH = 25;     /* o: waiting for output space to copy string */
const            LIT = 26;       /* o: waiting for output space to write literal */
const    CHECK = 27;     /* i: waiting for 32-bit check value */
const    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 29;      /* finished check, done -- remain here until reset */
const    BAD$1 = 30;       /* got a data error -- remain here until reset */
const    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS$1 = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS$1;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateResetKeep = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS$1);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS$1);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$2;
};


const inflateReset = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR$1; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$2) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS$1,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS$1, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR$1;
  }

  state = strm.state;
  if (state.mode === TYPE$1) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$2;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD$1;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED$2) {
          strm.msg = 'unknown compression method';
          state.mode = BAD$1;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD$1;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE$1;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED$2) {
          strm.msg = 'unknown compression method';
          state.mode = BAD$1;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD$1;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD$1;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE$1;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE$1;
        /* falls through */
      case TYPE$1:
        if (flush === Z_BLOCK$1 || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD$1;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD$1;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE$1;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD$1;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES$1, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD$1;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD$1;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD$1;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD$1) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD$1;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS$1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD$1;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS$1, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD$1;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE$1) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE$1;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD$1;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD$1;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD$1;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD$1;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD$1;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END$2;
        break inf_leave;
      case BAD$1:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD$1 &&
                      (state.mode < CHECK || flush !== Z_FINISH$2))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE$1 ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH$2) && ret === Z_OK$2) {
    ret = Z_BUF_ERROR$1;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR$1;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$2;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$2;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$2;
};


var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2 = inflate;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
*/

var inflate_1 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

const toString$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_FINISH: Z_FINISH$3,
  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_MEM_ERROR: Z_MEM_ERROR$1
} = constants;

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  let status  = inflate_1.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK$3) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK$3) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$3 : Z_NO_FLUSH$2;

  // Convert data if needed
  if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT$1 && dictionary) {
      status = inflate_1.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK$3) {
        status = inflate_1.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR$2) {
        // Replace code with more verbose
        status = Z_NEED_DICT$1;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END$3 &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      inflate_1.inflateReset(strm);
      status = inflate_1.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR$2:
      case Z_DATA_ERROR$2:
      case Z_NEED_DICT$1:
      case Z_MEM_ERROR$1:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END$3) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK$3 && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END$3) {
      status = inflate_1.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$3) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  const inflator = new Inflate(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || messages[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


var Inflate_1 = Inflate;
var inflate_2$1 = inflate$1;
var inflateRaw_1 = inflateRaw;
var ungzip = inflate$1;
var constants$2 = constants;

var inflate_1$1 = {
	Inflate: Inflate_1,
	inflate: inflate_2$1,
	inflateRaw: inflateRaw_1,
	ungzip: ungzip,
	constants: constants$2
};

const { Deflate: Deflate$1, deflate: deflate$2, deflateRaw: deflateRaw$1, gzip: gzip$1 } = deflate_1$1;

const { Inflate: Inflate$1, inflate: inflate$2, inflateRaw: inflateRaw$1, ungzip: ungzip$1 } = inflate_1$1;



var Deflate_1$1 = Deflate$1;
var deflate_1$2 = deflate$2;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var Inflate_1$1 = Inflate$1;
var inflate_1$2 = inflate$2;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip_1 = ungzip$1;
var constants_1 = constants;

var pako = {
	Deflate: Deflate_1$1,
	deflate: deflate_1$2,
	deflateRaw: deflateRaw_1$1,
	gzip: gzip_1$1,
	Inflate: Inflate_1$1,
	inflate: inflate_1$2,
	inflateRaw: inflateRaw_1$1,
	ungzip: ungzip_1,
	constants: constants_1
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pako);



/***/ }),

/***/ "./src/classes/HiFiAudioAPIData.ts":
/*!*****************************************!*\
  !*** ./src/classes/HiFiAudioAPIData.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Point3D": () => (/* binding */ Point3D),
/* harmony export */   "OrientationQuat3D": () => (/* binding */ OrientationQuat3D),
/* harmony export */   "OrientationEuler3D": () => (/* binding */ OrientationEuler3D),
/* harmony export */   "OrientationEuler3DOrder": () => (/* binding */ OrientationEuler3DOrder),
/* harmony export */   "eulerToQuaternion": () => (/* binding */ eulerToQuaternion),
/* harmony export */   "eulerFromQuaternion": () => (/* binding */ eulerFromQuaternion),
/* harmony export */   "HiFiAudioAPIData": () => (/* binding */ HiFiAudioAPIData),
/* harmony export */   "ReceivedHiFiAudioAPIData": () => (/* binding */ ReceivedHiFiAudioAPIData)
/* harmony export */ });
/* harmony import */ var _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/HiFiUtilities */ "./src/utilities/HiFiUtilities.ts");

class Point3D {
    constructor({ x = 0, y = 0, z = 0 } = {}) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}
class OrientationQuat3D {
    constructor({ w = 1, x = 0, y = 0, z = 0 } = {}) {
        this.w = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNonan(w, -1, 1, 1);
        this.x = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNonan(x, -1, 1, 0);
        this.y = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNonan(y, -1, 1, 0);
        this.z = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNonan(z, -1, 1, 0);
    }
}
function sanitizeAngleDegrees(v) {
    if (isNaN(v) || v === Infinity) {
        return 0;
    }
    else if (v === -Infinity) {
        return -0;
    }
    else {
        return v % 360;
    }
}
class OrientationEuler3D {
    constructor({ pitchDegrees = 0, yawDegrees = 0, rollDegrees = 0 } = {}) {
        this.pitchDegrees = sanitizeAngleDegrees(pitchDegrees);
        this.yawDegrees = sanitizeAngleDegrees(yawDegrees);
        this.rollDegrees = sanitizeAngleDegrees(rollDegrees);
    }
}
var OrientationEuler3DOrder;
(function (OrientationEuler3DOrder) {
    OrientationEuler3DOrder["PitchYawRoll"] = "PitchYawRoll";
    OrientationEuler3DOrder["YawPitchRoll"] = "YawPitchRoll";
    OrientationEuler3DOrder["RollPitchYaw"] = "RollPitchYaw";
    OrientationEuler3DOrder["RollYawPitch"] = "RollYawPitch";
    OrientationEuler3DOrder["YawRollPitch"] = "YawRollPitch";
    OrientationEuler3DOrder["PitchRollYaw"] = "PitchRollYaw";
})(OrientationEuler3DOrder || (OrientationEuler3DOrder = {}));
function eulerToQuaternion(euler, order) {
    const HALF_DEG_TO_RAD = 0.5 * Math.PI / 180.0;
    let cos = { P: Math.cos(euler.pitchDegrees * HALF_DEG_TO_RAD), Y: Math.cos(euler.yawDegrees * HALF_DEG_TO_RAD), R: Math.cos(euler.rollDegrees * HALF_DEG_TO_RAD) };
    let sin = { P: Math.sin(euler.pitchDegrees * HALF_DEG_TO_RAD), Y: Math.sin(euler.yawDegrees * HALF_DEG_TO_RAD), R: Math.sin(euler.rollDegrees * HALF_DEG_TO_RAD) };
    let ax = sin.P * cos.Y * cos.R;
    let ay = cos.P * sin.Y * cos.R;
    let az = cos.P * cos.Y * sin.R;
    let aw = cos.P * cos.Y * cos.R;
    let bx = cos.P * sin.Y * sin.R;
    let by = sin.P * cos.Y * sin.R;
    let bz = sin.P * sin.Y * cos.R;
    let bw = sin.P * sin.Y * sin.R;
    switch (order) {
        case OrientationEuler3DOrder.PitchYawRoll:
            {
                return new OrientationQuat3D({
                    x: ax + bx,
                    y: ay - by,
                    z: az + bz,
                    w: aw - bw,
                });
            }
            break;
        case OrientationEuler3DOrder.YawPitchRoll:
            {
                return new OrientationQuat3D({
                    x: ax + bx,
                    y: ay - by,
                    z: az - bz,
                    w: aw + bw,
                });
            }
            break;
        case OrientationEuler3DOrder.RollPitchYaw:
            {
                return new OrientationQuat3D({
                    x: ax - bx,
                    y: ay + by,
                    z: az + bz,
                    w: aw - bw,
                });
            }
            break;
        case OrientationEuler3DOrder.RollYawPitch:
            {
                return new OrientationQuat3D({
                    x: ax - bx,
                    y: ay + by,
                    z: az - bz,
                    w: aw + bw,
                });
            }
            break;
        case OrientationEuler3DOrder.YawRollPitch:
            {
                return new OrientationQuat3D({
                    x: ax + bx,
                    y: ay + by,
                    z: az - bz,
                    w: aw - bw,
                });
            }
            break;
        case OrientationEuler3DOrder.PitchRollYaw:
            {
                return new OrientationQuat3D({
                    x: ax - bx,
                    y: ay - by,
                    z: az + bz,
                    w: aw + bw,
                });
            }
            break;
    }
}
function eulerFromQuaternion(quat, order) {
    let qx2 = quat.x * quat.x;
    let qy2 = quat.y * quat.y;
    let qz2 = quat.z * quat.z;
    let qwx = quat.w * quat.x;
    let qwy = quat.w * quat.y;
    let qwz = quat.w * quat.z;
    let qxy = quat.x * quat.y;
    let qyz = quat.y * quat.z;
    let qxz = quat.z * quat.x;
    let r00 = 1.0 - 2.0 * (qy2 + qz2);
    let r10 = 2.0 * (qxy + qwz);
    let r20 = 2.0 * (qxz - qwy);
    let r01 = 2.0 * (qxy - qwz);
    let r11 = 1.0 - 2.0 * (qx2 + qz2);
    let r21 = 2.0 * (qyz + qwx);
    let r02 = 2.0 * (qxz + qwy);
    let r12 = 2.0 * (qyz - qwx);
    let r22 = 1.0 - 2.0 * (qx2 + qy2);
    let pitch = 0;
    let yaw = 0;
    let roll = 0;
    const ONE_MINUS_EPSILON = 0.9999999;
    switch (order) {
        case OrientationEuler3DOrder.PitchYawRoll:
            {
                yaw = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(r02));
                if (Math.abs(r02) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(-r12, r22);
                    roll = Math.atan2(-r01, r00);
                }
                else {
                    pitch = Math.atan2(r21, r11);
                }
            }
            break;
        case OrientationEuler3DOrder.YawPitchRoll:
            {
                pitch = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(-r12));
                if (Math.abs(r12) < ONE_MINUS_EPSILON) {
                    yaw = Math.atan2(r02, r22);
                    roll = Math.atan2(r10, r11);
                }
                else {
                    yaw = Math.atan2(-r20, r00);
                }
            }
            break;
        case OrientationEuler3DOrder.RollPitchYaw:
            {
                pitch = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(r21));
                if (Math.abs(r21) < ONE_MINUS_EPSILON) {
                    yaw = Math.atan2(-r20, r22);
                    roll = Math.atan2(-r01, r11);
                }
                else {
                    roll = Math.atan2(r10, r00);
                }
            }
            break;
        case OrientationEuler3DOrder.RollYawPitch:
            {
                yaw = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(-r20));
                if (Math.abs(r20) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(r21, r22);
                    roll = Math.atan2(r10, r00);
                }
                else {
                    roll = Math.atan2(-r01, r11);
                }
            }
            break;
        case OrientationEuler3DOrder.YawRollPitch:
            {
                roll = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(r10));
                if (Math.abs(r10) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(-r12, r11);
                    yaw = Math.atan2(-r20, r00);
                }
                else {
                    yaw = Math.atan2(r02, r22);
                }
            }
            break;
        case OrientationEuler3DOrder.PitchRollYaw:
            {
                roll = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(-r01));
                if (Math.abs(r01) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(r21, r11);
                    yaw = Math.atan2(r02, r00);
                }
                else {
                    yaw = Math.atan2(-r12, r22);
                }
            }
            break;
    }
    const RAD_TO_DEG = 180.0 / Math.PI;
    return new OrientationEuler3D({ pitchDegrees: RAD_TO_DEG * pitch, yawDegrees: RAD_TO_DEG * yaw, rollDegrees: RAD_TO_DEG * roll });
}
class HiFiAudioAPIData {
    constructor({ position = null, orientationQuat = null, orientationEuler = null, volumeThreshold = null, hiFiGain = null, userAttenuation = null, userRolloff = null } = {}) {
        this.position = position;
        this.orientationQuat = orientationQuat;
        this.orientationEuler = orientationEuler;
        this.volumeThreshold = volumeThreshold;
        this.hiFiGain = hiFiGain;
        this.userAttenuation = userAttenuation;
        this.userRolloff = userRolloff;
        this._otherUserGainQueue = {};
    }
}
class ReceivedHiFiAudioAPIData extends HiFiAudioAPIData {
    constructor(params = {}) {
        super(params);
        this.providedUserID = params.providedUserID;
        this.hashedVisitID = params.hashedVisitID;
        this.volumeDecibels = params.volumeDecibels;
        this.isStereo = params.isStereo;
    }
}


/***/ }),

/***/ "./src/classes/HiFiAxisConfiguration.ts":
/*!**********************************************!*\
  !*** ./src/classes/HiFiAxisConfiguration.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiAxes": () => (/* binding */ HiFiAxes),
/* harmony export */   "HiFiHandedness": () => (/* binding */ HiFiHandedness),
/* harmony export */   "HiFiAxisConfiguration": () => (/* binding */ HiFiAxisConfiguration),
/* harmony export */   "ourHiFiAxisConfiguration": () => (/* binding */ ourHiFiAxisConfiguration),
/* harmony export */   "HiFiAxisUtilities": () => (/* binding */ HiFiAxisUtilities)
/* harmony export */ });
/* harmony import */ var _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* harmony import */ var _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");


var HiFiAxes;
(function (HiFiAxes) {
    HiFiAxes["PositiveX"] = "Positive X";
    HiFiAxes["NegativeX"] = "Negative X";
    HiFiAxes["PositiveY"] = "Positive Y";
    HiFiAxes["NegativeY"] = "Negative Y";
    HiFiAxes["PositiveZ"] = "Positive Z";
    HiFiAxes["NegativeZ"] = "Negative Z";
})(HiFiAxes || (HiFiAxes = {}));
var HiFiHandedness;
(function (HiFiHandedness) {
    HiFiHandedness["RightHand"] = "Right Hand";
    HiFiHandedness["LeftHand"] = "Left Hand";
})(HiFiHandedness || (HiFiHandedness = {}));
class HiFiAxisConfiguration {
    constructor({ rightAxis, leftAxis, intoScreenAxis, outOfScreenAxis, upAxis, downAxis, handedness, eulerOrder }) {
        Object.assign(this, { rightAxis, leftAxis, intoScreenAxis, outOfScreenAxis, upAxis, downAxis, handedness, eulerOrder });
    }
}
let ourHiFiAxisConfiguration = new HiFiAxisConfiguration({
    rightAxis: HiFiAxes.PositiveX,
    leftAxis: HiFiAxes.NegativeX,
    intoScreenAxis: HiFiAxes.PositiveY,
    outOfScreenAxis: HiFiAxes.NegativeY,
    upAxis: HiFiAxes.PositiveZ,
    downAxis: HiFiAxes.NegativeZ,
    handedness: HiFiHandedness.RightHand,
    eulerOrder: _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationEuler3DOrder.YawPitchRoll,
});
class HiFiAxisUtilities {
    static verify(axisConfiguration) {
        let isValid = true;
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveX && axisConfiguration.leftAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.leftAxis === HiFiAxes.PositiveX && axisConfiguration.rightAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveY && axisConfiguration.leftAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.leftAxis === HiFiAxes.PositiveY && axisConfiguration.rightAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveZ && axisConfiguration.leftAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.leftAxis === HiFiAxes.PositiveZ && axisConfiguration.rightAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveX && axisConfiguration.outOfScreenAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveX && axisConfiguration.intoScreenAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveY && axisConfiguration.outOfScreenAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveY && axisConfiguration.intoScreenAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveZ && axisConfiguration.outOfScreenAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveZ && axisConfiguration.intoScreenAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.upAxis === HiFiAxes.PositiveX && axisConfiguration.downAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.downAxis === HiFiAxes.PositiveX && axisConfiguration.upAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.upAxis === HiFiAxes.PositiveY && axisConfiguration.downAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.downAxis === HiFiAxes.PositiveY && axisConfiguration.upAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.upAxis === HiFiAxes.PositiveZ && axisConfiguration.downAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.downAxis === HiFiAxes.PositiveZ && axisConfiguration.upAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (!(axisConfiguration.handedness === HiFiHandedness.RightHand || axisConfiguration.handedness === HiFiHandedness.LeftHand)) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nHandedness is ${axisConfiguration.handedness}!`);
            isValid = false;
        }
        return isValid;
    }
    static translatePoint3DToMixerSpace(axisConfiguration, inputPoint3D) {
        let retval = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.Point3D();
        retval = inputPoint3D;
        return retval;
    }
    static translatePoint3DFromMixerSpace(axisConfiguration, mixerPoint3D) {
        let retval = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.Point3D();
        retval = mixerPoint3D;
        return retval;
    }
    static translateOrientationQuat3DToMixerSpace(axisConfiguration, inputOrientationQuat3D) {
        let retval = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationQuat3D();
        retval = inputOrientationQuat3D;
        return retval;
    }
    static translateOrientationQuat3DFromMixerSpace(axisConfiguration, mixerOrientationQuat3D) {
        let retval = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationQuat3D();
        retval = mixerOrientationQuat3D;
        return retval;
    }
}


/***/ }),

/***/ "./src/classes/HiFiCommunicator.ts":
/*!*****************************************!*\
  !*** ./src/classes/HiFiCommunicator.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiConnectionStates": () => (/* binding */ HiFiConnectionStates),
/* harmony export */   "HiFiUserDataStreamingScopes": () => (/* binding */ HiFiUserDataStreamingScopes),
/* harmony export */   "HiFiCommunicator": () => (/* binding */ HiFiCommunicator)
/* harmony export */ });
/* harmony import */ var _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/HiFiConstants */ "./src/constants/HiFiConstants.ts");
/* harmony import */ var _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* harmony import */ var _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/HiFiUtilities */ "./src/utilities/HiFiUtilities.ts");
/* harmony import */ var _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");
/* harmony import */ var _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HiFiAxisConfiguration */ "./src/classes/HiFiAxisConfiguration.ts");
/* harmony import */ var _HiFiMixerSession__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./HiFiMixerSession */ "./src/classes/HiFiMixerSession.ts");
/* harmony import */ var _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./HiFiUserDataSubscription */ "./src/classes/HiFiUserDataSubscription.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







var HiFiConnectionStates;
(function (HiFiConnectionStates) {
    HiFiConnectionStates["Connected"] = "Connected";
    HiFiConnectionStates["Disconnected"] = "Disconnected";
    HiFiConnectionStates["Failed"] = "Failed";
    HiFiConnectionStates["Unavailable"] = "Unavailable";
})(HiFiConnectionStates || (HiFiConnectionStates = {}));
;
var HiFiUserDataStreamingScopes;
(function (HiFiUserDataStreamingScopes) {
    HiFiUserDataStreamingScopes["None"] = "none";
    HiFiUserDataStreamingScopes["Peers"] = "peers";
    HiFiUserDataStreamingScopes["All"] = "all";
})(HiFiUserDataStreamingScopes || (HiFiUserDataStreamingScopes = {}));
;
class HiFiCommunicator {
    constructor({ initialHiFiAudioAPIData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.HiFiAudioAPIData(), onConnectionStateChanged, onUsersDisconnected, transmitRateLimitTimeoutMS = _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.DEFAULT_TRANSMIT_RATE_LIMIT_TIMEOUT_MS, userDataStreamingScope = HiFiUserDataStreamingScopes.All, hiFiAxisConfiguration, webrtcSessionParams, customSTUNandTURNConfig, onMuteChanged } = {}) {
        this._timers = {
            transmitRateLimitTimeout: null,
            wantedToTransmitHiFiAudioAPIData: true
        };
        if (customSTUNandTURNConfig) {
            if (!customSTUNandTURNConfig.hasOwnProperty("stunUrls") || !Array.isArray(customSTUNandTURNConfig.stunUrls) || customSTUNandTURNConfig.stunUrls.length == 0) {
                throw new Error(`\`customSTUNandTURNConfig.stunUrls\` must be specified and must be a list containing at least one STUN server.`);
            }
            if (!customSTUNandTURNConfig.hasOwnProperty("turnUrls") || !Array.isArray(customSTUNandTURNConfig.turnUrls) || customSTUNandTURNConfig.turnUrls.length == 0) {
                throw new Error(`\`customSTUNandTURNConfig.turnUrls\` must be specified and must be a list containing at least one TURN server.`);
            }
            if (!customSTUNandTURNConfig.hasOwnProperty("turnUsername")) {
                throw new Error(`\`customSTUNandTURNConfig.turnUsername\` must be specified.`);
            }
            if (!customSTUNandTURNConfig.hasOwnProperty("turnCredential")) {
                throw new Error(`\`customSTUNandTURNConfig.turnCredential\` must be specified.`);
            }
        }
        this._customSTUNandTURNConfig = customSTUNandTURNConfig;
        if (transmitRateLimitTimeoutMS < _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`\`transmitRateLimitTimeoutMS\` must be >= ${_constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS}ms! Setting to ${_constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS}ms...`);
            transmitRateLimitTimeoutMS = _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS;
        }
        this.transmitRateLimitTimeoutMS = transmitRateLimitTimeoutMS;
        if (onUsersDisconnected) {
            this.onUsersDisconnected = onUsersDisconnected;
        }
        this._mixerSession = new _HiFiMixerSession__WEBPACK_IMPORTED_MODULE_5__.HiFiMixerSession({
            "userDataStreamingScope": userDataStreamingScope,
            "onUserDataUpdated": (data) => { this._handleUserDataUpdates(data); },
            "onUsersDisconnected": (data) => { this._onUsersDisconnected(data); },
            "onConnectionStateChanged": onConnectionStateChanged,
            "onMuteChanged": onMuteChanged
        });
        this._inputAudioMediaStream = undefined;
        this._currentHiFiAudioAPIData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.HiFiAudioAPIData();
        this._lastTransmittedHiFiAudioAPIData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.HiFiAudioAPIData();
        this._userDataSubscriptions = [];
        if (webrtcSessionParams && webrtcSessionParams.audioMinJitterBufferDuration && (webrtcSessionParams.audioMinJitterBufferDuration < 0.0 || webrtcSessionParams.audioMinJitterBufferDuration > 10.0)) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`The value of \`webrtcSessionParams.audioMinJitterBufferDuration\` (${webrtcSessionParams.audioMinJitterBufferDuration}) will be clamped to (0.0, 10.0).`);
            webrtcSessionParams.audioMinJitterBufferDuration = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_2__.HiFiUtilities.clamp(webrtcSessionParams.audioMinJitterBufferDuration, 0.0, 10.0);
        }
        if (webrtcSessionParams && webrtcSessionParams.audioMaxJitterBufferDuration && (webrtcSessionParams.audioMaxJitterBufferDuration < 0.0 || webrtcSessionParams.audioMaxJitterBufferDuration > 10.0)) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`The value of \`webrtcSessionParams.audioMaxJitterBufferDuration\` (${webrtcSessionParams.audioMaxJitterBufferDuration}) will be clamped to (0.0, 10.0).`);
            webrtcSessionParams.audioMaxJitterBufferDuration = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_2__.HiFiUtilities.clamp(webrtcSessionParams.audioMaxJitterBufferDuration, 0.0, 10.0);
        }
        this._webRTCSessionParams = webrtcSessionParams;
        if (hiFiAxisConfiguration) {
            if (_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.HiFiAxisUtilities.verify(hiFiAxisConfiguration)) {
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.rightAxis = hiFiAxisConfiguration.rightAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.leftAxis = hiFiAxisConfiguration.leftAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.intoScreenAxis = hiFiAxisConfiguration.intoScreenAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.outOfScreenAxis = hiFiAxisConfiguration.outOfScreenAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.upAxis = hiFiAxisConfiguration.upAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.downAxis = hiFiAxisConfiguration.downAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.handedness = hiFiAxisConfiguration.handedness;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.eulerOrder = hiFiAxisConfiguration.eulerOrder;
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`There is an error with the passed \`HiFiAxisConfiguration\`, so the new axis configuration was not set. There are more error details in the logs above.`);
            }
        }
        this._updateUserData(initialHiFiAudioAPIData);
    }
    connectToHiFiAudioAPIServer(hifiAuthJWT, signalingHostURL, signalingPort) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._mixerSession) {
                let errMsg = `\`this._mixerSession\` is falsey; try creating a new HiFiCommunicator and starting over.`;
                return Promise.reject({
                    success: false,
                    error: errMsg
                });
            }
            if (this._mixerSession.getCurrentHiFiConnectionState() === HiFiConnectionStates.Connected) {
                let msg = `Session is already connected! If you need to reset the connection, please disconnect fully using \`disconnectFromHiFiAudioAPIServer()\` and call this method again.`;
                return Promise.resolve({
                    success: true,
                    error: msg
                });
            }
            let mixerConnectionResponse;
            let signalingHostURLSafe;
            try {
                let url = new URL(signalingHostURL);
                signalingHostURLSafe = url.hostname;
                if (signalingPort == null && url.port !== "") {
                    signalingPort = Number(url.port);
                }
            }
            catch (e) {
                signalingHostURLSafe = signalingHostURL ? signalingHostURL : _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_ENDPOINT;
            }
            signalingPort = signalingPort ? signalingPort : _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_PORT;
            try {
                let webRTCSignalingAddress = `wss://${signalingHostURLSafe}:${signalingPort}/?token=`;
                this._mixerSession.webRTCAddress = `${webRTCSignalingAddress}${hifiAuthJWT}`;
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Using WebRTC Signaling Address:\n${webRTCSignalingAddress}<token redacted>`);
                mixerConnectionResponse = yield this._mixerSession.connectToHiFiMixer({ webRTCSessionParams: this._webRTCSessionParams, customSTUNandTURNConfig: this._customSTUNandTURNConfig });
            }
            catch (errorConnectingToMixer) {
                let errMsg = `Error when connecting to mixer!\n${errorConnectingToMixer}`;
                return Promise.reject({
                    success: false,
                    error: errMsg
                });
            }
            this._transmitHiFiAudioAPIDataToServer(true);
            return Promise.resolve({
                success: true,
                audionetInitResponse: mixerConnectionResponse.audionetInitResponse
            });
        });
    }
    setOtherUserGainForThisConnection(visitIdHash, gain) {
        return __awaiter(this, void 0, void 0, function* () {
            let otherUserGainMap = {};
            otherUserGainMap[visitIdHash] = gain;
            let result = this.setOtherUserGainsForThisConnection(otherUserGainMap);
            return Promise.resolve(result);
        });
    }
    setOtherUserGainsForThisConnection(otherUserGainMap) {
        return __awaiter(this, void 0, void 0, function* () {
            Object.assign(this._currentHiFiAudioAPIData._otherUserGainQueue, otherUserGainMap);
            let result = this._transmitHiFiAudioAPIDataToServer();
            return Promise.resolve({
                success: result.success,
                error: result.error
            });
        });
    }
    disconnectFromHiFiAudioAPIServer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._mixerSession) {
                return Promise.resolve(`No mixer session from which we can disconnect!`);
            }
            this._inputAudioMediaStream = undefined;
            this.onUsersDisconnected = undefined;
            this._userDataSubscriptions = [];
            this._currentHiFiAudioAPIData = undefined;
            this._lastTransmittedHiFiAudioAPIData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.HiFiAudioAPIData();
            return this._mixerSession.disconnectFromHiFiMixer();
        });
    }
    getOutputAudioMediaStream() {
        if (this._mixerSession) {
            return this._mixerSession.getOutputAudioMediaStream();
        }
        else {
            return null;
        }
    }
    getConnectionState() {
        if (this._mixerSession) {
            return this._mixerSession.getCurrentHiFiConnectionState();
        }
        else {
            return null;
        }
    }
    setInputAudioMediaStream(newInputAudioMediaStream, isStereo = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const retval = yield this._mixerSession.setRAVIInputAudio(newInputAudioMediaStream, isStereo);
            if (retval) {
                this._inputAudioMediaStream = newInputAudioMediaStream;
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Error trying to setRAVIInputAudio on this._mixerSession`);
            }
            return retval;
        });
    }
    setInputAudioMuted(isMuted) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._mixerSession) {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.debug(`Setting mute state to : ${isMuted}`);
                return yield this._mixerSession.setInputAudioMuted(isMuted);
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: No \`_mixerSession\`.`);
                return false;
            }
        });
    }
    getCommunicatorInfo() {
        let retval = {
            "clientInfo": {
                "inputAudioStreamSet": !!this._inputAudioMediaStream,
            }
        };
        let isBrowserContext = typeof self !== 'undefined';
        if (isBrowserContext && "string" === "string") {
            retval.clientInfo["apiVersion"] = "v1.2.2-3";
        }
        if (this._mixerSession && this._mixerSession.mixerInfo) {
            retval["serverInfo"] = this._mixerSession.mixerInfo;
        }
        return retval;
    }
    startCollectingWebRTCStats(callback) {
        if (!this._mixerSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`Couldn't start collecting WebRTC Stats: No \`_mixerSession\`!`);
        }
        this._mixerSession.startCollectingWebRTCStats(callback);
    }
    stopCollectingWebRTCStats() {
        if (!this._mixerSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`Couldn't stop collecting WebRTC Stats: No \`_mixerSession\`!`);
        }
        this._mixerSession.stopCollectingWebRTCStats();
    }
    _updateUserData({ position, orientationQuat, orientationEuler, volumeThreshold, hiFiGain, userAttenuation, userRolloff } = {}) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (position) {
            if (!this._currentHiFiAudioAPIData.position) {
                this._currentHiFiAudioAPIData.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.Point3D();
            }
            this._currentHiFiAudioAPIData.position.x = (_a = position.x) !== null && _a !== void 0 ? _a : this._currentHiFiAudioAPIData.position.x;
            this._currentHiFiAudioAPIData.position.y = (_b = position.y) !== null && _b !== void 0 ? _b : this._currentHiFiAudioAPIData.position.y;
            this._currentHiFiAudioAPIData.position.z = (_c = position.z) !== null && _c !== void 0 ? _c : this._currentHiFiAudioAPIData.position.z;
        }
        if (orientationQuat) {
            if (!this._currentHiFiAudioAPIData.orientationQuat) {
                this._currentHiFiAudioAPIData.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.OrientationQuat3D();
            }
            this._currentHiFiAudioAPIData.orientationQuat.w = (_d = orientationQuat.w) !== null && _d !== void 0 ? _d : this._currentHiFiAudioAPIData.orientationQuat.w;
            this._currentHiFiAudioAPIData.orientationQuat.x = (_e = orientationQuat.x) !== null && _e !== void 0 ? _e : this._currentHiFiAudioAPIData.orientationQuat.x;
            this._currentHiFiAudioAPIData.orientationQuat.y = (_f = orientationQuat.y) !== null && _f !== void 0 ? _f : this._currentHiFiAudioAPIData.orientationQuat.y;
            this._currentHiFiAudioAPIData.orientationQuat.z = (_g = orientationQuat.z) !== null && _g !== void 0 ? _g : this._currentHiFiAudioAPIData.orientationQuat.z;
        }
        else if (orientationEuler) {
            let checkedEuler = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.OrientationEuler3D(orientationEuler);
            this._currentHiFiAudioAPIData.orientationQuat = (0,_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.eulerToQuaternion)(checkedEuler, _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.eulerOrder);
        }
        if (typeof (volumeThreshold) === "number") {
            this._currentHiFiAudioAPIData.volumeThreshold = volumeThreshold;
        }
        if (typeof (hiFiGain) === "number") {
            this._currentHiFiAudioAPIData.hiFiGain = Math.max(0, hiFiGain);
        }
        if (typeof (userAttenuation) === "number") {
            this._currentHiFiAudioAPIData.userAttenuation = userAttenuation;
        }
        if (typeof (userRolloff) === "number") {
            this._currentHiFiAudioAPIData.userRolloff = Math.max(0, userRolloff);
        }
    }
    _maybeClearRateLimitTimeout() {
        if (this._timers.transmitRateLimitTimeout) {
            clearTimeout(this._timers.transmitRateLimitTimeout);
        }
        this._timers.transmitRateLimitTimeout = null;
    }
    _updateLastTransmittedHiFiAudioAPIData(dataJustTransmitted) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (dataJustTransmitted.position) {
            if (!this._lastTransmittedHiFiAudioAPIData.position) {
                this._lastTransmittedHiFiAudioAPIData.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.Point3D();
            }
            this._lastTransmittedHiFiAudioAPIData.position.x = (_a = dataJustTransmitted.position.x) !== null && _a !== void 0 ? _a : this._lastTransmittedHiFiAudioAPIData.position.x;
            this._lastTransmittedHiFiAudioAPIData.position.y = (_b = dataJustTransmitted.position.y) !== null && _b !== void 0 ? _b : this._lastTransmittedHiFiAudioAPIData.position.y;
            this._lastTransmittedHiFiAudioAPIData.position.z = (_c = dataJustTransmitted.position.z) !== null && _c !== void 0 ? _c : this._lastTransmittedHiFiAudioAPIData.position.z;
        }
        if (dataJustTransmitted.orientationQuat) {
            if (!this._lastTransmittedHiFiAudioAPIData.orientationQuat) {
                this._lastTransmittedHiFiAudioAPIData.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.OrientationQuat3D();
            }
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.w = (_d = dataJustTransmitted.orientationQuat.w) !== null && _d !== void 0 ? _d : this._lastTransmittedHiFiAudioAPIData.orientationQuat.w;
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.x = (_e = dataJustTransmitted.orientationQuat.x) !== null && _e !== void 0 ? _e : this._lastTransmittedHiFiAudioAPIData.orientationQuat.x;
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.y = (_f = dataJustTransmitted.orientationQuat.y) !== null && _f !== void 0 ? _f : this._lastTransmittedHiFiAudioAPIData.orientationQuat.y;
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.z = (_g = dataJustTransmitted.orientationQuat.z) !== null && _g !== void 0 ? _g : this._lastTransmittedHiFiAudioAPIData.orientationQuat.z;
        }
        if (typeof (dataJustTransmitted.volumeThreshold) === "number") {
            this._lastTransmittedHiFiAudioAPIData["volumeThreshold"] = dataJustTransmitted.volumeThreshold;
        }
        if (typeof (dataJustTransmitted.hiFiGain) === "number") {
            this._lastTransmittedHiFiAudioAPIData["hiFiGain"] = dataJustTransmitted.hiFiGain;
        }
        if (typeof (dataJustTransmitted.userAttenuation) === "number") {
            this._lastTransmittedHiFiAudioAPIData["userAttenuation"] = dataJustTransmitted.userAttenuation;
        }
        if (typeof (dataJustTransmitted.userRolloff) === "number") {
            this._lastTransmittedHiFiAudioAPIData["userRolloff"] = dataJustTransmitted.userRolloff;
        }
        if (typeof (dataJustTransmitted._otherUserGainQueue) === "object") {
            if (typeof (this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue) !== "object") {
                this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue = {};
            }
            for (const idToGain of Object.entries(dataJustTransmitted._otherUserGainQueue)) {
                this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue[idToGain[0]] = idToGain[1];
            }
        }
    }
    _transmitHiFiAudioAPIDataToServer(forceTransmit) {
        if (this._mixerSession && (!this._timers.transmitRateLimitTimeout || forceTransmit)) {
            this._timers.wantedToTransmitHiFiAudioAPIData = false;
            this._maybeClearRateLimitTimeout();
            if (!forceTransmit) {
                this._timers.transmitRateLimitTimeout = setTimeout(() => {
                    this._maybeClearRateLimitTimeout();
                    if (this._timers.wantedToTransmitHiFiAudioAPIData) {
                        this._transmitHiFiAudioAPIDataToServer(true);
                    }
                }, this.transmitRateLimitTimeoutMS);
            }
            let transmitRetval = this._mixerSession._transmitHiFiAudioAPIDataToServer(this._currentHiFiAudioAPIData, this._lastTransmittedHiFiAudioAPIData);
            if (transmitRetval.success) {
                this._updateLastTransmittedHiFiAudioAPIData(this._currentHiFiAudioAPIData);
                this._cleanUpHiFiAudioAPIDataHistory();
                return {
                    success: true,
                    rawDataTransmitted: transmitRetval.stringifiedDataForMixer
                };
            }
            else {
                return {
                    success: false,
                    error: transmitRetval.error
                };
            }
        }
        else if (this._mixerSession && this._timers.transmitRateLimitTimeout && !forceTransmit) {
            this._timers.wantedToTransmitHiFiAudioAPIData = true;
            return {
                success: true,
                error: `Transfer is rate limited. Transfer will occur shortly automatically.`
            };
        }
        else if (!this._mixerSession) {
            return {
                success: false,
                error: `No server connection yet; can't transmit user data.`
            };
        }
    }
    _cleanUpHiFiAudioAPIDataHistory() {
        this._currentHiFiAudioAPIData._otherUserGainQueue = {};
        let maxCachedOtherUserGains = 1000;
        if (Object.keys(this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue).length > maxCachedOtherUserGains) {
            this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue = {};
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Stored \`_lastTransmittedHiFiAudioAPIData._otherUserGainQueue\` was too large and was cleared to save space.`);
        }
    }
    updateUserDataAndTransmit(newUserData) {
        this._updateUserData(newUserData);
        return this._transmitHiFiAudioAPIDataToServer();
    }
    _handleUserDataUpdates(newUserDataFromServer) {
        if (this._userDataSubscriptions.length === 0) {
            return;
        }
        for (let subItr = 0; subItr < this._userDataSubscriptions.length; subItr++) {
            let currentSubscription = this._userDataSubscriptions[subItr];
            if (!currentSubscription.callback) {
                continue;
            }
            let currentSubscriptionCallbackData = [];
            for (let dataItr = 0; dataItr < newUserDataFromServer.length; dataItr++) {
                let currentDataFromServer = newUserDataFromServer[dataItr];
                if (currentSubscription.providedUserID && currentDataFromServer.providedUserID !== currentSubscription.providedUserID) {
                    continue;
                }
                let newCallbackData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.ReceivedHiFiAudioAPIData();
                if (typeof (currentDataFromServer.providedUserID) === "string") {
                    newCallbackData.providedUserID = currentDataFromServer.providedUserID;
                }
                if (typeof (currentDataFromServer.hashedVisitID) === "string") {
                    newCallbackData.hashedVisitID = currentDataFromServer.hashedVisitID;
                }
                let shouldPushNewCallbackData = false;
                for (let componentItr = 0; componentItr < currentSubscription.components.length; componentItr++) {
                    let currentComponent = currentSubscription.components[componentItr];
                    switch (currentComponent) {
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.Position:
                            if (currentDataFromServer.position) {
                                newCallbackData.position = currentDataFromServer.position;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.OrientationQuat:
                            if (currentDataFromServer.orientationQuat) {
                                newCallbackData.orientationQuat = currentDataFromServer.orientationQuat;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.OrientationEuler:
                            if (currentDataFromServer.orientationQuat) {
                                newCallbackData.orientationEuler = (0,_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.eulerFromQuaternion)(currentDataFromServer.orientationQuat, _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.eulerOrder);
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.VolumeDecibels:
                            if (typeof (currentDataFromServer.volumeDecibels) === "number") {
                                newCallbackData.volumeDecibels = currentDataFromServer.volumeDecibels;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.IsStereo:
                            if (typeof (currentDataFromServer.isStereo) === "boolean") {
                                newCallbackData.isStereo = currentDataFromServer.isStereo;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                    }
                }
                if (shouldPushNewCallbackData) {
                    currentSubscriptionCallbackData.push(newCallbackData);
                }
            }
            if (currentSubscription.callback && currentSubscriptionCallbackData.length > 0) {
                currentSubscription.callback(currentSubscriptionCallbackData);
            }
        }
    }
    _onUsersDisconnected(usersDisconnected) {
        if (this.onUsersDisconnected) {
            this.onUsersDisconnected(usersDisconnected);
        }
    }
    addUserDataSubscription(newSubscription) {
        if (!this._mixerSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`No \`_mixerSession\`! Data subscription not added.`);
            return;
        }
        if (this._mixerSession.userDataStreamingScope === HiFiUserDataStreamingScopes.None) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`During \`HiFiCommunicator\` construction, the server was set up to **not** send user data! Data subscription not added.`);
            return;
        }
        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Adding new User Data Subscription:\n${JSON.stringify(newSubscription)}`);
        this._userDataSubscriptions.push(newSubscription);
    }
}


/***/ }),

/***/ "./src/classes/HiFiMixerSession.ts":
/*!*****************************************!*\
  !*** ./src/classes/HiFiMixerSession.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MuteReason": () => (/* binding */ MuteReason),
/* harmony export */   "MuteChangedEvent": () => (/* binding */ MuteChangedEvent),
/* harmony export */   "HiFiMixerSession": () => (/* binding */ HiFiMixerSession)
/* harmony export */ });
/* harmony import */ var _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");
/* harmony import */ var _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* harmony import */ var _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HiFiCommunicator */ "./src/classes/HiFiCommunicator.ts");
/* harmony import */ var _libravi_RaviUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../libravi/RaviUtils */ "./src/libravi/RaviUtils.ts");
/* harmony import */ var _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../libravi/RaviSession */ "./src/libravi/RaviSession.ts");
/* harmony import */ var _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../libravi/RaviSignalingConnection */ "./src/libravi/RaviSignalingConnection.ts");
/* harmony import */ var _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./HiFiAxisConfiguration */ "./src/classes/HiFiAxisConfiguration.ts");
/* harmony import */ var _diagnostics_diagnostics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../diagnostics/diagnostics */ "./src/diagnostics/diagnostics.ts");
/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! pako */ "./node_modules/pako/dist/pako.esm.mjs");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};









const INIT_TIMEOUT_MS = 5000;
const PERSONAL_VOLUME_ADJUST_TIMEOUT_MS = 5000;
var MuteReason;
(function (MuteReason) {
    MuteReason["CLIENT"] = "client";
    MuteReason["ADMIN"] = "admin";
    MuteReason["INTERNAL"] = "internal";
})(MuteReason || (MuteReason = {}));
class MuteChangedEvent {
    constructor({ success, targetInputAudioMutedValue, currentInputAudioMutedValue, adminPreventsInputAudioUnmuting, muteReason }) {
        this.success = success;
        this.targetInputAudioMutedValue = targetInputAudioMutedValue;
        this.currentInputAudioMutedValue = currentInputAudioMutedValue;
        this.adminPreventsInputAudioUnmuting = adminPreventsInputAudioUnmuting;
        this.muteReason = muteReason;
    }
}
class HiFiMixerSession {
    constructor({ userDataStreamingScope = _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiUserDataStreamingScopes.All, onUserDataUpdated, onUsersDisconnected, onConnectionStateChanged, onMuteChanged }) {
        this.concurrency = 0;
        this.webRTCAddress = undefined;
        this.userDataStreamingScope = userDataStreamingScope;
        this.onUserDataUpdated = onUserDataUpdated;
        this.onUsersDisconnected = onUsersDisconnected;
        this._mixerPeerKeyToStateCacheDict = {};
        this._lastSuccessfulInputAudioMutedValue = false;
        this.onMuteChanged = onMuteChanged;
        _libravi_RaviUtils__WEBPACK_IMPORTED_MODULE_3__.RaviUtils.setDebug(false);
        this._raviSignalingConnection = new _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingConnection();
        this._raviSignalingConnection.addStateChangeHandler((event) => {
            this.onRAVISignalingStateChanged(event);
        });
        this._raviSession = new _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSession();
        this._raviSession.addStateChangeHandler((event) => {
            this.onRAVISessionStateChanged(event);
        });
        this.onConnectionStateChanged = onConnectionStateChanged;
        this._resetMixerInfo();
        this._raviDiagnostics = new _diagnostics_diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics({ label: 'ravi', session: this, ravi: this._raviSession });
        this._hifiDiagnostics = new _diagnostics_diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics({ label: 'app', session: this, ravi: this._raviSession,
            fireOn: ['visibilitychange', 'pagehide', 'beforeunload'] });
    }
    promiseToRunAudioInit() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let initData = {
                    primary: true,
                    visit_id: this._raviSession.getUUID(),
                    session: this._raviSession.getUUID(),
                    streaming_scope: this.userDataStreamingScope,
                    is_input_stream_stereo: this._inputAudioMediaStreamIsStereo
                };
                let commandController = this._raviSession.getCommandController();
                if (!commandController) {
                    return Promise.reject({
                        success: false,
                        error: `Couldn't connect to mixer: no \`commandController\`!`
                    });
                }
                let initTimeout = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    let errMsg = `Couldn't connect to mixer: Call to \`init\` timed out!`;
                    try {
                        yield this._disconnectFromHiFiMixer();
                    }
                    catch (errorClosing) {
                        errMsg += `\nAdditionally, there was an error trying to close the failed connection. Error:\n${errorClosing}`;
                    }
                    return Promise.reject({
                        success: false,
                        error: errMsg
                    });
                }), INIT_TIMEOUT_MS);
                commandController.queueCommand("audionet.init", initData, (response) => __awaiter(this, void 0, void 0, function* () {
                    clearTimeout(initTimeout);
                    let parsedResponse;
                    try {
                        parsedResponse = JSON.parse(response);
                        this.mixerInfo["connected"] = true;
                        this.mixerInfo["build_number"] = parsedResponse.build_number;
                        this.mixerInfo["build_type"] = parsedResponse.build_type;
                        this.mixerInfo["build_version"] = parsedResponse.build_version;
                        this.mixerInfo["visit_id_hash"] = parsedResponse.visit_id_hash;
                        this._raviDiagnostics.prime(this.mixerInfo.visit_id_hash);
                        this._hifiDiagnostics.prime(this.mixerInfo.visit_id_hash);
                        resolve({
                            success: true,
                            audionetInitResponse: parsedResponse
                        });
                    }
                    catch (e) {
                        reject({
                            success: false,
                            error: `Couldn't parse init response! Parse error:\n${e}`
                        });
                    }
                }));
            });
        });
    }
    handleRAVISessionBinaryData(data) {
        let unGZippedData = pako__WEBPACK_IMPORTED_MODULE_8__.default.ungzip(data, { to: 'string' });
        let jsonData = JSON.parse(unGZippedData);
        if (jsonData.deleted_visit_ids) {
            let allDeletedUserData = [];
            let deletedVisitIDs = jsonData.deleted_visit_ids;
            for (const deletedVisitID of deletedVisitIDs) {
                let hashedVisitID = deletedVisitID;
                let deletedUserData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.ReceivedHiFiAudioAPIData({
                    hashedVisitID: hashedVisitID
                });
                let mixerPeerKeys = Object.keys(this._mixerPeerKeyToStateCacheDict);
                for (const mixerPeerKey of mixerPeerKeys) {
                    if (this._mixerPeerKeyToStateCacheDict[mixerPeerKey].hashedVisitID === hashedVisitID) {
                        if (this._mixerPeerKeyToStateCacheDict[mixerPeerKey].providedUserID) {
                            deletedUserData.providedUserID = this._mixerPeerKeyToStateCacheDict[mixerPeerKey].providedUserID;
                        }
                        break;
                    }
                }
                allDeletedUserData.push(deletedUserData);
            }
            this.concurrency -= allDeletedUserData.length;
            if (this.onUsersDisconnected && allDeletedUserData.length > 0) {
                this.onUsersDisconnected(allDeletedUserData);
            }
        }
        if (jsonData.peers) {
            let allNewUserData = [];
            let peerKeys = Object.keys(jsonData.peers);
            for (let itr = 0; itr < peerKeys.length; itr++) {
                let peerDataFromMixer = jsonData.peers[peerKeys[itr]];
                let userDataCache;
                if (this._mixerPeerKeyToStateCacheDict[peerKeys[itr]]) {
                    userDataCache = this._mixerPeerKeyToStateCacheDict[peerKeys[itr]];
                }
                else {
                    userDataCache = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.ReceivedHiFiAudioAPIData();
                    this._mixerPeerKeyToStateCacheDict[peerKeys[itr]] = userDataCache;
                    this.concurrency += 1;
                }
                let newUserData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.ReceivedHiFiAudioAPIData();
                if (userDataCache.providedUserID) {
                    newUserData.providedUserID = userDataCache.providedUserID;
                }
                else if (typeof (peerDataFromMixer.J) === "string") {
                    userDataCache.providedUserID = peerDataFromMixer.J;
                    newUserData.providedUserID = peerDataFromMixer.J;
                }
                if (userDataCache.hashedVisitID) {
                    newUserData.hashedVisitID = userDataCache.hashedVisitID;
                }
                else if (typeof (peerDataFromMixer.e) === "string") {
                    userDataCache.hashedVisitID = peerDataFromMixer.e;
                    newUserData.hashedVisitID = peerDataFromMixer.e;
                }
                let serverSentNewUserData = false;
                let serverSentNewPosition = false;
                if (typeof (peerDataFromMixer.x) === "number") {
                    if (!userDataCache.position) {
                        userDataCache.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.Point3D();
                    }
                    userDataCache.position.x = peerDataFromMixer.x / 1000;
                    serverSentNewPosition = true;
                }
                if (typeof (peerDataFromMixer.y) === "number") {
                    if (!userDataCache.position) {
                        userDataCache.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.Point3D();
                    }
                    userDataCache.position.y = peerDataFromMixer.y / 1000;
                    serverSentNewPosition = true;
                }
                if (typeof (peerDataFromMixer.z) === "number") {
                    if (!userDataCache.position) {
                        userDataCache.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.Point3D();
                    }
                    userDataCache.position.z = peerDataFromMixer.z / 1000;
                    serverSentNewPosition = true;
                }
                if (serverSentNewPosition) {
                    newUserData.position = _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisUtilities.translatePoint3DFromMixerSpace(_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.ourHiFiAxisConfiguration, userDataCache.position);
                    serverSentNewUserData = true;
                }
                let serverSentNewOrientation = false;
                if (typeof (peerDataFromMixer.W) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.w = peerDataFromMixer.W / 1000;
                    serverSentNewOrientation = true;
                }
                if (typeof (peerDataFromMixer.X) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.x = peerDataFromMixer.X / 1000;
                    serverSentNewOrientation = true;
                }
                if (typeof (peerDataFromMixer.Y) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.y = peerDataFromMixer.Y / 1000;
                    serverSentNewOrientation = true;
                }
                if (typeof (peerDataFromMixer.Z) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.z = peerDataFromMixer.Z / 1000;
                    serverSentNewOrientation = true;
                }
                if (serverSentNewOrientation) {
                    newUserData.orientationQuat = _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisUtilities.translateOrientationQuat3DFromMixerSpace(_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.ourHiFiAxisConfiguration, userDataCache.orientationQuat);
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.v) === "number") {
                    userDataCache.volumeDecibels = peerDataFromMixer.v;
                    newUserData.volumeDecibels = peerDataFromMixer.v;
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.s) === "boolean") {
                    userDataCache.isStereo = peerDataFromMixer.s;
                    newUserData.isStereo = peerDataFromMixer.s;
                    serverSentNewUserData = true;
                }
                if (serverSentNewUserData) {
                    allNewUserData.push(newUserData);
                }
            }
            if (this.onUserDataUpdated && allNewUserData.length > 0) {
                this.onUserDataUpdated(allNewUserData);
            }
        }
        if (jsonData.instructions) {
            for (const instruction of jsonData.instructions) {
                if (!Array.isArray(instruction) || !instruction.length) {
                    continue;
                }
                let instructionName = instruction[0];
                let instructionArguments = instruction.slice(1);
                if (instructionName === "mute") {
                    let shouldBeMuted;
                    if (instructionArguments.length >= 1) {
                        if (typeof (instructionArguments[0]) === "boolean") {
                            shouldBeMuted = instructionArguments[0];
                        }
                    }
                    if (shouldBeMuted !== undefined) {
                        this._setMutedByAdmin(shouldBeMuted, MuteReason.ADMIN);
                    }
                }
            }
        }
    }
    connectToHiFiMixer({ webRTCSessionParams, customSTUNandTURNConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._currentHiFiConnectionState === _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Connected && this.mixerInfo["connected"]) {
                let msg = `Already connected! If a reconnect is needed, please hang up and try again.`;
                return Promise.resolve(msg);
            }
            if (!this.webRTCAddress) {
                let errMsg = `Couldn't connect: \`this.webRTCAddress\` is falsey!`;
                try {
                    yield this._disconnectFromHiFiMixer();
                }
                catch (errorClosing) {
                    errMsg += `\nAdditionally, there was an error trying to close the failed connection. Error:\n${errorClosing}`;
                }
                return Promise.reject(errMsg);
            }
            this._currentHiFiConnectionState = undefined;
            let mixerIsUnavailable = false;
            const tempUnavailableStateHandler = (event) => {
                if (event && event.state === _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingStates.UNAVAILABLE) {
                    mixerIsUnavailable = true;
                    this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                    this._raviSession.closeRAVISession();
                }
            };
            this._raviSignalingConnection.addStateChangeHandler(tempUnavailableStateHandler);
            try {
                yield this._raviSignalingConnection.openRAVISignalingConnection(this.webRTCAddress);
            }
            catch (errorOpeningSignalingConnection) {
                let errMsg = `Couldn't open signaling connection to \`${this.webRTCAddress.slice(0, this.webRTCAddress.indexOf("token="))}<token redacted>\`! Error:\n${errorOpeningSignalingConnection}`;
                try {
                    yield this._disconnectFromHiFiMixer();
                }
                catch (errorClosing) {
                    errMsg += `\nAdditionally, there was an error trying to close the failed connection. Error:\n${errorClosing}`;
                }
                this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                return Promise.reject(errMsg);
            }
            try {
                yield this._raviSession.openRAVISession({ signalingConnection: this._raviSignalingConnection, params: webRTCSessionParams, customStunAndTurn: customSTUNandTURNConfig });
            }
            catch (errorOpeningRAVISession) {
                let errMsg = `Couldn't open RAVI session associated with \`${this.webRTCAddress.slice(0, this.webRTCAddress.indexOf("token="))}<token redacted>\`! Error:\n${errorOpeningRAVISession}`;
                if (mixerIsUnavailable) {
                    errMsg = `High Fidelity server is at capacity; service is unavailable.`;
                }
                try {
                    yield this._disconnectFromHiFiMixer();
                }
                catch (errorClosing) {
                    errMsg += `\nAdditionally, there was an error trying to close the connection. Error:\n${errorClosing}`;
                }
                this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                return Promise.reject(errMsg);
            }
            let audionetInitResponse;
            try {
                audionetInitResponse = yield this.promiseToRunAudioInit();
            }
            catch (initError) {
                let errMsg = `\`audionet.init\` command failed! Error:\n${initError.error}`;
                try {
                    yield this._disconnectFromHiFiMixer();
                }
                catch (errorClosing) {
                    errMsg += `\nAdditionally, there was an error trying to close the failed connection. Error:\n${errorClosing}`;
                }
                this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                return Promise.reject(errMsg);
            }
            this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
            this.concurrency = 0;
            this._raviSession.getCommandController().addBinaryHandler((data) => { this.handleRAVISessionBinaryData(data); }, true);
            return Promise.resolve(audionetInitResponse);
        });
    }
    disconnectFromHiFiMixer() {
        return __awaiter(this, void 0, void 0, function* () {
            this._raviDiagnostics.noteExplicitApplicationClose();
            this._hifiDiagnostics.noteExplicitApplicationClose();
            return this._disconnectFromHiFiMixer();
        });
    }
    _disconnectFromHiFiMixer() {
        return __awaiter(this, void 0, void 0, function* () {
            function close(thingToClose, nameOfThingToClose, closedState) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (thingToClose) {
                        let state = thingToClose.getState();
                        if (!thingToClose || state === closedState) {
                            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`The RAVI ${nameOfThingToClose} was already closed.`);
                        }
                        else {
                            try {
                                if (thingToClose instanceof _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingConnection) {
                                    yield thingToClose.closeRAVISignalingConnection();
                                }
                                else if (thingToClose instanceof _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSession) {
                                    yield thingToClose.closeRAVISession();
                                }
                                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`The RAVI ${nameOfThingToClose} closed successfully from state ${state}.`);
                            }
                            catch (e) {
                                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`The RAVI ${nameOfThingToClose} didn't close successfully from state ${state}! Error:\n${e}`);
                            }
                        }
                    }
                    else {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`The RAVI ${nameOfThingToClose} was missing.`);
                    }
                    thingToClose = null;
                });
            }
            yield close(this._raviSignalingConnection, "Signaling Connection", _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingStates.CLOSED);
            yield close(this._raviSession, "Session", _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.CLOSED);
            this._resetMixerInfo();
            yield this._setMutedByAdmin(false, MuteReason.INTERNAL);
            return Promise.resolve(`Successfully disconnected.`);
        });
    }
    setRAVIInputAudio(inputAudioMediaStream, isStereo = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let retval = false;
            if (this._raviSession) {
                let streamController = this._raviSession.getStreamController();
                if (!streamController) {
                    _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set input audio on _raviSession.streamController: No \`streamController\`!`);
                    retval = false;
                }
                else {
                    streamController.setInputAudio(inputAudioMediaStream, isStereo);
                    _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set input audio on _raviSession.streamController!`);
                    retval = true;
                }
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set input audio on _raviSession.streamController: No \`_raviSession\`!`);
                retval = false;
            }
            if (retval) {
                if (this._inputAudioMediaStreamIsStereo != isStereo) {
                    if (this._raviSession.getState() === _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.CONNECTED) {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Stereo status has changed from ${this._inputAudioMediaStreamIsStereo} to ${isStereo}; attempting to re-initialize with the mixer`);
                        let audionetInitResponse;
                        try {
                            this._inputAudioMediaStreamIsStereo = isStereo;
                            audionetInitResponse = yield this.promiseToRunAudioInit();
                        }
                        catch (initError) {
                            let errMsg = `Attempt to call \`audionet.init\` for change in stereo status failed! Error:\n${initError.error}`;
                            return Promise.reject(errMsg);
                        }
                    }
                    else {
                        this._inputAudioMediaStreamIsStereo = isStereo;
                    }
                }
            }
            return retval;
        });
    }
    setInputAudioMuted(newMutedValue, tryToStopMicStream = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._setMuted(newMutedValue, tryToStopMicStream, MuteReason.CLIENT);
        });
    }
    _setMutedByAdmin(mutedByAdmin, muteReason) {
        return __awaiter(this, void 0, void 0, function* () {
            this._adminPreventsInputAudioUnmuting = mutedByAdmin;
            return yield this._setMuted(mutedByAdmin || this._lastSuccessfulInputAudioMutedValue, false, muteReason);
        });
    }
    _setMuted(newMutedValue, tryToStopMicStream, muteReason) {
        return __awaiter(this, void 0, void 0, function* () {
            let success = true;
            if (muteReason == MuteReason.CLIENT) {
                if (this._adminPreventsInputAudioUnmuting && !newMutedValue) {
                    _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: Muted by admin.`);
                    success = false;
                }
            }
            if (success) {
                success = yield this._trySetInputAudioMuted(newMutedValue, tryToStopMicStream);
            }
            if (success) {
                this._lastSuccessfulInputAudioMutedValue = newMutedValue;
            }
            if (this.onMuteChanged) {
                this.onMuteChanged(new MuteChangedEvent({
                    success: success,
                    targetInputAudioMutedValue: newMutedValue,
                    currentInputAudioMutedValue: this._lastSuccessfulInputAudioMutedValue,
                    adminPreventsInputAudioUnmuting: this._adminPreventsInputAudioUnmuting,
                    muteReason: muteReason
                }));
            }
            return success;
        });
    }
    _trySetInputAudioMuted(newMutedValue, tryToStopMicStream) {
        return __awaiter(this, void 0, void 0, function* () {
            let streamController = this._raviSession.getStreamController();
            if (this._raviSession && streamController) {
                let hasMicPermission = false;
                if (typeof (navigator) !== "undefined" && navigator.permissions && navigator.permissions.query) {
                    let result;
                    try {
                        result = yield navigator.permissions.query({ name: 'microphone' });
                    }
                    catch (_a) { }
                    if (result && result.state === "granted") {
                        hasMicPermission = true;
                    }
                }
                if (!tryToStopMicStream || !hasMicPermission || typeof self === 'undefined') {
                    let raviAudioStream = streamController._inputAudioStream;
                    if (raviAudioStream) {
                        raviAudioStream.getTracks().forEach((track) => {
                            track.enabled = !newMutedValue;
                        });
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set mute state to ${newMutedValue} on _raviSession.streamController._inputAudioStream`);
                        return true;
                    }
                    else {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: No \`_inputAudioStream\` on \`_raviSession.streamController\`.`);
                    }
                }
                else {
                    let raviAudioStream = streamController._inputAudioStream;
                    if (raviAudioStream && newMutedValue) {
                        raviAudioStream.getTracks().forEach((track) => {
                            this._cachedMediaTrackConstraints = track.getConstraints();
                            track.stop();
                        });
                        streamController.setInputAudio(null);
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set mute state to \`true\` by stopping all input media tracks!`);
                        return true;
                    }
                    else if (!raviAudioStream && !newMutedValue) {
                        let newMediaStream = yield navigator.mediaDevices.getUserMedia({ audio: this._cachedMediaTrackConstraints, video: false });
                        streamController.setInputAudio(newMediaStream);
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set mute state to \`false\` by getting new input media stream!`);
                        return true;
                    }
                    else if (raviAudioStream && !newMutedValue) {
                        raviAudioStream.getTracks().forEach((track) => {
                            track.enabled = true;
                        });
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set mute state to \`false\` by enabling all tracks on \`_raviSession.streamController._inputAudioStream\`!`);
                        return true;
                    }
                    else {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: No \`_inputAudioStream\` on \`_raviSession.streamController\`.`);
                    }
                }
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: No \`_raviSession\`, or \`_raviSession.getStreamController()\` returned null.`);
                return false;
            }
        });
    }
    getOutputAudioMediaStream() {
        if (!this._raviSession) {
            return null;
        }
        let streamController = this._raviSession.getStreamController();
        if (!streamController) {
            return null;
        }
        return streamController.getAudioStream();
    }
    _setCurrentHiFiConnectionState(state) {
        if (this._currentHiFiConnectionState !== state) {
            this._currentHiFiConnectionState = state;
            if (this.onConnectionStateChanged) {
                this.onConnectionStateChanged(this._currentHiFiConnectionState);
            }
            this._hifiDiagnostics.fire();
        }
    }
    getCurrentHiFiConnectionState() {
        return this._currentHiFiConnectionState;
    }
    onRAVISignalingStateChanged(event) {
        return __awaiter(this, void 0, void 0, function* () {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`New RAVI signaling state: \`${event.state}\``);
            switch (event.state) {
                case _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingStates.UNAVAILABLE:
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Unavailable);
                    try {
                        yield this._disconnectFromHiFiMixer();
                    }
                    catch (errorClosing) {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Error encountered while trying to close the connection. Error:\n${errorClosing}`);
                    }
                    break;
            }
        });
    }
    onRAVISessionStateChanged(event) {
        return __awaiter(this, void 0, void 0, function* () {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`New RAVI session state: \`${event.state}\``);
            this._raviDiagnostics.fire();
            switch (event.state) {
                case _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.CONNECTED:
                    this._mixerPeerKeyToStateCacheDict = {};
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Connected);
                    break;
                case _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.DISCONNECTED:
                    if (this._currentHiFiConnectionState === _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Unavailable) {
                        break;
                    }
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Disconnected);
                    try {
                        yield this._disconnectFromHiFiMixer();
                    }
                    catch (errorClosing) {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Error encountered while trying to close the connection. Error:\n${errorClosing}`);
                    }
                    break;
                case _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.FAILED:
                    if (this._currentHiFiConnectionState === _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Unavailable) {
                        break;
                    }
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Failed);
                    break;
                case _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.CLOSED:
                    if (this._currentHiFiConnectionState === _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Unavailable) {
                        break;
                    }
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Disconnected);
                    break;
            }
        });
    }
    startCollectingWebRTCStats(callback) {
        if (!this._raviSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`Couldn't start collecting WebRTC stats: No \`_raviSession\`!`);
            return;
        }
        if (this._statsObserverCallback) {
            this.stopCollectingWebRTCStats();
        }
        this._statsObserverCallback = callback;
        this._raviSession.addStatsObserver(this._statsObserverCallback);
    }
    stopCollectingWebRTCStats() {
        if (!this._raviSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`Couldn't stop collecting WebRTC stats: No \`_raviSession\`!`);
            return;
        }
        this._raviSession.removeStatsObserver(this._statsObserverCallback);
        this._statsObserverCallback = undefined;
    }
    _transmitHiFiAudioAPIDataToServer(currentHifiAudioAPIData, previousHifiAudioAPIData) {
        if (!this.mixerInfo["connected"] || !this._raviSession) {
            return {
                success: false,
                error: `Can't transmit data to mixer; not connected to mixer.`
            };
        }
        let dataForMixer = {};
        if (currentHifiAudioAPIData.position && (typeof (currentHifiAudioAPIData.position.x) === "number")
            && (typeof (currentHifiAudioAPIData.position.y) === "number")
            && (typeof (currentHifiAudioAPIData.position.z) === "number")) {
            let changedComponents = { x: false, y: false, z: false, changed: false };
            if (previousHifiAudioAPIData && previousHifiAudioAPIData.position) {
                if (currentHifiAudioAPIData.position.x !== previousHifiAudioAPIData.position.x) {
                    changedComponents.x = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.position.y !== previousHifiAudioAPIData.position.y) {
                    changedComponents.y = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.position.z !== previousHifiAudioAPIData.position.z) {
                    changedComponents.z = true;
                    changedComponents.changed = true;
                }
            }
            else {
                changedComponents.x = true;
                changedComponents.y = true;
                changedComponents.z = true;
                changedComponents.changed = true;
            }
            if (changedComponents.changed) {
                let translatedPosition = _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisUtilities.translatePoint3DToMixerSpace(_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.ourHiFiAxisConfiguration, currentHifiAudioAPIData.position);
                if (changedComponents.x) {
                    dataForMixer["x"] = Math.round(translatedPosition.x * 1000);
                }
                if (changedComponents.y) {
                    dataForMixer["y"] = Math.round(translatedPosition.y * 1000);
                }
                if (changedComponents.z) {
                    dataForMixer["z"] = Math.round(translatedPosition.z * 1000);
                }
            }
        }
        if (currentHifiAudioAPIData.orientationQuat && (typeof (currentHifiAudioAPIData.orientationQuat.w) === "number")
            && (typeof (currentHifiAudioAPIData.orientationQuat.x) === "number")
            && (typeof (currentHifiAudioAPIData.orientationQuat.y) === "number")
            && (typeof (currentHifiAudioAPIData.orientationQuat.z) === "number")) {
            let changedComponents = { w: false, x: false, y: false, z: false, changed: false };
            if (previousHifiAudioAPIData && previousHifiAudioAPIData.orientationQuat) {
                if (currentHifiAudioAPIData.orientationQuat.w !== previousHifiAudioAPIData.orientationQuat.w) {
                    changedComponents.w = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.orientationQuat.x !== previousHifiAudioAPIData.orientationQuat.x) {
                    changedComponents.x = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.orientationQuat.y !== previousHifiAudioAPIData.orientationQuat.y) {
                    changedComponents.y = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.orientationQuat.z !== previousHifiAudioAPIData.orientationQuat.z) {
                    changedComponents.z = true;
                    changedComponents.changed = true;
                }
            }
            else {
                changedComponents.w = true;
                changedComponents.x = true;
                changedComponents.y = true;
                changedComponents.z = true;
                changedComponents.changed = true;
            }
            if (changedComponents.changed) {
                let translatedOrientation = _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisUtilities.translateOrientationQuat3DToMixerSpace(_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.ourHiFiAxisConfiguration, currentHifiAudioAPIData.orientationQuat);
                if (changedComponents.w) {
                    dataForMixer["W"] = translatedOrientation.w * 1000;
                }
                if (changedComponents.x) {
                    dataForMixer["X"] = translatedOrientation.x * 1000;
                }
                if (changedComponents.y) {
                    dataForMixer["Y"] = translatedOrientation.y * 1000;
                }
                dataForMixer["Z"] = translatedOrientation.z * 1000;
            }
        }
        if (typeof (currentHifiAudioAPIData.volumeThreshold) === "number") {
            dataForMixer["T"] = currentHifiAudioAPIData.volumeThreshold;
        }
        if (typeof (currentHifiAudioAPIData.hiFiGain) === "number") {
            dataForMixer["g"] = Math.max(0, currentHifiAudioAPIData.hiFiGain);
        }
        if (typeof (currentHifiAudioAPIData.userAttenuation) === "number") {
            dataForMixer["a"] = currentHifiAudioAPIData.userAttenuation;
        }
        if (typeof (currentHifiAudioAPIData.userRolloff) === "number") {
            dataForMixer["r"] = Math.max(0, currentHifiAudioAPIData.userRolloff);
        }
        if (typeof (currentHifiAudioAPIData._otherUserGainQueue) == "object") {
            let changedUserGains = {};
            let idToGains = Object.entries(currentHifiAudioAPIData._otherUserGainQueue);
            let previousOtherUserGains = previousHifiAudioAPIData ? previousHifiAudioAPIData._otherUserGainQueue : undefined;
            for (const idToGain of idToGains) {
                let hashedVisitId = idToGain[0];
                let gain = idToGain[1];
                if (!(typeof (gain) == "number")) {
                    continue;
                }
                if (previousOtherUserGains && previousOtherUserGains[hashedVisitId] === gain) {
                    continue;
                }
                changedUserGains[hashedVisitId] = gain;
            }
            if (Object.entries(changedUserGains).length) {
                dataForMixer["V"] = changedUserGains;
            }
        }
        if (Object.keys(dataForMixer).length === 0) {
            return {
                success: true,
                stringifiedDataForMixer: JSON.stringify({})
            };
        }
        else {
            let commandController = this._raviSession.getCommandController();
            if (commandController) {
                let stringifiedDataForMixer = JSON.stringify(dataForMixer);
                commandController.sendInput(stringifiedDataForMixer);
                return {
                    success: true,
                    stringifiedDataForMixer: stringifiedDataForMixer
                };
            }
            else {
                return {
                    success: false,
                    error: `Can't transmit data to mixer; no \`commandController\`!.`
                };
            }
        }
    }
    _resetMixerInfo() {
        this.mixerInfo = {
            "connected": false,
        };
    }
}


/***/ }),

/***/ "./src/classes/HiFiUserDataSubscription.ts":
/*!*************************************************!*\
  !*** ./src/classes/HiFiUserDataSubscription.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AvailableUserDataSubscriptionComponents": () => (/* binding */ AvailableUserDataSubscriptionComponents),
/* harmony export */   "UserDataSubscription": () => (/* binding */ UserDataSubscription)
/* harmony export */ });
var AvailableUserDataSubscriptionComponents;
(function (AvailableUserDataSubscriptionComponents) {
    AvailableUserDataSubscriptionComponents["Position"] = "Position";
    AvailableUserDataSubscriptionComponents["OrientationEuler"] = "Orientation (Euler)";
    AvailableUserDataSubscriptionComponents["OrientationQuat"] = "Orientation (Quaternion)";
    AvailableUserDataSubscriptionComponents["VolumeDecibels"] = "Volume (Decibels)";
    AvailableUserDataSubscriptionComponents["IsStereo"] = "IsStereo";
})(AvailableUserDataSubscriptionComponents || (AvailableUserDataSubscriptionComponents = {}));
class UserDataSubscription {
    constructor({ providedUserID = null, components, callback }) {
        this.providedUserID = providedUserID;
        this.components = components;
        this.callback = callback;
    }
}


/***/ }),

/***/ "./src/constants/HiFiConstants.ts":
/*!****************************************!*\
  !*** ./src/constants/HiFiConstants.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiConstants": () => (/* binding */ HiFiConstants)
/* harmony export */ });
class HiFiConstants {
    constructor() { }
}
HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS = 10;
HiFiConstants.DEFAULT_TRANSMIT_RATE_LIMIT_TIMEOUT_MS = 50;
HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_ENDPOINT = "api.highfidelity.com";
HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_PORT = 443;
;


/***/ }),

/***/ "./src/diagnostics/diagnostics.ts":
/*!****************************************!*\
  !*** ./src/diagnostics/diagnostics.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Diagnostics": () => (/* binding */ Diagnostics)
/* harmony export */ });
/* harmony import */ var _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libravi/RaviSession */ "./src/libravi/RaviSession.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const isBrowser = typeof window !== 'undefined';
const noop = (_) => undefined;
const xStorage = isBrowser ? window.localStorage : { getItem: noop, setItem: noop, removeItem: noop };
const xAddEventListener = isBrowser ? window.addEventListener : noop;
const xRemoveEventListener = isBrowser ? window.removeEventListener : noop;
const xDocument = isBrowser ? window.document : { visibilityState: true, addEventListener: noop, removeEventListener: noop };
const xNavigator = isBrowser ? window.navigator : { onLine: true, userAgent: `NodeJS ${process.report.getReport().header.nodejsVersion}` };
let xfetch = isBrowser && window.fetch;
if (!isBrowser) {
    try {
        xfetch = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
    }
    catch (e) {
        ;
    }
}
const nonOperative = "non-operative";
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('remote-inbound-rtp', _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.get('remote-inbound-rtp').concat(['packetsLost', 'totalRoundTripTime']));
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('inbound-rtp', _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.get('inbound-rtp').concat(['packetsLost', 'packetsReceived', 'jitter']));
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('outbound-rtp', ['type', 'retransmittedPacketsSent', 'packetsSent']);
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('candidate-pair', ['writable', 'state', 'nominated', 'localCandidateId', 'remoteCandidateId']);
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('remote-candidate', ['id', 'address', 'ip', 'candidateType', 'protocol']);
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('local-candidate', ['id', 'address', 'ip', 'candidateType', 'protocol']);
let nStatsClients = 0;
let browserStats = {};
let remoteStats = {};
let reports;
const useDebugPrefixes = false;
class Diagnostics {
    constructor({ url = "https://webrtc-diag.highfidelity.com/api/v1/logs/post_logs", label, session, ravi, fireOn = [] }) {
        Object.assign(this, { url, label, session, ravi, fireOn });
        this.checkPersisted();
        this.reset();
        this.fireListener = () => this.fire();
        this.onlineListener = () => this.checkPersisted();
    }
    prime(identifier) {
        if (this.isPrimed())
            return;
        this.checkPersisted();
        this.identifier = identifier;
        this.grabRTCInternals();
        Diagnostics.startStats(this.session);
        this.fireOn.forEach(event => xDocument.addEventListener(event, this.fireListener));
    }
    fire() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isPrimed())
                return;
            const reportString = this.toString();
            if (!(yield this.report(reportString))) {
                this.persist(reportString);
            }
            this.reset();
        });
    }
    noteExplicitApplicationClose() {
        this.explicitApplicationClose = true;
    }
    reset() {
        Diagnostics.stopStats(this.session);
        this.identifier = nonOperative;
        this.explicitApplicationClose = false;
        this.webSocket = this.rtc = {};
        this.fireOn.forEach(event => xDocument.removeEventListener(event, this.fireListener));
        reports = {
            'outbound-rtp': {},
            'inbound-rtp': {},
            'remote-inbound-rtp': {}
        };
    }
    isPrimed() {
        return this.identifier !== nonOperative;
    }
    toString() {
        return `${new Date().toISOString()} ${this.identifier} ` +
            this.s('logReason', 'sessionEND') +
            this.connectionStats('browserStats') +
            this.connectionStats('mixerStats') +
            this.rtpStats() +
            this.rtcStates() +
            this.s('NUM_CONNECTED', this.session.concurrency, '\n') +
            this.s('APPSTATE', this.session.getCurrentHiFiConnectionState(), '\n') +
            this.s('RAVISTATE', this.ravi.getState()) +
            this.s('ONLINE', xNavigator.onLine ? 'yes' : 'no') +
            this.s('XPLICITCLOSED', this.explicitApplicationClose ? 'yes' : 'no') +
            this.visibilityInfo() +
            this.connectionInfo() +
            (useDebugPrefixes ? '\n' : '') +
            ` [${xNavigator.userAgent}]`;
    }
    s(name, value, debugPrefix = '') {
        let separator = isNaN(value) ? '_' : ':';
        return `${useDebugPrefixes ? debugPrefix : ''} ${this.label}${name}${separator}${value}`;
    }
    connectionInfo() {
        const info = xNavigator.connection || xNavigator.mozConnection || xNavigator.webkitConnection || {};
        return this.s('DEVICE', info.type, '\n') +
            this.s('RATING', info.effectiveType) +
            this.s('DL', info.downlink) +
            this.s('RTT', info.rtt);
    }
    visibilityInfo() {
        return this.s('VISIBLITY', xDocument.visibilityState);
    }
    grabRTCInternals() {
        let ravi = this.ravi, raviRTC = ravi._raviImplementation, signaling = raviRTC._signalingConnection._signalingImplementation;
        this.webSocket = signaling._webSocket;
        this.rtc = raviRTC._rtcConnection;
    }
    rtcStates() {
        let collector = {}, safelyGet = (property, source = this.rtc) => {
            try {
                collector[property] = source[property];
            }
            catch (e) {
                collector[property] = e.name;
            }
        };
        safelyGet('readyState', this.webSocket);
        ['connectionState', 'signalingState', 'iceConnctionState', 'iceGatheringState'].forEach(p => safelyGet(p));
        return this.s('WebSocket', collector.readyState, '\n') +
            this.s('RTC', collector.connectionState) +
            this.s('SIGNALING', collector.signalingState) +
            this.s('ICE', collector.iceConnectionState) +
            this.s('GATHERING', collector.iceGatheringState);
    }
    connectionStats(kind) {
        let report = kind === 'browserStats' ? browserStats : remoteStats;
        return this.s(kind + 'IP', report.ip || report.address, '\n') +
            this.s(kind + 'TYPE', report.candidateType) +
            this.s(kind + 'PROTOCOL', report.protocol);
    }
    rtpStats() {
        let s = '';
        Object.keys(reports).forEach(reportName => {
            let report = reports[reportName], first = true;
            Object.keys(report).forEach(propertyName => {
                s += this.s(`${reportName}_${propertyName}`, report[propertyName], first ? '\n' : '');
                first = false;
            });
        });
        return s;
    }
    report(reportString) {
        if (!xNavigator.onLine)
            return false;
        if (!xfetch)
            return false;
        return xfetch(this.url, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: reportString
        }).then((response) => response.ok, (x) => false);
    }
    persist(reportString) {
        let existing = xStorage.getItem(this.label) || "";
        if (existing)
            existing += "\n";
        xStorage.setItem(this.label, existing + reportString);
        xAddEventListener('online', this.onlineListener);
    }
    checkPersisted() {
        return __awaiter(this, void 0, void 0, function* () {
            xRemoveEventListener('online', this.onlineListener);
            let existing = xStorage.getItem(this.label);
            if (!existing)
                return;
            if (!(yield this.report(existing)))
                return;
            xStorage.removeItem(this.label);
        });
    }
    static startStats(session) {
        if (nStatsClients++ > 0)
            return;
        session.startCollectingWebRTCStats((next, previous) => {
            let selected = next.find((report) => report.writable || report.nominated), localReport = next.find((report) => report.id === selected.localCandidateId), remoteReport = next.find((report) => report.id === selected.remoteCandidateId);
            if (localReport)
                browserStats = localReport;
            if (remoteReport)
                remoteStats = remoteReport;
            function note(type, deltaProperties, absoluteProperties = []) {
                function findReport(list) {
                    return list.find((report) => {
                        return report.type == type;
                    });
                }
                let previousReport = findReport(previous), nextReport = findReport(next);
                deltaProperties.forEach(property => reports[type][property] =
                    nextReport && (nextReport[property] - (previousReport ? previousReport[property] : 0)));
                absoluteProperties.forEach(property => reports[type][property] =
                    nextReport && nextReport[property]);
            }
            note('outbound-rtp', ['retransmittedPacketsSent', 'packetsSent']);
            note('inbound-rtp', ['packetsLost', 'packetsReceived'], ['jitter']);
            note('remote-inbound-rtp', ['packetsLost'], ['roundTripTime', 'totalRoundTripTime', 'jitter']);
        });
    }
    static stopStats(session) {
        if (!nStatsClients)
            return;
        if (--nStatsClients > 0)
            return;
        session.stopCollectingWebRTCStats();
        browserStats = remoteStats = {};
    }
}


/***/ }),

/***/ "./src/libravi/RaviCommandController.ts":
/*!**********************************************!*\
  !*** ./src/libravi/RaviCommandController.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviCommandController": () => (/* binding */ RaviCommandController)
/* harmony export */ });
/* harmony import */ var _RaviUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");

const _BINARY_COMMAND_KEY = "_BINARY";
const _MOUSE_STATE_BUFFER_SIZE = 28;
var _KEY_CODE_TABLE;
(function (_KEY_CODE_TABLE) {
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ControlLeft"] = 0] = "ControlLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["AltLeft"] = 1] = "AltLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["OSLeft"] = 2] = "OSLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Space"] = 3] = "Space";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["OSRight"] = 4] = "OSRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["AltRight"] = 5] = "AltRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ControlRight"] = 6] = "ControlRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ShiftLeft"] = 7] = "ShiftLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ShiftRight"] = 8] = "ShiftRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Comma"] = 9] = "Comma";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Period"] = 10] = "Period";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Slash"] = 11] = "Slash";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["CapsLock"] = 12] = "CapsLock";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Enter"] = 13] = "Enter";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Semicolon"] = 14] = "Semicolon";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Quote"] = 15] = "Quote";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Tab"] = 16] = "Tab";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["BracketLeft"] = 17] = "BracketLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["BracketRight"] = 18] = "BracketRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Backslash"] = 19] = "Backslash";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Backquote"] = 20] = "Backquote";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Minus"] = 21] = "Minus";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Equal"] = 22] = "Equal";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit0"] = 23] = "Digit0";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit1"] = 24] = "Digit1";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit2"] = 25] = "Digit2";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit3"] = 26] = "Digit3";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit4"] = 27] = "Digit4";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit5"] = 28] = "Digit5";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit6"] = 29] = "Digit6";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit7"] = 30] = "Digit7";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit8"] = 31] = "Digit8";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit9"] = 32] = "Digit9";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Backspace"] = 33] = "Backspace";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Escape"] = 34] = "Escape";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowLeft"] = 35] = "ArrowLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowRight"] = 36] = "ArrowRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowDown"] = 37] = "ArrowDown";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowUp"] = 38] = "ArrowUp";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["PageDown"] = 39] = "PageDown";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["PageUp"] = 40] = "PageUp";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["End"] = 41] = "End";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Home"] = 42] = "Home";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Delete"] = 43] = "Delete";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Insert"] = 44] = "Insert";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad0"] = 45] = "Numpad0";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad1"] = 46] = "Numpad1";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad2"] = 47] = "Numpad2";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad3"] = 48] = "Numpad3";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad4"] = 49] = "Numpad4";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad5"] = 50] = "Numpad5";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad6"] = 51] = "Numpad6";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad7"] = 52] = "Numpad7";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad8"] = 53] = "Numpad8";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad9"] = 54] = "Numpad9";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadDecimal"] = 55] = "NumpadDecimal";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadEnter"] = 56] = "NumpadEnter";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadAdd"] = 57] = "NumpadAdd";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadSubtract"] = 58] = "NumpadSubtract";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumLock"] = 59] = "NumLock";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadEqual"] = 60] = "NumpadEqual";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadMultiply"] = 61] = "NumpadMultiply";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadDivide"] = 62] = "NumpadDivide";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyA"] = 63] = "KeyA";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyB"] = 64] = "KeyB";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyC"] = 65] = "KeyC";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyD"] = 66] = "KeyD";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyE"] = 67] = "KeyE";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyF"] = 68] = "KeyF";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyG"] = 69] = "KeyG";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyH"] = 70] = "KeyH";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyI"] = 71] = "KeyI";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyJ"] = 72] = "KeyJ";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyK"] = 73] = "KeyK";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyL"] = 74] = "KeyL";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyM"] = 75] = "KeyM";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyN"] = 76] = "KeyN";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyO"] = 77] = "KeyO";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyP"] = 78] = "KeyP";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyQ"] = 79] = "KeyQ";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyR"] = 80] = "KeyR";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyS"] = 81] = "KeyS";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyT"] = 82] = "KeyT";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyU"] = 83] = "KeyU";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyV"] = 84] = "KeyV";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyW"] = 85] = "KeyW";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyX"] = 86] = "KeyX";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyY"] = 87] = "KeyY";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyZ"] = 88] = "KeyZ";
})(_KEY_CODE_TABLE || (_KEY_CODE_TABLE = {}));
;
const _KEYBOARD_STATE_BUFFER_SIZE = 12;
class RaviCommandController {
    constructor() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviCommandController");
        this._commandQueueMap = new Map();
        this._numQueuedCommands = 0;
        this._commandQueueInterval = 1000;
        this._commandPumpTimer = null;
        this._inputTarget;
        this._keyboardTarget;
        this._mouseStateBuffer = new ArrayBuffer(_MOUSE_STATE_BUFFER_SIZE + 4);
        this._mouseStateUint8 = new Uint8Array(this._mouseStateBuffer);
        this._mouseStateUint8[0] = 0x4D;
        this._mouseStateFloat = new Float32Array(this._mouseStateBuffer, 4);
        this._mouseStateFloat[0] = -1.0;
        this._mouseStateFloat[1] = -1.0;
        this._mouseStateFloat[2] = -1.0;
        this._mouseStateFloat[3] = -1.0;
        this._keyboardStateBuffer = new ArrayBuffer(_KEYBOARD_STATE_BUFFER_SIZE + 1);
        this._keyboardState = new Uint8Array(this._keyboardStateBuffer);
        this._keyboardState[0] = 0x4B;
    }
    setCommandQueueInterval(queueInterval) {
        this._commandQueueInterval = queueInterval;
        if (this._commandPumpTimer) {
            this.stopMonitoringQueues();
            this.monitorQueues();
        }
    }
    queueCommand(command, param, handler) {
        var commandQueue = this._commandQueueMap.get(command);
        if (!commandQueue) {
            commandQueue = { toSend: [], listener: [] };
            this._commandQueueMap.set(command, commandQueue);
        }
        var handlerInstance = null;
        if (handler) {
            handlerInstance = new RaviCommandHandlerInstance(handler, false, true);
        }
        commandQueue.toSend.push(new RaviCommandInstance(command, param, handlerInstance));
        this._numQueuedCommands++;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Added command " + command, "RaviCommandController");
    }
    queueBinaryCommand(message) {
        let command = _BINARY_COMMAND_KEY;
        var commandQueue = this._commandQueueMap.get(command);
        if (!commandQueue) {
            commandQueue = { toSend: [], listener: [] };
            this._commandQueueMap.set(command, commandQueue);
        }
        commandQueue.toSend.push(new RaviCommandInstance(message, null, null));
        this._numQueuedCommands++;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Added binary command", "RaviCommandController");
    }
    addMessageHandler(expectedMessage, handler, isSticky) {
        var messageEntry = this._commandQueueMap.get(expectedMessage);
        if (!messageEntry) {
            messageEntry = { toSend: [], listener: [] };
            this._commandQueueMap.set(expectedMessage, messageEntry);
        }
        var handlerInstance = new RaviCommandHandlerInstance(handler, isSticky, false);
        messageEntry.listener.push(handlerInstance);
    }
    addBinaryHandler(handler, isSticky) {
        this.addMessageHandler(_BINARY_COMMAND_KEY, handler, isSticky);
    }
    sendInput(inputEvent) {
        if (this._inputDataChannel && this._inputDataChannel.readyState === 'open') {
            this._inputDataChannel.send(inputEvent);
        }
    }
    monitorQueues() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Begin monitoring for queued commands", "RaviCommandController");
        this._commandPumpTimer = setInterval(this._processSendingQueuedCommands.bind(this), this._commandQueueInterval);
    }
    stopMonitoringQueues() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Stop monitoring for queued commands", "RaviCommandController");
        clearInterval(this._commandPumpTimer);
        this._commandPumpTimer = null;
    }
    _processSendingQueuedCommands() {
        if (this._numQueuedCommands <= 0) {
            return;
        }
        this._commandQueueMap.forEach(function (value, key, map) {
            if (value.toSend.length) {
                var commandInstance = value.toSend.shift();
                if (commandInstance._handler) {
                    value.listener.push(commandInstance._handler);
                }
                if (this._sendCommandInstance(commandInstance)) {
                    this._numQueuedCommands--;
                }
                else {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Send failed. CommandDataChannel may have been disconnected. Will not retry.", "RaviCommandController");
                }
            }
        }.bind(this));
    }
    _serializeJsonCommandMessageToSend(command, payload) {
        return JSON.stringify({ "c": command, "p": payload });
    }
    _unserializeJsonCommandMessageFromReceived(message) {
        let commandMessage;
        try {
            commandMessage = JSON.parse(message);
        }
        catch (e) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err(`Couldn't parse command message! Error:\n${e}\n Full message contents:\n${message}`, "RaviCommandController");
            return;
        }
        if (commandMessage && commandMessage.c && commandMessage.p) {
            return { 'command': commandMessage.c, 'payload': commandMessage.p };
        }
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Message cannot be unserialized into a CommandMessage: " + message, "RaviCommandController");
        return null;
    }
    _sendCommandInstance(commandInstance) {
        try {
            let message = commandInstance._command;
            if (typeof message === "string") {
                message = this._serializeJsonCommandMessageToSend(commandInstance._command, commandInstance._param);
                _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Sending command " + message, "RaviCommandController");
            }
            else {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Sending binary command", "RaviCommandController");
            }
            this._commandDataChannel.send(message);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Received error while sending: " + err.message, "RaviCommandController");
            return false;
        }
    }
    _processListeningCommand(fromServerMessage) {
        let serverData = fromServerMessage.data;
        let commandMessage = null;
        if (serverData) {
            if (typeof serverData === 'string') {
                commandMessage = this._unserializeJsonCommandMessageFromReceived(serverData);
                this._continueProcessingListeningCommand(commandMessage);
            }
            else if (serverData instanceof ArrayBuffer) {
                commandMessage = { 'command': _BINARY_COMMAND_KEY, 'payload': new Uint8Array(serverData) };
                this._continueProcessingListeningCommand(commandMessage);
            }
            else if (serverData instanceof Blob) {
                serverData.arrayBuffer()
                    .then((processedArrayBuffer) => {
                    commandMessage = { 'command': _BINARY_COMMAND_KEY, 'payload': new Uint8Array(processedArrayBuffer) };
                    this._continueProcessingListeningCommand(commandMessage);
                });
            }
        }
    }
    _continueProcessingListeningCommand(commandMessage) {
        if (!commandMessage) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Received invalid command message, ignoring: " + JSON.stringify(commandMessage), "RaviCommandController");
            return;
        }
        var foundCommandInstance = this._commandQueueMap.get(commandMessage.command);
        if (foundCommandInstance) {
            var length = foundCommandInstance.listener.length;
            if (length > 0) {
                if (foundCommandInstance.listener[0] && foundCommandInstance.listener[0]._hasMatchingSentCommand) {
                    var commandInstance = foundCommandInstance.listener.shift();
                    if (commandInstance && commandInstance._handler) {
                        commandInstance._handler(commandMessage.payload);
                        return;
                    }
                    else {
                        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Undefined command handler: " + commandMessage, "RaviCommandController");
                    }
                }
                else {
                    var newListeners = [];
                    for (var i = 0; i < length; i++) {
                        var listener = foundCommandInstance.listener[i];
                        if (listener && listener._handler) {
                            listener._handler(commandMessage.payload);
                        }
                        else {
                            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Undefined message handler: " + commandMessage, "RaviCommandController");
                        }
                        if (listener && listener._isSticky) {
                            newListeners.push(listener);
                        }
                    }
                    foundCommandInstance.listener = newListeners;
                }
            }
        }
    }
    _setInputDataChannel(inputDataChannel) {
        this._inputDataChannel = inputDataChannel;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Received new input data channel with id " + this._inputDataChannel.id, "RaviCommandController");
        this._inputDataChannel.onopen = function () {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_inputDataChannel onopen, state is " + this._inputDataChannel.readyState, "RaviCommandController");
        }.bind(this);
        this._inputDataChannel.onclose = function () {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_inputDataChannel onclose, state is " + this._inputDataChannel.readyState, "RaviCommandController");
        }.bind(this);
        this._inputDataChannel.onmessage = function (message) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_inputDataChannel got message: " + (message.data), "RaviCommandController");
        }.bind(this);
    }
    _setCommandDataChannel(commandDataChannel) {
        this._commandDataChannel = commandDataChannel;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Received new data channel with id " + this._commandDataChannel.id, "RaviCommandController");
        this._commandDataChannel.onopen = function () {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_commandDataChannel ononpen, state is " + this._commandDataChannel.readyState, "RaviCommandController");
            this.monitorQueues();
        }.bind(this);
        this._commandDataChannel.onclose = function () {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_commandDataChannel onclose, state is " + this._commandDataChannel.readyState, "RaviCommandController");
            this.stopMonitoringQueues();
        }.bind(this);
        this._commandDataChannel.onmessage = function (message) {
            this._processListeningCommand(message);
        }.bind(this);
    }
    setInputTarget(inputTargetElement) {
        if (this._inputTarget) {
            this._inputTarget.onmousemove = null;
            this._inputTarget.onmouseenter = null;
            this._inputTarget.onmouseleave = null;
            this._inputTarget.onmousedown = null;
            this._inputTarget.onmouseup = null;
            this._inputTarget.onwheel = null;
        }
        this._inputTarget = inputTargetElement;
        if (this._inputTarget) {
            var that = this;
            this._inputTarget.onmousemove = function (event) { that._trackMouse(event); };
            this._inputTarget.onmouseenter = null;
            this._inputTarget.onmouseleave = null;
            this._inputTarget.onmousedown = function (event) { that._captureMouseDown(event); };
            this._inputTarget.onmouseup = function (event) { that._resetMouseDown(event); };
            this._inputTarget.onwheel = function (event) { that._wheelMouse(event); };
        }
    }
    setKeyboardTarget(inputTargetElement) {
        if (this._keyboardTarget) {
            this._keyboardTarget.onkeydown = null;
            this._keyboardTarget.onkeyup = null;
        }
        this._keyboardTarget = inputTargetElement;
        if (this._keyboardTarget) {
            var that = this;
            this._keyboardTarget.onkeydown = function (event) { that._onKeyboardDown(event); };
            this._keyboardTarget.onkeyup = function (event) { that._onKeyboardUp(event); };
        }
    }
    _captureMouseDown(e) {
        this._mouseStateFloat[0] = e.offsetX;
        this._mouseStateFloat[1] = e.offsetY;
        this._mouseStateFloat[2] = e.offsetX;
        this._mouseStateFloat[3] = e.offsetY;
        this._mouseStateUint8[1] = e.buttons;
        this._sendMouseState();
    }
    _resetMouseDown(e) {
        this._mouseStateFloat[0] = -1.0;
        this._mouseStateFloat[1] = -1.0;
        this._mouseStateFloat[2] = -1.0;
        this._mouseStateFloat[3] = -1.0;
        this._mouseStateUint8[1] = e.buttons;
        this._sendMouseState();
    }
    _trackMouse(e) {
        this._mouseStateFloat[0] = e.offsetX;
        this._mouseStateFloat[1] = e.offsetY;
        this._mouseStateFloat[4] = this._inputTarget.offsetWidth;
        this._mouseStateFloat[5] = this._inputTarget.offsetHeight;
        this._mouseStateUint8[1] = e.buttons;
        this._sendMouseState();
    }
    _wheelMouse(e) {
        this._mouseStateFloat[6] = e.deltaY;
        this._sendMouseState();
        this._mouseStateFloat[6] = 0;
    }
    _sendMouseState() {
        this.sendInput(this._mouseStateBuffer);
    }
    _keyByteNum(c) {
        return c >> 3;
    }
    _keyBitMask(c) {
        return (1 << (c % 8));
    }
    _onKeyboardDown(e) {
        let c = _KEY_CODE_TABLE[e.code];
        let keyByteNum = 1 + this._keyByteNum(c);
        let keyByteMask = this._keyBitMask(c);
        if ((this._keyboardState[keyByteNum] & keyByteMask) === 0) {
            this._keyboardState[keyByteNum] |= keyByteMask;
            this._sendKeyboardState();
        }
    }
    _onKeyboardUp(e) {
        let c = _KEY_CODE_TABLE[e.code];
        let keyByteNum = 1 + this._keyByteNum(c);
        let keyByteMask = this._keyBitMask(c);
        if ((this._keyboardState[keyByteNum] & keyByteMask) !== 0) {
            this._keyboardState[keyByteNum] ^= keyByteMask;
            this._sendKeyboardState();
        }
    }
    _sendKeyboardState() {
        this.sendInput(this._keyboardStateBuffer);
    }
}
class RaviCommandInstance {
    constructor(command, param, handler) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviCommandInstance");
        this._command = command;
        this._param = param;
        this._handler = handler;
    }
}
class RaviCommandHandlerInstance {
    constructor(handler, isSticky, hasMatchingSentCommand) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviCommandHandlerInstance");
        this._handler = handler;
        this._isSticky = isSticky;
        this._hasMatchingSentCommand = hasMatchingSentCommand;
    }
}


/***/ }),

/***/ "./src/libravi/RaviSession.ts":
/*!************************************!*\
  !*** ./src/libravi/RaviSession.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviSessionStates": () => (/* binding */ RaviSessionStates),
/* harmony export */   "RaviSession": () => (/* binding */ RaviSession),
/* harmony export */   "STATS_WATCHER_FILTER": () => (/* binding */ STATS_WATCHER_FILTER)
/* harmony export */ });
/* harmony import */ var _RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RaviSignalingConnection */ "./src/libravi/RaviSignalingConnection.ts");
/* harmony import */ var _RaviStreamController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RaviStreamController */ "./src/libravi/RaviStreamController.ts");
/* harmony import */ var _RaviUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");
/* harmony import */ var _RaviCommandController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RaviCommandController */ "./src/libravi/RaviCommandController.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




;
var RaviSessionStates;
(function (RaviSessionStates) {
    RaviSessionStates["NEW"] = "new";
    RaviSessionStates["CONNECTING"] = "checking";
    RaviSessionStates["CONNECTED"] = "connected";
    RaviSessionStates["COMPLETED"] = "completed";
    RaviSessionStates["DISCONNECTED"] = "disconnected";
    RaviSessionStates["FAILED"] = "failed";
    RaviSessionStates["CLOSED"] = "closed";
})(RaviSessionStates || (RaviSessionStates = {}));
;
class RaviSession {
    constructor() {
        this._stateChangeHandlers = new Set();
        this._uuid = _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.createUUID();
        this._commandController = new _RaviCommandController__WEBPACK_IMPORTED_MODULE_3__.RaviCommandController();
        this._streamController = new _RaviStreamController__WEBPACK_IMPORTED_MODULE_1__.RaviStreamController(this._commandController);
        this._state = RaviSessionStates.CLOSED;
        this._raviImplementation = new RaviWebRTCImplementation(this);
        const raviImpl = this._raviImplementation;
        this._streamController.setInputAudioChangeHandler(raviImpl._addAudioInputStream.bind(raviImpl));
        this._streamController.setInputVideoChangeHandler(raviImpl._addVideoInputStream.bind(raviImpl));
    }
    getState() {
        return this._state;
    }
    getUUID() {
        return this._uuid;
    }
    addStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.add(changeHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error adding a state change handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    removeStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.delete(changeHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error removing a state change handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    getCommandController() {
        return this._commandController;
    }
    getStreamController() {
        return this._streamController;
    }
    openRAVISession({ signalingConnection, timeout = 5000, params = null, customStunAndTurn = null }) {
        if (this._state === RaviSessionStates.CONNECTED || this._state === RaviSessionStates.COMPLETED) {
            return Promise.resolve("There is already an open RAVI session. To reconnect, first close the existing connection, and then attempt to open again.");
        }
        var raviSession = this;
        this._raviImplementation._assignSignalingConnection(signalingConnection);
        this._openingTimeout = setTimeout(() => {
            let errorMessage = "RaviSession.open timed out after " + timeout + " ms";
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log(errorMessage, "RaviSession");
            raviSession._fulfillPromises({ message: errorMessage }, RaviSessionStates.FAILED);
            raviSession.closeRAVISession();
        }, timeout);
        return new Promise((resolve, reject) => {
            raviSession._resolveOpen = resolve;
            raviSession._rejectOpen = reject;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Opening RAVI session", "RaviSession");
            this._state = RaviSessionStates.NEW;
            raviSession._raviImplementation._open(params, customStunAndTurn);
        });
    }
    closeRAVISession() {
        var raviSession = this;
        if (this._state === RaviSessionStates.CLOSED)
            return Promise.resolve("RAVI session is already closed.");
        this._streamController._stop();
        this._commandController.stopMonitoringQueues();
        return new Promise((resolve, reject) => {
            raviSession._resolveClose = resolve;
            raviSession._rejectClose = reject;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Closing RAVI session", "RaviSession");
            raviSession._raviImplementation._close();
        });
    }
    _fulfillPromises(event = {}, state) {
        let errorMessage = event.reason || event.message || state;
        switch (state) {
            case RaviSessionStates.CONNECTED:
            case RaviSessionStates.COMPLETED:
                if (this._openingTimeout) {
                    clearTimeout(this._openingTimeout);
                    this._openingTimeout = null;
                }
                if (this._resolveOpen)
                    this._resolveOpen();
                if (this._rejectClose)
                    this._rejectClose(errorMessage);
                break;
            case RaviSessionStates.DISCONNECTED:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("_fulfillPromises: Possible transitory state DISCONNECTED; leaving promises pending", "RaviSession");
                break;
            case RaviSessionStates.FAILED:
                if (this._openingTimeout) {
                    clearTimeout(this._openingTimeout);
                    this._openingTimeout = null;
                }
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._rejectClose)
                    this._rejectClose(errorMessage);
                let raviSession = this;
                const closeTimer = setTimeout(() => {
                    raviSession._raviImplementation._close();
                }, 0);
                break;
            case RaviSessionStates.CLOSED:
                if (this._openingTimeout) {
                    clearTimeout(this._openingTimeout);
                    this._openingTimeout = null;
                }
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._resolveClose)
                    this._resolveClose();
                break;
            default:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("_fulfillPromises: Skipping in-progress state " + state, "RaviSession");
        }
    }
    _doOntrack(event) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received new track: ", "RaviSession");
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log(event, "RaviSession");
        if (event && event.track && event.track.kind === "video") {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Adding remote video track to stream controller", "RaviSession");
            this._streamController._setVideoStream(event.streams[0]);
            this._streamController._onVideoStreamStateChanged("ready");
        }
        if (event && event.track && event.track.kind === "audio") {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Adding remote audio track to stream controller", "RaviSession");
            this._streamController._setAudioStream(event.streams[0]);
        }
    }
    _doOndatachannel(event) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received new channel: ", "RaviSession");
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log(event, "RaviSession");
        switch (event.channel.label) {
            case "ravi.input":
                this._commandController._setInputDataChannel(event.channel);
                break;
            case "ravi.command":
                this._commandController._setCommandDataChannel(event.channel);
                break;
            default:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received unknown data channel named " + event.channel.label, "RaviSession");
                break;
        }
    }
    _handleStateChange(event = {}, state) {
        event["state"] = state;
        this._fulfillPromises(event, state);
        if (state !== this._state) {
            this._state = state;
            event["state"] = state;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("_handleStateChange: " + _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.safelyPrintable(event), "RaviSession");
            this._stateChangeHandlers.forEach(function (handler) {
                if (handler) {
                    handler(event);
                }
            });
        }
    }
    addStatsObserver(observer) {
        return this._raviImplementation._addStatsObserver(observer);
    }
    removeStatsObserver(observer) {
        return this._raviImplementation._removeStatsObserver(observer);
    }
}
const STATS_WATCHER_FILTER = new Map([
    ["remote-inbound-rtp", ["id", "type", "timestamp", "roundTripTime", "jitter"]],
    ["inbound-rtp", ["id", "type", "timestamp", "jitterBufferDelay", "jitterBufferEmittedCount", "bytesReceived"]]
]);
class RaviWebRTCStatsWatcher {
    constructor(webRTCImplementation) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("constructor", "RaviStatsWatcher");
        this._raviImplementation = webRTCImplementation;
        this._observers = new Set();
        this._filter = STATS_WATCHER_FILTER;
        this._interval = 0;
        this._prevStats = [];
    }
    stop() {
        if (this._interval) {
            clearInterval(this._interval);
            this._interval = 0;
        }
    }
    addObserver(observer) {
        try {
            this._observers.add(observer);
            this._onObserverChange();
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error adding a stats observer: " +
                err.message, "RaviStatsWatcher");
            return false;
        }
        return false;
    }
    removeObserver(observer) {
        try {
            this._observers.delete(observer);
            this._onObserverChange();
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error removing a stats observer handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    _onObserverChange() {
        const INTERVAL = 1000;
        this._prevStats = [];
        if (this._observers.size > 0) {
            if (!this._interval) {
                setInterval((handler, timeout) => __awaiter(this, void 0, void 0, function* () {
                    const stats = yield this._raviImplementation._getStats();
                    let filteredStats = [];
                    if (stats) {
                        stats.forEach((report) => {
                            if (this._filter.has(report.type)) {
                                let selectedFields = this._filter.get(report.type);
                                let filteredReport = {};
                                selectedFields.forEach(key => {
                                    filteredReport[key] = report[key];
                                });
                                filteredStats.push(filteredReport);
                            }
                        });
                    }
                    if (filteredStats.length) {
                        this._observers.forEach((observer) => {
                            observer(filteredStats, this._prevStats);
                        });
                    }
                    this._prevStats = filteredStats;
                }), INTERVAL);
            }
        }
        else {
            if (this._interval) {
                clearInterval(this._interval);
                this._interval = 0;
            }
        }
    }
}
let crossPlatformRTCPeerConnection = null;
let crossPlatformRTCSessionDescription = null;
if (typeof self === 'undefined') {
    crossPlatformRTCPeerConnection = __webpack_require__(/*! wrtc */ "../.nvm/versions/node/v14.15.4/lib/node_modules/wrtc/lib/browser.js").RTCPeerConnection;
    crossPlatformRTCSessionDescription = __webpack_require__(/*! wrtc */ "../.nvm/versions/node/v14.15.4/lib/node_modules/wrtc/lib/browser.js").RTCSessionDescription;
}
else {
    crossPlatformRTCPeerConnection = RTCPeerConnection;
    crossPlatformRTCSessionDescription = RTCSessionDescription;
}
const DEFAULT_STUN_CONFIG = {
    'urls': ['stun:stun.l.google.com:19302']
};
const LEGACY_TURN_CONFIG = {
    'urls': ['turn:turn.highfidelity.com:3478'],
    'username': 'clouduser',
    'credential': 'chariot-travesty-hook'
};
let peerConnectionConfig = {
    'iceServers': [
        DEFAULT_STUN_CONFIG,
        LEGACY_TURN_CONFIG
    ]
};
class RaviWebRTCImplementation {
    constructor(raviSession) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("constructor", "RaviWebRTCImplementation");
        this._raviSession = raviSession;
        this._negotiator = this._setupConnection.bind(this);
        this._statsWatcher = new RaviWebRTCStatsWatcher(this);
        this._raviAudioSenders = [];
        this._raviVideoSenders = [];
    }
    _initRtcConnection() {
        const raviSession = this._raviSession;
        const sessionImplementation = this;
        this._rtcConnection = new crossPlatformRTCPeerConnection(peerConnectionConfig);
        const rtcConnection = this._rtcConnection;
        let senders = rtcConnection.getSenders();
        senders.forEach((sender) => {
            sender.replaceTrack(null);
        });
        this._raviAudioSenders = [];
        this._raviVideoSenders = [];
        rtcConnection.addEventListener('iceconnectionstatechange', function (event) {
            if (rtcConnection.iceConnectionState === "connected" || rtcConnection.iceConnectionState == "completed") {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Session has fully connected; removing short-circuit handler", "RaviWebRTCImplementation");
                sessionImplementation._signalingConnection.removeStateChangeHandler(sessionImplementation._shortCircuitHandler);
            }
            raviSession._handleStateChange(event, rtcConnection.iceConnectionState);
        });
        rtcConnection.addEventListener('datachannel', function (event) { raviSession._doOndatachannel(event); });
        rtcConnection.addEventListener('track', function (event) { raviSession._doOntrack(event); });
        rtcConnection.addEventListener('icecandidate', function (event) { sessionImplementation._doOnicecandidate(event); });
        rtcConnection.addEventListener('negotiationneeded', function (event) { sessionImplementation._doOnnegotiationneeded(event); });
        rtcConnection.addEventListener("signalingstatechange", function (event) { sessionImplementation._doOnsignalingstatechanged(event); });
    }
    _assignSignalingConnection(signalingConnection) {
        this._signalingConnection = signalingConnection;
    }
    _addAudioInputStream(stream) {
        const rtcConnection = this._rtcConnection;
        const sessionImplementation = this;
        var retval = false;
        if (stream) {
            this._audioInputStream = stream;
            if (!rtcConnection) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting audio input stream without available RTC connection; will store it until ready", "RaviWebRTCImplementation");
                return true;
            }
            const currentSenders = this._raviAudioSenders;
            const newAudioTracks = stream.getAudioTracks();
            const numNewTracks = newAudioTracks.length;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                if (i < numNewTracks) {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Replacing audio track #" + i + "  in rtcConnection", "RaviWebRTCImplementation");
                    currentSenders[i].replaceTrack(newAudioTracks[i]);
                }
                else {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting audio sender #" + i + " to null", "RaviWebRTCImplementation");
                    currentSenders[i].replaceTrack(null);
                }
            }
            for (i; i < numNewTracks; i++) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Adding local audio track #" + i + " to rtcConnection", "RaviWebRTCImplementation");
                currentSenders.push(rtcConnection.addTrack(newAudioTracks[i], stream));
            }
        }
        else {
            const currentSenders = this._raviAudioSenders;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting audio sender #" + i + " to null", "RaviWebRTCImplementation");
                currentSenders[i].replaceTrack(null);
            }
        }
        return retval;
    }
    _addVideoInputStream(stream) {
        const rtcConnection = this._rtcConnection;
        const that = this;
        var retval = false;
        if (stream) {
            this._videoInputStream = stream;
            if (!rtcConnection) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting video input stream without available RTC connection; will store it until ready", "RaviWebRTCImplementation");
                return true;
            }
            const currentSenders = this._raviVideoSenders;
            const newVideoTracks = stream.getVideoTracks();
            const numNewTracks = newVideoTracks.length;
            if (numNewTracks > 0) {
                if (currentSenders.length > 0) {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Replacing video track #0 in rtcConnection", "RaviWebRTCImplementation");
                    currentSenders[0].replaceTrack(newVideoTracks[0]);
                }
                else {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Adding video track #0 to rtcConnection", "RaviWebRTCImplementation");
                    currentSenders.push(rtcConnection.addTrack(newVideoTracks[0]));
                }
                retval = true;
            }
            else {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Assigned video stream doesn't contain vidoe track", "RaviWebRTCImplementation");
            }
        }
        else {
            const currentSenders = this._raviVideoSenders;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting video sender #" + i + " to null", "RaviWebRTCImplementation");
                currentSenders[i].replaceTrack(null);
            }
        }
        return retval;
    }
    _open(params, customStunAndTurn) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Attempting to open connection...", "RaviWebRTCImplementation");
        this._customStunAndTurn = customStunAndTurn;
        if (this._rtcConnection
            && (this._rtcConnection.connectionState == 'connecting'
                || this._rtcConnection.connectionState == 'connected')) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("We already have a connection in progress. Will not attempt a new one.", "RaviWebRTCImplementation");
            this._raviSession._handleStateChange({ "state": this._rtcConnection.connectionState }, this._rtcConnection.connectionState);
            return;
        }
        if (this._signalingConnection) {
            this._signalingConnection.addMessageHandler(this._negotiator);
            this._shortCircuitHandler = this._cancelOpeningProcessOnSignalingDisconnect.bind(this);
            this._signalingConnection.addStateChangeHandler(this._shortCircuitHandler);
            let message = {};
            if (params) {
                message = params;
                message["sessionID"] = this._raviSession.getUUID();
            }
            else {
                message = this._raviSession.getUUID();
            }
            this._signalingConnection.send(JSON.stringify({ 'request': message }));
        }
    }
    _cancelOpeningProcessOnSignalingDisconnect(event) {
        let state = event.state || "unknown";
        const raviSession = this._raviSession;
        switch (state) {
            case _RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_0__.RaviSignalingStates.CLOSED:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Signaling state closed before session was established; closing RaviSession", "RaviWebRTCImplementation");
                raviSession._handleStateChange(event, RaviSessionStates.CLOSED);
                this._close();
                break;
            case _RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_0__.RaviSignalingStates.ERROR:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Signaling state errored out before session was established; closing RaviSession", "RaviWebRTCImplementation");
                raviSession._handleStateChange(event, RaviSessionStates.FAILED);
                this._close();
                break;
            case _RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_0__.RaviSignalingStates.UNAVAILABLE:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Signaling state reached 'unavailable' before session was established; closing RaviSession", "RaviWebRTCImplementation");
                raviSession._handleStateChange(event, RaviSessionStates.FAILED);
                this._close();
                break;
            default:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Signaling state has changed during opening of RAVI session, but is an OK change. New state: " + state, "RaviWebRTCImplementation");
        }
    }
    _close() {
        this._statsWatcher.stop();
        const raviSession = this._raviSession;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("closing", "RaviWebRTCImplementation");
        if (this._rtcConnection) {
            this._rtcConnection.close();
        }
        this._signalingConnection.removeMessageHandler(this._negotiator);
        this._signalingConnection.removeStateChangeHandler(this._shortCircuitHandler);
        this._rtcConnection = null;
        raviSession._handleStateChange({}, RaviSessionStates.CLOSED);
    }
    _doOnicecandidate(event) {
        if (event.candidate && event.candidate != "") {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Sending local ICE candidate: " + JSON.stringify(event.candidate), "RaviWebRTCImplementation");
            this._signalingConnection.send(JSON.stringify({ 'ice': event.candidate, 'uuid': this._raviSession.getUUID() }));
        }
        else {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("End of local ICE candidates", "RaviSession");
        }
    }
    _doOnnegotiationneeded(event) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("need renegotiation please", "RaviWebRTCImplementation");
        const msg = {
            renegotiate: "please",
            uuid: this._raviSession.getUUID()
        };
        const desc = JSON.stringify(msg);
        if (this._signalingConnection && this._rtcConnection && this._rtcConnection.signalingState === "stable") {
            this._signalingConnection.send(desc);
        }
    }
    _doOnsignalingstatechanged(event) {
        if (this._rtcConnection) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("SignalingState changed: " + this._rtcConnection.signalingState, "RaviWebRTCImplementation");
        }
    }
    _forceBitrateUp(sdp) {
        const localAudioIsStereo = this._raviSession._streamController.isStereoInput();
        const bitrate = localAudioIsStereo ? 128000 : 64000;
        return sdp.replace(/a=fmtp:111 /g, 'a=fmtp:111 maxaveragebitrate=' + bitrate + ';');
    }
    _forceStereoDown(sdp) {
        return sdp.replace(/a=fmtp:111 /g, 'a=fmtp:111 maxaveragebitrate=128000;sprop-stereo=1;stereo=1;');
    }
    _setupConnection(event) {
        let fullMessage = "";
        let signal = "";
        const raviSession = this._raviSession;
        const signalingConnection = this._signalingConnection;
        const sessionImplementation = this;
        if (!raviSession || !signalingConnection) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Missing one of raviSession or signalingConnection! Can't set up connection.", "RaviWebRTCImplementation");
            return;
        }
        if (event && event.data) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log('Message from server: ' + event.data, "RaviWebRTCImplementation");
            fullMessage = JSON.parse(event.data);
        }
        else {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log('No message received by onMessage handler', "RaviWebRTCImplementation");
            return;
        }
        signal = fullMessage[raviSession.getUUID()];
        if (!signal)
            return;
        if (signal.sdp) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received sdp type=" + signal.type, "RaviWebRTCImplementation");
            if (sessionImplementation._customStunAndTurn) {
                const CUSTOM_TURN_CONFIG = {
                    'urls': sessionImplementation._customStunAndTurn.turnUrls,
                    'username': sessionImplementation._customStunAndTurn.turnUsername,
                    'credential': sessionImplementation._customStunAndTurn.turnCredential
                };
                const CUSTOM_STUN_CONFIG = {
                    'urls': sessionImplementation._customStunAndTurn.stunUrls
                };
                peerConnectionConfig = {
                    'iceServers': [
                        CUSTOM_STUN_CONFIG,
                        CUSTOM_TURN_CONFIG
                    ]
                };
            }
            else if (signal.turn && signal.turn.urls && signal.turn.username && signal.turn.credential) {
                const DYNAMIC_TURN_CONFIG = {
                    'urls': signal.turn.urls,
                    'username': signal.turn.username,
                    'credential': signal.turn.credential
                };
                peerConnectionConfig = {
                    'iceServers': [
                        DEFAULT_STUN_CONFIG,
                        DYNAMIC_TURN_CONFIG
                    ]
                };
            }
            if (!this._rtcConnection) {
                this._initRtcConnection();
                if (this._audioInputStream) {
                    this._addAudioInputStream(this._audioInputStream);
                }
                if (this._videoInputStream) {
                    this._addVideoInputStream(this._videoInputStream);
                }
            }
            let rtcConnection = this._rtcConnection;
            signal.sdp = sessionImplementation._forceBitrateUp(signal.sdp);
            const desc = new crossPlatformRTCSessionDescription(signal);
            rtcConnection.setRemoteDescription(desc)
                .then(function () {
                return rtcConnection.createAnswer();
            })
                .then(function (answer) {
                answer.sdp = sessionImplementation._forceStereoDown(answer.sdp);
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Answer:", "RaviWebRTCImplementation");
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log(answer, "RaviWebRTCImplementation");
                return rtcConnection.setLocalDescription(answer);
            })
                .then(function () {
                const msg = {
                    type: "answer",
                    sdp: rtcConnection.localDescription,
                    uuid: raviSession.getUUID()
                };
                const desc = JSON.stringify(msg);
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Sending answer to server", "RaviWebRTCImplementation");
                signalingConnection.send(desc);
            });
        }
        else if (signal.ice) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received remote ICE candidate: " + JSON.stringify(signal.ice), "RaviWebRTCImplementation");
            if (this._rtcConnection) {
                this._rtcConnection.addIceCandidate(signal.ice)
                    .then(function () {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Added remote candidate", "RaviWebRTCImplementation");
                })
                    .catch(function (e) {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error attempting to add remote ICE candidate: " + e.message, "RaviWebRTCImplementation");
                });
            }
            else {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Ignore ice candidate until we have an rtcConnection, ice='" + JSON.stringify(signal) + "'", "RaviWebRTCImplementation");
            }
        }
        else {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Unknown message " + JSON.stringify(signal), "RaviWebRTCImplementation");
        }
    }
    _addStatsObserver(observer) {
        return this._statsWatcher.addObserver(observer);
    }
    _removeStatsObserver(observer) {
        return this._statsWatcher.removeObserver(observer);
    }
    _getStats(selector = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._rtcConnection) {
                return this._rtcConnection.getStats(selector);
            }
            else {
                return [];
            }
        });
    }
}


/***/ }),

/***/ "./src/libravi/RaviSignalingConnection.ts":
/*!************************************************!*\
  !*** ./src/libravi/RaviSignalingConnection.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviSignalingStates": () => (/* binding */ RaviSignalingStates),
/* harmony export */   "RaviSignalingConnection": () => (/* binding */ RaviSignalingConnection)
/* harmony export */ });
/* harmony import */ var _RaviUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");

var RaviSignalingStates;
(function (RaviSignalingStates) {
    RaviSignalingStates["CONNECTING"] = "connecting";
    RaviSignalingStates["OPEN"] = "open";
    RaviSignalingStates["ERROR"] = "error";
    RaviSignalingStates["CLOSING"] = "closing";
    RaviSignalingStates["CLOSED"] = "closed";
    RaviSignalingStates["UNAVAILABLE"] = "unavailable";
})(RaviSignalingStates || (RaviSignalingStates = {}));
;
class RaviSignalingConnection {
    constructor() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Constructor", "RaviSignalingConnection");
        this._stateChangeHandlers = new Set();
        this._messageHandlers = new Set();
        this._state = RaviSignalingStates.CLOSED;
        this._signalingImplementation = new RaviSignalingWebSocketImplementation(this);
    }
    getState() {
        return this._state;
    }
    addStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.add(changeHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Error adding a state change handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    removeStateChangeHandler(changeHandler) {
        try {
            const retval = this._stateChangeHandlers.delete(changeHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Error removing a state change handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    addMessageHandler(messageHandler) {
        try {
            this._messageHandlers.add(messageHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Error adding a message handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    removeMessageHandler(messageHandler) {
        try {
            this._messageHandlers.delete(messageHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Error removing a state change handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    openRAVISignalingConnection(URL) {
        var signalingConnection = this;
        if (this._state === RaviSignalingStates.OPEN)
            return Promise.resolve("There is already an open WebSocket connection. To reconnect, first close the existing WebSocket and then attempt to open again.");
        return new Promise((resolve, reject) => {
            signalingConnection._resolveOpen = resolve;
            signalingConnection._rejectOpen = reject;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Opening signaling connection to " + URL, "RaviSignalingController");
            let event = { "state": RaviSignalingStates.CONNECTING };
            this._handleStateChange(event, RaviSignalingStates.CONNECTING);
            this._signalingImplementation._open(URL);
        });
    }
    send(message) {
        this._signalingImplementation._send(message);
    }
    closeRAVISignalingConnection() {
        var signalingConnection = this;
        if (this._state === RaviSignalingStates.CLOSED)
            return Promise.resolve("Signaling connection is already closed.");
        return new Promise((resolve, reject) => {
            signalingConnection._resolveClose = resolve;
            signalingConnection._rejectClose = reject;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Closing signaling connection", "RaviSignalingController");
            let event = { "state": RaviSignalingStates.CLOSING };
            this._handleStateChange(event, RaviSignalingStates.CLOSING);
            this._signalingImplementation._close();
        });
    }
    _handleStateChange(event = {}, state) {
        this._fulfillPromises(event, state);
        if (state !== this._state) {
            this._state = state;
            event["state"] = state;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_handleStateChange: " + _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.safelyPrintable(event), "RaviSignalingConnection");
            this._stateChangeHandlers.forEach(function (handler) {
                if (handler) {
                    handler(event);
                }
            });
        }
    }
    _fulfillPromises(event = {}, state) {
        let errorMessage = event.reason || event.message || state;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_fulfillPromises: Handling state " + state, "RaviSignalingConnection");
        switch (state) {
            case RaviSignalingStates.OPEN:
                if (this._resolveOpen)
                    this._resolveOpen();
                if (this._rejectClose)
                    this._rejectClose(errorMessage);
                break;
            case RaviSignalingStates.CLOSED:
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._resolveClose)
                    this._resolveClose();
                break;
            case RaviSignalingStates.ERROR:
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._rejectClose)
                    this._rejectClose(errorMessage);
                break;
            case RaviSignalingStates.UNAVAILABLE:
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._resolveClose)
                    this._resolveClose();
                break;
            default:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_fulfillPromises: Skipping in-progress state " + state, "RaviSignalingConnection");
        }
    }
    _handleMessage(message) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_doOnmessage: " + _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.safelyPrintable(message), "RaviSignalingConnection");
        if (message.data) {
            try {
                let messageData = JSON.parse(message.data);
                if (messageData.error && messageData.error === "service-unavailable") {
                    this._handleStateChange({}, RaviSignalingStates.UNAVAILABLE);
                }
            }
            catch (err) {
            }
        }
        this._messageHandlers.forEach(function (handler) {
            if (handler) {
                handler(message);
            }
        });
    }
}
let crossPlatformWebSocket = null;
if (typeof self === 'undefined') {
    crossPlatformWebSocket = __webpack_require__(/*! ws */ "./node_modules/ws/browser.js");
}
else {
    crossPlatformWebSocket = WebSocket;
}
class RaviSignalingWebSocketImplementation {
    constructor(raviSignalingConnection) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviSignalingWebSocketImplementation");
        this._raviSignalingConnection = raviSignalingConnection;
    }
    _open(socketAddress) {
        var signalingConnection = this._raviSignalingConnection;
        if (this._webSocket && this._webSocket.readyState === crossPlatformWebSocket.OPEN) {
            signalingConnection._handleStateChange({}, RaviSignalingStates.OPEN);
            return;
        }
        this._webSocket = new crossPlatformWebSocket(socketAddress);
        this._webSocket.addEventListener('open', function (event) { signalingConnection._handleStateChange(event, RaviSignalingStates.OPEN); });
        this._webSocket.addEventListener('error', function (event) { signalingConnection._handleStateChange(event, RaviSignalingStates.ERROR); });
        this._webSocket.addEventListener('close', function (event) {
            if (event && event.code && event.code > 4000) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("_handleStateChange: signaling error code " + event.code + ":  " + event.reason, "RaviSignalingConnection");
                signalingConnection._handleStateChange(event, RaviSignalingStates.ERROR);
            }
            else {
                signalingConnection._handleStateChange(event, RaviSignalingStates.CLOSED);
            }
        });
        this._webSocket.addEventListener('message', function (event) { signalingConnection._handleMessage(event); });
    }
    _send(message) {
        if (this._webSocket && this._webSocket.readyState === crossPlatformWebSocket.OPEN) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Sending message to server: " + message, "RaviSignalingWebSocketImplementation");
            this._webSocket.send(message);
        }
    }
    _close() {
        var signalingConnection = this._raviSignalingConnection;
        if (!this._webSocket || this._webSocket.readyState === crossPlatformWebSocket.CLOSED) {
            signalingConnection._handleStateChange({}, RaviSignalingStates.CLOSED);
            return;
        }
        this._webSocket.close();
        this._webSocket = null;
    }
}


/***/ }),

/***/ "./src/libravi/RaviStreamController.ts":
/*!*********************************************!*\
  !*** ./src/libravi/RaviStreamController.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviStreamController": () => (/* binding */ RaviStreamController)
/* harmony export */ });
/* harmony import */ var _RaviUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");

class RaviStreamController {
    constructor(raviCommandController) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviStreamController");
        this._commandController = raviCommandController;
        this._audioStream = null;
        this._videoStream = null;
        this._onVideoStreamStateChanged = function (state) { _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("onvideostreamstatechanged " + state, "RaviStreamController"); };
        this._onInputAudioChanged = null;
        this._onInputVideoChanged = null;
    }
    getVideoStream() {
        return this._videoStream;
    }
    _setVideoStream(videoStream) {
        this._videoStream = videoStream;
        if (this._videoContainer) {
            this._videoContainer.srcObject = this._videoStream;
        }
    }
    setVideoContainer(videoElement, onvideostreamstatechanged) {
        this._videoContainer = videoElement;
        if (this._videoStream) {
            this._videoContainer.srcObject = this._videoStream;
        }
        this.setVideoStateChangeHandler(onvideostreamstatechanged);
    }
    setVideoStateChangeHandler(onvideostreamstatechanged) {
        if (onvideostreamstatechanged) {
            this._onVideoStreamStateChanged = onvideostreamstatechanged;
        }
    }
    showVideoDashboard(enabled) {
        this._commandController.queueCommand("video.showDashboard", { "enabled": enabled }, null);
    }
    showVideoCursor(enabled) {
        this._commandController.queueCommand("video.showCursor", { "enabled": enabled }, null);
    }
    getAudioStream() {
        return this._audioStream;
    }
    _setAudioStream(audioStream) {
        this._audioStream = audioStream;
        if (this._audioContainer) {
            this._audioContainer.srcObject = this._audioStream;
        }
    }
    setAudioContainer(audioElement) {
        this._audioContainer = audioElement;
        if (this._audioStream) {
            this._audioContainer.srcObject = this._audioStream;
        }
    }
    setInputAudio(stream, isStereo = false) {
        this._inputAudioStream = stream;
        this._isStereo = isStereo;
        if (this._onInputAudioChanged)
            this._onInputAudioChanged(stream);
    }
    setInputAudioChangeHandler(oninputaudiochanged) {
        if (oninputaudiochanged) {
            this._onInputAudioChanged = oninputaudiochanged;
        }
    }
    setInputVideo(stream) {
        this._inputVideoStream = stream;
        if (this._onInputVideoChanged)
            this._onInputVideoChanged(stream);
    }
    setInputVideoChangeHandler(oninputvideochanged) {
        if (oninputvideochanged) {
            this._onInputVideoChanged = oninputvideochanged;
        }
    }
    isStereoInput() {
        return this._isStereo;
    }
    _stop() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("stopping streams", "RaviStreamController");
        if (this._videoContainer && this._videoContainer.srcObject) {
            let srcObject = this._videoContainer.srcObject;
            let tracks = srcObject.getTracks();
            tracks.forEach(track => track.stop());
            this._videoContainer.srcObject = null;
            this._onVideoStreamStateChanged("over");
        }
        if (this._audioStream) {
            this._audioStream.getTracks().forEach(track => track.stop());
            this._audioStream = null;
        }
    }
}


/***/ }),

/***/ "./src/libravi/RaviUtils.ts":
/*!**********************************!*\
  !*** ./src/libravi/RaviUtils.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviUtils": () => (/* binding */ RaviUtils)
/* harmony export */ });
var DEBUG = true;
class RaviUtils {
    static createUUID() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }
    static log(message, classname) {
        if (typeof classname !== 'undefined')
            message = classname + ": " + message;
        if (DEBUG) {
            console.log(message);
        }
        if (typeof document !== 'undefined' && DEBUG) {
            try {
                document.dispatchEvent(new CustomEvent('logger', { detail: message }));
            }
            catch (err) {
                console.log(message);
                console.log("Additionally, an error was encountered trying to log that.");
                console.log(err);
            }
        }
    }
    static err(message, classname) {
        if (typeof classname !== 'undefined')
            message = classname + ": " + message;
        console.log('%c %s', 'color: #FB0A1C', message);
        if (typeof document !== 'undefined') {
            document.dispatchEvent(new CustomEvent('errlogger', { detail: message }));
        }
    }
    static safelyPrintable(item) {
        try {
            return JSON.stringify(item);
        }
        catch (e) {
            return item;
        }
    }
    static getElementCSSSize(el) {
        if (!getComputedStyle) {
            return;
        }
        var cs = getComputedStyle(el);
        var w = parseInt(cs.getPropertyValue("width"), 10);
        var h = parseInt(cs.getPropertyValue("height"), 10);
        return { width: w, height: h };
    }
    static setDebug(debug) {
        DEBUG = debug;
    }
}


/***/ }),

/***/ "./src/utilities/HiFiLogger.ts":
/*!*************************************!*\
  !*** ./src/utilities/HiFiLogger.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiLogLevel": () => (/* binding */ HiFiLogLevel),
/* harmony export */   "HiFiLogger": () => (/* binding */ HiFiLogger)
/* harmony export */ });
var HiFiLogLevel;
(function (HiFiLogLevel) {
    HiFiLogLevel["None"] = "None";
    HiFiLogLevel["Error"] = "Error";
    HiFiLogLevel["Warn"] = "Warn";
    HiFiLogLevel["Debug"] = "Debug";
})(HiFiLogLevel || (HiFiLogLevel = {}));
class HiFiLogger {
    constructor(logLevel) {
        logLevel = logLevel ? logLevel : HiFiLogLevel.Debug;
    }
    static setHiFiLogLevel(newLogLevel) {
        HiFiLogger.logLevel = newLogLevel;
    }
    static log(message) {
        if (HiFiLogger.logLevel === HiFiLogLevel.Debug) {
            console.log(message);
            return true;
        }
        else {
            return false;
        }
    }
    static debug(message) {
        return this.log(message);
    }
    static warn(message) {
        if (HiFiLogger.logLevel === HiFiLogLevel.Debug || HiFiLogger.logLevel === HiFiLogLevel.Warn) {
            console.warn(message);
            return true;
        }
        else {
            return false;
        }
    }
    static error(message) {
        if (HiFiLogger.logLevel === HiFiLogLevel.Debug || HiFiLogger.logLevel === HiFiLogLevel.Warn || HiFiLogger.logLevel === HiFiLogLevel.Error) {
            console.error(message);
            return true;
        }
        else {
            return false;
        }
    }
}
HiFiLogger.logLevel = HiFiLogLevel.Error;


/***/ }),

/***/ "./src/utilities/HiFiUtilities.ts":
/*!****************************************!*\
  !*** ./src/utilities/HiFiUtilities.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiUtilities": () => (/* binding */ HiFiUtilities)
/* harmony export */ });
/* harmony import */ var _HiFiLogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* module decorator */ module = __webpack_require__.hmd(module);

function dynamicRequire(mod, requireString) {
    return mod.require(requireString);
}
let now;
if (typeof self === 'undefined') {
    try {
        now = dynamicRequire(module, 'perf_hooks').performance.now;
    }
    catch (_a) { }
}
class HiFiUtilities {
    constructor() { }
    static recursivelyDiffObjects(obj1, obj2) {
        if (!obj2 || Object.prototype.toString.call(obj2) !== '[object Object]') {
            return obj1;
        }
        let diffs = {};
        let key;
        let doArraysMatch = (arr1, arr2) => {
            if (arr1.length !== arr2.length) {
                return false;
            }
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i]) {
                    return false;
                }
            }
            return true;
        };
        let compare = (item1, item2, key) => {
            let type1 = Object.prototype.toString.call(item1);
            let type2 = Object.prototype.toString.call(item2);
            if (type2 === '[object Undefined]') {
                diffs[key] = null;
                return;
            }
            if (type1 !== type2) {
                diffs[key] = item2;
                return;
            }
            if (type1 === '[object Object]') {
                let objDiff = HiFiUtilities.recursivelyDiffObjects(item1, item2);
                if (Object.keys(objDiff).length > 0) {
                    diffs[key] = objDiff;
                }
                return;
            }
            if (type1 === '[object Array]') {
                if (!doArraysMatch(item1, item2)) {
                    diffs[key] = item2;
                }
                return;
            }
            if (type1 === '[object Function]') {
                if (item1.toString() !== item2.toString()) {
                    diffs[key] = item2;
                }
            }
            else {
                if (item1 !== item2) {
                    diffs[key] = item2;
                }
            }
        };
        for (key in obj1) {
            if (obj1.hasOwnProperty(key)) {
                compare(obj1[key], obj2[key], key);
            }
        }
        for (key in obj2) {
            if (obj2.hasOwnProperty(key)) {
                if (!obj1[key] && obj1[key] !== obj2[key]) {
                    diffs[key] = obj2[key];
                }
            }
        }
        return diffs;
    }
    ;
    static getBestAudioConstraints() {
        let audioConstraints = {};
        if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().echoCancellation) {
            audioConstraints.echoCancellation = false;
        }
        if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().noiseSuppression) {
            audioConstraints.noiseSuppression = false;
        }
        if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().autoGainControl) {
            audioConstraints.autoGainControl = false;
        }
        return audioConstraints;
    }
    static preciseInterval(callback, intervalMS) {
        if (!now) {
            _HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.warn(`\`preciseInterval()\` is a wrapper for \`setInterval()\` in the browser context!`);
            return setInterval(callback, intervalMS);
        }
        let nextTick = now();
        let clear = clearTimeout;
        let wrapper = () => {
            let thisTick = now();
            if (thisTick < nextTick) {
                clear = clearImmediate;
                return timeout = setImmediate(wrapper);
            }
            nextTick += intervalMS;
            clear = clearTimeout;
            timeout = setTimeout(wrapper, nextTick - thisTick - 2);
            callback();
        };
        let timeout = setTimeout(wrapper);
        return { clear: () => clear(timeout) };
    }
    static checkBrowserCompatibility() {
        let requiredFeatures = [
            "navigator",
            "navigator.mediaDevices.getUserMedia",
            "navigator.mediaDevices.getSupportedConstraints",
            "window.MediaStream",
            "window.RTCDataChannel",
            "window.RTCPeerConnection",
            "window.RTCSessionDescription"
        ];
        for (let i = 0; i < requiredFeatures.length; i++) {
            if (typeof (eval(requiredFeatures[i])) === "undefined") {
                _HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error("HiFi Audio API: The browser does not support: " + requiredFeatures[i]);
                if (requiredFeatures[i] === "navigator.mediaDevices.getUserMedia") {
                    _HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error("HiFi Audio API: Your browser may be preventing access to this feature if you are running in an insecure context, i.e. an `http` server.");
                }
                return false;
            }
        }
        return true;
    }
    static nonan(v, ifnan) {
        return (isNaN(v) ? ifnan : v);
    }
    static clamp(v, min, max) {
        return (v > max ? max : (v < min ? min : v));
    }
    static clampNonan(v, min, max, ifnan) {
        return (v > max ? max : (v < min ? min : HiFiUtilities.nonan(v, ifnan)));
    }
    static clampNormalized(v) {
        return (v > 1.0 ? 1.0 : (v < -1.0 ? -1.0 : v));
    }
}


/***/ }),

/***/ "./node_modules/ws/browser.js":
/*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
/***/ ((module) => {



module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiUtilities": () => (/* reexport safe */ _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities),
/* harmony export */   "hiFiAPIVersion": () => (/* binding */ apiVersion),
/* harmony export */   "apiVersion": () => (/* binding */ apiVersion),
/* harmony export */   "HiFiAudioAPIData": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.HiFiAudioAPIData),
/* harmony export */   "ReceivedHiFiAudioAPIData": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.ReceivedHiFiAudioAPIData),
/* harmony export */   "OrientationEuler3D": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationEuler3D),
/* harmony export */   "OrientationQuat3D": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationQuat3D),
/* harmony export */   "Point3D": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.Point3D),
/* harmony export */   "eulerToQuaternion": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.eulerToQuaternion),
/* harmony export */   "eulerFromQuaternion": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.eulerFromQuaternion),
/* harmony export */   "HiFiCommunicator": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiCommunicator),
/* harmony export */   "HiFiConnectionStates": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates),
/* harmony export */   "HiFiUserDataStreamingScopes": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiUserDataStreamingScopes),
/* harmony export */   "AvailableUserDataSubscriptionComponents": () => (/* reexport safe */ _classes_HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_3__.AvailableUserDataSubscriptionComponents),
/* harmony export */   "UserDataSubscription": () => (/* reexport safe */ _classes_HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_3__.UserDataSubscription),
/* harmony export */   "HiFiLogLevel": () => (/* reexport safe */ _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__.HiFiLogLevel),
/* harmony export */   "HiFiLogger": () => (/* reexport safe */ _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__.HiFiLogger),
/* harmony export */   "HiFiConstants": () => (/* reexport safe */ _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_5__.HiFiConstants),
/* harmony export */   "HiFiAxes": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxes),
/* harmony export */   "HiFiHandedness": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiHandedness),
/* harmony export */   "HiFiAxisConfiguration": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisConfiguration),
/* harmony export */   "getBestAudioConstraints": () => (/* binding */ getBestAudioConstraints),
/* harmony export */   "preciseInterval": () => (/* binding */ preciseInterval),
/* harmony export */   "Communicator": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiCommunicator),
/* harmony export */   "ConnectionStates": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates),
/* harmony export */   "UserDataStreamingScopes": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiUserDataStreamingScopes),
/* harmony export */   "ReceivedAudioAPIData": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.ReceivedHiFiAudioAPIData),
/* harmony export */   "AudioAPIData": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.HiFiAudioAPIData),
/* harmony export */   "Logger": () => (/* reexport safe */ _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__.HiFiLogger),
/* harmony export */   "LogLevel": () => (/* reexport safe */ _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__.HiFiLogLevel),
/* harmony export */   "Utilities": () => (/* reexport safe */ _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities),
/* harmony export */   "Constants": () => (/* reexport safe */ _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_5__.HiFiConstants),
/* harmony export */   "Axes": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxes),
/* harmony export */   "Handedness": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiHandedness),
/* harmony export */   "AxisConfiguration": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisConfiguration)
/* harmony export */ });
/* harmony import */ var _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities/HiFiUtilities */ "./src/utilities/HiFiUtilities.ts");
/* harmony import */ var _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");
/* harmony import */ var _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/HiFiCommunicator */ "./src/classes/HiFiCommunicator.ts");
/* harmony import */ var _classes_HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classes/HiFiUserDataSubscription */ "./src/classes/HiFiUserDataSubscription.ts");
/* harmony import */ var _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* harmony import */ var _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants/HiFiConstants */ "./src/constants/HiFiConstants.ts");
/* harmony import */ var _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./classes/HiFiAxisConfiguration */ "./src/classes/HiFiAxisConfiguration.ts");


let isBrowserContext = typeof self !== 'undefined';
if (isBrowserContext) {
    _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.checkBrowserCompatibility();
}
let apiVersion =  true ? "v1.2.2-3" : 0;








let getBestAudioConstraints = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.getBestAudioConstraints;

let preciseInterval = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.preciseInterval;








})();

HighFidelityAudio = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi4vLm52bS92ZXJzaW9ucy9ub2RlL3YxNC4xNS40L2xpYi9ub2RlX21vZHVsZXMvd3J0Yy9saWIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9icm93c2VyLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2Rpc3QvcGFrby5lc20ubWpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy9jbGFzc2VzL0hpRmlBdWRpb0FQSURhdGEudHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2NsYXNzZXMvSGlGaUF4aXNDb25maWd1cmF0aW9uLnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy9jbGFzc2VzL0hpRmlDb21tdW5pY2F0b3IudHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2NsYXNzZXMvSGlGaU1peGVyU2Vzc2lvbi50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvY2xhc3Nlcy9IaUZpVXNlckRhdGFTdWJzY3JpcHRpb24udHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2NvbnN0YW50cy9IaUZpQ29uc3RhbnRzLnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy9kaWFnbm9zdGljcy9kaWFnbm9zdGljcy50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvbGlicmF2aS9SYXZpQ29tbWFuZENvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2xpYnJhdmkvUmF2aVNlc3Npb24udHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2xpYnJhdmkvUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24udHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2xpYnJhdmkvUmF2aVN0cmVhbUNvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2xpYnJhdmkvUmF2aVV0aWxzLnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy91dGlsaXRpZXMvSGlGaUxvZ2dlci50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvdXRpbGl0aWVzL0hpRmlVdGlsaXRpZXMudHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3dzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdL3dlYnBhY2svcnVudGltZS9oYXJtb255IG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWE7O0FBRWIsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QixpQ0FBaUM7QUFDakMsc0JBQXNCO0FBQ3RCLG9CQUFv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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RyxLQUFLLENBQUM7U0FDbkI7UUFJRCxJQUFJLGlCQUFpQixDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsU0FBUyxJQUFJLGlCQUFpQixDQUFDLFFBQVEsS0FBSyxRQUFRLENBQUMsU0FBUyxFQUFFO1lBQ3RHLG1FQUFnQixDQUFDLDJDQUEyQyxpQkFBaUIsQ0FBQyxNQUFNLHNCQUFzQixpQkFBaUIsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1lBQ3pJLE9BQU8sR0FBRyxLQUFLLENBQUM7U0FDbkI7UUFDRCxJQUFJLGlCQUFpQixDQUFDLFFBQVEsS0FBSyxRQUFRLENBQUMsU0FBUyxJQUFJLGlCQUFpQixDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsU0FBUyxFQUFFO1lBQ3RHLG1FQUFnQixDQUFDLDJDQUEyQyxpQkFBaUIsQ0FBQyxNQUFNLHNCQUFzQixpQkFBaUIsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1lBQ3pJLE9BQU8sR0FBRyxLQUFLLENBQUM7U0FDbkI7UUFFRCxJQUFJLGlCQUFpQixDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsU0FBUyxJQUFJLGlCQUFpQixDQUFDLFFBQVEsS0FBSyxRQUFRLENBQUMsU0FBUyxFQUFFO1lBQ3RHLG1FQUFnQixDQUFDLDJDQUEyQyxpQkFBaUIsQ0FBQyxNQUFNLHNCQUFzQixpQkFBaUIsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1lBQ3pJLE9BQU8sR0FBRyxLQUFLLENBQUM7U0FDbkI7UUFDRCxJQUFJLGlCQUFpQixDQUFDLFFBQVEsS0FBSyxRQUFRLENBQUMsU0FBUyxJQUFJLGlCQUFpQixDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsU0FBUyxFQUFFO1lBQ3RHLG1FQUFnQixDQUFDLDJDQUEyQyxpQkFBaUIsQ0FBQyxNQUFNLHNCQUFzQixpQkFBaUIsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1lBQ3pJLE9BQU8sR0FBRyxLQUFLLENBQUM7U0FDbkI7UUFFRCxJQUFJLGlCQUFpQixDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsU0FBUyxJQUFJLGlC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RUFBRSxDQUFDO0NBQzdDO0FBQ0QsSUFBSSxVQUFVLEdBQUcsS0FBc0MsQ0FBQyxDQUFDLENBQUMsVUFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBUyxDQUFDO0FBQy9DO0FBQ2xCO0FBVXlKO0FBQzlEO0FBRUU7QUFDakQ7QUFDUjtBQUN3QztBQUdsRyxJQUFJLHVCQUF1QixHQUFHLDJGQUFxQyxDQUFDO0FBQ2pDO0FBQ25DLElBQUksZUFBZSxHQUFHLG1GQUE2QixDQUFDO0FBQ3pCO0FBS3FKO0FBQ2hEO0FBQ3hDO0FBQ2pCO0FBQ0E7QUFDc0UiLCJmaWxlIjoiSGlnaEZpZGVsaXR5QXVkaW8tbGF0ZXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLk1lZGlhU3RyZWFtID0gd2luZG93Lk1lZGlhU3RyZWFtO1xuZXhwb3J0cy5NZWRpYVN0cmVhbVRyYWNrID0gd2luZG93Lk1lZGlhU3RyZWFtVHJhY2s7XG5leHBvcnRzLlJUQ0RhdGFDaGFubmVsID0gd2luZG93LlJUQ0RhdGFDaGFubmVsO1xuZXhwb3J0cy5SVENEYXRhQ2hhbm5lbEV2ZW50ID0gd2luZG93LlJUQ0RhdGFDaGFubmVsRXZlbnQ7XG5leHBvcnRzLlJUQ0R0bHNUcmFuc3BvcnQgPSB3aW5kb3cuUlRDRHRsc1RyYW5zcG9ydDtcbmV4cG9ydHMuUlRDSWNlQ2FuZGlkYXRlID0gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZTtcbmV4cG9ydHMuUlRDSWNlVHJhbnNwb3J0ID0gd2luZG93LlJUQ0ljZVRyYW5zcG9ydDtcbmV4cG9ydHMuUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb247XG5leHBvcnRzLlJUQ1BlZXJDb25uZWN0aW9uSWNlRXZlbnQgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb25JY2VFdmVudDtcbmV4cG9ydHMuUlRDUnRwUmVjZWl2ZXIgPSB3aW5kb3cuUlRDUnRwUmVjZWl2ZXI7XG5leHBvcnRzLlJUQ1J0cFNlbmRlciA9IHdpbmRvdy5SVENSdHBTZW5kZXI7XG5leHBvcnRzLlJUQ1J0cFRyYW5zY2VpdmVyID0gd2luZG93LlJUQ1J0cFRyYW5zY2VpdmVyO1xuZXhwb3J0cy5SVENTY3RwVHJhbnNwb3J0ID0gd2luZG93LlJUQ1NjdHBUcmFuc3BvcnQ7XG5leHBvcnRzLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb247XG5leHBvcnRzLmdldFVzZXJNZWRpYSA9IHdpbmRvdy5nZXRVc2VyTWVkaWE7XG5leHBvcnRzLm1lZGlhRGV2aWNlcyA9IG5hdmlnYXRvci5tZWRpYURldmljZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gcmVmOiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIHRoZSBvbmx5IHJlbGlhYmxlIG1lYW5zIHRvIGdldCB0aGUgZ2xvYmFsIG9iamVjdCBpc1xuXHQvLyBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcblx0Ly8gSG93ZXZlciwgdGhpcyBjYXVzZXMgQ1NQIHZpb2xhdGlvbnMgaW4gQ2hyb21lIGFwcHMuXG5cdGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHNlbGY7IH1cblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH1cblx0aWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBnbG9iYWw7IH1cblx0dGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnKTtcbn1cblxudmFyIGdsb2JhbCA9IGdldEdsb2JhbCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBnbG9iYWwuZmV0Y2g7XG5cbi8vIE5lZWRlZCBmb3IgVHlwZVNjcmlwdCBhbmQgV2VicGFjay5cbmlmIChnbG9iYWwuZmV0Y2gpIHtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZ2xvYmFsLmZldGNoLmJpbmQoZ2xvYmFsKTtcbn1cblxuZXhwb3J0cy5IZWFkZXJzID0gZ2xvYmFsLkhlYWRlcnM7XG5leHBvcnRzLlJlcXVlc3QgPSBnbG9iYWwuUmVxdWVzdDtcbmV4cG9ydHMuUmVzcG9uc2UgPSBnbG9iYWwuUmVzcG9uc2U7IiwiXG4vKiEgcGFrbyAyLjAuMyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28gQGxpY2Vuc2UgKE1JVCBBTkQgWmxpYikgKi9cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtdW5hcnktb3BzICovXG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vY29uc3QgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL2NvbnN0IFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy9jb25zdCBaX1JMRSAgICAgICAgICAgICAgID0gMztcbmNvbnN0IFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL2NvbnN0IFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG5jb25zdCBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuY29uc3QgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vY29uc3QgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG5jb25zdCBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IGxldCBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxuY29uc3QgU1RPUkVEX0JMT0NLID0gMDtcbmNvbnN0IFNUQVRJQ19UUkVFUyA9IDE7XG5jb25zdCBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxuY29uc3QgTUlOX01BVENIICAgID0gMztcbmNvbnN0IE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxuY29uc3QgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbmNvbnN0IExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxuY29uc3QgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG5jb25zdCBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxuY29uc3QgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbmNvbnN0IEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG5jb25zdCBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxuY29uc3QgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG5jb25zdCBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxuY29uc3QgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuY29uc3QgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG5jb25zdCBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbmNvbnN0IGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdKTtcblxuY29uc3QgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM10pO1xuXG5jb25zdCBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddKTtcblxuY29uc3QgYmxfb3JkZXIgPVxuICBuZXcgVWludDhBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxuY29uc3QgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG5jb25zdCBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxuY29uc3Qgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbmNvbnN0IF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxuY29uc3QgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxuY29uc3QgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG5jb25zdCBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxubGV0IHN0YXRpY19sX2Rlc2M7XG5sZXQgc3RhdGljX2RfZGVzYztcbmxldCBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5jb25zdCBkX2NvZGUgPSAoZGlzdCkgPT4ge1xuXG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuY29uc3QgcHV0X3Nob3J0ID0gKHMsIHcpID0+IHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuY29uc3Qgc2VuZF9iaXRzID0gKHMsIHZhbHVlLCBsZW5ndGgpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59O1xuXG5cbmNvbnN0IHNlbmRfY29kZSA9IChzLCBjLCB0cmVlKSA9PiB7XG5cbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuY29uc3QgYmlfcmV2ZXJzZSA9IChjb2RlLCBsZW4pID0+IHtcblxuICBsZXQgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmNvbnN0IGJpX2ZsdXNoID0gKHMpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuY29uc3QgZ2VuX2JpdGxlbiA9IChzLCBkZXNjKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICBjb25zdCB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICBjb25zdCBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICBjb25zdCBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgY29uc3QgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICBjb25zdCBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICBjb25zdCBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICBjb25zdCBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICBsZXQgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgbGV0IG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIGxldCB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICBsZXQgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICBsZXQgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5jb25zdCBnZW5fY29kZXMgPSAodHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KSA9PlxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICBjb25zdCBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgbGV0IGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGxldCBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5jb25zdCB0cl9zdGF0aWNfaW5pdCA9ICgpID0+IHtcblxuICBsZXQgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIGxldCBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIGxldCBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICBsZXQgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIGNvbnN0IGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmNvbnN0IGluaXRfYmxvY2sgPSAocykgPT4ge1xuXG4gIGxldCBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuY29uc3QgYmlfd2luZHVwID0gKHMpID0+XG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmNvbnN0IGNvcHlfYmxvY2sgPSAocywgYnVmLCBsZW4sIGhlYWRlcikgPT5cbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHMucGVuZGluZ19idWYuc2V0KHMud2luZG93LnN1YmFycmF5KGJ1ZiwgYnVmICsgbGVuKSwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5jb25zdCBzbWFsbGVyID0gKHRyZWUsIG4sIG0sIGRlcHRoKSA9PiB7XG5cbiAgY29uc3QgX24yID0gbiAqIDI7XG4gIGNvbnN0IF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuY29uc3QgcHFkb3duaGVhcCA9IChzLCB0cmVlLCBrKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICBjb25zdCB2ID0gcy5oZWFwW2tdO1xuICBsZXQgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59O1xuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIGNvbnN0IFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuY29uc3QgY29tcHJlc3NfYmxvY2sgPSAocywgbHRyZWUsIGR0cmVlKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIGxldCBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgbGV0IGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgbGV0IGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIGxldCBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICBsZXQgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5jb25zdCBidWlsZF90cmVlID0gKHMsIGRlc2MpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIGNvbnN0IHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgY29uc3Qgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgY29uc3QgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICBjb25zdCBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICBsZXQgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgbGV0IG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICBsZXQgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmNvbnN0IHNjYW5fdHJlZSA9IChzLCB0cmVlLCBtYXhfY29kZSkgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIGxldCBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICBsZXQgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgbGV0IG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIGxldCBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIGxldCBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgbGV0IG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5jb25zdCBzZW5kX3RyZWUgPSAocywgdHJlZSwgbWF4X2NvZGUpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIGxldCBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICBsZXQgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgbGV0IGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgbGV0IG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICBsZXQgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5jb25zdCBidWlsZF9ibF90cmVlID0gKHMpID0+IHtcblxuICBsZXQgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5jb25zdCBzZW5kX2FsbF90cmVlcyA9IChzLCBsY29kZXMsIGRjb2RlcywgYmxjb2RlcykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIGxldCByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmNvbnN0IGRldGVjdF9kYXRhX3R5cGUgPSAocykgPT4ge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIGxldCBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgbGV0IG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn07XG5cblxubGV0IHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmNvbnN0IF90cl9pbml0ID0gKHMpID0+XG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuY29uc3QgX3RyX3N0b3JlZF9ibG9jayA9IChzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpID0+XG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5jb25zdCBfdHJfYWxpZ24gPSAocykgPT4ge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuY29uc3QgX3RyX2ZsdXNoX2Jsb2NrID0gKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgPT5cbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIGxldCBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIGxldCBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5jb25zdCBfdHJfdGFsbHkgPSAocywgZGlzdCwgbGMpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy9sZXQgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59O1xuXG52YXIgX3RyX2luaXRfMSAgPSBfdHJfaW5pdDtcbnZhciBfdHJfc3RvcmVkX2Jsb2NrXzEgPSBfdHJfc3RvcmVkX2Jsb2NrO1xudmFyIF90cl9mbHVzaF9ibG9ja18xICA9IF90cl9mbHVzaF9ibG9jaztcbnZhciBfdHJfdGFsbHlfMSA9IF90cl90YWxseTtcbnZhciBfdHJfYWxpZ25fMSA9IF90cl9hbGlnbjtcblxudmFyIHRyZWVzID0ge1xuXHRfdHJfaW5pdDogX3RyX2luaXRfMSxcblx0X3RyX3N0b3JlZF9ibG9jazogX3RyX3N0b3JlZF9ibG9ja18xLFxuXHRfdHJfZmx1c2hfYmxvY2s6IF90cl9mbHVzaF9ibG9ja18xLFxuXHRfdHJfdGFsbHk6IF90cl90YWxseV8xLFxuXHRfdHJfYWxpZ246IF90cl9hbGlnbl8xXG59O1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBpc24ndCB3b3J0aCBpdCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9ucyBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5jb25zdCBhZGxlcjMyID0gKGFkbGVyLCBidWYsIGxlbiwgcG9zKSA9PiB7XG4gIGxldCBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59O1xuXG5cbnZhciBhZGxlcjMyXzEgPSBhZGxlcjMyO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmNvbnN0IG1ha2VUYWJsZSA9ICgpID0+IHtcbiAgbGV0IGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59O1xuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxuY29uc3QgY3JjVGFibGUgPSBuZXcgVWludDMyQXJyYXkobWFrZVRhYmxlKCkpO1xuXG5cbmNvbnN0IGNyYzMyID0gKGNyYywgYnVmLCBsZW4sIHBvcykgPT4ge1xuICBjb25zdCB0ID0gY3JjVGFibGU7XG4gIGNvbnN0IGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn07XG5cblxudmFyIGNyYzMyXzEgPSBjcmMzMjtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgbWVzc2FnZXMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciBjb25zdGFudHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgWl9NRU1fRVJST1I6ICAgICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IHsgX3RyX2luaXQ6IF90cl9pbml0JDEsIF90cl9zdG9yZWRfYmxvY2s6IF90cl9zdG9yZWRfYmxvY2skMSwgX3RyX2ZsdXNoX2Jsb2NrOiBfdHJfZmx1c2hfYmxvY2skMSwgX3RyX3RhbGx5OiBfdHJfdGFsbHkkMSwgX3RyX2FsaWduOiBfdHJfYWxpZ24kMSB9ID0gdHJlZXM7XG5cblxuXG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0gsIFpfUEFSVElBTF9GTFVTSCwgWl9GVUxMX0ZMVVNILCBaX0ZJTklTSCwgWl9CTE9DSyxcbiAgWl9PSywgWl9TVFJFQU1fRU5ELCBaX1NUUkVBTV9FUlJPUiwgWl9EQVRBX0VSUk9SLCBaX0JVRl9FUlJPUixcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICBaX0ZJTFRFUkVELCBaX0hVRkZNQU5fT05MWSwgWl9STEUsIFpfRklYRUQ6IFpfRklYRUQkMSwgWl9ERUZBVUxUX1NUUkFURUdZLFxuICBaX1VOS05PV046IFpfVU5LTk9XTiQxLFxuICBaX0RFRkxBVEVEXG59ID0gY29uc3RhbnRzO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmNvbnN0IE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG5jb25zdCBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xuY29uc3QgREVGX01FTV9MRVZFTCA9IDg7XG5cblxuY29uc3QgTEVOR1RIX0NPREVTJDEgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbmNvbnN0IExJVEVSQUxTJDEgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuY29uc3QgTF9DT0RFUyQxICAgICAgID0gTElURVJBTFMkMSArIDEgKyBMRU5HVEhfQ09ERVMkMTtcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuY29uc3QgRF9DT0RFUyQxICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbmNvbnN0IEJMX0NPREVTJDEgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5jb25zdCBIRUFQX1NJWkUkMSAgICAgPSAyICogTF9DT0RFUyQxICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5jb25zdCBNQVhfQklUUyQxICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbmNvbnN0IE1JTl9NQVRDSCQxID0gMztcbmNvbnN0IE1BWF9NQVRDSCQxID0gMjU4O1xuY29uc3QgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0gkMSArIE1JTl9NQVRDSCQxICsgMSk7XG5cbmNvbnN0IFBSRVNFVF9ESUNUID0gMHgyMDtcblxuY29uc3QgSU5JVF9TVEFURSA9IDQyO1xuY29uc3QgRVhUUkFfU1RBVEUgPSA2OTtcbmNvbnN0IE5BTUVfU1RBVEUgPSA3MztcbmNvbnN0IENPTU1FTlRfU1RBVEUgPSA5MTtcbmNvbnN0IEhDUkNfU1RBVEUgPSAxMDM7XG5jb25zdCBCVVNZX1NUQVRFID0gMTEzO1xuY29uc3QgRklOSVNIX1NUQVRFID0gNjY2O1xuXG5jb25zdCBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xuY29uc3QgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbmNvbnN0IEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbmNvbnN0IEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG5jb25zdCBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuY29uc3QgZXJyID0gKHN0cm0sIGVycm9yQ29kZSkgPT4ge1xuICBzdHJtLm1zZyA9IG1lc3NhZ2VzW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59O1xuXG5jb25zdCByYW5rID0gKGYpID0+IHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn07XG5cbmNvbnN0IHplcm8kMSA9IChidWYpID0+IHtcbiAgbGV0IGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfVxufTtcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG5sZXQgSEFTSF9aTElCID0gKHMsIHByZXYsIGRhdGEpID0+ICgocHJldiA8PCBzLmhhc2hfc2hpZnQpIF4gZGF0YSkgJiBzLmhhc2hfbWFzaztcbi8vIFRoaXMgaGFzaCBjYXVzZXMgbGVzcyBjb2xsaXNpb25zLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28vaXNzdWVzLzEzNVxuLy8gQnV0IGJyZWFrcyBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy9sZXQgSEFTSF9GQVNUID0gKHMsIHByZXYsIGRhdGEpID0+ICgocHJldiA8PCA4KSArIChwcmV2ID4+IDgpICsgKGRhdGEgPDwgNCkpICYgcy5oYXNoX21hc2s7XG5sZXQgSEFTSCA9IEhBU0hfWkxJQjtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuY29uc3QgZmx1c2hfcGVuZGluZyA9IChzdHJtKSA9PiB7XG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIGxldCBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgc3RybS5vdXRwdXQuc2V0KHMucGVuZGluZ19idWYuc3ViYXJyYXkocy5wZW5kaW5nX291dCwgcy5wZW5kaW5nX291dCArIGxlbiksIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn07XG5cblxuY29uc3QgZmx1c2hfYmxvY2tfb25seSA9IChzLCBsYXN0KSA9PiB7XG4gIF90cl9mbHVzaF9ibG9jayQxKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59O1xuXG5cbmNvbnN0IHB1dF9ieXRlID0gKHMsIGIpID0+IHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmNvbnN0IHB1dFNob3J0TVNCID0gKHMsIGIpID0+IHtcblxuICAvLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuY29uc3QgcmVhZF9idWYgPSAoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkgPT4ge1xuXG4gIGxldCBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICBidWYuc2V0KHN0cm0uaW5wdXQuc3ViYXJyYXkoc3RybS5uZXh0X2luLCBzdHJtLm5leHRfaW4gKyBsZW4pLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMl8xKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5jb25zdCBsb25nZXN0X21hdGNoID0gKHMsIGN1cl9tYXRjaCkgPT4ge1xuXG4gIGxldCBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIGxldCBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgbGV0IG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgbGV0IGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICBsZXQgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIGxldCBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIGNvbnN0IGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgY29uc3QgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIGNvbnN0IHdtYXNrID0gcy53X21hc2s7XG4gIGNvbnN0IHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIGNvbnN0IHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0gkMTtcbiAgbGV0IHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICBsZXQgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCQxIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0gkMTtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmNvbnN0IGZpbGxfd2luZG93ID0gKHMpID0+IHtcblxuICBjb25zdCBfd19zaXplID0gcy53X3NpemU7XG4gIGxldCBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHMud2luZG93LnNldChzLndpbmRvdy5zdWJhcnJheShfd19zaXplLCBfd19zaXplICsgX3dfc2l6ZSksIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcblxuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcblxuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gkMSkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbc3RyICsgMV0pO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCQxIC0gMV0pO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIJDEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICBjb25zdCBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgbGV0IGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5jb25zdCBkZWZsYXRlX3N0b3JlZCA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgbGV0IG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICBjb25zdCBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuY29uc3QgZGVmbGF0ZV9mYXN0ID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gkMSkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0gkMSAtIDFdKTtcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCQxKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5JDEocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIJDEpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIJDEpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0gkMSAtIDFdKTtcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseSQxKHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIJDEgLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIJDEgLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5jb25zdCBkZWZsYXRlX3Nsb3cgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGxldCBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gkMSkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0gkMSAtIDFdKTtcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCQxIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0gkMSAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0gkMSAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIJDEgJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSCQxO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseSQxKHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIJDEpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCQxIC0gMV0pO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIJDEgLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5JDEocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gX3RyX3RhbGx5JDEocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0gkMSAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIJDEgLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5jb25zdCBkZWZsYXRlX3JsZSA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIGxldCBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgbGV0IHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgY29uc3QgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIJDEpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCQxICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIJDEgJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0gkMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCQxIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gkMSkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkkMShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCQxKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5JDEocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuY29uc3QgZGVmbGF0ZV9odWZmID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSBfdHJfdGFsbHkkMShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcblxuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxuY29uc3QgY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5jb25zdCBsbV9pbml0ID0gKHMpID0+IHtcblxuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvJDEocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCQxIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn07XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgVWludDE2QXJyYXkoSEVBUF9TSVpFJDEgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IFVpbnQxNkFycmF5KCgyICogRF9DT0RFUyQxICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IFVpbnQxNkFycmF5KCgyICogQkxfQ09ERVMkMSArIDEpICogMik7XG4gIHplcm8kMSh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8kMSh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8kMSh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IFVpbnQxNkFycmF5KE1BWF9CSVRTJDEgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyBVaW50MTZBcnJheSgyICogTF9DT0RFUyQxICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyQxKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyBVaW50MTZBcnJheSgyICogTF9DT0RFUyQxICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyQxKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmNvbnN0IGRlZmxhdGVSZXNldEtlZXAgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV04kMTtcblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICBfdHJfaW5pdCQxKHMpO1xuICByZXR1cm4gWl9PSztcbn07XG5cblxuY29uc3QgZGVmbGF0ZVJlc2V0ID0gKHN0cm0pID0+IHtcblxuICBjb25zdCByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBkZWZsYXRlU2V0SGVhZGVyID0gKHN0cm0sIGhlYWQpID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVJbml0MiA9IChzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpID0+IHtcblxuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBsZXQgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCQxKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIGNvbnN0IHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCQxIC0gMSkgLyBNSU5fTUFUQ0gkMSk7XG5cbiAgcy53aW5kb3cgPSBuZXcgVWludDhBcnJheShzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgVWludDE2QXJyYXkocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgVWludDE2QXJyYXkocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuXG4gIC8vb3ZlcmxheSA9ICh1c2hmICopIFpBTExPQyhzdHJtLCBzLT5saXRfYnVmc2l6ZSwgc2l6ZW9mKHVzaCkrMik7XG4gIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IFVpbnQ4QXJyYXkocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICAvLyBJdCBpcyBvZmZzZXQgZnJvbSBgcy5wZW5kaW5nX2J1ZmAgKHNpemUgaXMgYHMubGl0X2J1ZnNpemUgKiAyYClcbiAgLy9zLT5kX2J1ZiA9IG92ZXJsYXkgKyBzLT5saXRfYnVmc2l6ZS9zaXplb2YodXNoKTtcbiAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufTtcblxuY29uc3QgZGVmbGF0ZUluaXQgPSAoc3RybSwgbGV2ZWwpID0+IHtcblxuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGUgPSAoc3RybSwgZmx1c2gpID0+IHtcblxuICBsZXQgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgY29uc3Qgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgbGV0IGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgbGV0IGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIGxldCBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIF90cl9hbGlnbiQxKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgX3RyX3N0b3JlZF9ibG9jayQxKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyQxKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVFbmQgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgY29uc3Qgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmNvbnN0IGRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gKHN0cm0sIGRpY3Rpb25hcnkpID0+IHtcblxuICBsZXQgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG4gIGNvbnN0IHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzJfMShzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvJDEocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgbGV0IHRtcERpY3QgPSBuZXcgVWludDhBcnJheShzLndfc2l6ZSk7XG4gICAgdG1wRGljdC5zZXQoZGljdGlvbmFyeS5zdWJhcnJheShkaWN0TGVuZ3RoIC0gcy53X3NpemUsIGRpY3RMZW5ndGgpLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgY29uc3QgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBjb25zdCBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBjb25zdCBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gkMSkge1xuICAgIGxldCBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIGxldCBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIJDEgLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gkMSAtIDFdKTtcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIJDEgLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCQxIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbnZhciBkZWZsYXRlSW5pdF8xID0gZGVmbGF0ZUluaXQ7XG52YXIgZGVmbGF0ZUluaXQyXzEgPSBkZWZsYXRlSW5pdDI7XG52YXIgZGVmbGF0ZVJlc2V0XzEgPSBkZWZsYXRlUmVzZXQ7XG52YXIgZGVmbGF0ZVJlc2V0S2VlcF8xID0gZGVmbGF0ZVJlc2V0S2VlcDtcbnZhciBkZWZsYXRlU2V0SGVhZGVyXzEgPSBkZWZsYXRlU2V0SGVhZGVyO1xudmFyIGRlZmxhdGVfMiA9IGRlZmxhdGU7XG52YXIgZGVmbGF0ZUVuZF8xID0gZGVmbGF0ZUVuZDtcbnZhciBkZWZsYXRlU2V0RGljdGlvbmFyeV8xID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG52YXIgZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuXG52YXIgZGVmbGF0ZV8xID0ge1xuXHRkZWZsYXRlSW5pdDogZGVmbGF0ZUluaXRfMSxcblx0ZGVmbGF0ZUluaXQyOiBkZWZsYXRlSW5pdDJfMSxcblx0ZGVmbGF0ZVJlc2V0OiBkZWZsYXRlUmVzZXRfMSxcblx0ZGVmbGF0ZVJlc2V0S2VlcDogZGVmbGF0ZVJlc2V0S2VlcF8xLFxuXHRkZWZsYXRlU2V0SGVhZGVyOiBkZWZsYXRlU2V0SGVhZGVyXzEsXG5cdGRlZmxhdGU6IGRlZmxhdGVfMixcblx0ZGVmbGF0ZUVuZDogZGVmbGF0ZUVuZF8xLFxuXHRkZWZsYXRlU2V0RGljdGlvbmFyeTogZGVmbGF0ZVNldERpY3Rpb25hcnlfMSxcblx0ZGVmbGF0ZUluZm86IGRlZmxhdGVJbmZvXG59O1xuXG5jb25zdCBfaGFzID0gKG9iaiwga2V5KSA9PiB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufTtcblxudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICBjb25zdCBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgY29uc3Qgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbnZhciBmbGF0dGVuQ2h1bmtzID0gKGNodW5rcykgPT4ge1xuICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgbGV0IGxlbiA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7XG4gIH1cblxuICAvLyBqb2luIGNodW5rc1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuXG4gIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxldCBjaHVuayA9IGNodW5rc1tpXTtcbiAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgIHBvcyArPSBjaHVuay5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNvbW1vbiA9IHtcblx0YXNzaWduOiBhc3NpZ24sXG5cdGZsYXR0ZW5DaHVua3M6IGZsYXR0ZW5DaHVua3Ncbn07XG5cbi8vIFN0cmluZyBlbmNvZGUvZGVjb2RlIGhlbHBlcnNcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG5sZXQgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7IH1cblxuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbmNvbnN0IF91dGY4bGVuID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvciAobGV0IHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG52YXIgc3RyaW5nMmJ1ZiA9IChzdHIpID0+IHtcbiAgbGV0IGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgVWludDhBcnJheShidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXJcbmNvbnN0IGJ1ZjJiaW5zdHJpbmcgPSAoYnVmLCBsZW4pID0+IHtcbiAgLy8gT24gQ2hyb21lLCB0aGUgYXJndW1lbnRzIGluIGEgZnVuY3Rpb24gY2FsbCB0aGF0IGFyZSBhbGxvd2VkIGlzIGA2NTUzNGAuXG4gIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciBpcyBzbWFsbGVyIHRoYW4gdGhhdCwgd2UgY2FuIHVzZSB0aGlzIG9wdGltaXphdGlvbixcbiAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgdGFrZSBhIHNsb3dlciBwYXRoLlxuICBpZiAobGVuIDwgNjU1MzQpIHtcbiAgICBpZiAoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0spIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1Zi5sZW5ndGggPT09IGxlbiA/IGJ1ZiA6IGJ1Zi5zdWJhcnJheSgwLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG52YXIgYnVmMnN0cmluZyA9IChidWYsIG1heCkgPT4ge1xuICBsZXQgaSwgb3V0O1xuICBjb25zdCBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICBjb25zdCB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGxldCBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgbGV0IGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4gLSAxOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbnZhciB1dGY4Ym9yZGVyID0gKGJ1ZiwgbWF4KSA9PiB7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgbGV0IHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG5cbnZhciBzdHJpbmdzID0ge1xuXHRzdHJpbmcyYnVmOiBzdHJpbmcyYnVmLFxuXHRidWYyc3RyaW5nOiBidWYyc3RyaW5nLFxuXHR1dGY4Ym9yZGVyOiB1dGY4Ym9yZGVyXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbnZhciB6c3RyZWFtID0gWlN0cmVhbTtcblxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX05PX0ZMVVNIOiBaX05PX0ZMVVNIJDEsIFpfU1lOQ19GTFVTSCwgWl9GVUxMX0ZMVVNIOiBaX0ZVTExfRkxVU0gkMSwgWl9GSU5JU0g6IFpfRklOSVNIJDEsXG4gIFpfT0s6IFpfT0skMSwgWl9TVFJFQU1fRU5EOiBaX1NUUkVBTV9FTkQkMSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04kMSxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiBaX0RFRkFVTFRfU1RSQVRFR1kkMSxcbiAgWl9ERUZMQVRFRDogWl9ERUZMQVRFRCQxXG59ID0gY29uc3RhbnRzO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGBoZWFkZXJgIChPYmplY3QpIC0gY3VzdG9tIGhlYWRlciBmb3IgZ3ppcFxuICogICAtIGB0ZXh0YCAoQm9vbGVhbikgLSB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0XG4gKiAgIC0gYHRpbWVgIChOdW1iZXIpIC0gbW9kaWZpY2F0aW9uIHRpbWUsIHVuaXggdGltZXN0YW1wXG4gKiAgIC0gYG9zYCAoTnVtYmVyKSAtIG9wZXJhdGlvbiBzeXN0ZW0gY29kZVxuICogICAtIGBleHRyYWAgKEFycmF5KSAtIGFycmF5IG9mIGJ5dGVzIHdpdGggZXh0cmEgZGF0YSAobWF4IDY1NTM2KVxuICogICAtIGBuYW1lYCAoU3RyaW5nKSAtIGZpbGUgbmFtZSAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgY29tbWVudGAgKFN0cmluZykgLSBjb21tZW50IChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBoY3JjYCAoQm9vbGVhbikgLSB0cnVlIGlmIGhlYWRlciBjcmMgc2hvdWxkIGJlIGFkZGVkXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBuZXcgVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiBjb25zdCBkZWZsYXRlID0gbmV3IHBha28uRGVmbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogZGVmbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogZGVmbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoZGVmbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGRlZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGRlZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gRGVmbGF0ZShvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGNvbW1vbi5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04kMSxcbiAgICBtZXRob2Q6IFpfREVGTEFURUQkMSxcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIG1lbUxldmVsOiA4LFxuICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1kkMVxuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICBsZXQgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmIChvcHQuZ3ppcCAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAxNjtcbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSA9IG5ldyB6c3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIGxldCBzdGF0dXMgPSBkZWZsYXRlXzEuZGVmbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQubGV2ZWwsXG4gICAgb3B0Lm1ldGhvZCxcbiAgICBvcHQud2luZG93Qml0cyxcbiAgICBvcHQubWVtTGV2ZWwsXG4gICAgb3B0LnN0cmF0ZWd5XG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSyQxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICBkZWZsYXRlXzEuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgbGV0IGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IGRlZmxhdGVfMS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSyQxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXNbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBmbHVzaF9tb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBmbHVzaF9tb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdFxuICogaGF2ZSBgZmx1c2hfbW9kZWAgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nXG4gKiBidWZmZXJzIGFuZCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dLlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZsdXNoX21vZGUpIHtcbiAgY29uc3Qgc3RybSA9IHRoaXMuc3RybTtcbiAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgbGV0IHN0YXR1cywgX2ZsdXNoX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKGZsdXNoX21vZGUgPT09IH5+Zmx1c2hfbW9kZSkgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlO1xuICBlbHNlIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZSA9PT0gdHJ1ZSA/IFpfRklOSVNIJDEgOiBaX05PX0ZMVVNIJDE7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgVWludDhBcnJheShjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgYXZhaWxfb3V0ID4gNiB0byBhdm9pZCByZXBlYXRpbmcgbWFya2Vyc1xuICAgIGlmICgoX2ZsdXNoX21vZGUgPT09IFpfU1lOQ19GTFVTSCB8fCBfZmx1c2hfbW9kZSA9PT0gWl9GVUxMX0ZMVVNIJDEpICYmIHN0cm0uYXZhaWxfb3V0IDw9IDYpIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IGRlZmxhdGVfMS5kZWZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcblxuICAgIC8vIEVuZGVkID0+IGZsdXNoIGFuZCBmaW5pc2hcbiAgICBpZiAoc3RhdHVzID09PSBaX1NUUkVBTV9FTkQkMSkge1xuICAgICAgaWYgKHN0cm0ubmV4dF9vdXQgPiAwKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICAgIHN0YXR1cyA9IGRlZmxhdGVfMS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0skMTtcbiAgICB9XG5cbiAgICAvLyBGbHVzaCBpZiBvdXQgYnVmZmVyIGZ1bGxcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEZsdXNoIGlmIHJlcXVlc3RlZCBhbmQgaGFzIGRhdGFcbiAgICBpZiAoX2ZsdXNoX21vZGUgPiAwICYmIHN0cm0ubmV4dF9vdXQgPiAwKSB7XG4gICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheSk6IG91dHB1dCBkYXRhLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKS4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSyQxKSB7XG4gICAgdGhpcy5yZXN1bHQgPSBjb21tb24uZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheVxuICogLSBkYXRhIChVaW50OEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENvbXByZXNzIGBkYXRhYCB3aXRoIGRlZmxhdGUgYWxnb3JpdGhtIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gbGV2ZWxcbiAqIC0gd2luZG93Qml0c1xuICogLSBtZW1MZXZlbFxuICogLSBzdHJhdGVneVxuICogLSBkaWN0aW9uYXJ5XG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUkMShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChkZWZsYXRvci5lcnIpIHsgdGhyb3cgZGVmbGF0b3IubXNnIHx8IG1lc3NhZ2VzW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXlcbiAqIC0gZGF0YSAoVWludDhBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZSQxKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUkMShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxudmFyIERlZmxhdGVfMSA9IERlZmxhdGU7XG52YXIgZGVmbGF0ZV8yJDEgPSBkZWZsYXRlJDE7XG52YXIgZGVmbGF0ZVJhd18xID0gZGVmbGF0ZVJhdztcbnZhciBnemlwXzEgPSBnemlwO1xudmFyIGNvbnN0YW50cyQxID0gY29uc3RhbnRzO1xuXG52YXIgZGVmbGF0ZV8xJDEgPSB7XG5cdERlZmxhdGU6IERlZmxhdGVfMSxcblx0ZGVmbGF0ZTogZGVmbGF0ZV8yJDEsXG5cdGRlZmxhdGVSYXc6IGRlZmxhdGVSYXdfMSxcblx0Z3ppcDogZ3ppcF8xLFxuXHRjb25zdGFudHM6IGNvbnN0YW50cyQxXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xuY29uc3QgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0IFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbnZhciBpbmZmYXN0ID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIGxldCBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIGxldCBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgbGV0IF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIGxldCBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIGxldCBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGxldCBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIGxldCB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgbGV0IHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgbGV0IHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICBsZXQgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIGxldCBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICBsZXQgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIGxldCBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIGxldCBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgbGV0IGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIGxldCBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgbGV0IG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgbGV0IGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIGxldCBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICBsZXQgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIGxldCBmcm9tX3NvdXJjZTtcblxuXG4gIGxldCBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgTUFYQklUUyA9IDE1O1xuY29uc3QgRU5PVUdIX0xFTlMgPSA4NTI7XG5jb25zdCBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL2NvbnN0IEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG5jb25zdCBDT0RFUyA9IDA7XG5jb25zdCBMRU5TID0gMTtcbmNvbnN0IERJU1RTID0gMjtcblxuY29uc3QgbGJhc2UgPSBuZXcgVWludDE2QXJyYXkoWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXSk7XG5cbmNvbnN0IGxleHQgPSBuZXcgVWludDhBcnJheShbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXSk7XG5cbmNvbnN0IGRiYXNlID0gbmV3IFVpbnQxNkFycmF5KFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXSk7XG5cbmNvbnN0IGRleHQgPSBuZXcgVWludDhBcnJheShbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXSk7XG5cbmNvbnN0IGluZmxhdGVfdGFibGUgPSAodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cykgPT5cbntcbiAgY29uc3QgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgbGV0IGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgbGV0IHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIGxldCBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICBsZXQgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICBsZXQgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICBsZXQgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIGxldCBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgbGV0IHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgbGV0IGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIGxldCBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICBsZXQgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIGxldCBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICBsZXQgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgbGV0IG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIGxldCBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIGxldCBiYXNlX2luZGV4ID0gMDtcbi8vICBsZXQgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIGxldCBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICBjb25zdCBjb3VudCA9IG5ldyBVaW50MTZBcnJheShNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICBjb25zdCBvZmZzID0gbmV3IFVpbnQxNkFycmF5KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIGxldCBleHRyYSA9IG51bGw7XG4gIGxldCBleHRyYV9pbmRleCA9IDA7XG5cbiAgbGV0IGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuXG5cbnZhciBpbmZ0cmVlcyA9IGluZmxhdGVfdGFibGU7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuXG5cblxuXG5cbmNvbnN0IENPREVTJDEgPSAwO1xuY29uc3QgTEVOUyQxID0gMTtcbmNvbnN0IERJU1RTJDEgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX0ZJTklTSDogWl9GSU5JU0gkMiwgWl9CTE9DSzogWl9CTE9DSyQxLCBaX1RSRUVTLFxuICBaX09LOiBaX09LJDIsIFpfU1RSRUFNX0VORDogWl9TVFJFQU1fRU5EJDIsIFpfTkVFRF9ESUNULCBaX1NUUkVBTV9FUlJPUjogWl9TVFJFQU1fRVJST1IkMSwgWl9EQVRBX0VSUk9SOiBaX0RBVEFfRVJST1IkMSwgWl9NRU1fRVJST1IsIFpfQlVGX0VSUk9SOiBaX0JVRl9FUlJPUiQxLFxuICBaX0RFRkxBVEVEOiBaX0RFRkxBVEVEJDJcbn0gPSBjb25zdGFudHM7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuY29uc3QgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xuY29uc3QgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG5jb25zdCAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG5jb25zdCAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG5jb25zdCAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xuY29uc3QgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xuY29uc3QgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG5jb25zdCAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG5jb25zdCAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbmNvbnN0ICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG5jb25zdCAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG5jb25zdCAgICAgICAgVFlQRSQxID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuY29uc3QgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG5jb25zdCAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG5jb25zdCAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG5jb25zdCAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG5jb25zdCAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xuY29uc3QgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbmNvbnN0ICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG5jb25zdCAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xuY29uc3QgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xuY29uc3QgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xuY29uc3QgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbmNvbnN0ICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbmNvbnN0ICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xuY29uc3QgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBCQUQkMSA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0ICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbmNvbnN0IEVOT1VHSF9MRU5TJDEgPSA4NTI7XG5jb25zdCBFTk9VR0hfRElTVFMkMSA9IDU5Mjtcbi8vY29uc3QgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG5jb25zdCBNQVhfV0JJVFMkMSA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG5jb25zdCBERUZfV0JJVFMgPSBNQVhfV0JJVFMkMTtcblxuXG5jb25zdCB6c3dhcDMyID0gKHEpID0+IHtcblxuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn07XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IFVpbnQxNkFycmF5KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IFVpbnQxNkFycmF5KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cblxuY29uc3QgaW5mbGF0ZVJlc2V0S2VlcCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IEludDMyQXJyYXkoRU5PVUdIX0xFTlMkMSk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSF9ESVNUUyQxKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0skMjtcbn07XG5cblxuY29uc3QgaW5mbGF0ZVJlc2V0ID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufTtcblxuXG5jb25zdCBpbmZsYXRlUmVzZXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHtcbiAgbGV0IHdyYXA7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUluaXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgY29uc3Qgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIGNvbnN0IHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0skMikge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBpbmZsYXRlSW5pdCA9IChzdHJtKSA9PiB7XG5cbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufTtcblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG5sZXQgdmlyZ2luID0gdHJ1ZTtcblxubGV0IGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuXG5jb25zdCBmaXhlZHRhYmxlcyA9IChzdGF0ZSkgPT4ge1xuXG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICBsZW5maXggPSBuZXcgSW50MzJBcnJheSg1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgSW50MzJBcnJheSgzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIGxldCBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZ0cmVlcyhMRU5TJDEsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mdHJlZXMoRElTVFMkMSwgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn07XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmNvbnN0IHVwZGF0ZXdpbmRvdyA9IChzdHJtLCBzcmMsIGVuZCwgY29weSkgPT4ge1xuXG4gIGxldCBkaXN0O1xuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgVWludDhBcnJheShzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICBzdGF0ZS53aW5kb3cuc2V0KHNyYy5zdWJhcnJheShlbmQgLSBzdGF0ZS53c2l6ZSwgZW5kKSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIGNvcHksIGVuZCAtIGNvcHkgKyBkaXN0KSwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgc3RhdGUud2luZG93LnNldChzcmMuc3ViYXJyYXkoZW5kIC0gY29weSwgZW5kKSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn07XG5cblxuY29uc3QgaW5mbGF0ZSA9IChzdHJtLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBzdGF0ZTtcbiAgbGV0IGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIGxldCBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIGxldCBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICBsZXQgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICBsZXQgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICBsZXQgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIGxldCBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgbGV0IGZyb21fc291cmNlO1xuICBsZXQgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICBsZXQgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy9sZXQgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIGxldCBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICBsZXQgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgY29uc3QgaGJ1ZiA9IG5ldyBVaW50OEFycmF5KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICBsZXQgb3B0cztcblxuICBsZXQgbjsgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlIGZvciBORUVEX0JJVFNcblxuICBjb25zdCBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIG5ldyBVaW50OEFycmF5KFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdKTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSQxKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0skMjtcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICAgIGNhc2UgSEVBRDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEJDIpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAhISEgcGFrbyBwYXRjaC4gRm9yY2UgdXNlIGBvcHRpb25zLndpbmRvd0JpdHNgIGlmIHBhc3NlZC5cbiAgICAgICAgLy8gUmVxdWlyZWQgdG8gYWx3YXlzIHVzZSBtYXggd2luZG93IHNpemUgYnkgZGVmYXVsdC5cbiAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgICAgIC8vc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEUkMTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEJDIpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgICAvLz09PVxuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgT1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgVWludDhBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYS5zZXQoXG4gICAgICAgICAgICAgICAgaW5wdXQuc3ViYXJyYXkoXG4gICAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICAgIG5leHQgKyBjb3B5XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEUkMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJQ1RJRDpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESUNUOlxuICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFJDE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRSQxOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0skMSB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFRE86XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMTtcbiAgICAgICAgYml0cyAtPSAxO1xuICAgICAgICAvLy0tLS8vXG5cbiAgICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICBvdXRwdXQuc2V0KGlucHV0LnN1YmFycmF5KG5leHQsIG5leHQgKyBjb3B5KSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEUkMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZ0cmVlcyhDT0RFUyQxLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQkMSkgeyBicmVhazsgfVxuXG4gICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZnRyZWVzKExFTlMkMSwgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICAgIHJldCA9IGluZnRyZWVzKERJU1RTJDEsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmZhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSQxKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRSQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOR1RIOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EJDI7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEJDE6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUiQxO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgICAgY2FzZSBTWU5DOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEJDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCQyKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSA7XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyXzEoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSQxID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIJDIpICYmIHJldCA9PT0gWl9PSyQyKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1IkMTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBpbmZsYXRlRW5kID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgbGV0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LJDI7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVHZXRIZWFkZXIgPSAoc3RybSwgaGVhZCkgPT4ge1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0skMjtcbn07XG5cblxuY29uc3QgaW5mbGF0ZVNldERpY3Rpb25hcnkgPSAoc3RybSwgZGljdGlvbmFyeSkgPT4ge1xuICBjb25zdCBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgbGV0IHN0YXRlO1xuICBsZXQgZGljdGlkO1xuICBsZXQgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMl8xKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1IkMTtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0skMjtcbn07XG5cblxudmFyIGluZmxhdGVSZXNldF8xID0gaW5mbGF0ZVJlc2V0O1xudmFyIGluZmxhdGVSZXNldDJfMSA9IGluZmxhdGVSZXNldDI7XG52YXIgaW5mbGF0ZVJlc2V0S2VlcF8xID0gaW5mbGF0ZVJlc2V0S2VlcDtcbnZhciBpbmZsYXRlSW5pdF8xID0gaW5mbGF0ZUluaXQ7XG52YXIgaW5mbGF0ZUluaXQyXzEgPSBpbmZsYXRlSW5pdDI7XG52YXIgaW5mbGF0ZV8yID0gaW5mbGF0ZTtcbnZhciBpbmZsYXRlRW5kXzEgPSBpbmZsYXRlRW5kO1xudmFyIGluZmxhdGVHZXRIZWFkZXJfMSA9IGluZmxhdGVHZXRIZWFkZXI7XG52YXIgaW5mbGF0ZVNldERpY3Rpb25hcnlfMSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xudmFyIGluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cblxudmFyIGluZmxhdGVfMSA9IHtcblx0aW5mbGF0ZVJlc2V0OiBpbmZsYXRlUmVzZXRfMSxcblx0aW5mbGF0ZVJlc2V0MjogaW5mbGF0ZVJlc2V0Ml8xLFxuXHRpbmZsYXRlUmVzZXRLZWVwOiBpbmZsYXRlUmVzZXRLZWVwXzEsXG5cdGluZmxhdGVJbml0OiBpbmZsYXRlSW5pdF8xLFxuXHRpbmZsYXRlSW5pdDI6IGluZmxhdGVJbml0Ml8xLFxuXHRpbmZsYXRlOiBpbmZsYXRlXzIsXG5cdGluZmxhdGVFbmQ6IGluZmxhdGVFbmRfMSxcblx0aW5mbGF0ZUdldEhlYWRlcjogaW5mbGF0ZUdldEhlYWRlcl8xLFxuXHRpbmZsYXRlU2V0RGljdGlvbmFyeTogaW5mbGF0ZVNldERpY3Rpb25hcnlfMSxcblx0aW5mbGF0ZUluZm86IGluZmxhdGVJbmZvXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG52YXIgZ3poZWFkZXIgPSBHWmhlYWRlcjtcblxuY29uc3QgdG9TdHJpbmckMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0g6IFpfTk9fRkxVU0gkMiwgWl9GSU5JU0g6IFpfRklOSVNIJDMsXG4gIFpfT0s6IFpfT0skMywgWl9TVFJFQU1fRU5EOiBaX1NUUkVBTV9FTkQkMywgWl9ORUVEX0RJQ1Q6IFpfTkVFRF9ESUNUJDEsIFpfU1RSRUFNX0VSUk9SOiBaX1NUUkVBTV9FUlJPUiQyLCBaX0RBVEFfRVJST1I6IFpfREFUQV9FUlJPUiQyLCBaX01FTV9FUlJPUjogWl9NRU1fRVJST1IkMVxufSA9IGNvbnN0YW50cztcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogY29uc3QgY2h1bmsxID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqIGNvbnN0IGNodW5rMiA9IG5ldyBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIGNvbnN0IGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gY29tbW9uLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxMDI0ICogNjQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGNvbnN0IG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyB6c3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIGxldCBzdGF0dXMgID0gaW5mbGF0ZV8xLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LJDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXNbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBnemhlYWRlcigpO1xuXG4gIGluZmxhdGVfMS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpO1xuXG4gIC8vIFNldHVwIGRpY3Rpb25hcnlcbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZyQxLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9XG4gICAgaWYgKG9wdC5yYXcpIHsgLy9JbiByYXcgbW9kZSB3ZSBuZWVkIHRvIHNldCB0aGUgZGljdGlvbmFyeSBlYXJseVxuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgb3B0LmRpY3Rpb25hcnkpO1xuICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSyQzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIGZsdXNoX21vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXIpOiBpbnB1dCBkYXRhXG4gKiAtIGZsdXNoX21vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUVcbiAqICAgZmx1c2ggbW9kZXMuIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILFxuICogICBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBJZiBlbmQgb2Ygc3RyZWFtIGRldGVjdGVkLFxuICogW1tJbmZsYXRlI29uRW5kXV0gd2lsbCBiZSBjYWxsZWQuXG4gKlxuICogYGZsdXNoX21vZGVgIGlzIG5vdCBuZWVkZWQgZm9yIG5vcm1hbCBvcGVyYXRpb24sIGJlY2F1c2UgZW5kIG9mIHN0cmVhbVxuICogZGV0ZWN0ZWQgYXV0b21hdGljYWxseS4gWW91IG1heSB0cnkgdG8gdXNlIGl0IGZvciBhZHZhbmNlZCB0aGluZ3MsIGJ1dFxuICogdGhpcyBmdW5jdGlvbmFsaXR5IHdhcyBub3QgdGVzdGVkLlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZsdXNoX21vZGUpIHtcbiAgY29uc3Qgc3RybSA9IHRoaXMuc3RybTtcbiAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgY29uc3QgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICBsZXQgc3RhdHVzLCBfZmx1c2hfbW9kZSwgbGFzdF9hdmFpbF9vdXQ7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHJldHVybiBmYWxzZTtcblxuICBpZiAoZmx1c2hfbW9kZSA9PT0gfn5mbHVzaF9tb2RlKSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGU7XG4gIGVsc2UgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlID09PSB0cnVlID8gWl9GSU5JU0gkMyA6IFpfTk9fRkxVU0gkMjtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0b1N0cmluZyQxLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgVWludDhBcnJheShjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSBpbmZsYXRlXzEuaW5mbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG5cbiAgICBpZiAoc3RhdHVzID09PSBaX05FRURfRElDVCQxICYmIGRpY3Rpb25hcnkpIHtcbiAgICAgIHN0YXR1cyA9IGluZmxhdGVfMS5pbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KTtcblxuICAgICAgaWYgKHN0YXR1cyA9PT0gWl9PSyQzKSB7XG4gICAgICAgIHN0YXR1cyA9IGluZmxhdGVfMS5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBaX0RBVEFfRVJST1IkMikge1xuICAgICAgICAvLyBSZXBsYWNlIGNvZGUgd2l0aCBtb3JlIHZlcmJvc2VcbiAgICAgICAgc3RhdHVzID0gWl9ORUVEX0RJQ1QkMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTa2lwIHNueWMgbWFya2VycyBpZiBtb3JlIGRhdGEgZm9sbG93cyBhbmQgbm90IHJhdyBtb2RlXG4gICAgd2hpbGUgKHN0cm0uYXZhaWxfaW4gPiAwICYmXG4gICAgICAgICAgIHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EJDMgJiZcbiAgICAgICAgICAgc3RybS5zdGF0ZS53cmFwID4gMCAmJlxuICAgICAgICAgICBkYXRhW3N0cm0ubmV4dF9pbl0gIT09IDApXG4gICAge1xuICAgICAgaW5mbGF0ZV8xLmluZmxhdGVSZXNldChzdHJtKTtcbiAgICAgIHN0YXR1cyA9IGluZmxhdGVfMS5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSBaX1NUUkVBTV9FUlJPUiQyOlxuICAgICAgY2FzZSBaX0RBVEFfRVJST1IkMjpcbiAgICAgIGNhc2UgWl9ORUVEX0RJQ1QkMTpcbiAgICAgIGNhc2UgWl9NRU1fRVJST1IkMTpcbiAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJlbWVtYmVyIHJlYWwgYGF2YWlsX291dGAgdmFsdWUsIGJlY2F1c2Ugd2UgbWF5IHBhdGNoIG91dCBidWZmZXIgY29udGVudFxuICAgIC8vIHRvIGFsaWduIHV0Zjggc3RyaW5ncyBib3VuZGFyaWVzLlxuICAgIGxhc3RfYXZhaWxfb3V0ID0gc3RybS5hdmFpbF9vdXQ7XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EJDMpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbGV0IG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgbGV0IHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICBsZXQgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWwgJiByZWFsaWduIGNvdW50ZXJzXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSBzdHJtLm91dHB1dC5zZXQoc3RybS5vdXRwdXQuc3ViYXJyYXkobmV4dF9vdXRfdXRmOCwgbmV4dF9vdXRfdXRmOCArIHRhaWwpLCAwKTtcblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQubGVuZ3RoID09PSBzdHJtLm5leHRfb3V0ID8gc3RybS5vdXRwdXQgOiBzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNdXN0IHJlcGVhdCBpdGVyYXRpb24gaWYgb3V0IGJ1ZmZlciBpcyBmdWxsXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9PSyQzICYmIGxhc3RfYXZhaWxfb3V0ID09PSAwKSBjb250aW51ZTtcblxuICAgIC8vIEZpbmFsaXplIGlmIGVuZCBvZiBzdHJlYW0gcmVhY2hlZC5cbiAgICBpZiAoc3RhdHVzID09PSBaX1NUUkVBTV9FTkQkMykge1xuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDApIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGVhY2ggY2h1bmsgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0skMykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IGNvbW1vbi5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheSk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0XG4gKiBmb3JtYXQgdmlhIHdyYXBwZXIgaGVhZGVyIGJ5IGRlZmF1bHQuIFRoYXQncyB3aHkgd2UgZG9uJ3QgcHJvdmlkZVxuICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIHdpbmRvd0JpdHNcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJyk7XG4gKiBjb25zdCBpbnB1dCA9IHBha28uZGVmbGF0ZShuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKSk7XG4gKiBsZXQgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUkMShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHRocm93IGluZmxhdG9yLm1zZyB8fCBtZXNzYWdlc1tpbmZsYXRvci5lcnJdO1xuXG4gIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBpbmZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheSk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUkMShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5KTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbnZhciBJbmZsYXRlXzEgPSBJbmZsYXRlO1xudmFyIGluZmxhdGVfMiQxID0gaW5mbGF0ZSQxO1xudmFyIGluZmxhdGVSYXdfMSA9IGluZmxhdGVSYXc7XG52YXIgdW5nemlwID0gaW5mbGF0ZSQxO1xudmFyIGNvbnN0YW50cyQyID0gY29uc3RhbnRzO1xuXG52YXIgaW5mbGF0ZV8xJDEgPSB7XG5cdEluZmxhdGU6IEluZmxhdGVfMSxcblx0aW5mbGF0ZTogaW5mbGF0ZV8yJDEsXG5cdGluZmxhdGVSYXc6IGluZmxhdGVSYXdfMSxcblx0dW5nemlwOiB1bmd6aXAsXG5cdGNvbnN0YW50czogY29uc3RhbnRzJDJcbn07XG5cbmNvbnN0IHsgRGVmbGF0ZTogRGVmbGF0ZSQxLCBkZWZsYXRlOiBkZWZsYXRlJDIsIGRlZmxhdGVSYXc6IGRlZmxhdGVSYXckMSwgZ3ppcDogZ3ppcCQxIH0gPSBkZWZsYXRlXzEkMTtcblxuY29uc3QgeyBJbmZsYXRlOiBJbmZsYXRlJDEsIGluZmxhdGU6IGluZmxhdGUkMiwgaW5mbGF0ZVJhdzogaW5mbGF0ZVJhdyQxLCB1bmd6aXA6IHVuZ3ppcCQxIH0gPSBpbmZsYXRlXzEkMTtcblxuXG5cbnZhciBEZWZsYXRlXzEkMSA9IERlZmxhdGUkMTtcbnZhciBkZWZsYXRlXzEkMiA9IGRlZmxhdGUkMjtcbnZhciBkZWZsYXRlUmF3XzEkMSA9IGRlZmxhdGVSYXckMTtcbnZhciBnemlwXzEkMSA9IGd6aXAkMTtcbnZhciBJbmZsYXRlXzEkMSA9IEluZmxhdGUkMTtcbnZhciBpbmZsYXRlXzEkMiA9IGluZmxhdGUkMjtcbnZhciBpbmZsYXRlUmF3XzEkMSA9IGluZmxhdGVSYXckMTtcbnZhciB1bmd6aXBfMSA9IHVuZ3ppcCQxO1xudmFyIGNvbnN0YW50c18xID0gY29uc3RhbnRzO1xuXG52YXIgcGFrbyA9IHtcblx0RGVmbGF0ZTogRGVmbGF0ZV8xJDEsXG5cdGRlZmxhdGU6IGRlZmxhdGVfMSQyLFxuXHRkZWZsYXRlUmF3OiBkZWZsYXRlUmF3XzEkMSxcblx0Z3ppcDogZ3ppcF8xJDEsXG5cdEluZmxhdGU6IEluZmxhdGVfMSQxLFxuXHRpbmZsYXRlOiBpbmZsYXRlXzEkMixcblx0aW5mbGF0ZVJhdzogaW5mbGF0ZVJhd18xJDEsXG5cdHVuZ3ppcDogdW5nemlwXzEsXG5cdGNvbnN0YW50czogY29uc3RhbnRzXzFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHBha287XG5leHBvcnQgeyBEZWZsYXRlXzEkMSBhcyBEZWZsYXRlLCBJbmZsYXRlXzEkMSBhcyBJbmZsYXRlLCBjb25zdGFudHNfMSBhcyBjb25zdGFudHMsIGRlZmxhdGVfMSQyIGFzIGRlZmxhdGUsIGRlZmxhdGVSYXdfMSQxIGFzIGRlZmxhdGVSYXcsIGd6aXBfMSQxIGFzIGd6aXAsIGluZmxhdGVfMSQyIGFzIGluZmxhdGUsIGluZmxhdGVSYXdfMSQxIGFzIGluZmxhdGVSYXcsIHVuZ3ppcF8xIGFzIHVuZ3ppcCB9O1xuIiwiLyoqXG4gKiBUaGlzIE1vZHVsZSBjb250YWlucyBjbGFzc2VzIHJlbGV2YW50IHRvIGRhdGEgYWJvdXQgYSB1c2VyIGluIHRoZSB2aXJ0dWFsIDNEIGVudmlyb25tZW50LlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cblxuaW1wb3J0IHsgSGlGaVV0aWxpdGllcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvSGlGaVV0aWxpdGllc1wiO1xuXG5cbi8qKlxuICogSW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcyBkZWZpbmUgYSBwb3NpdGlvbiBpbiAzRCBzcGFjZS4gVGhlIHBvc2l0aW9uIG9mIGEgdXNlciBhZmZlY3RzIHRoZSB3YXkgdGhlIG1peGVkIHNwYXRpYWxcbiAqIGF1ZGlvIGlzIGhlYXJkIGJ5IHRoZSB1c2VyLlxuICovXG5leHBvcnQgY2xhc3MgUG9pbnQzRCB7XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgK3ggaXMgdG8gdGhlIHJpZ2h0IGFuZCAteCBpcyB0byB0aGUgbGVmdC4gVW5pdHMgZm9yIHRoaXMgbWVtYmVyIHZhcmlhYmxlIGFyZSAqKm1ldGVycyoqLlxuICAgICAqL1xuICAgIHg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCAreSBpcyBpbnRvIHRoZSBzY3JlZW4gYW5kIC15IGlzIG91dCBvZiB0aGUgc2NyZWVuIHRvd2FyZHMgdGhlIHVzZXIuIFVuaXRzIGZvciB0aGlzIG1lbWJlciB2YXJpYWJsZSBhcmUgKiptZXRlcnMqKi5cbiAgICAgKi9cbiAgICB5OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgK3ogaXMgdXAgYW5kIC16IGlzIGRvd24uIFVuaXRzIGZvciB0aGlzIG1lbWJlciB2YXJpYWJsZSBhcmUgKiptZXRlcnMqKi5cbiAgICAgKi9cbiAgICB6OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYFBvaW50M0RgIG9iamVjdC4gQWxsIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLiBVbnNldCBwYXJhbWV0ZXJzIHdpbGwgYmUgc2V0IHRvIGAwYC4gUmVtZW1iZXIsIGFsbCB1bml0cyBmb3IgbWVtYmVyIHZhcmlhYmxlcyBhcmUgYG1ldGVyc2AuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyB4ID0gMCwgeSA9IDAsIHogPSAwIH06IHsgeD86IG51bWJlciwgeT86IG51bWJlciwgej86IG51bWJlciB9ID0ge30pIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICB9XG59XG5cbi8qKlxuICogSW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcyBkZWZpbmUgYW4gb3JpZW50YXRpb24gaW4gM0Qgc3BhY2UgaW4gUXVhdGVybmlvbiBmb3JtYXQuIEEgdXNlcidzIG9yaWVudGF0aW9uIGluIDNEIHNwYWNlXG4gKiBhZmZlY3RzIHRoZSB3YXkgdGhlIG1peGVkIHNwYXRpYWwgYXVkaW8gaXMgaGVhcmQgYnkgdGhlIHVzZXIuIEFkZGl0aW9uYWxseSwgb3JpZW50YXRpb24gYWZmZWN0cyB0aGUgd2F5XG4gKiBhIHVzZXIncyBhdWRpbyBpbnB1dCBwcm9wYWdhdGVzIHRocm91Z2ggYSBzcGFjZTogc3BlYWtlcnMgZmFjaW5nIGRpcmVjdGx5IHRvd2FyZHMgYSBsaXN0ZW5lciB3aWxsIHNvdW5kIGxvdWRlciB0aGFuXG4gKiBzcGVha2VycyBmYWNpbmcgYXdheSBmcm9tIGEgbGlzdGVuZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBPcmllbnRhdGlvblF1YXQzRCB7XG4gICAgdzogbnVtYmVyO1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgejogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGBPcmllbnRhdGlvblF1YXQzRGAgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgdyA9IDEsIHggPSAwLCB5ID0gMCwgeiA9IDAgfTogeyB3PzogbnVtYmVyLCB4PzogbnVtYmVyLCB5PzogbnVtYmVyLCB6PzogbnVtYmVyIH0gPSB7fSkge1xuICAgICAgICB0aGlzLncgPSBIaUZpVXRpbGl0aWVzLmNsYW1wTm9uYW4odywgLTEsIDEsIDEpO1xuICAgICAgICB0aGlzLnggPSBIaUZpVXRpbGl0aWVzLmNsYW1wTm9uYW4oeCwgLTEsIDEsIDApO1xuICAgICAgICB0aGlzLnkgPSBIaUZpVXRpbGl0aWVzLmNsYW1wTm9uYW4oeSwgLTEsIDEsIDApO1xuICAgICAgICB0aGlzLnogPSBIaUZpVXRpbGl0aWVzLmNsYW1wTm9uYW4oeiwgLTEsIDEsIDApO1xuICAgIH1cbn1cblxuXG4vLyBoZWxwZXIgZnVuY3Rpb24gdGhhdCBrZWVwcyBhbiBhbmdsZSBleHByZXNzZWQgaW4gZGVncmVlcyBpbiB0aGUgcmFuZ2UgXS0zNjAsIDM2MFtcbmZ1bmN0aW9uIHNhbml0aXplQW5nbGVEZWdyZWVzKHY6IG51bWJlcik6IG51bWJlciB7XG4gICAgLy8gaW4gdGhlIGNhc2UgdiBpcyBJbmZpbml0eSBvciBOYW4sICBsZXQncyBzcGVjaWFsIGNhc2VcbiAgICBpZiAoaXNOYU4odikgfHwgdiA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmICh2ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIC0wO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGJyaW5nIHRoZSB2YWx1ZSBpbiB0aGUgcmFuZ2UgXS0zNjAsIDM2MFtcbiAgICAgICAgLy8gaWYgdiBpcyA8IDAgdGhlbiBpdCB3aWxsIGN5Y2xlIGluIF0tMzYwLCAwXVxuICAgICAgICAvLyBpZiB2IGlzID4gMCB0aGVuIGl0IHdpbGwgY3ljbGUgaW4gWzAsIDM2MFtcbiAgICAgICAgcmV0dXJuIHYgJSAzNjA7XG4gICAgfVxufVxuXG4vKipcbiAqIEluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MgZGVmaW5lIGFuIG9yaWVudGF0aW9uIGluIDNEIHNwYWNlIHJlcHJlc2VudGVkIGJ5IGV1bGVyIGFuZ2xlcy5cbiAqIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIHF1YXRlcm5pb24gcmVwcmVzZW50YXRpb24gZm9yIG9yaWVudGF0aW9uIHdoZW4gdXBkYXRpbmcgdGhlIGNsaWVudFxuICogb3Igd2hlbiByZWNlaXZpbmcgdGhlIHVwZGF0ZXMgYWJvdXQgdGhlIG90aGVyIGNsaWVudHMgaW4gdGhlIHNwYWNlLlxuICovXG5leHBvcnQgY2xhc3MgT3JpZW50YXRpb25FdWxlcjNEIHtcbiAgICAvKipcbiAgICAgKiBDb25zaWRlciBhbiBhaXJjcmFmdDogXCJQaXRjaFwiIGlzIGRlZmluZWQgYXMgXCJub3NlIHVwL2Rvd24gYWJvdXQgdGhlIGF4aXMgcnVubmluZyBmcm9tIHdpbmcgdG8gd2luZ1wiLlxuICAgICAqICoqTmVnYXRpdmUgcGl0Y2gqKiBtZWFucyB0aGF0IHRoZSBhaXJjcmFmdCBtb3ZlcyBpdHMgbm9zZSAqKmNsb3NlciB0byB0aGUgZ3JvdW5kKiouXG4gICAgICogKipQb3NpdGl2ZSBwaXRjaCoqIG1lYW5zIHRoYXQgdGhlIGFpcmNyYWZ0IG1vdmVzIGl0cyBub3NlICoqYXdheSBmcm9tIHRoZSBncm91bmQqKi5cbiAgICAgKiBVbml0cyBoZXJlIGFyZSBkZWdyZWVzLlxuICAgICAqL1xuICAgIHBpdGNoRGVncmVlczogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENvbnNpZGVyIGFuIGFpcmNyYWZ0OiBcIllhd1wiIGlzIGRlZmluZWQgYXMgXCJub3NlIGxlZnQvcmlnaHQgYWJvdXQgdGhlIGF4aXMgcnVubmluZyB1cCBhbmQgZG93blwiLlxuICAgICAqICoqTmVnYXRpdmUgeWF3KiogbWVhbnMgdGhhdCB0aGUgYWlyY3JhZnQgd2lsbCByb3RhdGUgKipjbG9ja3dpc2UqKiB3aGVuIHZpZXdpbmcgdGhlIGFpcmNyYWZ0IGZyb20gYWJvdmUuXG4gICAgICogKipQb3NpdGl2ZSB5YXcqKiBtZWFucyB0aGF0IHRoZSBhaXJjcmFmdCB3aWxsIHJvdGF0ZSAqKmNvdW50ZXItY2xvY2t3aXNlKiogd2hlbiB2aWV3aW5nIHRoZSBhaXJjcmFmdCBmcm9tIGFib3ZlLlxuICAgICAqIFVuaXRzIGhlcmUgYXJlIGRlZ3JlZXMuXG4gICAgICovXG4gICAgeWF3RGVncmVlczogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENvbnNpZGVyIGFuIGFpcmNyYWZ0OiBcIlJvbGxcIiBpcyBkZWZpbmVkIGFzIFwicm90YXRpb24gYWJvdXQgdGhlIGF4aXMgcnVubmluZyBmcm9tIG5vc2UgdG8gdGFpbFwiLlxuICAgICAqICoqUG9zaXRpdmUgcm9sbCoqIG1lYW5zIHRoYXQgdGhlIGFpcmNyYWZ0J3MgKipyaWdodCB3aW5nIHdpbGwgbW92ZSBjbG9zZXIgdG8gdGhlIGdyb3VuZCoqLlxuICAgICAqICoqTmVnYXRpdmUgcm9sbCoqIG1lYW5zIHRoYXQgdGhlIGFpcmNyYWZ0J3MgKipsZWZ0IHdpbmcgd2lsbCBtb3ZlIGNsb3NlciB0byB0aGUgZ3JvdW5kKiouXG4gICAgICogVW5pdHMgaGVyZSBhcmUgZGVncmVlcy5cbiAgICAgKi9cbiAgICByb2xsRGVncmVlczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGBPcmllbnRhdGlvbkV1bGVyM0RgIG9iamVjdC4gQWxsIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLiBVbnNldCBwYXJhbWV0ZXJzIHdpbGwgYmUgc2V0IHRvIGAwYC4gUmVtZW1iZXIsIGFsbCB1bml0cyBmb3IgbWVtYmVyIHZhcmlhYmxlcyBhcmUgYGRlZ3JlZXNgLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgcGl0Y2hEZWdyZWVzID0gMCwgeWF3RGVncmVlcyA9IDAsIHJvbGxEZWdyZWVzID0gMCB9OiB7IHBpdGNoRGVncmVlcz86IG51bWJlciwgeWF3RGVncmVlcz86IG51bWJlciwgcm9sbERlZ3JlZXM/OiBudW1iZXIgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMucGl0Y2hEZWdyZWVzID0gc2FuaXRpemVBbmdsZURlZ3JlZXMocGl0Y2hEZWdyZWVzKTtcbiAgICAgICAgdGhpcy55YXdEZWdyZWVzID0gc2FuaXRpemVBbmdsZURlZ3JlZXMoeWF3RGVncmVlcyk7XG4gICAgICAgIHRoaXMucm9sbERlZ3JlZXMgPSBzYW5pdGl6ZUFuZ2xlRGVncmVlcyhyb2xsRGVncmVlcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFzaWRlIGZyb20gdGhlIDMgYW5nbGVzIFlhdywgUGl0Y2gsIFJvbGwgZGVmaW5pbmcgYW4gb3JpZW50YXRpb24sIGV1bGVyIGFuZ2xlcyByZXF1aXJlcyBcbiAqIHRvIGRlZmluZSB0aGUgb3JkZXIgaW4gd2l0Y2ggdGhlIGluZGl2aWR1YWwgeWF3LCBwaXRjaCByb2xsIHJvdGF0aW9ucyBhcmUgY29tYmluZWQuXG4gKiBUaGVyZSBhcmUgNiBvcmRlcnMgcG9zc2libGUgaWRlbnRpZmllZCBieSB0aGUgSGlGaUV1bGVyT3JkZXIgZW51bS5cbiAqIFxuICogIEZvciBleGFtcGxlLCB0aGUgb3JkZXIgWWF3UGl0Y2hSb2xsIGlzIGRlc2NyaWJpbmcgdGhlIGZvbGxvd2luZyBzZXF1ZW5jZVxuICogIHN0YXJ0aW5nIGZyb20gdGhlIGJhc2UgM2QgZnJhbWUsXG4gKiAgMS8gWWF3LCByb3RhdGluZyBhcm91bmQgdGhlIHZlcnRpY2FsIGF4aXNcbiAqICAyLyBQaXRjaCwgcm90YXRpbmcgYXJvdW5kIHRoZSByaWdodCBheGlzIFxuICogIDMvIFJvbGwsIHJvdGF0aW5nIGFyb3VuZCB0aGUgZnJvbnQgYXhpc1xuICogIHRoZSByZXN1bHRpbmcgM2QgZnJhbWUgb3JpZW50YXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIGJhc2UgZnJhbWUuXG4gKi9cbmV4cG9ydCBlbnVtIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyIHtcbiAgICBQaXRjaFlhd1JvbGwgPSBcIlBpdGNoWWF3Um9sbFwiLFxuICAgIFlhd1BpdGNoUm9sbCA9IFwiWWF3UGl0Y2hSb2xsXCIsXG4gICAgUm9sbFBpdGNoWWF3ID0gXCJSb2xsUGl0Y2hZYXdcIixcbiAgICBSb2xsWWF3UGl0Y2ggPSBcIlJvbGxZYXdQaXRjaFwiLFxuICAgIFlhd1JvbGxQaXRjaCA9IFwiWWF3Um9sbFBpdGNoXCIsXG4gICAgUGl0Y2hSb2xsWWF3ID0gXCJQaXRjaFJvbGxZYXdcIixcbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBvcmllbnRhdGlvbiBxdWF0ZXJuaW9uIGZyb20gdGhlIHNwZWNpZmllZCBldWxlciBhbmdsZXMuXG4gKiBUaGUgcmVzdWx0aW5nIHF1YXRlcm5pb24gaXMgdGhlIHJvdGF0aW9uIHRyYW5zZm9ybWluZyBmcm9tIGNvbWJpbmluZyB0aGUgZXVsZXIgYW5nbGVzIHJvdGF0aW9ucyBpbiB0aGUgc3BlY2lmaWVkIG9yZGVyXG4gKiBcbiAqIEZvciBleGFtcGxlLCB0aGUgb3JkZXIgWWF3UGl0Y2hSb2xsIGlzIGNvbXB1dGVkIGFzIGZvbGxvdzpcbiAqICBzdGFydGluZyBmcm9tIHRoZSBiYXNlIDNkIGZyYW1lLFxuICogIDEvIFlhdywgcm90YXRpbmcgYXJvdW5kIHRoZSB2ZXJ0aWNhbCBheGlzXG4gKiAgMi8gUGl0Y2gsIHJvdGF0aW5nIGFyb3VuZCB0aGUgcmlnaHQgYXhpcyBcbiAqICAzLyBSb2xsLCByb3RhdGluZyBhcm91bmQgdGhlIGZyb250IGF4aXNcbiAqICB0aGUgcmVzdWx0aW5nIDNkIGZyYW1lIG9yaWVudGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBiYXNlIGZyYW1lLlxuICogIFRoZSByZXN1bHRpbmcgcm90YXRpb24gaXMgZGVmaW5pbmcgdGhlICdyb3RhdGVkJyBzcGFjZSByZWxhdGl2ZSB0byB0aGUgJ2Jhc2UnIHNwYWNlLlxuICogIEEgdmVjdG9yIFZyIGluIFwicm90YXRlZCcgc3BhY2UgYW5kIGl0cyBlcXVpdmFsZW50IHZhbHVlIFZiIGluIHRoZSdiYXNlJyBzcGFjZSBpcyBjb21wdXRlZCBhcyBmb2xsb3c6XG4gKiAgVmIgPSBbUF1bWV1bUl0gVnJcbiAqIFxuICogQHBhcmFtIGV1bGVyIC0gVGhlIGV1bGVyIGFuZ2xlcy5cbiAqIEBwYXJhbSBvcmRlciAtIFRoZSBldWxlciBvcmRlciBjb252ZW50aW9uLlxuICogXG4gKiBAcmV0dXJuIFRoZSBlbmQgcmVzdWx0aW5nIHF1YXRlcm5pb24gZGVmaW5lZCBmcm9tIHRoZSBldWxlciBhbmdsZXMgY29tYmluYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV1bGVyVG9RdWF0ZXJuaW9uKGV1bGVyOiBPcmllbnRhdGlvbkV1bGVyM0QsIG9yZGVyOiBPcmllbnRhdGlvbkV1bGVyM0RPcmRlcik6IE9yaWVudGF0aW9uUXVhdDNEIHtcbiAgICAvLyBjb21wdXRlIHRoZSBpbmRpdmlkdWFsIGV1bGVyIGFuZ2xlIHJvdGF0aW9uIHF1YXRlcm5pb24gdGVybXMgc2luKGFuZ2xlLzIpIGFuZCBjb3MoYWFuZ2xlLzIpXG4gICAgY29uc3QgSEFMRl9ERUdfVE9fUkFEID0gMC41ICogTWF0aC5QSSAvIDE4MC4wO1xuICAgIGxldCBjb3MgPSB7IFA6IE1hdGguY29zKGV1bGVyLnBpdGNoRGVncmVlcyAqIEhBTEZfREVHX1RPX1JBRCksIFk6IE1hdGguY29zKGV1bGVyLnlhd0RlZ3JlZXMgKiBIQUxGX0RFR19UT19SQUQpLCBSOiBNYXRoLmNvcyhldWxlci5yb2xsRGVncmVlcyAqIEhBTEZfREVHX1RPX1JBRCl9O1xuICAgIGxldCBzaW4gPSB7IFA6IE1hdGguc2luKGV1bGVyLnBpdGNoRGVncmVlcyAqIEhBTEZfREVHX1RPX1JBRCksIFk6IE1hdGguc2luKGV1bGVyLnlhd0RlZ3JlZXMgKiBIQUxGX0RFR19UT19SQUQpLCBSOiBNYXRoLnNpbihldWxlci5yb2xsRGVncmVlcyAqIEhBTEZfREVHX1RPX1JBRCl9O1xuXG4gICAgLy8gdGhlIGNvbXB1dGVkIHF1YXRlcm5pb24gY29tcG9uZW50cyBmb3IgdGhlIDYgb3JkZXJzIGFyZSBiYXNlZCBvbiB0aGUgc2FtZSBwYXR0ZXJuXG4gICAgLy8gcS54ID0gYXggKy8tIGJ4IFxuICAgIC8vIHEueSA9IGF5ICsvLSBieSBcbiAgICAvLyBxLnogPSBheiArLy0gYnogXG4gICAgLy8gcS53ID0gYXcgKy8tIGJ3IFxuXG4gICAgbGV0IGF4ID0gc2luLlAgKiBjb3MuWSAqIGNvcy5SO1xuICAgIGxldCBheSA9IGNvcy5QICogc2luLlkgKiBjb3MuUjtcbiAgICBsZXQgYXogPSBjb3MuUCAqIGNvcy5ZICogc2luLlI7XG4gICAgbGV0IGF3ID0gY29zLlAgKiBjb3MuWSAqIGNvcy5SO1xuXG4gICAgbGV0IGJ4ID0gY29zLlAgKiBzaW4uWSAqIHNpbi5SO1xuICAgIGxldCBieSA9IHNpbi5QICogY29zLlkgKiBzaW4uUjtcbiAgICBsZXQgYnogPSBzaW4uUCAqIHNpbi5ZICogY29zLlI7XG4gICAgbGV0IGJ3ID0gc2luLlAgKiBzaW4uWSAqIHNpbi5SO1xuXG4gICAgc3dpdGNoIChvcmRlcikge1xuICAgIC8vIGZyb20gJ2Jhc2UnIHNwYWNlIHJvdGF0ZSBQaXRjaCwgdGhlbiBZYXcgdGhlbiBSb2xsXG4gICAgLy8gUmVzdWx0aW5nIHJvdGF0aW9uIGlzIGRlZmluaW5nIHRoZSAncm90YXRlZCcgc3BhY2UgcmVsYXRpdmUgdG8gdGhlICdiYXNlJyBzcGFjZS5cbiAgICAvLyBBIHZlY3RvciBWciBpbiBcInJvdGF0ZWQnIHNwYWNlIGFuZCBpdHMgZXF1aXZhbGVudCB2YWx1ZSBWYiBpbiB0aGUnYmFzZScgc3BhY2UgaXMgY29tcHV0ZWQgYXMgZm9sbG93OlxuICAgIC8vIFZiID0gW1BdW1ldW1JdIFZyXG4gICAgY2FzZSBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5QaXRjaFlhd1JvbGw6IHtcbiAgICAgICAgcmV0dXJuIG5ldyBPcmllbnRhdGlvblF1YXQzRCh7XG4gICAgICAgICAgICAgICAgeDogYXggKyBieCxcbiAgICAgICAgICAgICAgICB5OiBheSAtIGJ5LFxuICAgICAgICAgICAgICAgIHo6IGF6ICsgYnosXG4gICAgICAgICAgICAgICAgdzogYXcgLSBidyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgLy8gRnJvbSAnYmFzZScgc3BhY2Ugcm90YXRlIFlhdywgdGhlbiBQaXRjaCB0aGVuIFJvbGwuLi5cbiAgICBjYXNlIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLllhd1BpdGNoUm9sbDoge1xuICAgICAgICByZXR1cm4gbmV3IE9yaWVudGF0aW9uUXVhdDNEKHtcbiAgICAgICAgICAgICAgICB4OiBheCArIGJ4LFxuICAgICAgICAgICAgICAgIHk6IGF5IC0gYnksXG4gICAgICAgICAgICAgICAgejogYXogLSBieixcbiAgICAgICAgICAgICAgICB3OiBhdyArIGJ3LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gYnJlYWs7XG4gXG4gICAgLy8gRnJvbSAnYmFzZScgc3BhY2Ugcm90YXRlIFJvbGwsIHRoZW4gUGl0Y2ggdGhlbiBZYXcuLi5cbiAgICBjYXNlIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLlJvbGxQaXRjaFlhdzoge1xuICAgICAgICByZXR1cm4gbmV3IE9yaWVudGF0aW9uUXVhdDNEKHtcbiAgICAgICAgICAgICAgICB4OiBheCAtIGJ4LFxuICAgICAgICAgICAgICAgIHk6IGF5ICsgYnksXG4gICAgICAgICAgICAgICAgejogYXogKyBieixcbiAgICAgICAgICAgICAgICB3OiBhdyAtIGJ3LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gYnJlYWs7XG4gXG4gICAgLy8gRnJvbSAnYmFzZScgc3BhY2Ugcm90YXRlIFJvbGwsIHRoZW4gWWF3IHRoZW4gUGl0Y2guLi5cbiAgICBjYXNlIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLlJvbGxZYXdQaXRjaDoge1xuICAgICAgICByZXR1cm4gbmV3IE9yaWVudGF0aW9uUXVhdDNEKHtcbiAgICAgICAgICAgICAgICB4OiBheCAtIGJ4LFxuICAgICAgICAgICAgICAgIHk6IGF5ICsgYnksXG4gICAgICAgICAgICAgICAgejogYXogLSBieixcbiAgICAgICAgICAgICAgICB3OiBhdyArIGJ3LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gYnJlYWs7XG4gIFxuICAgIC8vIEZyb20gJ2Jhc2UnIHNwYWNlIHJvdGF0ZSBZYXcsIHRoZW4gUm9sbCB0aGVuIFBpdGNoLi4uXG4gICAgY2FzZSBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5ZYXdSb2xsUGl0Y2g6IHtcbiAgICAgICAgcmV0dXJuIG5ldyBPcmllbnRhdGlvblF1YXQzRCh7XG4gICAgICAgICAgICAgICAgeDogYXggKyBieCxcbiAgICAgICAgICAgICAgICB5OiBheSArIGJ5LFxuICAgICAgICAgICAgICAgIHo6IGF6IC0gYnosXG4gICAgICAgICAgICAgICAgdzogYXcgLSBidyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGJyZWFrO1xuICBcbiAgICAvLyBGcm9tICdiYXNlJyBzcGFjZSByb3RhdGUgUGl0Y2gsIHRoZW4gUm9sbCB0aGVuIFlhdy4uLlxuICAgIGNhc2UgT3JpZW50YXRpb25FdWxlcjNET3JkZXIuUGl0Y2hSb2xsWWF3OiB7XG4gICAgICAgIHJldHVybiBuZXcgT3JpZW50YXRpb25RdWF0M0Qoe1xuICAgICAgICAgICAgICAgIHg6IGF4IC0gYngsXG4gICAgICAgICAgICAgICAgeTogYXkgLSBieSxcbiAgICAgICAgICAgICAgICB6OiBheiArIGJ6LFxuICAgICAgICAgICAgICAgIHc6IGF3ICsgYncsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBicmVhaztcbiAgICB9ICAgIFxufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIG9yaWVudGF0aW9uIGV1bGVyIGRlY29tcG9zaXRpb24gZnJvbSB0aGUgc3BlY2lmaWVkIHF1YXRlcm5pb24uXG4gKiBUaGUgcmVzdWx0aW5nIGV1bGVyIGlzIHRoZSByb3RhdGlvbiB0cmFuc2Zvcm1pbmcgZnJvbSBjb21iaW5pbmcgdGhlIGV1bGVyIGFuZ2xlcyByb3RhdGlvbnMgaW4gdGhlIHNwZWNpZmllZCBvcmRlclxuICogXG4gKiBGb3IgZXhhbXBsZSwgdGhlIG9yZGVyIFlhd1BpdGNoUm9sbCBpcyBjb21wdXRlZCBhcyBmb2xsb3c6XG4gKiAgc3RhcnRpbmcgZnJvbSB0aGUgYmFzZSAzZCBmcmFtZSxcbiAqICAxLyBZYXcsIHJvdGF0aW5nIGFyb3VuZCB0aGUgdmVydGljYWwgYXhpc1xuICogIDIvIFBpdGNoLCByb3RhdGluZyBhcm91bmQgdGhlIHJpZ2h0IGF4aXMgXG4gKiAgMy8gUm9sbCwgcm90YXRpbmcgYXJvdW5kIHRoZSBmcm9udCBheGlzXG4gKiAgdGhlIHJlc3VsdGluZyAzZCBmcmFtZSBvcmllbnRhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgYmFzZSBmcmFtZS5cbiAqICBUaGUgcmVzdWx0aW5nIHJvdGF0aW9uIGlzIGRlZmluaW5nIHRoZSAncm90YXRlZCcgc3BhY2UgcmVsYXRpdmUgdG8gdGhlICdiYXNlJyBzcGFjZS5cbiAqICBBIHZlY3RvciBWciBpbiBcInJvdGF0ZWQnIHNwYWNlIGFuZCBpdHMgZXF1aXZhbGVudCB2YWx1ZSBWYiBpbiB0aGUnYmFzZScgc3BhY2UgaXMgY29tcHV0ZWQgYXMgZm9sbG93OlxuICogIFZiID0gW1BdW1ldW1JdIFZyXG4gKiBcbiAqIEBwYXJhbSBxdWF0IC0gVGhlIG9yaWVudGF0aW9uIHF1YXRlcm5pb24uXG4gKiBAcGFyYW0gb3JkZXIgLSBUaGUgZXVsZXIgb3JkZXIgY29udmVudGlvbi5cbiAqIFxuICogQHJldHVybiBUaGUgZW5kIHJlc3VsdGluZyBxdWF0ZXJuaW9uIGRlZmluZWQgZnJvbSB0aGUgZXVsZXIgYW5nbGVzIGNvbWJpbmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldWxlckZyb21RdWF0ZXJuaW9uKHF1YXQ6IE9yaWVudGF0aW9uUXVhdDNELCBvcmRlcjogT3JpZW50YXRpb25FdWxlcjNET3JkZXIpOiBPcmllbnRhdGlvbkV1bGVyM0Qge1xuICAgIC8vIFdlIG5lZWQgdG8gY29udmVydCB0aGUgcXVhdGVybmlvbiB0byB0aGUgZXF1aXZhbGVudCBtYXQzeDNcbiAgICBsZXQgcXgyID0gcXVhdC54ICogcXVhdC54O1xuICAgIGxldCBxeTIgPSBxdWF0LnkgKiBxdWF0Lnk7XG4gICAgbGV0IHF6MiA9IHF1YXQueiAqIHF1YXQuejtcbiAgICAvLyBsZXQgcXcyID0gcXVhdC53ICogcXVhdC53OyB3ZSBjb3VsZCBjaG9vc2UgdG8gdXNlIGl0IGluc3RlYWQgb2YgdGhlIDEgLSAyKiB0ZXJtLi4uXG4gICAgbGV0IHF3eCA9IHF1YXQudyAqIHF1YXQueDtcbiAgICBsZXQgcXd5ID0gcXVhdC53ICogcXVhdC55O1xuICAgIGxldCBxd3ogPSBxdWF0LncgKiBxdWF0Lno7XG4gICAgbGV0IHF4eSA9IHF1YXQueCAqIHF1YXQueTtcbiAgICBsZXQgcXl6ID0gcXVhdC55ICogcXVhdC56O1xuICAgIGxldCBxeHogPSBxdWF0LnogKiBxdWF0Lng7XG4gICAgLy8gUk9UIE1hdDMzID0gIHsgIDEgLSAycXkyIC0gMnF6MiAgfCAgMihxeHkgLSBxd3opICAgIHwgIDIocXh6ICsgcXd5KSAgfVxuICAgIC8vICAgICAgICAgICAgICB7ICAyKHF4eSArIHF3eikgICAgIHwgIDEgLSAycXgyIC0gMnF6MiB8ICAyKHF5eiAtIHF3eCkgIH1cbiAgICAvLyAgICAgICAgICAgICAgeyAgMihxeHogLSBxd3kpICAgICB8ICAyKHF5eiArIHF3eCkgICAgfCAgMSAtIDJxeDIgLSAycXkyICB9XG4gICAgbGV0IHIwMCA9IDEuMCAtIDIuMCAqIChxeTIgKyBxejIpO1xuICAgIGxldCByMTAgPSAyLjAgKiAocXh5ICsgcXd6KTtcbiAgICBsZXQgcjIwID0gMi4wICogKHF4eiAtIHF3eSk7XG5cbiAgICBsZXQgcjAxID0gMi4wICogKHF4eSAtIHF3eik7XG4gICAgbGV0IHIxMSA9IDEuMCAtIDIuMCAqIChxeDIgKyBxejIpOyBcbiAgICBsZXQgcjIxID0gMi4wICogKHF5eiArIHF3eCk7XG4gICBcbiAgICBsZXQgcjAyID0gMi4wICogKHF4eiArIHF3eSk7XG4gICAgbGV0IHIxMiA9IDIuMCAqIChxeXogLSBxd3gpO1xuICAgIGxldCByMjIgPSAxLjAgLSAyLjAgKiAocXgyICsgcXkyKTsgXG5cbiAgICAvLyB0aGVuIGRlcGVuZGluZyBvbiB0aGUgZXVsZXIgcm90YXRpb24gb3JkZXIgZGVjb21wb3NpdGlvbiwgd2UgZXh0cmFjdCB0aGUgYW5nbGVzIFxuICAgIC8vIGZyb20gdGhlIGJhc2UgdmVjdG9yIGNvbXBvbmVudHNcbiAgICBsZXQgcGl0Y2ggPSAwO1xuICAgIGxldCB5YXcgPSAwO1xuICAgIGxldCByb2xsID0gMDtcbiAgICBjb25zdCBPTkVfTUlOVVNfRVBTSUxPTiA9IDAuOTk5OTk5OTtcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5QaXRjaFlhd1JvbGw6IHtcbiAgICAgICAgeWF3ID0gTWF0aC5hc2luKCBIaUZpVXRpbGl0aWVzLmNsYW1wTm9ybWFsaXplZChyMDIpICk7XG4gICAgICAgIGlmICggTWF0aC5hYnMoIHIwMiApIDwgT05FX01JTlVTX0VQU0lMT04gKSB7XG4gICAgICAgICAgICBwaXRjaCA9IE1hdGguYXRhbjIoIC1yMTIsIHIyMik7XG4gICAgICAgICAgICByb2xsID0gTWF0aC5hdGFuMiggLXIwMSwgcjAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpdGNoID0gTWF0aC5hdGFuMihyMjEsIHIxMSk7XG4gICAgICAgIH0gICAgICAgXG4gICAgfSBicmVhaztcbiAgICBjYXNlIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLllhd1BpdGNoUm9sbDoge1xuICAgICAgICBwaXRjaCA9IE1hdGguYXNpbiggSGlGaVV0aWxpdGllcy5jbGFtcE5vcm1hbGl6ZWQoLXIxMikgKTtcbiAgICAgICAgaWYgKCBNYXRoLmFicyggcjEyICkgPCBPTkVfTUlOVVNfRVBTSUxPTiApIHtcbiAgICAgICAgICAgIHlhdyA9IE1hdGguYXRhbjIocjAyLCByMjIpO1xuICAgICAgICAgICAgcm9sbCA9IE1hdGguYXRhbjIocjEwLCByMTEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWF3ID0gTWF0aC5hdGFuMigtcjIwLCByMDApO1xuICAgICAgICB9IFxuICAgIH0gYnJlYWs7XG4gICAgY2FzZSBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5Sb2xsUGl0Y2hZYXc6IHtcbiAgICAgICAgcGl0Y2ggPSBNYXRoLmFzaW4oIEhpRmlVdGlsaXRpZXMuY2xhbXBOb3JtYWxpemVkKHIyMSkgKTtcbiAgICAgICAgaWYgKCBNYXRoLmFicyggcjIxICkgPCBPTkVfTUlOVVNfRVBTSUxPTiApIHtcbiAgICAgICAgICAgIHlhdyA9IE1hdGguYXRhbjIoLXIyMCwgcjIyKTtcbiAgICAgICAgICAgIHJvbGwgPSBNYXRoLmF0YW4yKC1yMDEsIHIxMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb2xsID0gTWF0aC5hdGFuMihyMTAsIHIwMCk7XG4gICAgICAgIH1cbiAgICB9IGJyZWFrO1xuICAgIGNhc2UgT3JpZW50YXRpb25FdWxlcjNET3JkZXIuUm9sbFlhd1BpdGNoOiB7XG4gICAgICAgIHlhdyA9IE1hdGguYXNpbiggSGlGaVV0aWxpdGllcy5jbGFtcE5vcm1hbGl6ZWQoLXIyMCkgKTtcbiAgICAgICAgaWYgKCBNYXRoLmFicyggcjIwICkgPCBPTkVfTUlOVVNfRVBTSUxPTiApIHtcbiAgICAgICAgICAgIHBpdGNoID0gTWF0aC5hdGFuMiggcjIxLCByMjIpO1xuICAgICAgICAgICAgcm9sbCA9IE1hdGguYXRhbjIoIHIxMCwgcjAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvbGwgPSBNYXRoLmF0YW4yKCAtcjAxLCByMTEpO1xuICAgICAgICB9ICBcbiAgICB9IGJyZWFrO1xuICAgIGNhc2UgT3JpZW50YXRpb25FdWxlcjNET3JkZXIuWWF3Um9sbFBpdGNoOiB7XG4gICAgICAgIHJvbGwgPSBNYXRoLmFzaW4oIEhpRmlVdGlsaXRpZXMuY2xhbXBOb3JtYWxpemVkKHIxMCkgKTtcbiAgICAgICAgaWYgKCBNYXRoLmFicyggcjEwICkgPCBPTkVfTUlOVVNfRVBTSUxPTiApIHtcbiAgICAgICAgICAgIHBpdGNoID0gTWF0aC5hdGFuMiggLXIxMiwgcjExKTtcbiAgICAgICAgICAgIHlhdyA9IE1hdGguYXRhbjIoIC1yMjAsIHIwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5YXcgPSBNYXRoLmF0YW4yKCByMDIsIHIyMik7XG4gICAgICAgIH1cbiAgICB9IGJyZWFrO1xuICAgIGNhc2UgT3JpZW50YXRpb25FdWxlcjNET3JkZXIuUGl0Y2hSb2xsWWF3OiB7XG4gICAgICAgIHJvbGwgPSBNYXRoLmFzaW4oIEhpRmlVdGlsaXRpZXMuY2xhbXBOb3JtYWxpemVkKC1yMDEpICk7XG4gICAgICAgIGlmICggTWF0aC5hYnMoIHIwMSApIDwgT05FX01JTlVTX0VQU0lMT04gKSB7XG4gICAgICAgICAgICBwaXRjaCA9IE1hdGguYXRhbjIoIHIyMSwgcjExKTtcbiAgICAgICAgICAgIHlhdyA9IE1hdGguYXRhbjIoIHIwMiwgcjAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlhdyA9IE1hdGguYXRhbjIoIC1yMTIsIHIyMik7XG4gICAgICAgIH1cbiAgICB9IGJyZWFrO1xuICAgIH0gICAgXG4gICAgY29uc3QgUkFEX1RPX0RFRyA9IDE4MC4wIC8gTWF0aC5QSTtcbiAgICByZXR1cm4gbmV3IE9yaWVudGF0aW9uRXVsZXIzRCh7IHBpdGNoRGVncmVlczogUkFEX1RPX0RFRyAqIHBpdGNoLCB5YXdEZWdyZWVzOiBSQURfVE9fREVHICogeWF3LCByb2xsRGVncmVlczogUkFEX1RPX0RFRyAqIHJvbGwgfSk7XG59XG5cbi8qKlxuICogSW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcyBkZWZpbmUgYSBtYXAgYmV0d2VlbiBoYXNoZWQgdmlzaXQgSURzIGFuZCB0aGUgZ2FpbnMgb2Ygb3RoZXIgdXNlcnMuXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGluIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLnNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb259IHRvIGNoYW5nZSB0aGUgZ2FpbnMgb2Ygb3RoZXIgdXNlcnMgYXMgcGVyY2VpdmVkIGJ5IHRoZSBjdXJyZW50IGNvbm5lY3Rpb24sIHByb3ZpZGluZyBhIG1vcmUgY29tZm9ydGFibGUgbGlzdGVuaW5nIGV4cGVyaWVuY2UgZm9yIHRoZSBjbGllbnQuIElmIHlvdSBuZWVkIHRvIHBlcmZvcm0gbW9kZXJhdGlvbiBhY3Rpb25zIG9uIHRoZSBzZXJ2ZXIgc2lkZSwgdXNlIHRoZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmhpZ2hmaWRlbGl0eS5jb20vcmVzdC9sYXRlc3QvaW5kZXguaHRtbHxBZG1pbmlzdHJhdGl2ZSBSRVNUIEFQSX0uXG4gKlxuICogSW50ZXJuYWxseSwgdGhpcyBjbGFzcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb3RoZXIgdXNlciBnYWluIGNoYW5nZXMgbmVlZCB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCB0eXBlIE90aGVyVXNlckdhaW5NYXAgPSB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9O1xuXG4vKipcbiAqIEluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MgY29udGFpbiBhbGwgb2YgdGhlIGRhdGEgdGhhdCBpcyBwb3NzaWJsZSB0byAqKnNlbmQgdG8gQU5EIHJlY2VpdmUgZnJvbSoqIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBTZXJ2ZXIuXG4gKiBBbGwgbWVtYmVyIGRhdGEgaW5zaWRlIHRoaXMgYGNsYXNzYCBjYW4gYmUgc2VudCB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgU2VydmVyLiBTZWUgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAqIFxuICogU2VlIHtAbGluayBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGF9IGZvciBkYXRhIHRoYXQgY2FuJ3QgYmUgc2VudCB0byB0aGUgU2VydmVyLCBidXQgcmF0aGVyIGNhbiBvbmx5IGJlIHJlY2VpdmVkIGZyb20gdGhlIFNlcnZlciAoaS5lLiBgdm9sdW1lRGVjaWJlbHNgKS5cbiAqIFxuICogTWVtYmVyIGRhdGEgb2YgdGhpcyBjbGFzcyB0aGF0IGlzIHNlbnQgdG8gdGhlIFNlcnZlciB3aWxsIGFmZmVjdCB0aGUgZmluYWwgbWl4ZWQgc3BhdGlhbCBhdWRpbyBmb3IgYWxsIGxpc3RlbmVycyBpbiB0aGUgc2VydmVyJ3MgdmlydHVhbCBzcGFjZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEhpRmlBdWRpb0FQSURhdGEge1xuICAgIC8qKlxuICAgICAqIElmIHlvdSBkb24ndCBzdXBwbHkgYSBgcG9zaXRpb25gIHdoZW4gY29uc3RydWN0aW5nIGluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MsIGBwb3NpdGlvbmAgd2lsbCBiZSBgbnVsbGAuXG4gICAgICogXG4gICAgICog4pyUIFRoZSBjbGllbnQgc2VuZHMgYHBvc2l0aW9uYCBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2hlbiBgX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKClgIGlzIGNhbGxlZC5cbiAgICAgKiBcbiAgICAgKiDinJQgVGhlIHNlcnZlciBzZW5kcyBgcG9zaXRpb25gIGRhdGEgdG8gYWxsIGNsaWVudHMgY29ubmVjdGVkIHRvIGEgc2VydmVyIGR1cmluZyBcInBlZXIgdXBkYXRlc1wiLlxuICAgICAqL1xuICAgIHBvc2l0aW9uOiBQb2ludDNEO1xuICAgIC8qKlxuICAgICAqIElmIHlvdSBkb24ndCBzdXBwbHkgYW4gYG9yaWVudGF0aW9uUXVhdGAgd2hlbiBjb25zdHJ1Y3RpbmcgaW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcywgYG9yaWVudGF0aW9uUXVhdGAgd2lsbCBiZSBgbnVsbGAuXG4gICAgICogXG4gICAgICog4pyUIFRoZSBjbGllbnQgc2VuZHMgYG9yaWVudGF0aW9uUXVhdGAgZGF0YSB0byB0aGUgc2VydmVyIHdoZW4gYF90cmFuc21pdEhpRmlBdWRpb0FQSURhdGFUb1NlcnZlcigpYCBpcyBjYWxsZWQuXG4gICAgICogXG4gICAgICog4pyUIFRoZSBzZXJ2ZXIgc2VuZHMgYG9yaWVudGF0aW9uUXVhdGAgZGF0YSB0byBhbGwgY2xpZW50cyBjb25uZWN0ZWQgdG8gYSBzZXJ2ZXIgZHVyaW5nIFwicGVlciB1cGRhdGVzXCIuXG4gICAgICovXG4gICAgb3JpZW50YXRpb25RdWF0OiBPcmllbnRhdGlvblF1YXQzRDtcbiAgICAvKipcbiAgICAgKiBGb3IgY29udmVuaWVuY2UsIGEgRXVsZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9yaWVudGF0aW9uIGlzIHN1cHBvcnRlZC5cbiAgICAgKiBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHdheSB0byBzcGVjaWZ5IHRoZSBgb3JpZW50YXRpb25RdWF0YCBmaWVsZCBpbiB0aGUgYEhpRmlBdWRpb0FQSURhdGFgIHRoYXQgaXMgc2VudCB0byBvciByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogXG4gICAgICogIOKclCBXaGVuIHVzaW5nIGV1bGVyIHJlcHJlc2VudGF0aW9uIHRvIHVwZGF0ZSB0aGUgY2xpZW50IG9yaWVudGF0aW9uLCB0aGUgZXF1aXZhbGVudCBRdWF0ZXJuaW9uIGlzIGV2YWx1YXRlZCBpbiBgX3VwZGF0ZVVzZXJEYXRhKClgXG4gICAgICogXG4gICAgICogIOKclCBXaGVuIHJlcXVlc3Rpbmcgb3JpZW50YXRpb24gRXVsZXIgZnJvbSBzZXJ2ZXIgdXBkYXRlcywgdGhlIEV1bGVyIHJlcHJlc2VudGF0aW9uIGlzIGV2YWx1YXRlZCBpbiBgX2hhbmRsZVVzZXJEYXRhVXBkYXRlcygpYFxuICAgICAqL1xuICAgIG9yaWVudGF0aW9uRXVsZXI6IE9yaWVudGF0aW9uRXVsZXIzRDtcbiAgICAvKipcbiAgICAgKiBBIHZvbHVtZSBsZXZlbCBiZWxvdyB0aGlzIHZhbHVlIGlzIGNvbnNpZGVyZWQgYmFja2dyb3VuZCBub2lzZSBhbmQgd2lsbCBiZSBzbW9vdGhseSBnYXRlZCBvZmYuXG4gICAgICogVGhlIGZsb2F0aW5nIHBvaW50IHZhbHVlIGlzIHNwZWNpZmllZCBpbiBkQkZTIChkZWNpYmVscyByZWxhdGl2ZSB0byBmdWxsIHNjYWxlKSB3aXRoIHZhbHVlcyBiZXR3ZWVuIC05NiBkQiAoaW5kaWNhdGluZyBubyBnYXRpbmcpXG4gICAgICogYW5kIDAgZEIgKGVmZmVjdGl2ZWx5IG11dGluZyB0aGUgaW5wdXQgZnJvbSB0aGlzIHVzZXIpLiBJdCBpcyBpbiB0aGUgc2FtZSBkZWNpYmVsIHVuaXRzIGFzIHRoZSBWb2x1bWVEZWNpYmVscyBjb21wb25lbnQgb2YgVXNlckRhdGFTdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgdm9sdW1lVGhyZXNob2xkOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBhZmZlY3RzIGhvdyBsb3VkIFVzZXIgQSB3aWxsIHNvdW5kIHRvIFVzZXIgQiBhdCBhIGdpdmVuIGRpc3RhbmNlIGluIDNEIHNwYWNlLlxuICAgICAqIFRoaXMgdmFsdWUgYWxzbyBhZmZlY3RzIHRoZSBkaXN0YW5jZSBhdCB3aGljaCBVc2VyIEEgY2FuIGJlIGhlYXJkIGluIDNEIHNwYWNlLlxuICAgICAqIEhpZ2hlciB2YWx1ZXMgZm9yIFVzZXIgQSBtZWFucyB0aGF0IFVzZXIgQSB3aWxsIHNvdW5kIGxvdWRlciB0byBvdGhlciB1c2VycyBhcm91bmQgVXNlciBBLCBhbmQgaXQgYWxzbyBtZWFucyB0aGF0IFVzZXIgQSB3aWxsIGJlIGF1ZGlibGUgZnJvbSBhIGdyZWF0ZXIgZGlzdGFuY2UuXG4gICAgICogSWYgeW91IGRvbid0IHN1cHBseSBhbiBgaGlGaUdhaW5gIHdoZW4gY29uc3RydWN0aW5nIGluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MsIGBoaUZpR2FpbmAgd2lsbCBiZSBgbnVsbGAuXG4gICAgICogXG4gICAgICog4pyUIFRoZSBjbGllbnQgc2VuZHMgYGhpRmlHYWluYCBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2hlbiBgX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKClgIGlzIGNhbGxlZC5cbiAgICAgKiBcbiAgICAgKiDinYwgVGhlIHNlcnZlciBkb2VzIG5vdCBzZW5kIGBoaUZpR2FpbmAgZGF0YSB0byBhbGwgY2xpZW50cyBhcyBwYXJ0IG9mIFwicGVlciB1cGRhdGVzXCIuXG4gICAgICovXG4gICAgaGlGaUdhaW46IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGlzIHZhbHVlIGFmZmVjdHMgaG93IGZhciBhIHVzZXIncyBzb3VuZCB3aWxsIHRyYXZlbCBpbiAzRCBzcGFjZSwgd2l0aG91dCBhZmZlY3RpbmcgdGhlIHVzZXIncyBsb3VkbmVzcy5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGVyZSBpcyBhIGdsb2JhbCBhdHRlbnVhdGlvbiB2YWx1ZSAoc2V0IGZvciBhIGdpdmVuIHNwYWNlKSB0aGF0IGFwcGxpZXMgdG8gYWxsIHVzZXJzIGluIGEgc3BhY2UuIFRoaXMgZGVmYXVsdCBzcGFjZVxuICAgICAqIGF0dGVudWF0aW9uIGlzIHVzdWFsbHkgMC41LCB3aGljaCByZXByZXNlbnRzIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uIG9mIGEgcmVhbC13b3JsZCBmYWxsLW9mZiBpbiBzb3VuZCBvdmVyIGRpc3RhbmNlLlxuICAgICAqIExvd2VyIG51bWJlcnMgcmVwcmVzZW50IGxlc3MgYXR0ZW51YXRpb24gKGkuZS4gc291bmQgdHJhdmVscyBmYXJ0aGVyKTsgaGlnaGVyIG51bWJlcnMgcmVwcmVzZW50IG1vcmUgYXR0ZW51YXRpb24gKGkuZS4gc291bmQgZHJvcHNcbiAgICAgKiBvZmYgbW9yZSBxdWlja2x5KS5cbiAgICAgKiBcbiAgICAgKiBXaGVuIHNldHRpbmcgdGhpcyB2YWx1ZSBmb3IgYW4gaW5kaXZpZHVhbCB1c2VyLCB0aGUgZm9sbG93aW5nIGhvbGRzOlxuICAgICAqICAgLSBQb3NpdGl2ZSBudW1iZXJzIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGFuZCB0aGV5IHJlcHJlc2VudCBhIGxvZ2FyaXRobWljIGF0dGVudWF0aW9uLiBUaGlzIHJhbmdlIGlzIHJlY29tbWVuZGVkLCBhcyBpdCBpc1xuICAgICAqIG1vcmUgbmF0dXJhbCBzb3VuZGluZy4gIFNtYWxsZXIgbnVtYmVycyByZXByZXNlbnQgbGVzcyBhdHRlbnVhdGlvbiwgc28gYSBudW1iZXIgc3VjaCBhcyAwLjIgY2FuIGJlIHVzZWQgdG8gbWFrZSBhIHBhcnRpY3VsYXIgXG4gICAgICogdXNlcidzIGF1ZGlvIHRyYXZlbCBmYXJ0aGVyIHRoYW4gb3RoZXIgdXNlcnMnLCBmb3IgaW5zdGFuY2UgaW4gXCJhbXBsaWZpZWRcIiBjb25jZXJ0IHR5cGUgc2V0dGluZ3MuIFNpbWlsYXJseSwgYW4gZXh0cmVtZWx5IFxuICAgICAqIHNtYWxsIG5vbi16ZXJvIG51bWJlciAoZS5nLiAwLjAwMDAxKSBjYW4gYmUgdXNlZCB0byBlZmZlY3RpdmVseSB0dXJuIG9mZiBhdHRlbnVhdGlvbiBmb3IgYSBnaXZlbiB1c2VyIHdpdGhpbiBhIHJlYXNvbmFibHkgXG4gICAgICogc2l6ZWQgc3BhY2UsIHJlc3VsdGluZyBpbiBhIFwiYnJvYWRjYXN0IG1vZGVcIiB3aGVyZSB0aGUgdXNlciBjYW4gYmUgaGVhcmQgdGhyb3VnaG91dCBtb3N0IG9mIHRoZSBzcGFjZSByZWdhcmRsZXNzIG9mIHRoZWlyIGxvY2F0aW9uXG4gICAgICogcmVsYXRpdmUgdG8gb3RoZXIgdXNlcnMuIChOb3RlOiBUaGUgYWN0dWFsIHZhbHVlIFwiMFwiIGlzIHVzZWQgaW50ZXJuYWxseSB0byByZXByZXNlbnQgdGhlIGRlZmF1bHQ7IGZvciBzZXR0aW5nIG1pbmltYWwgYXR0ZW51YXRpb24sIFxuICAgICAqIHNtYWxsIG5vbi16ZXJvIG51bWJlcnMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC4gU2VlIGFsc28gXCJ1c2VyUm9sbG9mZlwiIGJlbG93LilcbiAgICAgKiAgIC0gTmVnYXRpdmUgYXR0ZW51YXRpb24gbnVtYmVycyBhcmUgdXNlZCB0byByZXByZXNlbnQgbGluZWFyIGF0dGVudWF0aW9uLCBhbmQgYXJlIGEgc29tZXdoYXQgYXJ0aWZpY2lhbCwgbm9uLXJlYWwtd29ybGQgY29uY2VwdC4gSG93ZXZlcixcbiAgICAgKiB0aGlzIHNldHRpbmcgY2FuIGJlIHVzZWQgYXMgYSBibHVudCB0b29sIHRvIGVhc2lseSB0ZXN0IGF0dGVudWF0aW9uLCBhbmQgdHVuZSBpdCBhZ2dyZXNzaXZlbHkgaW4gZXh0cmVtZSBjaXJjdW1zdGFuY2VzLiBXaGVuIHVzaW5nIGxpbmVhciBcbiAgICAgKiBhdHRlbnVhdGlvbiwgdGhlIHNldHRpbmcgaXMgdGhlIGRpc3RhbmNlIGluIG1ldGVycyBhdCB3aGljaCB0aGUgYXVkaW8gYmVjb21lcyB0b3RhbGx5IGluYXVkaWJsZS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBkb24ndCBzdXBwbHkgYW4gYHVzZXJBdHRlbnVhdGlvbmAgd2hlbiBjb25zdHJ1Y3RpbmcgaW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcywgYHVzZXJBdHRlbnVhdGlvbmAgd2lsbCBiZSBgbnVsbGAgYW5kIHRoZVxuICAgICAqIGRlZmF1bHQgd2lsbCBiZSB1c2VkLlxuICAgICAqIFxuICAgICAqIOKclCBUaGUgY2xpZW50IHNlbmRzIGB1c2VyQXR0ZW51YXRpb25gIGRhdGEgdG8gdGhlIHNlcnZlciB3aGVuIGBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIoKWAgaXMgY2FsbGVkLlxuICAgICAqIFxuICAgICAqIOKdjCBUaGUgc2VydmVyIG5ldmVyIHNlbmRzIGB1c2VyQXR0ZW51YXRpb25gIGRhdGEuXG4gICAgICovXG4gICAgdXNlckF0dGVudWF0aW9uOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHVzZXJSb2xsb2ZmIFRoaXMgdmFsdWUgcmVwcmVzZW50cyB0aGUgcHJvZ3Jlc3NpdmUgaGlnaCBmcmVxdWVuY3kgcm9sbC1vZmYgaW4gbWV0ZXJzLCBhIG1lYXN1cmUgb2YgaG93IHRoZSBoaWdoZXIgZnJlcXVlbmNpZXMgXG4gICAgICogaW4gYSB1c2VyJ3Mgc291bmQgYXJlIGRhbXBlbmVkIGFzIHRoZSB1c2VyIGdldHMgZnVydGhlciBhd2F5LiBCeSBkZWZhdWx0LCB0aGVyZSBpcyBhIGdsb2JhbCByb2xsLW9mZiB2YWx1ZSAoc2V0IGZvciBhIGdpdmVuIHNwYWNlKSwgY3VycmVudGx5IDE2IFxuICAgICAqIG1ldGVycywgd2hpY2ggYXBwbGllcyB0byBhbGwgdXNlcnMgaW4gYSBzcGFjZS4gVGhpcyB2YWx1ZSByZXByZXNlbnRzIHRoZSBkaXN0YW5jZSBmb3IgYSAxa0h6IHJvbGxvZmYuIFZhbHVlcyBpbiB0aGUgcmFuZ2Ugb2YgXG4gICAgICogMTIgdG8gMzIgbWV0ZXJzIHByb3ZpZGUgYSBtb3JlIFwiZW5jbG9zZWRcIiBzb3VuZCwgaW4gd2hpY2ggaGlnaCBmcmVxdWVuY2llcyB0ZW5kIHRvIGJlIGRhbXBlbmVkIG92ZXIgZGlzdGFuY2UgYXMgdGhleSBhcmUgXG4gICAgICogaW4gdGhlIHJlYWwgd29ybGQuIEdlbmVyYWxseSBjaGFuZ2VzIHRvIHJvbGwtb2ZmIHZhbHVlcyBzaG91bGQgYmUgbWFkZSBmb3IgdGhlIGVudGlyZSBzcGFjZSByYXRoZXIgdGhhbiBmb3IgaW5kaXZpZHVhbCB1c2VycywgYnV0XG4gICAgICogZXh0cmVtZWx5IGhpZ2ggdmFsdWVzIChlLmcuIDk5OTk5KSBzaG91bGQgYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIFwiYnJvYWRjYXN0IG1vZGVcIi1zdHlsZSB1c2VyQXR0ZW51YXRpb24gc2V0dGluZ3MgdG8gY2F1c2UgdGhlXG4gICAgICogYnJvYWRjYXN0ZWQgdm9pY2UgdG8gc291bmQgY3Jpc3AgYW5kIFwidXAgY2xvc2VcIiBldmVuIGF0IHZlcnkgbGFyZ2UgZGlzdGFuY2VzLlxuICAgICAqXG4gICAgICogSWYgeW91IGRvbid0IHN1cHBseSBhbiBgdXNlclJvbGxvZmZgIHdoZW4gY29uc3RydWN0aW5nIGluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MsIGB1c2VyUm9sbG9mZmAgd2lsbCBiZSBgbnVsbGAuXG4gICAgICogXG4gICAgICog4pyUIFRoZSBjbGllbnQgc2VuZHMgYHVzZXJSb2xsb2ZmYCBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2hlbiBgX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKClgIGlzIGNhbGxlZC5cbiAgICAgKiBcbiAgICAgKiDinYwgVGhlIHNlcnZlciBuZXZlciBzZW5kcyBgdXNlclJvbGxvZmZgIGRhdGEuXG4gICAgICovXG4gICAgdXNlclJvbGxvZmY6IG51bWJlcjtcblxuICAgIC8qXG4gICAgICogVGhpcyBpcyBhbiBpbnRlcm5hbCBjbGFzcyBhbmQgaXQgaXMgbm90IHJlY29tbWVuZGVkIGZvciBub3JtYWwgdXNhZ2Ugb2YgdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIFNlZSBpbnN0ZWFkIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLnNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb259LCB3aGljaCBhbGxvd3MgeW91IHRvIHNldCB0aGUgZGVzaXJlZCBnYWlucyBmb3Igb25lIG9yIG1vcmUgdXNlcnMgYXMgcGVyY2VpdmVkIGJ5IHRoaXMgY2xpZW50IG9ubHkuIElmIHlvdSBuZWVkIHRvIHBlcmZvcm0gbW9kZXJhdGlvbiBhY3Rpb25zIG9uIHRoZSBzZXJ2ZXIgc2lkZSwgdXNlIHRoZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmhpZ2hmaWRlbGl0eS5jb20vcmVzdC9sYXRlc3QvaW5kZXguaHRtbHxBZG1pbmlzdHJhdGl2ZSBSRVNUIEFQSX0uXG4gICAgICpcbiAgICAgKiBJbnRlcm5hbGx5LCB0aGlzIHZhcmlhYmxlIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBvdGhlciB1c2VyIGdhaW4gY2hhbmdlcyBuZWVkIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci4gVGhlIGtleXMgYXJlIGhhc2hlZCB2aXNpdCBJRHMsIGFuZCB0aGUgdmFsdWVzIGFyZSBnYWlucy5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX290aGVyVXNlckdhaW5RdWV1ZTogT3RoZXJVc2VyR2Fpbk1hcDtcbiAgICBcbiAgICBjb25zdHJ1Y3Rvcih7IHBvc2l0aW9uID0gbnVsbCwgb3JpZW50YXRpb25RdWF0ID0gbnVsbCwgb3JpZW50YXRpb25FdWxlciA9IG51bGwsIHZvbHVtZVRocmVzaG9sZCA9IG51bGwsIGhpRmlHYWluID0gbnVsbCwgdXNlckF0dGVudWF0aW9uID0gbnVsbCwgdXNlclJvbGxvZmYgPSBudWxsIH06IHsgcG9zaXRpb24/OiBQb2ludDNELCBvcmllbnRhdGlvblF1YXQ/OiBPcmllbnRhdGlvblF1YXQzRCwgb3JpZW50YXRpb25FdWxlcj86IE9yaWVudGF0aW9uRXVsZXIzRCwgdm9sdW1lVGhyZXNob2xkPzogbnVtYmVyLCBoaUZpR2Fpbj86IG51bWJlciwgdXNlckF0dGVudWF0aW9uPzogbnVtYmVyLCB1c2VyUm9sbG9mZj86IG51bWJlciB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uUXVhdCA9IG9yaWVudGF0aW9uUXVhdDtcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbkV1bGVyID0gb3JpZW50YXRpb25FdWxlcjtcbiAgICAgICAgdGhpcy52b2x1bWVUaHJlc2hvbGQgPSB2b2x1bWVUaHJlc2hvbGQ7XG4gICAgICAgIHRoaXMuaGlGaUdhaW4gPSBoaUZpR2FpbjtcbiAgICAgICAgdGhpcy51c2VyQXR0ZW51YXRpb24gPSB1c2VyQXR0ZW51YXRpb247XG4gICAgICAgIHRoaXMudXNlclJvbGxvZmYgPSB1c2VyUm9sbG9mZjtcbiAgICAgICAgdGhpcy5fb3RoZXJVc2VyR2FpblF1ZXVlID0ge307XG4gICAgfVxufVxuXG4vKipcbiAqIEluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MgY29udGFpbiBhbGwgb2YgdGhlIGRhdGEgdGhhdCBpcyBwb3NzaWJsZSB0byAqKnJlY2VpdmUgZnJvbSoqIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBTZXJ2ZXIuXG4gKiBTZWUgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAqIFxuICogU2VlIHtAbGluayBIaUZpQXVkaW9BUElEYXRhfSBmb3IgZGF0YSB0aGF0IGNhbiBib3RoIGJlIHNlbnQgdG8gYW5kIHJlY2VpdmVkIGZyb20gdGhlIFNlcnZlciAoaS5lLiBgcG9zaXRpb25gKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSBleHRlbmRzIEhpRmlBdWRpb0FQSURhdGEge1xuICAgIC8qKlxuICAgICAqIFRoaXMgVXNlciBJRCBpcyBhbiBhcmJpdHJhcnkgc3RyaW5nIHByb3ZpZGVkIGJ5IGFuIGFwcGxpY2F0aW9uIGRldmVsb3BlciB3aGljaCBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSB0aGUgdXNlciBhc3NvY2lhdGVkIHdpdGggYSBjbGllbnQuXG4gICAgICogV2UgcmVjb21tZW5kIHRoYXQgdGhpcyBgcHJvdmlkZWRVc2VySURgIGlzIHVuaXF1ZSBhY3Jvc3MgYWxsIHVzZXJzLCBidXQgdGhlIEhpZ2ggRmlkZWxpdHkgQVBJIHdpbGwgbm90IGVuZm9yY2UgdW5pcXVlbmVzcyBhY3Jvc3MgY2xpZW50cyBmb3IgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBwcm92aWRlZFVzZXJJRDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoaXMgc3RyaW5nIGlzIGEgaGFzaGVkIHZlcnNpb24gb2YgdGhlIHJhbmRvbSBVVUlEIHRoYXQgaXMgZ2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICogXG4gICAgICogQSBjb25uZWN0aW5nIGNsaWVudCBzZW5kcyB0aGlzIHZhbHVlIGFzIHRoZSBgc2Vzc2lvbmAga2V5IGluc2lkZSB0aGUgYXJndW1lbnQgdG8gdGhlIGBhdWRpb25ldC5pbml0YCBjb21tYW5kLlxuICAgICAqIFxuICAgICAqIEl0IGlzIHVzZWQgdG8gaWRlbnRpZnkgYSBnaXZlbiBjbGllbnQgYWNyb3NzIGEgY2xvdWQgb2YgbWl4ZXJzIGFuZCBpcyBndWFyYW50ZWVkIChcImd1YXJhbnRlZWRcIiBnaXZlbiB0aGUgY29udGV4dCBvZiByYW5kb20gVVVJRFMpIHRvIGJlIHVuaXF1ZS5cbiAgICAgKiBBcHBsaWNhdGlvbiBkZXZlbG9wZXJzIHNob3VsZCBub3QgbmVlZCB0byBpbnRlcmFjdCB3aXRoIG9yIG1ha2UgdXNlIG9mIHRoaXMgdmFsdWUsIHVubGVzcyB0aGV5IHdhbnQgdG8gdXNlIGl0IGludGVybmFsbHkgZm9yIHRyYWNraW5nIG9yIG90aGVyIHB1cnBvc2VzLlxuICAgICAqIFxuICAgICAqIFRoaXMgdmFsdWUgY2Fubm90IGJlIHNldCBieSB0aGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyLlxuICAgICAqL1xuICAgIGhhc2hlZFZpc2l0SUQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCB2b2x1bWUgb2YgdGhlIHVzZXIgaW4gZGVjaWJlbHMuXG4gICAgICogXG4gICAgICog4p2MIFRoZSBjbGllbnQgbmV2ZXIgc2VuZHMgYHZvbHVtZURlY2liZWxzYCBkYXRhIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogXG4gICAgICog4pyUIFRoZSBzZXJ2ZXIgc2VuZHMgYHZvbHVtZURlY2liZWxzYCBkYXRhIHRvIGFsbCBjbGllbnRzIGNvbm5lY3RlZCB0byBhIHNlcnZlciBkdXJpbmcgXCJwZWVyIHVwZGF0ZXNcIi5cbiAgICAgKi9cbiAgICB2b2x1bWVEZWNpYmVsczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHBlZXIgaXMgcHJvdmlkaW5nIHN0ZXJlbyBhdWRpby5cbiAgICAgKlxuICAgICAqIFRoZSBzZXJ2ZXIgc2VuZHMgYGlzU3RlcmVvYCBkYXRhIHRvIGFsbCBjbGllbnRzIGNvbm5lY3RlZCB0byBhIHNlcnZlciBkdXJpbmcgXCJwZWVyIHVwZGF0ZXNcIi5cbiAgICAgKi9cbiAgICBpc1N0ZXJlbzogYm9vbGVhbjtcbiAgICBcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXM6IHsgcHJvdmlkZWRVc2VySUQ/OiBzdHJpbmcsIGhhc2hlZFZpc2l0SUQ/OiBzdHJpbmcsIHZvbHVtZURlY2liZWxzPzogbnVtYmVyLCBwb3NpdGlvbj86IFBvaW50M0QsIG9yaWVudGF0aW9uUXVhdD86IE9yaWVudGF0aW9uUXVhdDNELCBpc1N0ZXJlbz86IGJvb2xlYW4gfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgICAgIHRoaXMucHJvdmlkZWRVc2VySUQgPSBwYXJhbXMucHJvdmlkZWRVc2VySUQ7XG4gICAgICAgIHRoaXMuaGFzaGVkVmlzaXRJRCA9IHBhcmFtcy5oYXNoZWRWaXNpdElEO1xuICAgICAgICB0aGlzLnZvbHVtZURlY2liZWxzID0gcGFyYW1zLnZvbHVtZURlY2liZWxzO1xuICAgICAgICB0aGlzLmlzU3RlcmVvID0gcGFyYW1zLmlzU3RlcmVvO1xuICAgIH1cbn1cbiIsIi8qKlxuICogVGhpcyBtb2R1bGUgcGVydGFpbnMgdG8gM0QgQXhpcyBjb25maWd1YXRpb24uIE1vZGlmeSB5b3VyIDNEIGF4aXMgY29uZmlndXJhdGlvbiB3aGVuIGNvbnN0cnVjdGluZyBhIG5ldyBbW0hpRmlDb21tdW5pY2F0b3JdXSBvYmplY3QuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG5pbXBvcnQgeyBIaUZpTG9nZ2VyIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9IaUZpTG9nZ2VyXCI7XG5pbXBvcnQgeyBPcmllbnRhdGlvblF1YXQzRCwgUG9pbnQzRCwgT3JpZW50YXRpb25FdWxlcjNET3JkZXIsIE9yaWVudGF0aW9uRXVsZXIzRCB9IGZyb20gXCIuL0hpRmlBdWRpb0FQSURhdGFcIjtcblxuZXhwb3J0IGVudW0gSGlGaUF4ZXMge1xuICAgIFBvc2l0aXZlWCA9IFwiUG9zaXRpdmUgWFwiLFxuICAgIE5lZ2F0aXZlWCA9IFwiTmVnYXRpdmUgWFwiLFxuICAgIFBvc2l0aXZlWSA9IFwiUG9zaXRpdmUgWVwiLFxuICAgIE5lZ2F0aXZlWSA9IFwiTmVnYXRpdmUgWVwiLFxuICAgIFBvc2l0aXZlWiA9IFwiUG9zaXRpdmUgWlwiLFxuICAgIE5lZ2F0aXZlWiA9IFwiTmVnYXRpdmUgWlwiXG59XG5cbmV4cG9ydCBlbnVtIEhpRmlIYW5kZWRuZXNzIHtcbiAgICBSaWdodEhhbmQgPSBcIlJpZ2h0IEhhbmRcIixcbiAgICBMZWZ0SGFuZCA9IFwiTGVmdCBIYW5kXCJcbn1cblxuLyoqXG4gKiBUaGUgYXhpcyBjb25maWd1cmF0aW9uIGRlc2NyaWJlcyB0aGUgM2QgZnJhbWUgb2YgcmVmZXJlbmNlIGluIHdoaWNoIGFyZSBleHByZXNzZWQgdGhlIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiB0aGUgSGlmaUNvbW11bmljYXRvciBwZWVycy5cbiAqIEFsbCBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gc2VuZCBvciByZWNlaXZlZCBmcm9tIHRoZSBhcGkgY2FsbHMgYXJlIGV4cGVjdGVkIHRvIGJlIGV4cHJlc3NlZCB1c2luZyB0aGF0IHNwYWNlIGNvbnZlbnRpb24uXG4gKiBPbiB0aGUgd2lyZSBhbmQgaW4gdGhlIG1peGVyLCB0aGUgSGlGaSBTcGF0aWFsIEF1ZGlvIHN5c3RlbSBpcyB1c2luZyBhIHNpbmdsZSB1bmlmaWVkIGNvbnZlbnRpb24gY2FsbGVkICdNaXhlclNwYWNlJyB3aGljaCBpcyB0aGUgc2FtZSBhcyB0aGUgXG4gKiBkZWZhdWx0IHZhbHVlLCBzZWUge0BsaW5rIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbn0uXG4gKiBcbiAqIFdoZW4gY29udmVydGluZyB0aGUgb3JpZW50YXRpb25FdWxlciwgdG8gb3IgZnJvbSB0aGUgcXVhdGVybmlvbiByZXByZXNlbnRhdGlvbiwgdGhlIExpYnJhcnkgcmVsaWVzIG9uIHRoZSBIaUZpQ29tbXVuaWNhdG9yJ3MgYXhpc0NvbmZpZ3VyYXRpb25cbiAqIHRvIGFwcGx5IHRoZSBleHBlY3RlZCBjb252ZW50aW9uIGFuZCBjb3JyZWN0IGNvbnZlcnNpb24uXG4gKiBUaGUgJ2V1bGVyT3JkZXInIGZpZWxkIG9mIHRoZSBheGlzIGNvbmZpZ3VyYXRpb24gaXMgdXNlZCBmb3IgdGhpcyBjb252ZXJzaW9uLlxuICogXG4gKiDimqAgV0FSTklORyDimqAgXG4gKiBUaGUgYXhpcyBjb25maWd1cmF0aW9uIGZpZWxkcyAocmlnaHRBeGlzLCBsZWZ0QXhpcywgaW50b1NjcmVlbkF4aXMsIG91dE9mU2NyZWVuQXhpcywgdXBBeGlzLCBkb3duQXhpcywgaGFuZGVkbmVzcykgYXJlIG5vdCBpbiB1c2UgeWV0XG4gKiBPbmx5IHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzIGZpZWxkcyB3aWxsIHJlc3VsdCBpbiB0aGUgZXhwZWN0ZWQgYmVoYXZpb3IuXG4gKiBUaGUgZXVsZXJPcmRlciBmaWVsZCBpcyB3b3JraW5nIGNvcnJlY2x0eSBhbmQgY2FuIGJlIGNvbmZpZ3VyZWQgYXQgdGhlIGNyZWF0aW9uIG9mIHRoZSBIaUZpQ29tbXVuaWNhdG9yXG4gKi9cbmV4cG9ydCBjbGFzcyBIaUZpQXhpc0NvbmZpZ3VyYXRpb24ge1xuICAgIHJpZ2h0QXhpczogSGlGaUF4ZXM7XG4gICAgbGVmdEF4aXM6IEhpRmlBeGVzO1xuXG4gICAgaW50b1NjcmVlbkF4aXM6IEhpRmlBeGVzO1xuICAgIG91dE9mU2NyZWVuQXhpczogSGlGaUF4ZXM7XG5cbiAgICB1cEF4aXM6IEhpRmlBeGVzO1xuICAgIGRvd25BeGlzOiBIaUZpQXhlcztcblxuICAgIGhhbmRlZG5lc3M6IEhpRmlIYW5kZWRuZXNzO1xuXG4gICAgZXVsZXJPcmRlcjogT3JpZW50YXRpb25FdWxlcjNET3JkZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcih7cmlnaHRBeGlzLCBsZWZ0QXhpcywgaW50b1NjcmVlbkF4aXMsIG91dE9mU2NyZWVuQXhpcywgdXBBeGlzLCBkb3duQXhpcywgaGFuZGVkbmVzcywgZXVsZXJPcmRlcn06IHtyaWdodEF4aXM6IEhpRmlBeGVzLCBsZWZ0QXhpczogSGlGaUF4ZXMsIGludG9TY3JlZW5BeGlzOiBIaUZpQXhlcywgb3V0T2ZTY3JlZW5BeGlzOiBIaUZpQXhlcywgdXBBeGlzOiBIaUZpQXhlcywgZG93bkF4aXM6IEhpRmlBeGVzLCBoYW5kZWRuZXNzOiBIaUZpSGFuZGVkbmVzcywgZXVsZXJPcmRlcjogT3JpZW50YXRpb25FdWxlcjNET3JkZXIgfSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgcmlnaHRBeGlzLCBsZWZ0QXhpcywgaW50b1NjcmVlbkF4aXMsIG91dE9mU2NyZWVuQXhpcywgdXBBeGlzLCBkb3duQXhpcywgaGFuZGVkbmVzcywgZXVsZXJPcmRlciB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29udGFpbnMgdGhlIGFwcGxpY2F0aW9uJ3MgM0QgYXhpcyBjb25maWd1cmF0aW9uLiBCeSBkZWZhdWx0OlxuICogLSBgK3hgIGlzIHRvIHRoZSByaWdodCBhbmQgYC14YCBpcyB0byB0aGUgbGVmdFxuICogLSBgK3lgIGlzIHVwIGFuZCBgLXlgIGlzIGRvd25cbiAqIC0gYCt6YCBpcyBiYWNrIGFuZCBgLXpgIGlzIGZyb250XG4gKiAtIFRoZSBjb29yZGluYXRlIHN5c3RlbSBpcyByaWdodC1oYW5kZWQuXG4gKiAtIEV1bGVyIG9yZGVyIGlzIGBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5ZYXdQaXRjaFJvbGxgXG4gKi9cbmV4cG9ydCBsZXQgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uID0gbmV3IEhpRmlBeGlzQ29uZmlndXJhdGlvbih7XG4gICAgcmlnaHRBeGlzOiBIaUZpQXhlcy5Qb3NpdGl2ZVgsXG4gICAgbGVmdEF4aXM6IEhpRmlBeGVzLk5lZ2F0aXZlWCxcbiAgICBpbnRvU2NyZWVuQXhpczogSGlGaUF4ZXMuUG9zaXRpdmVZLFxuICAgIG91dE9mU2NyZWVuQXhpczogSGlGaUF4ZXMuTmVnYXRpdmVZLFxuICAgIHVwQXhpczogSGlGaUF4ZXMuUG9zaXRpdmVaLFxuICAgIGRvd25BeGlzOiBIaUZpQXhlcy5OZWdhdGl2ZVosXG4gICAgaGFuZGVkbmVzczogSGlGaUhhbmRlZG5lc3MuUmlnaHRIYW5kLFxuICAgIGV1bGVyT3JkZXI6IE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLllhd1BpdGNoUm9sbCxcbn0pO1xuXG5leHBvcnQgY2xhc3MgSGlGaUF4aXNVdGlsaXRpZXMge1xuICAgIHN0YXRpYyB2ZXJpZnkoYXhpc0NvbmZpZ3VyYXRpb246IEhpRmlBeGlzQ29uZmlndXJhdGlvbikge1xuICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG5cbiAgICAgICAgLy8gU1RBUlQgbGVmdC9yaWdodCBheGlzIGVycm9yIGNoZWNraW5nXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVYKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5SaWdodCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzfSwgYW5kIExlZnQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWCkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuUmlnaHQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpc30sIGFuZCBMZWZ0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWSkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuUmlnaHQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpc30sIGFuZCBMZWZ0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVkpIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblJpZ2h0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXN9LCBhbmQgTGVmdCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVopIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblJpZ2h0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXN9LCBhbmQgTGVmdCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGF4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVaKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5SaWdodCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzfSwgYW5kIExlZnQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFTkQgbGVmdC9yaWdodCBheGlzIGVycm9yIGNoZWNraW5nXG5cbiAgICAgICAgLy8gU1RBUlQgaW50by1zY3JlZW4vb3V0LW9mLXNjcmVlbiBheGlzIGVycm9yIGNoZWNraW5nXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVYKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5JbnRvU2NyZWVuIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpc30sIGFuZCBPdXRPZlNjcmVlbiBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVggJiYgYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWCkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuSW50b1NjcmVlbiBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXN9LCBhbmQgT3V0T2ZTY3JlZW4gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWSkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuSW50b1NjcmVlbiBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXN9LCBhbmQgT3V0T2ZTY3JlZW4gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVZICYmIGF4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVkpIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcbkludG9TY3JlZW4gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzfSwgYW5kIE91dE9mU2NyZWVuIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgYXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVopIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcbkludG9TY3JlZW4gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzfSwgYW5kIE91dE9mU2NyZWVuIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVaKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5JbnRvU2NyZWVuIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpc30sIGFuZCBPdXRPZlNjcmVlbiBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFTkQgaW50by1zY3JlZW4vb3V0LW9mLXNjcmVlbiBheGlzIGVycm9yIGNoZWNraW5nXG5cbiAgICAgICAgLy8gU1RBUlQgdXAvZG93biBheGlzIGVycm9yIGNoZWNraW5nXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi51cEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVYKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5VcCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzfSwgYW5kIERvd24gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBheGlzQ29uZmlndXJhdGlvbi51cEF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWCkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuVXAgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnVwQXhpc30sIGFuZCBEb3duIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWSkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuVXAgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnVwQXhpc30sIGFuZCBEb3duIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVkpIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblVwIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi51cEF4aXN9LCBhbmQgRG93biBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLnVwQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGF4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVopIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblVwIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi51cEF4aXN9LCBhbmQgRG93biBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGF4aXNDb25maWd1cmF0aW9uLnVwQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVaKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5VcCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzfSwgYW5kIERvd24gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFTkQgdXAvZG93biBheGlzIGVycm9yIGNoZWNraW5nXG5cbiAgICAgICAgaWYgKCEoYXhpc0NvbmZpZ3VyYXRpb24uaGFuZGVkbmVzcyA9PT0gSGlGaUhhbmRlZG5lc3MuUmlnaHRIYW5kIHx8IGF4aXNDb25maWd1cmF0aW9uLmhhbmRlZG5lc3MgPT09IEhpRmlIYW5kZWRuZXNzLkxlZnRIYW5kKSkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuSGFuZGVkbmVzcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmhhbmRlZG5lc3N9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIOKaoCBXQVJOSU5HIOKaoCBUaGUgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIElTIHdyb25nLlxuICAgICAqIFRPRE86IGltcGxlbWVudCB0aGUgZnVuY3Rpb24sIGp1c3QgYSBOTyBPUCBhdCB0aGUgbW9tZW50LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBheGlzQ29uZmlndXJhdGlvbiBcbiAgICAgKiBAcGFyYW0gaW5wdXRQb2ludDNEIFxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2xhdGVQb2ludDNEVG9NaXhlclNwYWNlKGF4aXNDb25maWd1cmF0aW9uOiBIaUZpQXhpc0NvbmZpZ3VyYXRpb24sIGlucHV0UG9pbnQzRDogUG9pbnQzRCk6IFBvaW50M0Qge1xuICAgICAgICBsZXQgcmV0dmFsID0gbmV3IFBvaW50M0QoKTtcbiAgICAgICAgLypcbiAgICAgICAgbGV0IGlucHV0WElzTnVtYmVyID0gdHlwZW9mIChpbnB1dFBvaW50M0QueCkgPT09IFwibnVtYmVyXCI7XG4gICAgICAgIGxldCBpbnB1dFlJc051bWJlciA9IHR5cGVvZiAoaW5wdXRQb2ludDNELnkpID09PSBcIm51bWJlclwiO1xuICAgICAgICBsZXQgaW5wdXRaSXNOdW1iZXIgPSB0eXBlb2YgKGlucHV0UG9pbnQzRC56KSA9PT0gXCJudW1iZXJcIjtcblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVggJiYgaW5wdXRYSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHZhbC54ID0gaW5wdXRQb2ludDNELng7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBpbnB1dFhJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnggPSAtaW5wdXRQb2ludDNELng7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBpbnB1dFlJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnggPSBpbnB1dFBvaW50M0QueTtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBpbnB1dFlJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnggPSAtaW5wdXRQb2ludDNELnk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVggJiYgaW5wdXRaSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHZhbC54ID0gaW5wdXRQb2ludDNELno7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBpbnB1dFpJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnggPSAtaW5wdXRQb2ludDNELno7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgaW5wdXRYSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHZhbC55ID0gaW5wdXRQb2ludDNELng7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBpbnB1dFhJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnkgPSAtaW5wdXRQb2ludDNELng7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBpbnB1dFlJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnkgPSBpbnB1dFBvaW50M0QueTtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBpbnB1dFlJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnkgPSAtaW5wdXRQb2ludDNELnk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgaW5wdXRaSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHZhbC55ID0gaW5wdXRQb2ludDNELno7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBpbnB1dFpJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnkgPSAtaW5wdXRQb2ludDNELno7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgaW5wdXRYSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHZhbC56ID0gaW5wdXRQb2ludDNELng7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBpbnB1dFhJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnogPSAtaW5wdXRQb2ludDNELng7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBpbnB1dFlJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnogPSBpbnB1dFBvaW50M0QueTtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBpbnB1dFlJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnogPSAtaW5wdXRQb2ludDNELnk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgaW5wdXRaSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHZhbC56ID0gaW5wdXRQb2ludDNELno7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBpbnB1dFpJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnogPSAtaW5wdXRQb2ludDNELno7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dmFsID0gaW5wdXRQb2ludDNEO1xuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOKaoCBXQVJOSU5HIOKaoCBUaGUgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIElTIHdyb25nLlxuICAgICAqIFRPRE86IGltcGxlbWVudCB0aGUgZnVuY3Rpb24sIGp1c3QgYSBOTyBPUCBhdCB0aGUgbW9tZW50LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBheGlzQ29uZmlndXJhdGlvbiBcbiAgICAgKiBAcGFyYW0gaW5wdXRPcmllbnRhdGlvblF1YXQzRCBcbiAgICAgKi9cbiAgICBzdGF0aWMgdHJhbnNsYXRlUG9pbnQzREZyb21NaXhlclNwYWNlKGF4aXNDb25maWd1cmF0aW9uOiBIaUZpQXhpc0NvbmZpZ3VyYXRpb24sIG1peGVyUG9pbnQzRDogUG9pbnQzRCk6IFBvaW50M0Qge1xuICAgICAgICBsZXQgcmV0dmFsID0gbmV3IFBvaW50M0QoKTtcbiAgICAgICAgcmV0dmFsID0gbWl4ZXJQb2ludDNEO1xuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOKaoCBXQVJOSU5HIOKaoCBUaGUgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIElTIHdyb25nLlxuICAgICAqIFRPRE86IGltcGxlbWVudCB0aGUgZnVuY3Rpb24sIGp1c3QgYSBOTyBPUCBhdCB0aGUgbW9tZW50LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBheGlzQ29uZmlndXJhdGlvbiBcbiAgICAgKiBAcGFyYW0gaW5wdXRPcmllbnRhdGlvblF1YXQzRCBcbiAgICAgKi9cbiAgICBzdGF0aWMgdHJhbnNsYXRlT3JpZW50YXRpb25RdWF0M0RUb01peGVyU3BhY2UoYXhpc0NvbmZpZ3VyYXRpb246IEhpRmlBeGlzQ29uZmlndXJhdGlvbiwgaW5wdXRPcmllbnRhdGlvblF1YXQzRDogT3JpZW50YXRpb25RdWF0M0QpOiBPcmllbnRhdGlvblF1YXQzRCB7XG4gICAgICAgIGxldCByZXR2YWwgPSBuZXcgT3JpZW50YXRpb25RdWF0M0QoKTtcbiAgICAgICAgcmV0dmFsID0gaW5wdXRPcmllbnRhdGlvblF1YXQzRDtcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDimqAgV0FSTklORyDimqAgVGhlIGNvZGUgaW4gdGhpcyBmdW5jdGlvbiBJUyB3cm9uZy5cbiAgICAgKiBUT0RPOiBpbXBsZW1lbnQgdGhlIGZ1bmN0aW9uLCBqdXN0IGEgTk8gT1AgYXQgdGhlIG1vbWVudC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gYXhpc0NvbmZpZ3VyYXRpb24gXG4gICAgICogQHBhcmFtIGlucHV0T3JpZW50YXRpb25RdWF0M0QgXG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zbGF0ZU9yaWVudGF0aW9uUXVhdDNERnJvbU1peGVyU3BhY2UoYXhpc0NvbmZpZ3VyYXRpb246IEhpRmlBeGlzQ29uZmlndXJhdGlvbiwgbWl4ZXJPcmllbnRhdGlvblF1YXQzRDogT3JpZW50YXRpb25RdWF0M0QpOiBPcmllbnRhdGlvblF1YXQzRCB7XG4gICAgICAgIGxldCByZXR2YWwgPSBuZXcgT3JpZW50YXRpb25RdWF0M0QoKTtcbiAgICAgICAgcmV0dmFsID0gbWl4ZXJPcmllbnRhdGlvblF1YXQzRDtcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9XG59XG4iLCIvKipcbiAqIE1ldGhvZHMgb24gdGhlIFtbSGlGaUNvbW11bmljYXRvcl1dIGNsYXNzIGFsbG93IGRldmVsb3BlcnMgdG8gcGVyZm9ybSBhY3Rpb25zIHN1Y2ggYXM6XG4gKiAtIGBjb25uZWN0VG9IaUZpQXVkaW9BUElTZXJ2ZXIoKWA6IENvbm5lY3QgdG8gYW5kIGRpc2Nvbm5lY3QgZnJvbSB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBTZXJ2ZXJcbiAqIC0gYHVwZGF0ZVVzZXJEYXRhQW5kVHJhbnNtaXQoKWA6IFVwZGF0ZSB0aGUgdXNlcidzIGRhdGEgKHBvc2l0aW9uLCBvcmllbnRhdGlvbiwgZXRjKSBvbiB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBTZXJ2ZXJcbiAqIC0gYHNldElucHV0QXVkaW9NZWRpYVN0cmVhbSgpYDogU2V0IGEgbmV3IGlucHV0IGF1ZGlvIG1lZGlhIHN0cmVhbSAoZm9yIGV4YW1wbGUsIHdoZW4gdGhlIHVzZXIncyBhdWRpbyBpbnB1dCBkZXZpY2UgY2hhbmdlcylcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5cbmRlY2xhcmUgdmFyIEhJRklfQVBJX1ZFUlNJT046IHN0cmluZztcblxuaW1wb3J0IHsgSGlGaUNvbnN0YW50cyB9IGZyb20gXCIuLi9jb25zdGFudHMvSGlGaUNvbnN0YW50c1wiO1xuaW1wb3J0IHsgV2ViUlRDU2Vzc2lvblBhcmFtcywgQ3VzdG9tU1RVTmFuZFRVUk5Db25maWcgfSBmcm9tIFwiLi4vbGlicmF2aS9SYXZpU2Vzc2lvblwiO1xuaW1wb3J0IHsgSGlGaUxvZ2dlciB9IGZyb20gXCIuLi91dGlsaXRpZXMvSGlGaUxvZ2dlclwiO1xuaW1wb3J0IHsgSGlGaVV0aWxpdGllcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvSGlGaVV0aWxpdGllc1wiO1xuaW1wb3J0IHsgSGlGaUF1ZGlvQVBJRGF0YSwgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhLCBQb2ludDNELCBPcmllbnRhdGlvblF1YXQzRCwgT3JpZW50YXRpb25FdWxlcjNELCBPcmllbnRhdGlvbkV1bGVyM0RPcmRlciwgZXVsZXJUb1F1YXRlcm5pb24sIGV1bGVyRnJvbVF1YXRlcm5pb24sIE90aGVyVXNlckdhaW5NYXAgfSBmcm9tIFwiLi9IaUZpQXVkaW9BUElEYXRhXCI7XG5pbXBvcnQgeyBIaUZpQXhpc0NvbmZpZ3VyYXRpb24sIEhpRmlBeGlzVXRpbGl0aWVzLCBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi9IaUZpQXhpc0NvbmZpZ3VyYXRpb25cIjtcbmltcG9ydCB7IEhpRmlNaXhlclNlc3Npb24sIFNldE90aGVyVXNlckdhaW5Gb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlLCBTZXRPdGhlclVzZXJHYWluc0ZvclRoaXNDb25uZWN0aW9uUmVzcG9uc2UsIE9uTXV0ZUNoYW5nZWRDYWxsYmFjayB9IGZyb20gXCIuL0hpRmlNaXhlclNlc3Npb25cIjtcbmltcG9ydCB7IEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cywgVXNlckRhdGFTdWJzY3JpcHRpb24gfSBmcm9tIFwiLi9IaUZpVXNlckRhdGFTdWJzY3JpcHRpb25cIjtcblxuLyoqXG4gKiBXaGVuIHRoZSBzdGF0ZSBvZiB0aGUgY29ubmVjdGlvbiB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBTZXJ2ZXIgY2hhbmdlcywgdGhlIG5ldyBzdGF0ZSB3aWxsIGJlIG9uZSBvZiB0aGVzZSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBlbnVtIEhpRmlDb25uZWN0aW9uU3RhdGVzIHtcbiAgICBDb25uZWN0ZWQgPSBcIkNvbm5lY3RlZFwiLFxuICAgIERpc2Nvbm5lY3RlZCA9IFwiRGlzY29ubmVjdGVkXCIsXG4gICAgRmFpbGVkID0gXCJGYWlsZWRcIixcbiAgICAvKipcbiAgICAgKiBUaGUgYEhpRmlDb25uZWN0aW9uU3RhdGVgIHdpbGwgYmUgYFwiVW5hdmFpbGFibGVcImAgd2hlbiB0aGUgQVBJIFNlcnZlciBpcyBhdCBjYXBhY2l0eS5cbiAgICAgKi9cbiAgICBVbmF2YWlsYWJsZSA9IFwiVW5hdmFpbGFibGVcIlxufTtcblxuLyoqXG4gKiBcbiAqL1xuZXhwb3J0IGVudW0gSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzIHtcbiAgICAvKipcbiAgICAgKiBQYXNzaW5nIHRoaXMgdmFsdWUgdG8gdGhlIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yfSBjb25zdHJ1Y3RvciBtZWFucyB0aGF0IHRoZSBTZXJ2ZXIgd2lsbCBub3Qgc2VuZCBhbnlcbiAgICAgKiBVc2VyIERhdGEgdXBkYXRlcyB0byB0aGUgY2xpZW50LCBtZWFuaW5nIFVzZXIgRGF0YSBTdWJzY3JpcHRpb25zIHdpbGwgbm90IGZ1bmN0aW9uLiBUaGlzIFN0cmVhbWluZyBTY29wZVxuICAgICAqIHNhdmVzIGJhbmR3aWR0aCBhbmQsIG1hcmdpbmFsbHksIHByb2Nlc3NpbmcgdGltZS5cbiAgICAgKi9cbiAgICBOb25lID0gXCJub25lXCIsXG4gICAgLyoqXG4gICAgICogUGFzc2luZyB0aGlzIHZhbHVlIHRvIHRoZSB7QGxpbmsgSGlGaUNvbW11bmljYXRvcn0gY29uc3RydWN0b3IgbWVhbnMgdGhhdCB0aGUgU2VydmVyIHdpbGwgb25seSBzZW5kXG4gICAgICogX3BlZXIgZGF0YV8gdG8gdGhlIENsaWVudDsgdGhlIFNlcnZlciB3aWxsIG5vdCBzZW5kIFVzZXIgRGF0YSBwZXJ0YWluaW5nIHRvIHRoZSBjb25uZWN0aW5nIENsaWVudCB3aGVuXG4gICAgICogdGhpcyBEYXRhIFN0cmVhbWluZyBTY29wZSBpcyBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBQZWVycyA9IFwicGVlcnNcIixcbiAgICAvKipcbiAgICAgKiBcImFsbFwiIGlzIHRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gdGhlIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yfSBjb25zdHJ1Y3RvciBpcyBjYWxsZWQuIEFsbCBVc2VyIERhdGFcbiAgICAgKiB3aWxsIGJlIHN0cmVhbWVkIGZyb20gdGhlIFNlcnZlciB0byB0aGUgQ2xpZW50LlxuICAgICAqL1xuICAgIEFsbCA9IFwiYWxsXCJcbn07XG5cbi8qKlxuICogVGhpcyBjbGFzcyBleHBvc2VzIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdXNlZnVsIGZvciBjb21tdW5pY2F0aW5nIGZyb20gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIENsaWVudCB0b1xuICogdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIFNlcnZlci4gXG4gKi9cbmV4cG9ydCBjbGFzcyBIaUZpQ29tbXVuaWNhdG9yIHtcbiAgICAvLyBQcmV2ZW50cyB1c2VycyBvZiBvdXIgY2xpZW50LXNpZGUgQVBJIGZyb20gc2xhbW1pbmcgdGhlaXIgbWl4ZXIgd2l0aCByZXF1ZXN0cy5cbiAgICAvLyBPZiBjb3Vyc2UsIGJlY2F1c2UgdGhpcyByYXRlIGxpbWl0IGlzIGNsaWVudHNpZGUsIGl0IGNvdWxkIGJlIHdvcmtlZCBhcm91bmQuXG4gICAgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVM6IG51bWJlcjtcbiAgICBwcml2YXRlIF90aW1lcnM6IGFueSA9IHtcbiAgICAgICAgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0OiBudWxsLFxuICAgICAgICB3YW50ZWRUb1RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YTogdHJ1ZVxuICAgIH07XG5cbiAgICAvLyBUaGlzIGlzIHVzdWFsbHkgdGhlIGBNZWRpYVN0cmVhbWAgYXNzb2NpYXRlZCB3aXRoIGEgdXNlcidzIGF1ZGlvIGlucHV0IGRldmljZSxcbiAgICAvLyBidXQgaXQgY291bGQgYmUgYW55IGBNZWRpYVN0cmVhbWAuXG4gICAgcHJpdmF0ZSBfaW5wdXRBdWRpb01lZGlhU3RyZWFtOiBNZWRpYVN0cmVhbTtcblxuICAgIC8vIFRoZXNlIG5leHQgdHdvIG1lbWJlciB2YXJpYWJsZXMgYXJlIHVzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCB0byBzZW5kIHRvIHRoZSBtaXhlci5cbiAgICAvLyBUaGUgY2xpZW50IG9ubHkgc2VuZHMgZGF0YSB0aGF0IHRoZSBtaXhlciBkb2Vzbid0IGFscmVhZHkga25vdyBhYm91dC5cbiAgICBwcml2YXRlIF9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YTogSGlGaUF1ZGlvQVBJRGF0YTtcbiAgICBwcml2YXRlIF9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhOiBIaUZpQXVkaW9BUElEYXRhO1xuXG4gICAgLy8gTGlicmFyeSB1c2VycyBjYW4gbWFrZSB1c2Ugb2YgXCJVc2VyIERhdGEgU3Vic2NyaXB0aW9uc1wiIHRvIGNhdXNlIHNvbWV0aGluZyB0byBoYXBwZW5cbiAgICAvLyB3aGVuIHRoZSBzZXJ2ZXIgcmVwb3J0cyB0aGF0IGEgdXNlcidzIGRhdGEgLSBzdWNoIGFzIHBvc2l0aW9uLCBvcmllbnRhdGlvbiwgYW5kIHZvbHVtZSAtIGhhcyBiZWVuIG1vZGlmaWVkLlxuICAgIHByaXZhdGUgX3VzZXJEYXRhU3Vic2NyaXB0aW9uczogQXJyYXk8VXNlckRhdGFTdWJzY3JpcHRpb24+O1xuXG4gICAgLyoqXG4gICAgICogU2VlIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLl9vblVzZXJzRGlzY29ubmVjdGVkfS5cbiAgICAgKi9cbiAgICBvblVzZXJzRGlzY29ubmVjdGVkOiBGdW5jdGlvbjtcblxuICAgIC8vIFRoaXMgY29udGFpbnMgZGF0YSBkZWFsaW5nIHdpdGggdGhlIG1peGVyIHNlc3Npb24sIHN1Y2ggYXMgdGhlIFJBVkkgc2Vzc2lvbiwgV2ViUlRDIGFkZHJlc3MsIGV0Yy5cbiAgICBwcml2YXRlIF9taXhlclNlc3Npb246IEhpRmlNaXhlclNlc3Npb247XG5cbiAgICBwcml2YXRlIF93ZWJSVENTZXNzaW9uUGFyYW1zPzogV2ViUlRDU2Vzc2lvblBhcmFtcztcbiAgICBwcml2YXRlIF9jdXN0b21TVFVOYW5kVFVSTkNvbmZpZz86IEN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBIaUZpQ29tbXVuaWNhdG9yIG9iamVjdC4gT25jZSB5b3UgaGF2ZSBjcmVhdGVkIGEgSGlGaUNvbW11bmljYXRvciwgeW91IGNhbiB1c2UgdGhlXG4gICAgICoge0BsaW5rIHNldElucHV0QXVkaW9NZWRpYVN0cmVhbX0gbWV0aG9kIHRvIGFzc2lnbiBhbiBpbnB1dCBhdWRpbyBzdHJlYW0gdG8gdGhlIGNvbm5lY3Rpb24sIGFuZFxuICAgICAqIG9uY2UgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQsIHVzZSB0aGUge0BsaW5rIGdldE91dHB1dEF1ZGlvTWVkaWFTdHJlYW19IG1ldGhvZCB0b1xuICAgICAqIHJldHJpZXZlIHRoZSBvdXRwdXQgYXVkaW8gZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBfX25hbWVkUGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBpbml0aWFsSGlGaUF1ZGlvQVBJRGF0YSAtIFRoZSBpbml0aWFsIHBvc2l0aW9uLCBvcmllbnRhdGlvbiwgZXRjIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0ZSB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgU2VydmVyIGNoYW5nZXMuIFNlZSB7QGxpbmsgSGlGaUNvbm5lY3Rpb25TdGF0ZXN9LlxuICAgICAqIEBwYXJhbSBvblVzZXJzRGlzY29ubmVjdGVkIC0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSBwZWVyIGRpc2Nvbm5lY3RzIGZyb20gdGhlIFNwYWNlLlxuICAgICAqIEBwYXJhbSB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNUyAtIFVzZXIgRGF0YSB1cGRhdGVzIHdpbGwgbm90IGJlIHNlbnQgdG8gdGhlIHNlcnZlciBhbnkgbW9yZSBmcmVxdWVudGx5IHRoYW4gdGhpcyBudW1iZXIgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBwYXJhbSB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlIC0gQ2Fubm90IGJlIHNldCBsYXRlci4gU2VlIHtAbGluayBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXN9LlxuICAgICAqIEBwYXJhbSBoaUZpQXhpc0NvbmZpZ3VyYXRpb24gLSBDYW5ub3QgYmUgc2V0IGxhdGVyLiBUaGUgM0QgYXhpcyBjb25maWd1cmF0aW9uLiBTZWUge0BsaW5rIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbn0gZm9yIGRlZmF1bHRzLlxuICAgICAqIEBwYXJhbSB3ZWJydGNTZXNzaW9uUGFyYW1zIC0gQ2Fubm90IGJlIHNldCBsYXRlci4gRXh0cmEgcGFyYW1ldGVycyB1c2VkIGZvciBjb25maWd1cmluZyB0aGUgdW5kZXJseWluZyBXZWJSVEMgY29ubmVjdGlvbiB0byB0aGUgQVBJIHNlcnZlcnMuXG4gICAgICogVGhlc2Ugc2V0dGluZ3MgYXJlIG5vdCBmcmVxdWVudGx5IHVzZWQ7IHRoZXkgYXJlIHByaW1hcmlseSBmb3Igc3BlY2lmaWMgaml0dGVyIGJ1ZmZlciBjb25maWd1cmF0aW9ucy5cbiAgICAgKiBAcGFyYW0gY3VzdG9tU1RVTmFuZFRVUk5Db25maWcgLSBDYW5ub3QgYmUgc2V0IGxhdGVyLiBUaGlzIG9iamVjdCBjYW4gYmUgdXNlZCBpZiBzcGVjaWZpYyBTVFVOIGFuZCBUVVJOIHNlcnZlciBpbmZvcm1hdGlvbiBuZWVkcyB0byBiZVxuICAgICAqIHByb3ZpZGVkIGZvciBuZWdvdGlhdGluZyB0aGUgdW5kZXJseWluZyBXZWJSVEMgY29ubmVjdGlvbi4gQnkgZGVmYXVsdCwgSGlnaCBGaWRlbGl0eSdzIFRVUk4gc2VydmVyIHdpbGwgYmUgdXNlZCwgd2hpY2ggc2hvdWxkIHN1ZmZpY2VcbiAgICAgKiBmb3IgbW9zdCBvcGVyYXRpb25zLiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIHRlc3Rpbmcgb3IgZm9yIHVzaW5nIGEgY29tbWVyY2lhbCBUVVJOIHNlcnZlciBwcm92aWRlciBmb3IgZGVhbGluZyB3aXRoIHBhcnRpY3VsYXJseSBjaGFsbGVuZ2luZyBjbGllbnQgbmV0d29ya3MvZmlyZXdhbGxzLlxuICAgICAqIFNlZSB7QGxpbmsgQ3VzdG9tU1RVTmFuZFRVUk5Db25maWd9IGZvciB0aGUgZm9ybWF0IG9mIHRoaXMgb2JqZWN0IChub3RlIHRoYXQgX2FsbF8gdmFsdWVzIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBzZXR0aW5nIHRoaXMpLlxuICAgICAqIEBwYXJhbSBvbk11dGVDaGFuZ2VkIC0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIG11dGUgc3RhdGUgb2YgdGhlIGNsaWVudCBoYXMgY2hhbmdlZCwgZm9yIGV4YW1wbGUgd2hlbiBtdXRlZCBieSBhbiBhZG1pbi4gU2VlIHtAbGluayBPbk11dGVDaGFuZ2VkQ2FsbGJhY2t9IGZvciB0aGUgaW5mb3JtYXRpb24gdGhpcyBmdW5jdGlvbiB3aWxsIHJlY2VpdmUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBpbml0aWFsSGlGaUF1ZGlvQVBJRGF0YSA9IG5ldyBIaUZpQXVkaW9BUElEYXRhKCksXG4gICAgICAgIG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCxcbiAgICAgICAgb25Vc2Vyc0Rpc2Nvbm5lY3RlZCxcbiAgICAgICAgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVMgPSBIaUZpQ29uc3RhbnRzLkRFRkFVTFRfVFJBTlNNSVRfUkFURV9MSU1JVF9USU1FT1VUX01TLFxuICAgICAgICB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlID0gSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzLkFsbCxcbiAgICAgICAgaGlGaUF4aXNDb25maWd1cmF0aW9uLFxuICAgICAgICB3ZWJydGNTZXNzaW9uUGFyYW1zLFxuICAgICAgICBjdXN0b21TVFVOYW5kVFVSTkNvbmZpZyxcbiAgICAgICAgb25NdXRlQ2hhbmdlZFxuICAgIH06IHtcbiAgICAgICAgaW5pdGlhbEhpRmlBdWRpb0FQSURhdGE/OiBIaUZpQXVkaW9BUElEYXRhLFxuICAgICAgICBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQ/OiBGdW5jdGlvbixcbiAgICAgICAgb25Vc2Vyc0Rpc2Nvbm5lY3RlZD86IEZ1bmN0aW9uLFxuICAgICAgICB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNUz86IG51bWJlcixcbiAgICAgICAgdXNlckRhdGFTdHJlYW1pbmdTY29wZT86IEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3BlcyxcbiAgICAgICAgaGlGaUF4aXNDb25maWd1cmF0aW9uPzogSGlGaUF4aXNDb25maWd1cmF0aW9uLFxuICAgICAgICB3ZWJydGNTZXNzaW9uUGFyYW1zPzogV2ViUlRDU2Vzc2lvblBhcmFtcyxcbiAgICAgICAgY3VzdG9tU1RVTmFuZFRVUk5Db25maWc/OiBDdXN0b21TVFVOYW5kVFVSTkNvbmZpZyxcbiAgICAgICAgb25NdXRlQ2hhbmdlZD86IE9uTXV0ZUNoYW5nZWRDYWxsYmFjayxcbiAgICB9ID0ge30pIHtcbiAgICAgICAgLy8gSWYgdXNlciBwYXNzZWQgaW4gdGhlaXIgb3duIHN0dW4vdHVybiBjb25maWcsIG1ha2Ugc3VyZSBpdCBtYXRjaGVzIG91ciBpbnRlcmZhY2UgKGlzaCkuXG4gICAgICAgIC8vIChJIGRvIHNvIHdpc2ggdGhhdCBUeXBlU2NyaXB0IGNvdWxkIGp1c3QgZG8gdGhpcyBmb3IgdXMgYmFzZWQgb24gdGhlIGludGVyZmFjZSBkZWZpbml0aW9uLCBidXQgaXQgc2VlbXMgdGhhdCBpdCBjYW4gbm90LilcbiAgICAgICAgaWYgKGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoIWN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLmhhc093blByb3BlcnR5KFwic3R1blVybHNcIikgfHwgIUFycmF5LmlzQXJyYXkoY3VzdG9tU1RVTmFuZFRVUk5Db25maWcuc3R1blVybHMpIHx8IGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLnN0dW5VcmxzLmxlbmd0aCA9PSAwICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgY3VzdG9tU1RVTmFuZFRVUk5Db25maWcuc3R1blVybHNcXGAgbXVzdCBiZSBzcGVjaWZpZWQgYW5kIG11c3QgYmUgYSBsaXN0IGNvbnRhaW5pbmcgYXQgbGVhc3Qgb25lIFNUVU4gc2VydmVyLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXN0b21TVFVOYW5kVFVSTkNvbmZpZy5oYXNPd25Qcm9wZXJ0eShcInR1cm5VcmxzXCIpIHx8ICFBcnJheS5pc0FycmF5KGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLnR1cm5VcmxzKSB8fCBjdXN0b21TVFVOYW5kVFVSTkNvbmZpZy50dXJuVXJscy5sZW5ndGggPT0gMCApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLnR1cm5VcmxzXFxgIG11c3QgYmUgc3BlY2lmaWVkIGFuZCBtdXN0IGJlIGEgbGlzdCBjb250YWluaW5nIGF0IGxlYXN0IG9uZSBUVVJOIHNlcnZlci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3VzdG9tU1RVTmFuZFRVUk5Db25maWcuaGFzT3duUHJvcGVydHkoXCJ0dXJuVXNlcm5hbWVcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLnR1cm5Vc2VybmFtZVxcYCBtdXN0IGJlIHNwZWNpZmllZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3VzdG9tU1RVTmFuZFRVUk5Db25maWcuaGFzT3duUHJvcGVydHkoXCJ0dXJuQ3JlZGVudGlhbFwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgY3VzdG9tU1RVTmFuZFRVUk5Db25maWcudHVybkNyZWRlbnRpYWxcXGAgbXVzdCBiZSBzcGVjaWZpZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VzdG9tU1RVTmFuZFRVUk5Db25maWcgPSBjdXN0b21TVFVOYW5kVFVSTkNvbmZpZztcblxuICAgICAgICAvLyBNYWtlIG1pbmltdW0gMTBtc1xuICAgICAgICBpZiAodHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVMgPCBIaUZpQ29uc3RhbnRzLk1JTl9UUkFOU01JVF9SQVRFX0xJTUlUX1RJTUVPVVRfTVMpIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgXFxgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVNcXGAgbXVzdCBiZSA+PSAke0hpRmlDb25zdGFudHMuTUlOX1RSQU5TTUlUX1JBVEVfTElNSVRfVElNRU9VVF9NU31tcyEgU2V0dGluZyB0byAke0hpRmlDb25zdGFudHMuTUlOX1RSQU5TTUlUX1JBVEVfTElNSVRfVElNRU9VVF9NU31tcy4uLmApO1xuICAgICAgICAgICAgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVMgPSBIaUZpQ29uc3RhbnRzLk1JTl9UUkFOU01JVF9SQVRFX0xJTUlUX1RJTUVPVVRfTVM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNUyA9IHRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dE1TO1xuXG4gICAgICAgIGlmIChvblVzZXJzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uVXNlcnNEaXNjb25uZWN0ZWQgPSBvblVzZXJzRGlzY29ubmVjdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWl4ZXJTZXNzaW9uID0gbmV3IEhpRmlNaXhlclNlc3Npb24oe1xuICAgICAgICAgICAgXCJ1c2VyRGF0YVN0cmVhbWluZ1Njb3BlXCI6IHVzZXJEYXRhU3RyZWFtaW5nU2NvcGUsXG4gICAgICAgICAgICBcIm9uVXNlckRhdGFVcGRhdGVkXCI6IChkYXRhOiBBcnJheTxSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE+KSA9PiB7IHRoaXMuX2hhbmRsZVVzZXJEYXRhVXBkYXRlcyhkYXRhKTsgfSxcbiAgICAgICAgICAgIFwib25Vc2Vyc0Rpc2Nvbm5lY3RlZFwiOiAoZGF0YTogQXJyYXk8UmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhPikgPT4geyB0aGlzLl9vblVzZXJzRGlzY29ubmVjdGVkKGRhdGEpOyB9LFxuICAgICAgICAgICAgXCJvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcIjogb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkLFxuICAgICAgICAgICAgXCJvbk11dGVDaGFuZ2VkXCI6IG9uTXV0ZUNoYW5nZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5faW5wdXRBdWRpb01lZGlhU3RyZWFtID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhID0gbmV3IEhpRmlBdWRpb0FQSURhdGEoKTtcblxuICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhID0gbmV3IEhpRmlBdWRpb0FQSURhdGEoKTtcblxuICAgICAgICB0aGlzLl91c2VyRGF0YVN1YnNjcmlwdGlvbnMgPSBbXTtcblxuICAgICAgICBpZiAod2VicnRjU2Vzc2lvblBhcmFtcyAmJiB3ZWJydGNTZXNzaW9uUGFyYW1zLmF1ZGlvTWluSml0dGVyQnVmZmVyRHVyYXRpb24gJiYgKHdlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NaW5KaXR0ZXJCdWZmZXJEdXJhdGlvbiA8IDAuMCB8fCB3ZWJydGNTZXNzaW9uUGFyYW1zLmF1ZGlvTWluSml0dGVyQnVmZmVyRHVyYXRpb24gPiAxMC4wKSkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBUaGUgdmFsdWUgb2YgXFxgd2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01pbkppdHRlckJ1ZmZlckR1cmF0aW9uXFxgICgke3dlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NaW5KaXR0ZXJCdWZmZXJEdXJhdGlvbn0pIHdpbGwgYmUgY2xhbXBlZCB0byAoMC4wLCAxMC4wKS5gKTtcbiAgICAgICAgICAgIHdlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NaW5KaXR0ZXJCdWZmZXJEdXJhdGlvbiA9IEhpRmlVdGlsaXRpZXMuY2xhbXAod2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01pbkppdHRlckJ1ZmZlckR1cmF0aW9uLCAwLjAsIDEwLjApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWJydGNTZXNzaW9uUGFyYW1zICYmIHdlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NYXhKaXR0ZXJCdWZmZXJEdXJhdGlvbiAmJiAod2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01heEppdHRlckJ1ZmZlckR1cmF0aW9uIDwgMC4wIHx8IHdlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NYXhKaXR0ZXJCdWZmZXJEdXJhdGlvbiA+IDEwLjApKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYFRoZSB2YWx1ZSBvZiBcXGB3ZWJydGNTZXNzaW9uUGFyYW1zLmF1ZGlvTWF4Sml0dGVyQnVmZmVyRHVyYXRpb25cXGAgKCR7d2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01heEppdHRlckJ1ZmZlckR1cmF0aW9ufSkgd2lsbCBiZSBjbGFtcGVkIHRvICgwLjAsIDEwLjApLmApO1xuICAgICAgICAgICAgd2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01heEppdHRlckJ1ZmZlckR1cmF0aW9uID0gSGlGaVV0aWxpdGllcy5jbGFtcCh3ZWJydGNTZXNzaW9uUGFyYW1zLmF1ZGlvTWF4Sml0dGVyQnVmZmVyRHVyYXRpb24sIDAuMCwgMTAuMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2ViUlRDU2Vzc2lvblBhcmFtcyA9IHdlYnJ0Y1Nlc3Npb25QYXJhbXM7XG5cbiAgICAgICAgaWYgKGhpRmlBeGlzQ29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKEhpRmlBeGlzVXRpbGl0aWVzLnZlcmlmeShoaUZpQXhpc0NvbmZpZ3VyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpcyA9IGhpRmlBeGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXM7XG4gICAgICAgICAgICAgICAgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzID0gaGlGaUF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzO1xuICAgICAgICAgICAgICAgIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyA9IGhpRmlBeGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcztcbiAgICAgICAgICAgICAgICBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzID0gaGlGaUF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcztcbiAgICAgICAgICAgICAgICBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID0gaGlGaUF4aXNDb25maWd1cmF0aW9uLnVwQXhpcztcbiAgICAgICAgICAgICAgICBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgPSBoaUZpQXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXM7XG4gICAgICAgICAgICAgICAgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLmhhbmRlZG5lc3MgPSBoaUZpQXhpc0NvbmZpZ3VyYXRpb24uaGFuZGVkbmVzcztcbiAgICAgICAgICAgICAgICBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24uZXVsZXJPcmRlciA9IGhpRmlBeGlzQ29uZmlndXJhdGlvbi5ldWxlck9yZGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBUaGVyZSBpcyBhbiBlcnJvciB3aXRoIHRoZSBwYXNzZWQgXFxgSGlGaUF4aXNDb25maWd1cmF0aW9uXFxgLCBzbyB0aGUgbmV3IGF4aXMgY29uZmlndXJhdGlvbiB3YXMgbm90IHNldC4gVGhlcmUgYXJlIG1vcmUgZXJyb3IgZGV0YWlscyBpbiB0aGUgbG9ncyBhYm92ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGN1cnJlbnQgQXVkaW8gQVBJIERhdGEgd2l0aCB0aGUgZ2l2ZW4gZGF0YSwgYnV0IHVzZSB0aGUgJ3VwZGF0ZVVzZXJEYXRhKCknIGNhbGwgZm9yIHNhbml0eS5cbiAgICAgICAgdGhpcy5fdXBkYXRlVXNlckRhdGEoaW5pdGlhbEhpRmlBdWRpb0FQSURhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBzZXJ2ZXIgYW5kIHRyYW5zbWl0cyB0aGUgaW5pdGlhbCB1c2VyIGRhdGEgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gaGlmaUF1dGhKV1QgIFRoaXMgSlNPTiBXZWIgVG9rZW4gKEpXVCkgaXMgdXNlZCBieSBjYWxsZXJzIHRvIGFzc29jaWF0ZSBhIHVzZXIgd2l0aCBhIHNwZWNpZmljIEhpZ2ggRmlkZWxpdHkgU3BhdGlhbCBBdWRpbyBBUEkgU2VydmVyLlxuICAgICAqIEpXVHMgYXJlIGFuIGluZHVzdHJ5LXN0YW5kYXJkIG1ldGhvZCBmb3Igc2VjdXJlbHkgcmVwcmVzZW50aW5nIGNsYWltcyBiZXR3ZWVuIHR3byBhcHBsaWNhdGlvbnMuXG4gICAgICogXG4gICAgICogKipJbXBvcnRhbnQgaW5mb3JtYXRpb24gYWJvdXQgSldUczoqKlxuICAgICAqIC0gKipEbyBub3QgZXhwb3NlIEpXVHMgdG8gdXNlcnMhKiogQW55b25lIHdpdGggYWNjZXNzIHRvIG9uZSBvZiB5b3VyIEpXVHMgd2lsbCBiZSBhYmxlIHRvIGNvbm5lY3QgdG8geW91ciBIaWdoIEZpZGVsaXR5IFNwYXRpYWwgQXVkaW8gQVBJIFNlcnZlci5cbiAgICAgKiAtIEluIHlvdXIgYXBwbGljYXRpb24ncyBwcm9kdWN0aW9uIGVudmlyb25tZW50LCBlYWNoIGNsaWVudCBydW5uaW5nIHlvdXIgYXBwIGNvZGUgc2hvdWxkIGNvbm5lY3QgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgU3BhdGlhbCBBdWRpbyBTZXJ2ZXIgd2l0aCBhIHVuaXF1ZSBKV1QuXG4gICAgICogSW4gdGhlIGNhc2Ugb2YgYSBXZWIgYXBwbGljYXRpb24sIHlvdXIgYXBwbGljYXRpb24gc2VydmVyIGNvZGUgc2hvdWxkIGdlbmVyYXRlIGEgSldUIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciByZXF1ZXN0aW5nIHlvdXIgV2ViIGFwcGxpY2F0aW9uLlxuICAgICAqIFxuICAgICAqIFRvIGdlbmVyYXRlIGEgSldUIGZvciB1c2Ugd2l0aCB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEk6XG4gICAgICogMS4gSGVhZCB0byB7QGxpbmsgaHR0cHM6Ly9qd3QuaW8vfSB0byBmaW5kIHRoZSBhcHByb3ByaWF0ZSBsaWJyYXJ5IGZvciB5b3VyIGxhbmdhdWdlLlxuICAgICAqICAgICBhLiBGb3IgTm9kZUpTIGFwcGxpY2F0aW9ucyBhbmQgV2ViIGFwcGxpY2F0aW9ucyBjb21waWxpZWQgZnJvbSBOb2RlSlMgY29kZSwgd2UgcmVjb21tZW5kIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9qb3NlfGpvc2V9LlxuICAgICAqIDIuIFVzaW5nIHRoZSB7QGxpbmsgaHR0cHM6Ly9hY2NvdW50LmhpZ2hmaWRlbGl0eS5jb20vZGV2L2FjY291bnR8SGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgRGV2ZWxvcGVyIENvbnNvbGV9LFxuICAgICAqIG9idGFpbiB5b3VyIEFwcCBJRCwgU3BhY2UgSUQsIGFuZCBBcHAgU2VjcmV0LlxuICAgICAqIDMuIENyZWF0ZSB5b3VyIHVzZXIncyBKV1QgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGxpYnJhcnksIHBhc3NpbmcgeW91ciBBcHAgSUQsIFNwYWNlIElELCBhbmQgQXBwIFNlY3JldC4gSGVyZSBpcyBhbiBleGFtcGxlIG9mIHdoYXQgdGhhdCBtaWdodCBsb29rIGxpa2UsIHVzaW5nIE5vZGVKUyBhbmQgYGpvc2VgOlxuICAgICAqICAgICBgYGBcbiAgICAgKiBoaUZpU2FtcGxlSldUID0gYXdhaXQgbmV3IFNpZ25KV1Qoe1xuICAgICAqICAgICBcImFwcF9pZFwiOiBBUFBfSUQsXG4gICAgICogICAgIFwic3BhY2VfaWRcIjogU1BBQ0VfSURcbiAgICAgKiB9KVxuICAgICAqIC5zZXRQcm90ZWN0ZWRIZWFkZXIoeyBhbGc6ICdIUzI1NicsIHR5cDogJ0pXVCcgfSlcbiAgICAgKiAuc2lnbihjcnlwdG8uY3JlYXRlU2VjcmV0S2V5KEJ1ZmZlci5mcm9tKEFQUF9TRUNSRVQsIFwidXRmOFwiKSkpO1xuICAgICAqICAgICBgYGBcbiAgICAgKiBQbGVhc2UgcmVmZXJlbmNlIG91ciB7QGxpbmsgaHR0cHM6Ly93d3cuaGlnaGZpZGVsaXR5LmNvbS9hcGkvZ3VpZGVzL21pc2MvZ2V0QUpXVHxcIkdldCBhIEpXVFwiIGd1aWRlfSBmb3IgYWRkaXRpb25hbCBjb250ZXh0LlxuICAgICAqIDQuIFBhc3MgdGhlIGNyZWF0ZWQgSldUIHRvIGBjb25uZWN0VG9IaUZpQXVkaW9BUElTZXJ2ZXIoKWAuXG4gICAgICogXG4gICAgICogQXMgb2YgMjAyMS0wMS0yMSwgd2UndmUgYWRkZWQgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIHdoaWNoLCBpbiB0aGUgYnJvd3NlciBjb250ZXh0LCBzZWFyY2hlcyBmb3IgYSBgdG9rZW5gIFVSTCBxdWVyeSBwYXJhbWV0ZXIgYW5kLCBpZiBhIEpXVFxuICAgICAqIGlzbid0IHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb24sIHVzZXMgdGhlIHZhbHVlIG9mIHRoYXQgYHRva2VuYCBVUkwgcXVlcnkgcGFyYW1ldGVyIGFzIHRoZSBKV1QuXG4gICAgICogV2Ugc2hvdWxkIHJlbW92ZSB0aGF0IGxhdGVyLCBiZWNhdXNlIHdlIGFsbW9zdCBjZXJ0YWlubHkgZG9uJ3Qgd2FudCB0aGlzIHRvIHN0YXkgaW4gdGhlIEFQSSBjb2RlLCBidXQgaXQncyBfdmVyeV8gY29udmVuaWVudCBmb3Igc2FtcGxlIGFwcHMgZm9yIHJpZ2h0IG5vdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaWduYWxpbmdIb3N0VVJMIEFuIFVSTCB0aGF0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSB2YWxpZCBXZWJSVEMgc2lnbmFsaW5nIGFkZHJlc3MgYXQgSGlnaCBGaWRlbGl0eS4gVGhlIHBhc3NlZCBgc2lnbmFsaW5nSG9zdFVSTGAgcGFyYW1ldGVyIHNob3VsZCBub3QgY29udGFpbiB0aGUgcHJvdG9jb2xcbiAgICAgKiBvciBwb3J0IC0gZS5nLiBgc2VydmVyLmhpZ2hmaWRlbGl0eS5jb21gIC0gYW5kIGl0IHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBzaWduYWxpbmcgYWRkcmVzcyBvZiB0aGUgZm9ybTogYHdzczovLyR7c2lnbmFsaW5nSG9zdFVSTH06JHtzaWduYWxpbmdQb3J0fS8/dG9rZW49YFxuICAgICAqIElmIHRoZSBkZXZlbG9wZXIgZG9lcyBub3QgcGFzcyBhIGBzaWduYWxpbmdIb3N0VVJMYCBwYXJhbWV0ZXIsIGEgZGVmYXVsdCBVUkwgd2lsbCBiZSB1c2VkIGluc3RlYWQuIFNlZToge0BsaW5rIERFRkFVTFRfUFJPRF9ISUdIX0ZJREVMSVRZX0VORFBPSU5UfVxuICAgICAqIFJlYWRpbmcgdGhpcyBwYXJhbWV0ZXIgZnJvbSB0aGUgVVJMIChpZiBuZWVkZWQpIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgZGV2ZWxvcGVyIGFzIHBhcnQgb2YgdGhlIGFwcGxpY2F0aW9uIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2lnbmFsaW5nUG9ydCBUaGUgcG9ydCB0byB1c2UgZm9yIG1ha2luZyBXZWJTb2NrZXQgY29ubmVjdGlvbnMgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgc2VydmVycy5cbiAgICAgKiBJZiB0aGUgZGV2ZWxvcGVyIGRvZXMgbm90IHBhc3MgYSBgc2lnbmFsaW5nUG9ydGAgcGFyYW1ldGVyLCB0aGUgZGVmYXVsdCAoNDQzKSB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gU2VlOiB7QGxpbmsgREVGQVVMVF9QUk9EX0hJR0hfRklERUxJVFlfUE9SVH1cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBJZiB0aGlzIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGUgUHJvbWlzZSB3aWxsIHJlc29sdmUgd2l0aCBgeyBzdWNjZXNzOiB0cnVlLCBhdWRpb25ldEluaXRSZXNwb25zZTogPFRoZSByZXNwb25zZSB0byBgYXVkaW9uZXQuaW5pdGAgZnJvbSB0aGUgc2VydmVyIGluIE9iamVjdCBmb3JtYXQ+fWAuXG4gICAgICogSWYgdW5zdWNjZXNzZnVsLCB0aGUgUHJvbWlzZSB3aWxsIHJlamVjdCB3aXRoIGB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogPGFuIGVycm9yIG1lc3NhZ2U+IH1gLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3RUb0hpRmlBdWRpb0FQSVNlcnZlcihoaWZpQXV0aEpXVDogc3RyaW5nLCBzaWduYWxpbmdIb3N0VVJMPzogc3RyaW5nLCBzaWduYWxpbmdQb3J0PzogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgaWYgKCF0aGlzLl9taXhlclNlc3Npb24pIHtcbiAgICAgICAgICAgIGxldCBlcnJNc2cgPSBgXFxgdGhpcy5fbWl4ZXJTZXNzaW9uXFxgIGlzIGZhbHNleTsgdHJ5IGNyZWF0aW5nIGEgbmV3IEhpRmlDb21tdW5pY2F0b3IgYW5kIHN0YXJ0aW5nIG92ZXIuYDtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyck1zZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWl4ZXJTZXNzaW9uLmdldEN1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlKCkgPT09IEhpRmlDb25uZWN0aW9uU3RhdGVzLkNvbm5lY3RlZCkge1xuICAgICAgICAgICAgbGV0IG1zZyA9IGBTZXNzaW9uIGlzIGFscmVhZHkgY29ubmVjdGVkISBJZiB5b3UgbmVlZCB0byByZXNldCB0aGUgY29ubmVjdGlvbiwgcGxlYXNlIGRpc2Nvbm5lY3QgZnVsbHkgdXNpbmcgXFxgZGlzY29ubmVjdEZyb21IaUZpQXVkaW9BUElTZXJ2ZXIoKVxcYCBhbmQgY2FsbCB0aGlzIG1ldGhvZCBhZ2Fpbi5gO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtaXhlckNvbm5lY3Rpb25SZXNwb25zZTtcbiAgICAgICAgbGV0IHNpZ25hbGluZ0hvc3RVUkxTYWZlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChzaWduYWxpbmdIb3N0VVJMKTtcbiAgICAgICAgICAgIHNpZ25hbGluZ0hvc3RVUkxTYWZlID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICAgICAgaWYgKHNpZ25hbGluZ1BvcnQgPT0gbnVsbCAmJiB1cmwucG9ydCAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIC8vIHNvbWV0aW1lcyB0aGUgc2lnbmFsaW5nUG9ydCBpcyBzcGVjaWZpZWQgaW4gdGhlIHNpZ25hbEhvc3RVUkwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgICAgIC8vIHdlIGV4dHJhY3QgdGhlIHBvcnQgbnVtYmVyIHJhdGhlciB0aGFuIGZhbGxiYWNrIHRvIGRlZmF1bHRcbiAgICAgICAgICAgICAgICBzaWduYWxpbmdQb3J0ID0gTnVtYmVyKHVybC5wb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBJZiBzaWduYWxpbmdIb3N0VVJMIGlzIG5vdCBkZWZpbmVkLCB3ZSBhc3NpZ24gdGhlIGRlZmF1bHQgVVJMXG4gICAgICAgICAgICBzaWduYWxpbmdIb3N0VVJMU2FmZSA9IHNpZ25hbGluZ0hvc3RVUkwgPyBzaWduYWxpbmdIb3N0VVJMIDogSGlGaUNvbnN0YW50cy5ERUZBVUxUX1BST0RfSElHSF9GSURFTElUWV9FTkRQT0lOVDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpZ25hbGluZ1BvcnQgPSBzaWduYWxpbmdQb3J0ID8gc2lnbmFsaW5nUG9ydCA6IEhpRmlDb25zdGFudHMuREVGQVVMVF9QUk9EX0hJR0hfRklERUxJVFlfUE9SVDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHdlYlJUQ1NpZ25hbGluZ0FkZHJlc3MgPSBgd3NzOi8vJHtzaWduYWxpbmdIb3N0VVJMU2FmZX06JHtzaWduYWxpbmdQb3J0fS8/dG9rZW49YDtcbiAgICAgICAgICAgIHRoaXMuX21peGVyU2Vzc2lvbi53ZWJSVENBZGRyZXNzID0gYCR7d2ViUlRDU2lnbmFsaW5nQWRkcmVzc30ke2hpZmlBdXRoSldUfWA7XG5cbiAgICAgICAgICAgIEhpRmlMb2dnZXIubG9nKGBVc2luZyBXZWJSVEMgU2lnbmFsaW5nIEFkZHJlc3M6XFxuJHt3ZWJSVENTaWduYWxpbmdBZGRyZXNzfTx0b2tlbiByZWRhY3RlZD5gKTtcblxuICAgICAgICAgICAgbWl4ZXJDb25uZWN0aW9uUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9taXhlclNlc3Npb24uY29ubmVjdFRvSGlGaU1peGVyKHsgd2ViUlRDU2Vzc2lvblBhcmFtczogdGhpcy5fd2ViUlRDU2Vzc2lvblBhcmFtcywgY3VzdG9tU1RVTmFuZFRVUk5Db25maWc6IHRoaXMuX2N1c3RvbVNUVU5hbmRUVVJOQ29uZmlnIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvckNvbm5lY3RpbmdUb01peGVyKSB7XG4gICAgICAgICAgICBsZXQgZXJyTXNnID0gYEVycm9yIHdoZW4gY29ubmVjdGluZyB0byBtaXhlciFcXG4ke2Vycm9yQ29ubmVjdGluZ1RvTWl4ZXJ9YDtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyck1zZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90cmFuc21pdEhpRmlBdWRpb0FQSURhdGFUb1NlcnZlcih0cnVlKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgYXVkaW9uZXRJbml0UmVzcG9uc2U6IG1peGVyQ29ubmVjdGlvblJlc3BvbnNlLmF1ZGlvbmV0SW5pdFJlc3BvbnNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIGdhaW4gb2YgYW5vdGhlciB1c2VyIGZvciB0aGlzIGNvbW11bmljYXRvcidzIGN1cnJlbnQgY29ubmVjdGlvbiBvbmx5LiBUaGlzIGlzIGEgc2luZ2xlIHVzZXIgdmVyc2lvbiBvZiB7QGxpbmsgSGlGaUNvbW11bmljYXRvci5zZXRPdGhlclVzZXJHYWluc0ZvclRoaXNDb25uZWN0aW9ufS5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgYSBtb3JlIGNvbWZvcnRhYmxlIGxpc3RlbmluZyBleHBlcmllbmNlIGZvciB0aGUgY2xpZW50LiBJZiB5b3UgbmVlZCB0byBwZXJmb3JtIG1vZGVyYXRpb24gYWN0aW9ucyB3aGljaCBhcHBseSBzZXJ2ZXIgc2lkZSwgdXNlIHRoZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmhpZ2hmaWRlbGl0eS5jb20vcmVzdC9sYXRlc3QvaW5kZXguaHRtbHxBZG1pbmlzdHJhdGl2ZSBSRVNUIEFQSX0uXG4gICAgICogXG4gICAgICogVG8gdXNlIHRoaXMgY29tbWFuZCwgdGhlIGNvbW11bmljYXRvciBtdXN0IGN1cnJlbnRseSBiZSBjb25uZWN0ZWQgdG8gYSBzcGFjZS4gWW91IGNhbiBjb25uZWN0IHRvIGEgc3BhY2UgdXNpbmcge0BsaW5rIGNvbm5lY3RUb0hpRmlBdWRpb0FQSVNlcnZlcn0uXG4gICAgICogXG4gICAgICogQHBhcmFtIGhhc2hlZFZpc2l0SWQgIFRoZSBoYXNoZWQgdmlzaXQgSUQgb2YgdGhlIHVzZXIgd2hvc2UgZ2FpbiB3aWxsIGJlIGFkanVzdGVkLlxuICAgICAqIFVzZSB7QGxpbmsgYWRkVXNlckRhdGFTdWJzY3JpcHRpb259IGFuZCB7QGxpbmsgSGlGaUNvbW11bmljYXRvci5vblVzZXJzRGlzY29ubmVjdGVkfSB0byBrZWVwIHRyYWNrIG9mIHRoZSBoYXNoZWQgdmlzaXQgSURzIG9mIGN1cnJlbnRseSBjb25uZWN0ZWQgdXNlcnMuXG4gICAgICogXG4gICAgICogV2hlbiB5b3Ugc3Vic2NyaWJlIHRvIHVzZXIgZGF0YSwgeW91IHdpbGwgZ2V0IGEgbGlzdCBvZiB7QGxpbmsgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhfSBvYmplY3RzLCB3aGljaCBlYWNoIGNvbnRhaW4sIGF0IG1pbmltdW0sIHtAbGluayBSZWNlaXZlZEhpZmlBdWRpb0FQSURhdGEuaGFzaGVkVmlzaXRJRH1zIGFuZCB7QGxpbmsgUmVjZWl2ZWRIaWZpQXVkaW9BUElEYXRhLnByb3ZpZGVkVXNlcklEfXMgZm9yIGVhY2ggdXNlciBpbiB0aGUgc3BhY2UuIEJ5IGluc3BlY3RpbmcgZWFjaCBvZiB0aGVzZSBvYmplY3RzLCB5b3UgY2FuIGFzc29jaWF0ZSBhIHVzZXIgd2l0aCB0aGVpciBoYXNoZWQgdmlzaXQgSUQsIGlmIHlvdSBrbm93IHRoZWlyIHByb3ZpZGVkIHVzZXIgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ2FpbiAgVGhlIHJlbGF0aXZlIGdhaW4gdG8gYXBwbHkgdG8gdGhlIG90aGVyIHVzZXIuIEJ5IGRlZmF1bHQsIHRoaXMgaXMgYDEuMGAuIFRoZSBnYWluIGNhbiBiZSBhbnkgdmFsdWUgZ3JlYXRlciBvciBlcXVhbCB0byBgMC4wYC5cbiAgICAgKiBGb3IgZXhhbXBsZTogYSBnYWluIG9mIGAyLjBgIHdpbGwgZG91YmxlIHRoZSBsb3VkbmVzcyBvZiB0aGUgdXNlciwgd2hpbGUgYSBnYWluIG9mIGAwLjVgIHdpbGwgaGFsdmUgdGhlIHVzZXIncyBsb3VkbmVzcy4gQSBnYWluIG9mIGAwLjBgIHdpbGwgZWZmZWN0aXZlbHkgbXV0ZSB0aGUgdXNlci5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBJZiB0aGlzIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGUgUHJvbWlzZSB3aWxsIHJlc29sdmUgd2l0aCB7QGxpbmsgU2V0T3RoZXJVc2VyR2FpbkZvclRoaXNDb25uZWN0aW9uUmVzcG9uc2V9IHdpdGggYHN1Y2Nlc3NgIGVxdWFsIHRvIGB0cnVlYC5cbiAgICAgKiBJZiB1bnN1Y2Nlc3NmdWwsIHRoZSBQcm9taXNlIHdpbGwgcmVqZWN0IHdpdGgge0BsaW5rIFNldE90aGVyVXNlckdhaW5Gb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlfSB3aXRoIGBzdWNjZXNzYCBlcXVhbCB0byBgZmFsc2VgIGFuZCBgZXJyb3JgIHNldCB0byBhbiBlcnJvciBtZXNzYWdlIGRlc2NyaWJpbmcgd2hhdCB3ZW50IHdyb25nLlxuICAgICAqL1xuICAgIGFzeW5jIHNldE90aGVyVXNlckdhaW5Gb3JUaGlzQ29ubmVjdGlvbih2aXNpdElkSGFzaDogc3RyaW5nLCBnYWluOiBudW1iZXIpOiBQcm9taXNlPFNldE90aGVyVXNlckdhaW5Gb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlPiB7XG4gICAgICAgIGxldCBvdGhlclVzZXJHYWluTWFwOiBPdGhlclVzZXJHYWluTWFwID0ge307XG4gICAgICAgIG90aGVyVXNlckdhaW5NYXBbdmlzaXRJZEhhc2hdID0gZ2FpbjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvbihvdGhlclVzZXJHYWluTWFwKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIGdhaW4gb2Ygb25lIG9yIG1vcmUgdXNlcnMgZm9yIHRoaXMgY29tbXVuaWNhdG9yJ3MgY3VycmVudCBjb25uZWN0aW9uIG9ubHkuXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGEgbW9yZSBjb21mb3J0YWJsZSBsaXN0ZW5pbmcgZXhwZXJpZW5jZSBmb3IgdGhlIGNsaWVudC4gSWYgeW91IG5lZWQgdG8gcGVyZm9ybSBtb2RlcmF0aW9uIGFjdGlvbnMgb24gdGhlIHNlcnZlciBzaWRlLCB1c2UgdGhlIHtAbGluayBodHRwczovL2RvY3MuaGlnaGZpZGVsaXR5LmNvbS9yZXN0L2xhdGVzdC9pbmRleC5odG1sfEFkbWluaXN0cmF0aXZlIFJFU1QgQVBJfS5cbiAgICAgKiBcbiAgICAgKiBUbyB1c2UgdGhpcyBjb21tYW5kLCB0aGUgY29tbXVuaWNhdG9yIG11c3QgY3VycmVudGx5IGJlIGNvbm5lY3RlZCB0byBhIHNwYWNlLiBZb3UgY2FuIGNvbm5lY3QgdG8gYSBzcGFjZSB1c2luZyB7QGxpbmsgY29ubmVjdFRvSGlGaUF1ZGlvQVBJU2VydmVyfS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gb3RoZXJVc2VyR2Fpbk1hcCAgVGhlIG1hcCBiZXR3ZWVuIGhhc2hlZCB2aXNpdCBJRHMgYW5kIHRoZSBkZXNpcmVkIGFkanVzdGVkIGdhaW5zIG9mIHVzZXJzIGZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIHRoaXMgY2xpZW50LCBmb3IgdGhpcyBjb25uZWN0aW9uIG9ubHkuXG4gICAgICogXG4gICAgICogVXNlIHtAbGluayBhZGRVc2VyRGF0YVN1YnNjcmlwdGlvbn0gYW5kIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLm9uVXNlcnNEaXNjb25uZWN0ZWR9IHRvIGtlZXAgdHJhY2sgb2YgdGhlIGhhc2hlZCB2aXNpdCBJRHMgb2YgY3VycmVudGx5IGNvbm5lY3RlZCB1c2Vycy5cbiAgICAgKiBcbiAgICAgKiBXaGVuIHlvdSBzdWJzY3JpYmUgdG8gdXNlciBkYXRhLCB5b3Ugd2lsbCBnZXQgYSBsaXN0IG9mIHtAbGluayBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGF9IG9iamVjdHMsIHdoaWNoIGVhY2ggY29udGFpbiwgYXQgbWluaW11bSwge0BsaW5rIFJlY2VpdmVkSGlmaUF1ZGlvQVBJRGF0YS5oYXNoZWRWaXNpdElEfXMgYW5kIHtAbGluayBSZWNlaXZlZEhpZmlBdWRpb0FQSURhdGEucHJvdmlkZWRVc2VySUR9cyBmb3IgZWFjaCB1c2VyIGluIHRoZSBzcGFjZS4gQnkgaW5zcGVjdGluZyBlYWNoIG9mIHRoZXNlIG9iamVjdHMsIHlvdSBjYW4gYXNzb2NpYXRlIGEgdXNlciB3aXRoIHRoZWlyIGhhc2hlZCB2aXNpdCBJRCwgaWYgeW91IGtub3cgdGhlaXIgcHJvdmlkZWQgdXNlciBJRC5cbiAgICAgKiBcbiAgICAgKiBUaGUgcmVsYXRpdmUgZ2FpbiB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIG90aGVyIHVzZXIgd2l0aCB0aGUgbWF0Y2hpbmcgaGFzaGVkIHZpc2l0IElELiBCeSBkZWZhdWx0LCB0aGlzIGlzIGAxLjBgLiBUaGUgZ2FpbiBjYW4gYmUgYW55IHZhbHVlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gYDAuMGAuXG4gICAgICogRm9yIGV4YW1wbGU6IGEgZ2FpbiBvZiBgMi4wYCB3aWxsIGRvdWJsZSB0aGUgbG91ZG5lc3Mgb2YgdGhlIHVzZXIsIHdoaWxlIGEgZ2FpbiBvZiBgMC41YCB3aWxsIGhhbHZlIHRoZSB1c2VyJ3MgbG91ZG5lc3MuIEEgZ2FpbiBvZiBgMC4wYCB3aWxsIGVmZmVjdGl2ZWx5IG11dGUgdGhlIHVzZXIuXG4gICAgICogXG4gICAgICogQHJldHVybnMgSWYgdGhpcyBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bCwgdGhlIFByb21pc2Ugd2lsbCByZXNvbHZlIHdpdGgge0BsaW5rIFNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb25SZXNwb25zZX0gd2l0aCBgc3VjY2Vzc2AgZXF1YWwgdG8gYHRydWVgLlxuICAgICAqIElmIHVuc3VjY2Vzc2Z1bCwgdGhlIFByb21pc2Ugd2lsbCByZWplY3Qgd2l0aCB7QGxpbmsgU2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlfSB3aXRoIGBzdWNjZXNzYCBlcXVhbCB0byBgZmFsc2VgIGFuZCBgZXJyb3JgIHNldCB0byBhbiBlcnJvciBtZXNzYWdlIGRlc2NyaWJpbmcgd2hhdCB3ZW50IHdyb25nLlxuICAgICAqL1xuICAgIGFzeW5jIHNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb24ob3RoZXJVc2VyR2Fpbk1hcDogT3RoZXJVc2VyR2Fpbk1hcCk6IFByb21pc2U8U2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlPiB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEuX290aGVyVXNlckdhaW5RdWV1ZSwgb3RoZXJVc2VyR2Fpbk1hcCk7XG5cbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgc3VjY2VzczogcmVzdWx0LnN1Y2Nlc3MsXG4gICAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIGZyb20gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJLiBBZnRlciB0aGlzIGNhbGwsIHVzZXIgZGF0YSB3aWxsIG5vIGxvbmdlciBiZSB0cmFuc21pdHRlZCB0byBIaWdoIEZpZGVsaXR5LCB0aGUgYXVkaW9cbiAgICAgKiBpbnB1dCBzdHJlYW0gd2lsbCBub3QgYmUgdHJhbnNtaXR0ZWQgdG8gSGlnaCBGaWRlbGl0eSwgYW5kIHRoZSB1c2VyIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gaGVhciB0aGUgYXVkaW8gc3RyZWFtIGZyb20gSGlnaCBGaWRlbGl0eS5cbiAgICAgKi9cbiAgICBhc3luYyBkaXNjb25uZWN0RnJvbUhpRmlBdWRpb0FQSVNlcnZlcigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBpZiAoIXRoaXMuX21peGVyU2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShgTm8gbWl4ZXIgc2Vzc2lvbiBmcm9tIHdoaWNoIHdlIGNhbiBkaXNjb25uZWN0IWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5wdXRBdWRpb01lZGlhU3RyZWFtID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9uVXNlcnNEaXNjb25uZWN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3VzZXJEYXRhU3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YSA9IG5ldyBIaUZpQXVkaW9BUElEYXRhKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21peGVyU2Vzc2lvbi5kaXNjb25uZWN0RnJvbUhpRmlNaXhlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBmaW5hbCBtaXhlZCBhdWRpbyBgTWVkaWFTdHJlYW1gIGNvbWluZyBmcm9tIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIFNlcnZlci5cbiAgICAgKi9cbiAgICBnZXRPdXRwdXRBdWRpb01lZGlhU3RyZWFtKCk6IE1lZGlhU3RyZWFtIHtcbiAgICAgICAgaWYgKHRoaXMuX21peGVyU2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21peGVyU2Vzc2lvbi5nZXRPdXRwdXRBdWRpb01lZGlhU3RyZWFtKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBjb25uZWN0aW9uIHRvIEhpZ2ggRmlkZWxpdHksIGFzIG9uZSBvZiB0aGUgSGlGaUNvbm5lY3Rpb25TdGF0ZXMuXG4gICAgICogVGhpcyB3aWxsIHJldHVybiBudWxsIGlmIHRoZSBjdXJyZW50IHN0YXRlIGlzIG5vdCBhdmFpbGFibGUgKGUuZy4gaWYgdGhlIEhpRmlDb21tdW5pY2F0b3JcbiAgICAgKiBpcyBzdGlsbCBpbiB0aGUgcHJvY2VzcyBvZiBpbml0aWFsaXppbmcgaXRzIHVuZGVybHlpbmcgSGlGaU1peGVyU2Vzc2lvbikuXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdGlvblN0YXRlKCk6IEhpRmlDb25uZWN0aW9uU3RhdGVzIHtcbiAgICAgICAgaWYgKHRoaXMuX21peGVyU2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21peGVyU2Vzc2lvbi5nZXRDdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBmdW5jdGlvbiB0byBzZXQgdGhlIGBNZWRpYVN0cmVhbWAgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyLiBUaGlzIGBNZWRpYVN0cmVhbWAgd2lsbCBiZSBzZW50IHVwIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIFNlcnZlcnMgYW5kXG4gICAgICogbWl4ZWQgd2l0aCBvdGhlciB1c2VycycgYXVkaW8gc3RyZWFtcy4gVGhlIHJlc3VsdGFudCBtaXhlZCBzdHJlYW0gd2lsbCBiZSBzZW50IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cy5cbiAgICAgKlxuICAgICAqICoqQmUgbWluZGZ1bCoqIG9mIHN1cHBseWluZyB0aGlzIHN0cmVhbSB1cG9uIGluaXRpYWwgY29ubmVjdGlvbiB3aGVuIHlvdSBhbnRpY2lwYXRlIHRoYXQgdGhlIHVzZXIgaXMgdXNpbmcgQmx1ZXRvb3RoIGF1ZGlvXG4gICAgICogaW5wdXQgYW5kIEJsdWV0b290aCBhdWRpbyBvdXRwdXQgc2ltdWx0YW5lb3VzbHkuIE1hbnkgQmx1ZXRvb3RoIGF1ZGlvIGRldmljZXMgZG8gbm90IHN1cHBvcnQgc3RlcmVvIChzcGF0aWFsaXplZCkgYXVkaW9cbiAgICAgKiBvdXRwdXQgYW5kIG1pY3JvcGhvbmUgYXVkaW8gaW5wdXQgc2ltdWx0YW5lb3VzbHksIGluY2x1ZGluZyB0aGUgcG9wdWxhciBjb21iaW5hdGlvbiBvZiBhbiBpUGhvbmUgYW5kIEFpclBvZHMuXG4gICAgICogWW91ciB1c2VycyBtYXkgaGF2ZSBhIGJldHRlciBleHBlcmllbmNlIGlmIHRoZXkgam9pbiB0aGUgU2VydmVyIGluIFwibGlzdGVuLW9ubHlcIiBtb2RlIC0gaS5lLiB3aXRob3V0IG1pY3JvcGhvbmUgaW5wdXQgLSBhbmQgdGhlblxuICAgICAqIGFyZSBhc2tlZCBmb3IgbWljcm9waG9uZSBwZXJtaXNzaW9uIGxhdGVyICh3aGljaCB3aWxsIGZvcmNlIHRoZWlyIEJsdWV0b290aCBvdXRwdXQgZGV2aWNlIGludG8gYSBsb3dlci1xdWFsaXR5LCB1bnNwYXRpYWxpemVkIG1vbm8gbW9kZSkuXG4gICAgICogXG4gICAgICogQHBhcmFtIG5ld0lucHV0QXVkaW9NZWRpYVN0cmVhbSAtIFRoZSBuZXcgYE1lZGlhU3RyZWFtYCB0byBzZW5kIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIFNlcnZlci4gSWYgdGhpc1xuICAgICAqIGlzIHNldCB0byBhbiBgdW5kZWZpbmVkYCB2YWx1ZSwgdGhlIGV4aXN0aW5nIGlucHV0IHN0cmVhbSAoaWYgb25lIGlzIHNldCkgd2lsbCBiZSBjbGVhcmVkLlxuICAgICAqIEBwYXJhbSBpc1N0ZXJlbyAtIGB0cnVlYCBpZiB0aGUgaW5wdXQgc3RyZWFtIHNob3VsZCBiZSB0cmVhdGVkIGFzIHN0ZXJlbywgYGZhbHNlYCBmb3IgbW9ubyAoZGVmYXVsdCkuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBuZXcgYE1lZGlhU3RyZWFtYCB3YXMgc3VjY2Vzc2Z1bGx5IHNldCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgYXN5bmMgc2V0SW5wdXRBdWRpb01lZGlhU3RyZWFtKG5ld0lucHV0QXVkaW9NZWRpYVN0cmVhbTogTWVkaWFTdHJlYW0sIGlzU3RlcmVvOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgcmV0dmFsID0gYXdhaXQgdGhpcy5fbWl4ZXJTZXNzaW9uLnNldFJBVklJbnB1dEF1ZGlvKG5ld0lucHV0QXVkaW9NZWRpYVN0cmVhbSwgaXNTdGVyZW8pO1xuICAgICAgICBpZiAocmV0dmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW0gPSBuZXdJbnB1dEF1ZGlvTWVkaWFTdHJlYW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYEVycm9yIHRyeWluZyB0byBzZXRSQVZJSW5wdXRBdWRpbyBvbiB0aGlzLl9taXhlclNlc3Npb25gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHNldCB3aGV0aGVyIGlucHV0IGF1ZGlvIHN0cmVhbSB3aWxsIGhhdmUgdGhlIGBlbmFibGVkYCBwcm9wZXJ0eSBvZiBlYWNoIG9mIGl0cyBgTWVkaWFTdHJlYW1UcmFja2BzIHNldCB0byBgZmFsc2VgXG4gICAgICogKGFuZCBhbiB1bm11dGVkIHN0cmVhbSAtLSB0aGUgZGVmYXVsdCAtLSB3aWxsIGhhdmUgdGhlIGBlbmFibGVkYCBwcm9wZXJ0eSBzZXQgdG8gYHRydWVgKS4gVGhpcyB3aWxsIHNpbGVuY2UgdGhlIGlucHV0LFxuICAgICAqIGJ1dCBoYXMgc3BlY2lmaWMgY29uc2VxdWVuY2VzOlxuICAgICAqICAgLSBJZiB5b3UgYXJlIHVzaW5nIHRoZSBzYW1lIGBNZWRpYVN0cmVhbWAgb2JqZWN0IGluIG90aGVyIHdheXMsIGl0IHdpbGwgYmUgYWZmZWN0ZWQgYnlcbiAgICAgKiBjYWxsaW5nIHRoaXMgbWV0aG9kLiBTbywgaWYgeW91IHdvdWxkIGxpa2UgdG8gbXV0ZS91bm11dGUgdGhlIGlucHV0IGF1ZGlvIHN0cmVhbSBzZXBhcmF0ZWx5IGZvciB0aGVcbiAgICAgKiBIaWdoIEZpZGVsaXR5IGF1ZGlvIHZzLiBzb21lIG90aGVyIHVzZSBvZiBpdCwgaXQgaXMgcmVjb21tZW5kZWQgdG8gY2xvbmUgdGhlIGF1ZGlvIHN0cmVhbSBzZXBhcmF0ZWx5XG4gICAgICogZm9yIGVhY2ggdXNlLlxuICAgICAqICAgLSBUaGUgZWZmZWN0IGlzIGltbWVkaWF0ZSBhbmQgY291bGQgcmVzdWx0IGluIGEgY2xpY2sgb3Igb3RoZXIgYXVkaW8gYXJ0aWZhY3QgaWYgdGhlcmUgaXMgc3RlYWR5IHNvdW5kIGF0XG4gICAgICogdGhlIG1vbWVudCB0aGUgaW5wdXQgaXMgbXV0ZWQuXG4gICAgICpcbiAgICAgKiBBbiBhbHRlcmF0aXZlIGlzIHRvIHNldCB0aGUgdXNlcidzIHtAbGluayB2b2x1bWVUaHJlc2hvbGR9IHRvIDAsIHdoaWNoIHNtb290aGx5IGdhdGVzIG9mZiB0aGUgdXNlcidzIGlucHV0LlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3RyZWFtIHdhcyBzdWNjZXNzZnVsbHkgbXV0ZWQvdW5tdXRlZCwgYGZhbHNlYCBpZiBpdCB3YXMgbm90LiAoVGhlIHVzZXIgc2hvdWxkXG4gICAgICogYXNzdW1lIHRoYXQgaWYgdGhpcyByZXR1cm5zIGBmYWxzZWAsIG5vIGNoYW5nZSB3YXMgbWFkZSB0byB0aGUgbXV0ZSAodHJhY2sgZW5hYmxlZCkgc3RhdGUgb2YgdGhlIHN0cmVhbS4pXG4gICAgICovXG4gICAgYXN5bmMgc2V0SW5wdXRBdWRpb011dGVkKGlzTXV0ZWQ6IGJvb2xlYW4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgaWYgKHRoaXMuX21peGVyU2Vzc2lvbikge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5kZWJ1ZyhgU2V0dGluZyBtdXRlIHN0YXRlIHRvIDogJHtpc011dGVkfWApO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX21peGVyU2Vzc2lvbi5zZXRJbnB1dEF1ZGlvTXV0ZWQoaXNNdXRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYENvdWxkbid0IHNldCBtdXRlIHN0YXRlOiBObyBcXGBfbWl4ZXJTZXNzaW9uXFxgLmApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgQSBidW5jaCBvZiBpbmZvIGFib3V0IHRoaXMgYEhpRmlDb21tdW5pY2F0b3JgIGluc3RhbnRpYXRpb24sIGluY2x1ZGluZyBTZXJ2ZXIgVmVyc2lvbi5cbiAgICAgKi9cbiAgICBnZXRDb21tdW5pY2F0b3JJbmZvKCk6IGFueSB7XG4gICAgICAgIGxldCByZXR2YWw6IGFueSA9IHtcbiAgICAgICAgICAgIFwiY2xpZW50SW5mb1wiOiB7XG4gICAgICAgICAgICAgICAgXCJpbnB1dEF1ZGlvU3RyZWFtU2V0XCI6ICEhdGhpcy5faW5wdXRBdWRpb01lZGlhU3RyZWFtLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBpc0Jyb3dzZXJDb250ZXh0ID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAoaXNCcm93c2VyQ29udGV4dCAmJiB0eXBlb2YgKEhJRklfQVBJX1ZFUlNJT04pID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR2YWwuY2xpZW50SW5mb1tcImFwaVZlcnNpb25cIl0gPSBISUZJX0FQSV9WRVJTSU9OO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21peGVyU2Vzc2lvbiAmJiB0aGlzLl9taXhlclNlc3Npb24ubWl4ZXJJbmZvKSB7XG4gICAgICAgICAgICByZXR2YWxbXCJzZXJ2ZXJJbmZvXCJdID0gdGhpcy5fbWl4ZXJTZXNzaW9uLm1peGVySW5mbztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgY29sbGVjdGluZyBkYXRhIGFib3V0IHRoZSBXZWJSVEMgY29ubmVjdGlvbiBiZXR3ZWVuIENsaWVudCBhbmQgU2VydmVyLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgZGF0YSBpbnNpZGUgdGhlIHJlcG9ydHMgcGVydGFpbnMgb25seSB0byBwYXlsb2FkIGRhdGEgaW50ZXJuYWwgdG8gdGhlIFdlYlJUQyBjb25uZWN0aW9uXG4gICAgICogYW5kIGRvZXMgbm90IGluY2x1ZGUgX3RvdGFsXyBkYXRhIHNlbnQgb3ZlciB0aGUgd2lyZSBvciByZWNlaXZlZCBvdmVyIHRoZSB3aXJlIGluIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9ucyB3aWxsIGJlIHByb3ZpZGVkIHR3byBBcnJheSBhcmd1bWVudHM6IGBzdGF0c2AgYW5kIGBwcmV2U3RhdHNgLlxuICAgICAqIEVhY2ggb2YgdGhvc2UgQXJyYXkgaXRlbXMgY29udGFpbnMgb25lIG9yIG1vcmUgT2JqZWN0cywgd2hpY2ggYXJlIHJlcG9ydHMgb2YgV2ViUlRDIHN0YXRzIGRhdGEsXG4gICAgICogaW5jbHVkaW5nIGRhdGEgc3VjaCBhcyBcImEgdGltZXN0YW1wXCIsIFwidGhlIG51bWJlciBvZiBieXRlcyByZWNlaXZlZCBzaW5jZSB0aGUgbGFzdCByZXBvcnRcIiBhbmQgXCJjdXJyZW50IGppdHRlciBidWZmZXIgZGVsYXlcIi5cbiAgICAgKi9cbiAgICBzdGFydENvbGxlY3RpbmdXZWJSVENTdGF0cyhjYWxsYmFjazogRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9taXhlclNlc3Npb24pIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYENvdWxkbid0IHN0YXJ0IGNvbGxlY3RpbmcgV2ViUlRDIFN0YXRzOiBObyBcXGBfbWl4ZXJTZXNzaW9uXFxgIWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWl4ZXJTZXNzaW9uLnN0YXJ0Q29sbGVjdGluZ1dlYlJUQ1N0YXRzKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGNvbGxlY3RpbmcgZGF0YSBhYm91dCB0aGUgV2ViUlRDIGNvbm5lY3Rpb24gYmV0d2VlbiBDbGllbnQgYW5kIFNlcnZlci5cbiAgICAgKi9cbiAgICBzdG9wQ29sbGVjdGluZ1dlYlJUQ1N0YXRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21peGVyU2Vzc2lvbikge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgQ291bGRuJ3Qgc3RvcCBjb2xsZWN0aW5nIFdlYlJUQyBTdGF0czogTm8gXFxgX21peGVyU2Vzc2lvblxcYCFgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21peGVyU2Vzc2lvbi5zdG9wQ29sbGVjdGluZ1dlYlJUQ1N0YXRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgY29weSBvZiB0aGUgVXNlciBEYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBjbGllbnQuIERvZXMgKipOT1QqKiB1cGRhdGVcbiAgICAgKiB0aGUgdXNlciBkYXRhIG9uIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBzZXJ2ZXIuIFRoZXJlIGFyZSBubyBnb29kIHJlYXNvbnMgZm9yIGEgY2xpZW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvblxuICAgICAqIGFuZCBfbm90XyB1cGRhdGUgdGhlIHNlcnZlciBVc2VyIERhdGEsIGFuZCB0aHVzIHRoaXMgZnVuY3Rpb24gaXMgYHByaXZhdGVgLlxuICAgICAqIFxuICAgICAqIFlvdSBjYW4gdXBkYXRlIHVzZXIgb3JpZW50YXRpb24gYnkgcGFzc2luZyBRdWF0ZXJuaW9uIG9yIEV1bGVyIG9yaWVudGF0aW9uIHJlcHJlc2VudGF0aW9ucyB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICogVGhlIHF1YXRlcm5pb24gcmVwcmVzZW50YXRpb24gaXMgcHJlZmVycmVkLlxuICAgICAqIElmIGJvdGggcmVwcmVzZW50YXRpb24gYXJlIHByb3ZpZGVkLCB0aGUgZXVsZXIgcmVwcmVzZW50YXRpb24gaXMgaWdub3JlZC5cbiAgICAgKiBJZiBvbmx5IHRoZSBldWxlciByZXByZXNlbnRhdGlvbiBpcyBwcm92aWRlZCwgaXQgaXMgdGhlbiBjb252ZXJ0ZWQgaW1tZWRpYXRlbHkgdG8gdGhlIGVxdWl2YWxlbnQgcXVhdGVybmlvbiByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBUaGUgZXVsZXJPcmRlciB1c2VkIGZvciB0aGUgY29udmVyc2lvbiBpcyB0aGUgcHJvdmlkZWQgYnkgdGhlICdvdXJBeGlzQ29uZmlndXJhdGlvbi5ldWxlck9yZGVyJy5cbiAgICAgKiBFdWxlciByZXByZXNlbnRhdGlvbiBpcyBub3QgdXNlZCBpbnRlcm5hbGx5IGFueW1vcmUgaW4gdGhlIEhpZmkgQVBJLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBfX25hbWVkUGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAtIFRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9yaWVudGF0aW9uUXVhdCAtIFRoZSBuZXcgb3JpZW50YXRpb25RdWF0IG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcmllbnRhdGlvbkV1bGVyIC0gVGhlIG5ldyBvcmllbnRhdGlvbkV1bGVyIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSB2b2x1bWVUaHJlc2hvbGQgLSBUaGUgbmV3IHZvbHVtZVRocmVzaG9sZCBvZiB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gaGlGaUdhaW4gLSBUaGlzIHZhbHVlIGFmZmVjdHMgaG93IGxvdWQgVXNlciBBIHdpbGwgc291bmQgdG8gVXNlciBCIGF0IGEgZ2l2ZW4gZGlzdGFuY2UgaW4gM0Qgc3BhY2UuXG4gICAgICogVGhpcyB2YWx1ZSBhbHNvIGFmZmVjdHMgdGhlIGRpc3RhbmNlIGF0IHdoaWNoIFVzZXIgQSBjYW4gYmUgaGVhcmQgaW4gM0Qgc3BhY2UuXG4gICAgICogSGlnaGVyIHZhbHVlcyBmb3IgVXNlciBBIG1lYW5zIHRoYXQgVXNlciBBIHdpbGwgc291bmQgbG91ZGVyIHRvIG90aGVyIHVzZXJzIGFyb3VuZCBVc2VyIEEsIGFuZCBpdCBhbHNvIG1lYW5zIHRoYXQgVXNlciBBIHdpbGwgYmUgYXVkaWJsZSBmcm9tIGEgZ3JlYXRlciBkaXN0YW5jZS5cbiAgICAgKiBUaGUgbmV3IGhpRmlHYWluIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSB1c2VyQXR0ZW51YXRpb24gLSBUaGlzIHZhbHVlIGFmZmVjdHMgaG93IGZhciBhIHVzZXIncyB2b2ljZSB3aWxsIHRyYXZlbCBpbiAzRCBzcGFjZS5cbiAgICAgKiBUaGUgbmV3IGF0dGVudWF0aW9uIHZhbHVlIGZvciB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gdXNlclJvbGxvZmYgLSBUaGlzIHZhbHVlIGFmZmVjdHMgdGhlIGZyZXF1ZW5jeSByb2xsb2ZmIGZvciBhIGdpdmVuIHVzZXIuXG4gICAgICogVGhlIG5ldyByb2xsb2ZmIHZhbHVlIGZvciB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBwcml2YXRlIF91cGRhdGVVc2VyRGF0YSh7IHBvc2l0aW9uLCBvcmllbnRhdGlvblF1YXQsIG9yaWVudGF0aW9uRXVsZXIsIHZvbHVtZVRocmVzaG9sZCwgaGlGaUdhaW4sIHVzZXJBdHRlbnVhdGlvbiwgdXNlclJvbGxvZmYgfTogeyBwb3NpdGlvbj86IFBvaW50M0QsIG9yaWVudGF0aW9uRXVsZXI/OiBPcmllbnRhdGlvbkV1bGVyM0QsIG9yaWVudGF0aW9uUXVhdD86IE9yaWVudGF0aW9uUXVhdDNELCB2b2x1bWVUaHJlc2hvbGQ/OiBudW1iZXIsIGhpRmlHYWluPzogbnVtYmVyLCB1c2VyQXR0ZW51YXRpb24/OiBudW1iZXIsIHVzZXJSb2xsb2ZmPzogbnVtYmVyIH0gPSB7fSk6IHZvaWQge1xuICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbiA9IG5ldyBQb2ludDNEKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnggPSBwb3NpdGlvbi54ID8/IHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLng7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi55ID0gcG9zaXRpb24ueSA/PyB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi55O1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24ueiA9IHBvc2l0aW9uLnogPz8gdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24uejtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvblF1YXQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0ID0gbmV3IE9yaWVudGF0aW9uUXVhdDNEKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC53ID0gb3JpZW50YXRpb25RdWF0LncgPz8gdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0Lnc7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueCA9IG9yaWVudGF0aW9uUXVhdC54ID8/IHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC54O1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnkgPSBvcmllbnRhdGlvblF1YXQueSA/PyB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC56ID0gb3JpZW50YXRpb25RdWF0LnogPz8gdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0Lno7XG4gICAgICAgIH0gXG4gICAgICAgIC8vIGlmIG9yaWVudGF0aW9uIGlzIHByb3ZpZGVkIGFzIGFuIGV1bGVyIGZvcm1hdCwgdGhlbiBkbyB0aGUgY29udmVyc2lvbiBpbW1lZGlhdGVseVxuICAgICAgICBlbHNlIGlmIChvcmllbnRhdGlvbkV1bGVyKSB7XG4gICAgICAgICAgICBsZXQgY2hlY2tlZEV1bGVyID0gbmV3IE9yaWVudGF0aW9uRXVsZXIzRChvcmllbnRhdGlvbkV1bGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdCA9IGV1bGVyVG9RdWF0ZXJuaW9uKGNoZWNrZWRFdWxlciwgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLmV1bGVyT3JkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiAodm9sdW1lVGhyZXNob2xkKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEudm9sdW1lVGhyZXNob2xkID0gdm9sdW1lVGhyZXNob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGhpRmlHYWluKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEuaGlGaUdhaW4gPSBNYXRoLm1heCgwLCBoaUZpR2Fpbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodXNlckF0dGVudWF0aW9uKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEudXNlckF0dGVudWF0aW9uID0gdXNlckF0dGVudWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHVzZXJSb2xsb2ZmKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEudXNlclJvbGxvZmYgPSBNYXRoLm1heCgwLCB1c2VyUm9sbG9mZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNsaWVudHNpZGUgcmF0ZSBsaW1pdCB0aW1lb3V0IHVzZWQgdG8gcHJldmVudCB1c2VyIGRhdGEgZnJvbSBiZWluZyBzZW50IHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBzZXJ2ZXIgdG9vIG9mdGVuLlxuICAgICAqL1xuICAgIHByaXZhdGUgX21heWJlQ2xlYXJSYXRlTGltaXRUaW1lb3V0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fdGltZXJzLnRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVycy50cmFuc21pdFJhdGVMaW1pdFRpbWVvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdGltZXJzLnRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2Uga2VlcCBhIGNsaWVudHNpZGUgY29weSBvZiB0aGUgZGF0YSB0aGF0IHdlIGxhc3QgdHJhbnNtaXR0ZWQgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIHNlcnZlci4gV2UgdXNlIHRoaXMgZGF0YSB0b1xuICAgICAqIGVuc3VyZSB0aGF0IHdlIG9ubHkgc2VuZCB0byB0aGUgc2VydmVyIHRoZSBtaW5pbXVtIHNldCBvZiBkYXRhIG5lY2Vzc2FyeSAtIGkuZS4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZGF0YSBjb250YWluZWQgb24gdGhlIHNlcnZlclxuICAgICAqIGFib3V0IHRoZSB1c2VyIGFuZCB0aGUgbmV3IGRhdGEgdGhhdCB0aGUgY2xpZW50IGhhcyBsb2NhbGx5LiBXZSB1c2UgdGhpcyBmdW5jdGlvbiBoZXJlIHRvIHVwZGF0ZSB0aGUgY2xpZW50c2lkZSBjb3B5IG9mIHRoZSBkYXRhXG4gICAgICogdGhhdCB3ZSBsYXN0IHRyYW5zbWl0dGVkLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBkYXRhSnVzdFRyYW5zbWl0dGVkIC0gVGhlIGRhdGEgdGhhdCB3ZSBqdXN0IHRyYW5zbWl0dGVkIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBzZXJ2ZXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfdXBkYXRlTGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YShkYXRhSnVzdFRyYW5zbWl0dGVkOiBIaUZpQXVkaW9BUElEYXRhKTogdm9pZCB7XG4gICAgICAgIGlmIChkYXRhSnVzdFRyYW5zbWl0dGVkLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uID0gbmV3IFBvaW50M0QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi54ID0gZGF0YUp1c3RUcmFuc21pdHRlZC5wb3NpdGlvbi54ID8/IHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24ueDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24ueSA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQucG9zaXRpb24ueSA/PyB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnogPSBkYXRhSnVzdFRyYW5zbWl0dGVkLnBvc2l0aW9uLnogPz8gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi56O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGFKdXN0VHJhbnNtaXR0ZWQub3JpZW50YXRpb25RdWF0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQgPSBuZXcgT3JpZW50YXRpb25RdWF0M0QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQudyA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQub3JpZW50YXRpb25RdWF0LncgPz8gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQudztcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnggPSBkYXRhSnVzdFRyYW5zbWl0dGVkLm9yaWVudGF0aW9uUXVhdC54ID8/IHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0Lng7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC55ID0gZGF0YUp1c3RUcmFuc21pdHRlZC5vcmllbnRhdGlvblF1YXQueSA/PyB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC55O1xuICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueiA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQub3JpZW50YXRpb25RdWF0LnogPz8gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQuejtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgKGRhdGFKdXN0VHJhbnNtaXR0ZWQudm9sdW1lVGhyZXNob2xkKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YVtcInZvbHVtZVRocmVzaG9sZFwiXSA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQudm9sdW1lVGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiAoZGF0YUp1c3RUcmFuc21pdHRlZC5oaUZpR2FpbikgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGFbXCJoaUZpR2FpblwiXSA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQuaGlGaUdhaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoZGF0YUp1c3RUcmFuc21pdHRlZC51c2VyQXR0ZW51YXRpb24pID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhW1widXNlckF0dGVudWF0aW9uXCJdID0gZGF0YUp1c3RUcmFuc21pdHRlZC51c2VyQXR0ZW51YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoZGF0YUp1c3RUcmFuc21pdHRlZC51c2VyUm9sbG9mZikgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGFbXCJ1c2VyUm9sbG9mZlwiXSA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQudXNlclJvbGxvZmY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoZGF0YUp1c3RUcmFuc21pdHRlZC5fb3RoZXJVc2VyR2FpblF1ZXVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZih0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWUpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5fb3RoZXJVc2VyR2FpblF1ZXVlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkVG9HYWluIG9mIE9iamVjdC5lbnRyaWVzKGRhdGFKdXN0VHJhbnNtaXR0ZWQuX290aGVyVXNlckdhaW5RdWV1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWVbaWRUb0dhaW5bMF1dID0gaWRUb0dhaW5bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIHRoZSBsb2NhbCB1c2VyIGRhdGEgcHJvcGVybHksIHRoZW4gc2VuZHMgdGhhdCB1c2VyIGRhdGEgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIHNlcnZlci4gVGhpcyB0cmFuc2ZlciBpcyByYXRlIGxpbWl0ZWQuXG4gICAgICogXG4gICAgICogVGhlcmUgaXMgbm8gcmVhc29uIGEgbGlicmFyeSB1c2VyIHdvdWxkIG5lZWQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHdpdGhvdXQgYWxzbyBzaW11bHRhbmVvdXNseSB1cGRhdGluZyBVc2VyIERhdGEsIHNvIHRoaXMgZnVuY3Rpb24gaXMgYHByaXZhdGVgLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBmb3JjZVRyYW5zbWl0IC0gYHRydWVgIGlmIHdlIHNob3VsZCBpZ25vcmUgdGhlIGNsaWVudHNpZGUgcmF0ZSBsaW1pdGVyIGFuZCBzZW5kIHRoZSBkYXRhIHJlZ2FyZGxlc3Mgb2YgaXRzIHN0YXR1czsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICogQHJldHVybnMgSWYgdGhpcyBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bCwgcmV0dXJucyBgeyBzdWNjZXNzOiB0cnVlLCByYXdEYXRhVHJhbnNtaXR0ZWQ6IDx0aGUgcmF3IGRhdGEgdGhhdCB3YXMgdHJhbnNtaXR0ZWQgdG8gdGhlIHNlcnZlcj59YC4gSWYgdW5zdWNjZXNzZnVsLCByZXR1cm5zXG4gICAgICogYHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiA8YW4gZXJyb3IgbWVzc2FnZT4gfWAuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIoZm9yY2VUcmFuc21pdD86IGJvb2xlYW4pOiBhbnkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhIGNhbGxlciBjYW4ndCB0cmFuc21pdCBkYXRhIGZvciBhbm90aGVyIGB0aGlzLnRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dE1TYCBtaWxsaXNlY29uZHMuXG4gICAgICAgIGlmICh0aGlzLl9taXhlclNlc3Npb24gJiYgKCF0aGlzLl90aW1lcnMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0IHx8IGZvcmNlVHJhbnNtaXQpKSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lcnMud2FudGVkVG9UcmFuc21pdEhpRmlBdWRpb0FQSURhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX21heWJlQ2xlYXJSYXRlTGltaXRUaW1lb3V0KCk7XG4gICAgICAgICAgICBpZiAoIWZvcmNlVHJhbnNtaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lcnMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21heWJlQ2xlYXJSYXRlTGltaXRUaW1lb3V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RpbWVycy53YW50ZWRUb1RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzLnRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dE1TKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGF0YSB0byB0cmFuc21pdCwgd2hpY2ggaXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbGFzdCBkYXRhIHdlIHRyYW5zbWl0dGVkXG4gICAgICAgICAgICAvLyBhbmQgdGhlIGN1cnJlbnQgZGF0YSB3ZSBoYXZlIHN0b3JlZC5cbiAgICAgICAgICAgLy8gbGV0IGRlbHRhID0gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5kaWZmKHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhKTtcbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCB0cmFuc2xhdGUgdGhlIG5ldyBgSGlGaUF1ZGlvQVBJRGF0YWAgb2JqZWN0IGZyb20gYWJvdmUgaW50byBzdHJpbmdpZmllZCBKU09OIGRhdGEgaW4gdGhlIHByb3BlciBmb3JtYXQsXG4gICAgICAgICAgICAvLyB0aGVuIHNlbmQgdGhhdCBkYXRhIHRvIHRoZSBtaXhlci5cbiAgICAgICAgICAgIC8vIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmF3IGRhdGEgdGhhdCBpdCBzZW50IHRvIHRoZSBtaXhlci5cbiAgICAgICAgICAgIGxldCB0cmFuc21pdFJldHZhbCA9IHRoaXMuX21peGVyU2Vzc2lvbi5fdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIodGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEsIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEpO1xuICAgICAgICAgICAgaWYgKHRyYW5zbWl0UmV0dmFsLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3cgd2UgaGF2ZSB0byB1cGRhdGUgb3VyIFwibGFzdCB0cmFuc21pdHRlZFwiIGBIaUZpQXVkaW9BUElEYXRhYCBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyB0byBjb250YWluIHRoZSBkYXRhIHRoYXQgd2UganVzdCB0cmFuc21pdHRlZC5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhKHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBpbiBzb21lIGNhc2VzLCBjbGVhbiB1cCBzb21lIG9mIHRoZSB0cmFuc21pdHRlZCBkYXRhIGhpc3RvcnlcbiAgICAgICAgICAgICAgICAvLyAocGFydGljdWxhcmx5LCBfb3RoZXJVc2VyR2FpblF1ZXVlKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFuVXBIaUZpQXVkaW9BUElEYXRhSGlzdG9yeSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmF3RGF0YVRyYW5zbWl0dGVkOiB0cmFuc21pdFJldHZhbC5zdHJpbmdpZmllZERhdGFGb3JNaXhlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdHJhbnNtaXRSZXR2YWwuZXJyb3JcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX21peGVyU2Vzc2lvbiAmJiB0aGlzLl90aW1lcnMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0ICYmICFmb3JjZVRyYW5zbWl0KSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lcnMud2FudGVkVG9UcmFuc21pdEhpRmlBdWRpb0FQSURhdGEgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgVHJhbnNmZXIgaXMgcmF0ZSBsaW1pdGVkLiBUcmFuc2ZlciB3aWxsIG9jY3VyIHNob3J0bHkgYXV0b21hdGljYWxseS5gXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9taXhlclNlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBObyBzZXJ2ZXIgY29ubmVjdGlvbiB5ZXQ7IGNhbid0IHRyYW5zbWl0IHVzZXIgZGF0YS5gXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsbHksIHdlIHRyeSB0byBsaW1pdCB0aGUgYW1vdW50IG9mIGRhdGEgd2UgdHJhbnNtaXQgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIHNlcnZlciwgYnkgcmVtZW1iZXJpbmcgd2hhdCB3ZVxuICAgICAqIHNlbnQuIFNlZSB7QGxpbmsgX3VwZGF0ZVVzZXJEYXRhfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdGhpcyBpcyBkb25lLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBleGlzdHMgdG8gaGFuZGxlIGFueSBzY2VuYXJpb3Mgb2YgcmVtZW1iZXJpbmcgdG9vIG11Y2ggc2VudCBkYXRhLiBJdCBpcyBjYWxsZWQganVzdCBhZnRlciBkYXRhIGlzIHN1Y2Nlc2Z1bGx5IHNlbnQsIHdoZW4gZGF0YSBpcyBrbm93biB0byBubyBsb25nZXIgYmUgbmVlZGVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2NsZWFuVXBIaUZpQXVkaW9BUElEYXRhSGlzdG9yeSgpOiB2b2lkIHtcbiAgICAgICAgLy8gQWx3YXlzIGNsZWFyIF9vdGhlclVzZXJHYWluUXVldWUgaW4gb3VyIGxvY2FsIGRhdGFcbiAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEuX290aGVyVXNlckdhaW5RdWV1ZSA9IHt9O1xuXG4gICAgICAgIGxldCBtYXhDYWNoZWRPdGhlclVzZXJHYWlucyA9IDEwMDA7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWUpLmxlbmd0aCA+IG1heENhY2hlZE90aGVyVXNlckdhaW5zKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWUgPSB7fTtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgU3RvcmVkIFxcYF9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWVcXGAgd2FzIHRvbyBsYXJnZSBhbmQgd2FzIGNsZWFyZWQgdG8gc2F2ZSBzcGFjZS5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGZ1bmN0aW9uIHRoYXQgY2FsbHMge0BsaW5rIF91cGRhdGVVc2VyRGF0YX0sIGZvbGxvd2VkIGJ5IHtAbGluayBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXJ9LlxuICAgICAqIERldmVsb3BlcnMgY2FuIGNhbGwgdGhpcyBmdW5jdGlvbiBhcyBvZnRlbiBhcyB0aGV5IHdhbnQuIFRoaXMgZnVuY3Rpb24gd2lsbCB1cGRhdGUgdGhlIGludGVybmFsIGRhdGEgc3RvcmUgb2YgdGhlIHVzZXInc1xuICAgICAqIHBvc2l0aW9uLCBvcmllbnRhdGlvbiwgZXRjLiBObyBtYXR0ZXIgaG93IG9mdGVuIGRldmVsb3BlcnMgY2FsbCB0aGlzIGZ1bmN0aW9uLCB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSB0cmFuc21pc3Npb24gaXMgcmF0ZS1saW1pdGVkXG4gICAgICogYW5kIHdpbGwgb25seSBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIgb25jZSBldmVyeSBgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVNgIG1pbGxpc2Vjb25kcy4gV2hlbiB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSBpcyB0cmFuc21pdHRlZCxcbiAgICAgKiB0aGUgbW9zdCB1cC10by1kYXRlIGRhdGEgd2lsbCBiZSB0cmFuc21pdHRlZC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gbmV3VXNlckRhdGEgLSBUaGUgbmV3IHVzZXIgZGF0YSB0aGF0IHdlIHdhbnQgdG8gc2VuZCB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgc2VydmVyLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHJldHVybiB2YWx1ZSBvZiB7QGxpbmsgX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyfS5cbiAgICAgKi9cbiAgICB1cGRhdGVVc2VyRGF0YUFuZFRyYW5zbWl0KG5ld1VzZXJEYXRhOiBhbnkpOiBzdHJpbmcge1xuICAgICAgICB0aGlzLl91cGRhdGVVc2VyRGF0YShuZXdVc2VyRGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5nZXN0cyB1c2VyIGRhdGEgdXBkYXRlcyBmcm9tIHRoZSBzZXJ2ZXIgYW5kLCBpZiByZWxldmFudCwgY2FsbHMgdGhlIHJlbGV2YW50IGNhbGxiYWNrIGZ1bmN0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogVXNlciBEYXRhIFN1YnNjcmlwdGlvbnMuIFNlZSB7QGxpbmsgYWRkVXNlckRhdGFTdWJzY3JpcHRpb259LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBuZXdVc2VyRGF0YUZyb21TZXJ2ZXIgLSBDb250YWlucyBhbGwgb2YgdGhlIG5ldyB1c2VyIGRhdGEgbW9zdCByZWNlbnRseSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuIFxuICAgICAqL1xuICAgIHByaXZhdGUgX2hhbmRsZVVzZXJEYXRhVXBkYXRlcyhuZXdVc2VyRGF0YUZyb21TZXJ2ZXI6IEFycmF5PFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YT4pOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX3VzZXJEYXRhU3Vic2NyaXB0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHN1Ykl0ciA9IDA7IHN1Ykl0ciA8IHRoaXMuX3VzZXJEYXRhU3Vic2NyaXB0aW9ucy5sZW5ndGg7IHN1Ykl0cisrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuX3VzZXJEYXRhU3Vic2NyaXB0aW9uc1tzdWJJdHJdO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBib3RoZXIgY29udGludWluZyB0byBkbyBhbnl0aGluZyBpZiB0aGUgZGV2ZWxvcGVyIGRpZG4ndCBzcGVjaWZ5IGEgY2FsbGJhY2sgYXNzb2NpYXRlZFxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgY3VycmVudCBTdWJzY3JpcHRpb24gdGhhdCB3ZSBhcmUgcHJvY2Vzc2luZy5cbiAgICAgICAgICAgIGlmICghY3VycmVudFN1YnNjcmlwdGlvbi5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY3VycmVudFN1YnNjcmlwdGlvbkNhbGxiYWNrRGF0YTogQXJyYXk8UmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhPiA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBkYXRhSXRyID0gMDsgZGF0YUl0ciA8IG5ld1VzZXJEYXRhRnJvbVNlcnZlci5sZW5ndGg7IGRhdGFJdHIrKykge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50RGF0YUZyb21TZXJ2ZXIgPSBuZXdVc2VyRGF0YUZyb21TZXJ2ZXJbZGF0YUl0cl07XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN1YnNjcmlwdGlvbi5wcm92aWRlZFVzZXJJRCAmJiBjdXJyZW50RGF0YUZyb21TZXJ2ZXIucHJvdmlkZWRVc2VySUQgIT09IGN1cnJlbnRTdWJzY3JpcHRpb24ucHJvdmlkZWRVc2VySUQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IG5ld0NhbGxiYWNrRGF0YSA9IG5ldyBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnREYXRhRnJvbVNlcnZlci5wcm92aWRlZFVzZXJJRCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tEYXRhLnByb3ZpZGVkVXNlcklEID0gY3VycmVudERhdGFGcm9tU2VydmVyLnByb3ZpZGVkVXNlcklEO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnREYXRhRnJvbVNlcnZlci5oYXNoZWRWaXNpdElEKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBuZXdDYWxsYmFja0RhdGEuaGFzaGVkVmlzaXRJRCA9IGN1cnJlbnREYXRhRnJvbVNlcnZlci5oYXNoZWRWaXNpdElEO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBzaG91bGRQdXNoTmV3Q2FsbGJhY2tEYXRhID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb21wb25lbnRJdHIgPSAwOyBjb21wb25lbnRJdHIgPCBjdXJyZW50U3Vic2NyaXB0aW9uLmNvbXBvbmVudHMubGVuZ3RoOyBjb21wb25lbnRJdHIrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudENvbXBvbmVudCA9IGN1cnJlbnRTdWJzY3JpcHRpb24uY29tcG9uZW50c1tjb21wb25lbnRJdHJdO1xuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY3VycmVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHMuUG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREYXRhRnJvbVNlcnZlci5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxsYmFja0RhdGEucG9zaXRpb24gPSBjdXJyZW50RGF0YUZyb21TZXJ2ZXIucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFB1c2hOZXdDYWxsYmFja0RhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHMuT3JpZW50YXRpb25RdWF0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RGF0YUZyb21TZXJ2ZXIub3JpZW50YXRpb25RdWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrRGF0YS5vcmllbnRhdGlvblF1YXQgPSBjdXJyZW50RGF0YUZyb21TZXJ2ZXIub3JpZW50YXRpb25RdWF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQdXNoTmV3Q2FsbGJhY2tEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cy5PcmllbnRhdGlvbkV1bGVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSBldWxlciB2ZXJzaW9uIG9mIG9yaWVudGF0aW9uIGlmIHF1YXQgdmVyc2lvbiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudERhdGFGcm9tU2VydmVyLm9yaWVudGF0aW9uUXVhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxsYmFja0RhdGEub3JpZW50YXRpb25FdWxlciA9IGV1bGVyRnJvbVF1YXRlcm5pb24oY3VycmVudERhdGFGcm9tU2VydmVyLm9yaWVudGF0aW9uUXVhdCwgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLmV1bGVyT3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQdXNoTmV3Q2FsbGJhY2tEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXZhaWxhYmxlVXNlckRhdGFTdWJzY3JpcHRpb25Db21wb25lbnRzLlZvbHVtZURlY2liZWxzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnREYXRhRnJvbVNlcnZlci52b2x1bWVEZWNpYmVscykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tEYXRhLnZvbHVtZURlY2liZWxzID0gY3VycmVudERhdGFGcm9tU2VydmVyLnZvbHVtZURlY2liZWxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQdXNoTmV3Q2FsbGJhY2tEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXZhaWxhYmxlVXNlckRhdGFTdWJzY3JpcHRpb25Db21wb25lbnRzLklzU3RlcmVvOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnREYXRhRnJvbVNlcnZlci5pc1N0ZXJlbykgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrRGF0YS5pc1N0ZXJlbyA9IGN1cnJlbnREYXRhRnJvbVNlcnZlci5pc1N0ZXJlbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkUHVzaE5ld0NhbGxiYWNrRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFB1c2hOZXdDYWxsYmFja0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN1YnNjcmlwdGlvbkNhbGxiYWNrRGF0YS5wdXNoKG5ld0NhbGxiYWNrRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFN1YnNjcmlwdGlvbi5jYWxsYmFjayAmJiBjdXJyZW50U3Vic2NyaXB0aW9uQ2FsbGJhY2tEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3Vic2NyaXB0aW9uLmNhbGxiYWNrKGN1cnJlbnRTdWJzY3JpcHRpb25DYWxsYmFja0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBmdW5jdGlvbiBjYWxsZWQgYnkgb3VyIGluc3RhbnRpYXRpb24gb2YgYEhpRmlNaXhlclNlc3Npb25gIHRoYXQgY2FsbHMgdGhlIHVzZXItcHJvdmlkZWQgYG9uVXNlcnNEaXNjb25uZWN0ZWQoKWBcbiAgICAgKiBmdW5jdGlvbiBpZiBvbmUgZXhpc3RzLlxuICAgICAqIExpYnJhcnkgdXNlcnMgY2FuIHByb3ZpZGUgYW4gYG9uVXNlcnNEaXNjb25uZWN0ZWQoKWAgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBgSGlGaUNvbW11bmljYXRvcmAgb2JqZWN0LCBvciBieSBzZXR0aW5nXG4gICAgICogYEhpRmlDb21tdW5pY2F0b3Iub25Vc2Vyc0Rpc2Nvbm5lY3RlZGAgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAgICAgKiBAcGFyYW0gdXNlcnNEaXNjb25uZWN0ZWQgLSBBbiBBcnJheSBvZiB7QGxpbmsgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhfSByZWdhcmRpbmcgdGhlIHVzZXJzIHdobyBkaXNjb25uZWN0ZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfb25Vc2Vyc0Rpc2Nvbm5lY3RlZCh1c2Vyc0Rpc2Nvbm5lY3RlZDogQXJyYXk8UmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhPik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5vblVzZXJzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uVXNlcnNEaXNjb25uZWN0ZWQodXNlcnNEaXNjb25uZWN0ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBVc2VyIERhdGEgU3Vic2NyaXB0aW9uIHRvIHRoZSBsaXN0IG9mIGNsaWVudHNpZGUgU3Vic2NyaXB0aW9ucy4gVXNlciBEYXRhIFN1YnNjcmlwdGlvbnMgYXJlIHVzZWQgdG8gb2J0YWluXG4gICAgICogVXNlciBEYXRhIGFib3V0IG90aGVyIFVzZXJzLiBGb3IgZXhhbXBsZSwgaWYgeW91IHNldCB1cCBhIFVzZXIgRGF0YSBTdWJzY3JpcHRpb24gZm9yIHlvdXIgb3duIFVzZXIgRGF0YSwgeW91IGNhbiB1c2UgdGhhdCBzdWJzY3JpcHRpb24gXG4gICAgICogdG8gZW5zdXJlIHRoYXQgdGhlIGRhdGEgb24gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIFNlcnZlciBpcyB0aGUgc2FtZSBhcyB0aGUgZGF0YSB5b3UgYXJlIHNlbmRpbmdcbiAgICAgKiB0byBpdCBmcm9tIHRoZSBjbGllbnQuIFxuICAgICAqIFxuICAgICAqIFRvIGNoZWNrIGlmIGEgdXNlciBoYXMgZGlzY29ubmVjdGVkLCB1c2Uge0BsaW5rIEhpRmlDb21tdW5pY2F0b3Iub25Vc2Vyc0Rpc2Nvbm5lY3RlZH0uXG4gICAgICogXG4gICAgICogQHBhcmFtIG5ld1N1YnNjcmlwdGlvbiAtIFRoZSBuZXcgVXNlciBEYXRhIFN1YnNjcmlwdGlvbiBhc3NvY2lhdGVkIHdpdGggYSB1c2VyLiBcbiAgICAgKi9cbiAgICBhZGRVc2VyRGF0YVN1YnNjcmlwdGlvbihuZXdTdWJzY3JpcHRpb246IFVzZXJEYXRhU3Vic2NyaXB0aW9uKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5fbWl4ZXJTZXNzaW9uKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBObyBcXGBfbWl4ZXJTZXNzaW9uXFxgISBEYXRhIHN1YnNjcmlwdGlvbiBub3QgYWRkZWQuYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWl4ZXJTZXNzaW9uLnVzZXJEYXRhU3RyZWFtaW5nU2NvcGUgPT09IEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3Blcy5Ob25lKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBEdXJpbmcgXFxgSGlGaUNvbW11bmljYXRvclxcYCBjb25zdHJ1Y3Rpb24sIHRoZSBzZXJ2ZXIgd2FzIHNldCB1cCB0byAqKm5vdCoqIHNlbmQgdXNlciBkYXRhISBEYXRhIHN1YnNjcmlwdGlvbiBub3QgYWRkZWQuYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgQWRkaW5nIG5ldyBVc2VyIERhdGEgU3Vic2NyaXB0aW9uOlxcbiR7SlNPTi5zdHJpbmdpZnkobmV3U3Vic2NyaXB0aW9uKX1gKTtcbiAgICAgICAgdGhpcy5fdXNlckRhdGFTdWJzY3JpcHRpb25zLnB1c2gobmV3U3Vic2NyaXB0aW9uKTtcbiAgICB9XG59XG4iLCIvKipcbiAqIENvZGUgaW4gdGhpcyBtb2R1bGUgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBbW0hpRmlDb21tdW5pY2F0b3JdXSBvYmplY3QgdG8gbWFuYWdlIHRoZSBjb25uZWN0aW9uIGJldHdlZW4gY2xpZW50IGFuZCBzZXJ2ZXIuXG4gKiBEZXZlbG9wZXJzIGRvIG5vdCBuZWVkIHRvIGFuZCBzaG91bGQgbm90IGNvbnNpZGVyIHRoaXMgbW9kdWxlIHdoZW4gd3JpdGluZyB0aGVpciBhcHBsaWNhdGlvbnMuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG5pbXBvcnQgeyBIaUZpQXVkaW9BUElEYXRhLCBPcmllbnRhdGlvblF1YXQzRCwgUG9pbnQzRCwgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhLCBPdGhlclVzZXJHYWluTWFwIH0gZnJvbSBcIi4vSGlGaUF1ZGlvQVBJRGF0YVwiO1xuaW1wb3J0IHsgSGlGaUxvZ2dlciB9IGZyb20gXCIuLi91dGlsaXRpZXMvSGlGaUxvZ2dlclwiO1xuaW1wb3J0IHsgSGlGaUNvbm5lY3Rpb25TdGF0ZXMsIEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3BlcyB9IGZyb20gXCIuL0hpRmlDb21tdW5pY2F0b3JcIjtcblxuaW1wb3J0IHsgUmF2aVV0aWxzIH0gZnJvbSBcIi4uL2xpYnJhdmkvUmF2aVV0aWxzXCI7XG5pbXBvcnQgeyBSYXZpU2Vzc2lvbiwgUmF2aVNlc3Npb25TdGF0ZXMsIFdlYlJUQ1Nlc3Npb25QYXJhbXMsIEN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnIH0gZnJvbSBcIi4uL2xpYnJhdmkvUmF2aVNlc3Npb25cIjtcbmltcG9ydCB7IFJhdmlTaWduYWxpbmdDb25uZWN0aW9uLCBSYXZpU2lnbmFsaW5nU3RhdGVzIH0gZnJvbSBcIi4uL2xpYnJhdmkvUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25cIjtcbmltcG9ydCB7IEhpRmlBeGlzVXRpbGl0aWVzLCBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi9IaUZpQXhpc0NvbmZpZ3VyYXRpb25cIjtcbmltcG9ydCB7IERpYWdub3N0aWNzIH0gZnJvbSBcIi4uL2RpYWdub3N0aWNzL2RpYWdub3N0aWNzXCI7XG5pbXBvcnQgcGFrbyBmcm9tICdwYWtvJ1xuXG5jb25zdCBJTklUX1RJTUVPVVRfTVMgPSA1MDAwO1xuY29uc3QgUEVSU09OQUxfVk9MVU1FX0FESlVTVF9USU1FT1VUX01TID0gNTAwMDtcblxuaW50ZXJmYWNlIEF1ZGlvbmV0U2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlIHtcbiAgICBzdWNjZXNzOiBib29sZWFuLFxuICAgIHJlYXNvbj86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb25SZXNwb25zZSB7XG4gICAgc3VjY2VzczogYm9vbGVhbixcbiAgICBlcnJvcj86IHN0cmluZyxcbiAgICBhdWRpb25ldFNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb25SZXNwb25zZT86IEF1ZGlvbmV0U2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlXG59XG5cbmV4cG9ydCB0eXBlIFNldE90aGVyVXNlckdhaW5Gb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlID0gU2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlO1xuXG4vKipcbiAqIFRoaXMgZW51bSBzdHJpbmcgcmVwcmVzZW50cyB0aGUgcmVhc29uIHRoZSBjbGllbnQncyBtdXRlIHN0YXRlIGhhcyB1cGRhdGVkLlxuICogU2VlIHtAbGluayBPbk11dGVDaGFuZ2VkQ2FsbGJhY2t9IGZvciBob3cgdGhpcyBpcyB1c2VkLlxuICpcbiAqIHtAbGluayBNdXRlUmVhc29uLkNMSUVOVH0gaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBjbGllbnQgaGFzIGF0dGVtcHRlZCB0byBjaGFuZ2UgdGhlIG11dGUgc3RhdGUgdXNpbmcge0BsaW5rIEhpRmlDb21tdW5pY2F0b3Iuc2V0SW5wdXRBdWRpb011dGVkfVxuICpcbiAqIHtAbGluayBNdXRlUmVhc29uLkFETUlOfSBpcyB1c2VkIHRvIGluZGljYXRlIHRoYXQgdGhlIHNlcnZlciBoYXMgY2hhbmdlZCB0aGUgY2xpZW50J3MgbXV0ZSBzdGF0ZS5cbiAqXG4gKiB7QGxpbmsgTXV0ZVJlYXNvbi5JTlRFUk5BTH0gaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBjbGllbnQncyBtdXRlIHN0YXRlIGhhcyBjaGFuZ2VkIGR1ZSB0byBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgdGhlIHNwYXRpYWwgYXVkaW8gQVBJLCBmb3IgZXhhbXBsZSB0byBrZWVwIHRoZSBzdGF0ZSBvZiB0aGUgY2xpZW50IGNvbnNpc3RlbnQgd2l0aCB0aGUgc2VydmVyLlxuKi9cbmV4cG9ydCBlbnVtIE11dGVSZWFzb24ge1xuICAgIENMSUVOVCA9IFwiY2xpZW50XCIsXG4gICAgQURNSU4gPSBcImFkbWluXCIsXG4gICAgSU5URVJOQUwgPSBcImludGVybmFsXCJcbn1cblxuLyoqXG4gKiBUaGlzIGV2ZW50IG9iamVjdCBkZXNjcmliZXMgaG93IGFuZCB3aHkgdGhlIG11dGUgc3RhdGUgb2YgdGhlIGNsaWVudCBoYXMgY2hhbmdlZC4gSXQgaXMgcGFzc2VkIGluIGFzIGEgcGFyYW1ldGVyIHRvIHtAbGluayBPbk11dGVDaGFuZ2VkQ2FsbGJhY2t9LlxuKi9cbmV4cG9ydCBjbGFzcyBNdXRlQ2hhbmdlZEV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGhlIG11dGUgc3RhdGUgd2FzIHNldCBzdWNjZXNzZnVsbHkuXG4gICAgICogVGhpcyBtYXkgYmUgYGZhbHNlYCBpZiB0aGUgY2xpZW50IGlzIHRyeWluZyB0byB1bm11dGUgdGhlbXNlbHZlcyB3aGVuIG11dGVkIGJ5IGFuIGFkbWluLCBvciBpZiB0aGVyZSB3YXMgYSBmYWlsdXJlIHNldHRpbmcgdGhlIG11dGUgc3RhdGUgb2YgdGhlIGlucHV0IGRldmljZS5cbiAgICAqL1xuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBtdXRlZCB2YWx1ZSB0aGF0IHdvdWxkIGhhdmUgYmVlbiBzZXQgaWYgdGhlIG11dGUgc3RhdGUgd2FzIHNldCBzdWNjZXNmdWxseS5cbiAgICAgKiBgdHJ1ZWAgbWVhbnMgbXV0ZWQsIGBmYWxzZWAgbWVhbnMgdW5tdXRlZC5cbiAgICAqL1xuICAgIHRhcmdldElucHV0QXVkaW9NdXRlZFZhbHVlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgY3VycmVudCBtdXRlZCB2YWx1ZSBhZnRlciBhdHRlbXB0aW5nIHRvIHNldCBtdXRlIHN0YXRlLlxuICAgICAqIGB0cnVlYCBtZWFucyBtdXRlZCwgYGZhbHNlYCBtZWFucyB1bm11dGVkLlxuICAgICovXG4gICAgY3VycmVudElucHV0QXVkaW9NdXRlZFZhbHVlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IHByZXZlbnRlZCBmcm9tIHVubXV0aW5nIHVzaW5nIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLnNldElucHV0QXVkaW9NdXRlZH0uXG4gICAgKi9cbiAgICBhZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgcmVhc29uIHRoZSBtdXRlIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICovXG4gICAgbXV0ZVJlYXNvbjogTXV0ZVJlYXNvbjtcblxuICAgIGNvbnN0cnVjdG9yKHsgc3VjY2VzcywgdGFyZ2V0SW5wdXRBdWRpb011dGVkVmFsdWUsIGN1cnJlbnRJbnB1dEF1ZGlvTXV0ZWRWYWx1ZSwgYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZywgbXV0ZVJlYXNvbiB9OiB7IHN1Y2Nlc3M6IGJvb2xlYW4sIHRhcmdldElucHV0QXVkaW9NdXRlZFZhbHVlOiBib29sZWFuLCBjdXJyZW50SW5wdXRBdWRpb011dGVkVmFsdWU6IGJvb2xlYW4sIGFkbWluUHJldmVudHNJbnB1dEF1ZGlvVW5tdXRpbmc6IGJvb2xlYW4sIG11dGVSZWFzb246IE11dGVSZWFzb24gfSkge1xuICAgICAgICB0aGlzLnN1Y2Nlc3MgPSBzdWNjZXNzO1xuICAgICAgICB0aGlzLnRhcmdldElucHV0QXVkaW9NdXRlZFZhbHVlID0gdGFyZ2V0SW5wdXRBdWRpb011dGVkVmFsdWU7XG4gICAgICAgIHRoaXMuY3VycmVudElucHV0QXVkaW9NdXRlZFZhbHVlID0gY3VycmVudElucHV0QXVkaW9NdXRlZFZhbHVlO1xuICAgICAgICB0aGlzLmFkbWluUHJldmVudHNJbnB1dEF1ZGlvVW5tdXRpbmcgPSBhZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nO1xuICAgICAgICB0aGlzLm11dGVSZWFzb24gPSBtdXRlUmVhc29uO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBbiBgb25NdXRlQ2hhbmdlZGAgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCB0aGlzIHNpZ25hdHVyZSBjYW4gYmUgcHJvdmlkZWQgdG8ge0BsaW5rIEhpRmlDb21tdW5pY2F0b3IuY29uc3RydWN0b3J9LiBUaGUgZnVuY3Rpb24geW91IHByb3ZpZGUgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIG11dGUgc3RhdGUgb2YgdGhlIGNsaWVudCBtYXkgaGF2ZSB1cGRhdGVkLlxuICpcbiAqIE9uZSBzaXR1YXRpb24gd2hlcmUgdGhpcyBpcyB1c2VmdWwgaXMgd2hlbiB0aGUgY2xpZW50J3MgbXV0ZSBzdGF0ZSBoYXMgYmVlbiBjaGFuZ2VkIGJ5IGFuIGFkbWluLCBpLmUuIHdoZW4ge0BsaW5rIE11dGVDaGFuZ2VkRXZlbnQubXV0ZVJlYXNvbn0gaXMge0BsaW5rIE11dGVSZWFzb24uQURNSU59LiBJZiB7QGxpbmsgTXV0ZUNoYW5nZWRFdmVudC5hZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nfSBpcyBgdHJ1ZWAsIHRoZW4gdGhlIGNsaWVudCBpcyBtdXRlZCwgYW5kIGlzIHByZXZlbnRlZCBmcm9tIHVubXV0aW5nIHdoZW4gdXNpbmcge0BsaW5rIEhpRmlDb21tdW5pY2F0b3Iuc2V0SW5wdXRBdWRpb011dGVkfS4gSWYge0BsaW5rIE11dGVDaGFuZ2VkRXZlbnQuYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZ30gaXMgYGZhbHNlYCwgdGhlbiB0aGUgY2xpZW50IGlzIG5vIGxvbmdlciBwcmV2ZW50ZWQgZnJvbSB1bm11dGluZywgYnV0IGlzIG5vdCBhdXRvbWF0aWNhbGx5IHVubXV0ZWQuIFRoZSBjbGllbnQgaXMgYWxsb3dlZCB0byBtdXRlIHRoZW1zZWxmIGF0IGFueSB0aW1lIHJlZ2FyZGxlc3Mgb2YgdGhlIGN1cnJlbnQgbXV0ZSBzdGF0ZS5cbiAqXG4gKiBJZiB7QGxpbmsgTXV0ZUNoYW5nZWRFdmVudC5tdXRlUmVhc29ufSBpcyBlcXVhbCB0byB7QGxpbmsgTXV0ZVJlYXNvbi5DTElFTlR9LCB0aGUgY2xpZW50IGF0dGVtcHRlZCB0byBzZXQgdGhlIG11dGUgc3RhdGUgdGhyb3VnaCB7QGxpbmsgSGlGaUNvbW11bmljYXRvci5zZXRJbnB1dEF1ZGlvTXV0ZWR9LlxuICpcbiAqIElmIHtAbGluayBNdXRlQ2hhbmdlZEV2ZW50Lm11dGVSZWFzb259IGlzIGVxdWFsIHRvIHtAbGluayBNdXRlUmVhc29uLklOVEVSTkFMfSwgdGhlIGNsaWVudCdzIG11dGUgc3RhdGUgaGFzIGNoYW5nZWQgZHVlIHRvIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiB0aGUgc3BhdGlhbCBhdWRpbyBBUEksIGZvciBleGFtcGxlIHRvIGtlZXAgdGhlIHN0YXRlIG9mIHRoZSBjbGllbnQgY29uc2lzdGVudCB3aXRoIHRoZSBzZXJ2ZXIuXG4gKlxuICogVGhpcyBjYWxsYmFjayBjYW4gYWxzbyBiZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGUgY2xpZW50IGlzIG11dGVkIGFuZCBkaXNwbGF5IHRoaXMgaW4gdGhlIGNsaWVudCBVSSwgYW5kIGNhbiBhbHNvIGJlIHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy4gVGhlIG11dGUgc3RhdGUgb2YgdGhlIGNsaWVudCBtYXkgbm90IGhhdmUgY2hhbmdlZCBhZnRlciB0aGlzIGNhbGxiYWNrLlxuKi9cbmV4cG9ydCB0eXBlIE9uTXV0ZUNoYW5nZWRDYWxsYmFjayA9IChtdXRlQ2hhbmdlZEV2ZW50OiBNdXRlQ2hhbmdlZEV2ZW50KSA9PiB2b2lkO1xuXG4vKipcbiAqIEluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MgY29udGFpbiBkYXRhIGFib3V0IGEgY29ubmVjdGlvbiBiZXR3ZWVuIGEgY2xpZW50IGFuZCBhIG1peGVyLlxuICogQ2xpZW50IGxpYnJhcnkgdXNlcnMgc2hvdWxkbid0IGhhdmUgdG8gY2FyZSBhdCBhbGwgYWJvdXQgdGhlIHZhcmlhYmxlcyBhbmQgbWV0aG9kcyBjb250YWluZWQgaW4gdGhpcyBjbGFzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEhpRmlNaXhlclNlc3Npb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBSQVZJIFNpZ25hbGluZyBDb25uZWN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE1peGVyIFNlc3Npb24uXG4gICAgICovXG4gICAgcHJpdmF0ZSBfcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb246IFJhdmlTaWduYWxpbmdDb25uZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIFRoZSBSQVZJIFNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgTWl4ZXIgU2Vzc2lvbi5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9yYXZpU2Vzc2lvbjogUmF2aVNlc3Npb247XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGN1cnJlbnQgSGlGaSBDb25uZWN0aW9uIFN0YXRlLCB3aGljaCBpcyBhbiBhYnN0cmFjdGlvbiBzZXBhcmF0ZSBmcm9tIHRoZSBSQVZJIFNlc3Npb24gU3RhdGUgYW5kIFJBVkkgU2lnbmFsaW5nIFN0YXRlLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2N1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlOiBIaUZpQ29ubmVjdGlvblN0YXRlcztcblxuICAgIC8qKlxuICAgICAqIFVzZWQgd2hlbiBtdXRpbmcgYW5kIHVubXV0aW5nIHRvIHNhdmUgdGhlIHN0YXRlIG9mIHRoZSB1c2VyJ3MgaW5wdXQgZGV2aWNlJ3MgYE1lZGlhVHJhY2tDb25zdHJhaW50c2AuXG4gICAgICogV2hlbiBhIHVzZXIgbXV0ZXMsIHdlIGV4cGxpY2l0bHkgY2FsbCBgc3RvcCgpYCBvbiBhbGwgYXVkaW8gdHJhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlcidzIGlucHV0IGRldmljZS5cbiAgICAgKiBXaGVuIGEgdXNlciB1bm11dGVzLCB3ZSBtdXN0IGNhbGwgYGdldFVzZXJNZWRpYSgpYCB0byByZS1vYnRhaW4gdGhvc2UgYXVkaW8gdHJhY2tzLiBXZSB3YW50IHRvIGNhbGwgYGdldFVzZXJNZWRpYSgpYFxuICAgICAqIHdpdGggdGhlIHNhbWUgY29uc3RyYWludHMgdXNlZCBieSB0aGUgYXBwbGljYXRpb24gd2hlbiBfaXRfIGZpcnN0IGNhbGxzIGBnZXRVc2VyTWVkaWEoKWAuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfY2FjaGVkTWVkaWFUcmFja0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHM7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIHJlY2VpdmUgcGVlciBkYXRhIGZyb20gdGhlIHNlcnZlciwgaXQncyBpbiBhIGZvcm1hdCBsaWtlIHRoaXM6XG4gICAgICoge1xuICAgICAqICAgICAzMTg6IHtjOiBcIiM1ZGYxZjVcIiwgZDogXCJIb3dhcmRcIiwgZTogXCI4NzNjNGQ0My1jY2Q5LTRjZTQtOWFjNy1kNWZhZGU0ZGVmOTI5YVwiLCBpOiBcIntmMGNlMjJiYi04YjY3LTQwNDQtYThjNS02NWFlZmJjZTQwNjB9XCIsIG86IDAsIOKApn1cbiAgICAgKiAgICAgMzQxOiB7ZTogXCI5YzVhZjQ0Yi03ZTNmLThmNjUtNTQyMS0zNzRiNDNiZWJjNGFcIiwgaTogXCJ7YmUzOGEyNTYtODUwYS00YzhkLWJkZGQtY2ZlODBhYWRkZmU5fVwiLCBvOiAwLCBwOiB0cnVlLCB2OiAtMTIwLCDigKZ9XG4gICAgICogfVxuICAgICAqIFRoZSBwZWVyIGRhdGEgZG9lcyBub3QgYWx3YXlzIGNvbnRhaW4gYWxsIHBvc3NpYmxlIGtleS92YWx1ZSBwYWlycyBhc3NvY2lhdGVkIHdpdGggZWFjaCBrZXkgaW4gdGhpcyBPYmplY3QuIEluIGZhY3QsIG1vc3Qgb2YgdGhlIHRpbWUsIGl0IGNvbnRhaW5zXG4gICAgICogb25seSBhIGZyYWN0aW9uIG9mIHRoZSBkYXRhLiBGb3IgZXhhbXBsZSwgd2UgbWlnaHQgcmVjZWl2ZSBgeyAzNDE6IHt2OiAtNDB9IH1gIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKiBXaGVuIHRoZSBIaUZpIEF1ZGlvIExpYnJhcnkgdXNlciBzZXRzIHVwIGEgVXNlciBEYXRhIFN1YnNjcmlwdGlvbiwgdGhleSBjYW4gb3B0aW9uYWxseSBhc3NvY2lhdGUgdGhlIFN1YnNjcmlwdGlvbiB3aXRoIGEgXCJQcm92aWRlZCBVc2VyIElEXCIuXG4gICAgICogU2luY2UgdGhlIHNlcnZlciBkb2Vzbid0IGFsd2F5cyBzZW5kIHRoZSBcIlByb3ZpZGVkIFVzZXIgSURcIiBpbiB0aGVzZSBwZWVyIHVwZGF0ZXMsIHdlIGhhdmUgdG8ga2VlcCB0cmFjayBvZiB0aGUgKHByZXN1bWFibHkgc3RhYmxlKSBrZXkgaW4gYGpzb25EYXRhLnBlZXJzYFxuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGF0IFwiUHJvdmlkZWQgVXNlciBJRFwiIGluIG9yZGVyIHRvIGZvcndhcmQgdGhhdCBcIlByb3ZpZGVkIFVzZXIgSURcIiB0byB0aGUgU3Vic2NyaXB0aW9uIGhhbmRsZXIgYW5kIHRodXMgdG8gdGhlIExpYnJhcnkgdXNlci5cbiAgICAgKiBcbiAgICAgKiBBbmQgc2luY2Ugd2UgYXJlIGNhY2hpbmcgdGhhdCBvbmUgdmFsdWUsIHdlIGFyZSBhbHNvIGNhY2hpbmcgdGhlIGZ1bGwgc3RhdGUgZm9yIGFsbCBrbm93biBwZWVycy5cbiAgICAgKiBUaGlzIGFsbG93cyB1cyB0byBvcHRpbWl6ZSB0aGUgcmVjZWl2ZWQgc3RyZWFtIG9mIGNoYW5nZWQgZGF0YSBmb3IgYSBnaXZlbiBwZWVyIGZyb20gdGhlIHNlcnZlciB0byBqdXN0IHRoZSBuZWNlc3NhcnkgYml0c1xuICAgICAqIGFuZCByZWNvbnN0cnVjdCB0aGUgY29tcGxldGUgaW5mb3JtYXRpb24gd2l0aCB0aGUga25vd2xlZGdlIG9mIHRoZSBjYWNoZWQgc3RhdGUgb2YgdGhhdGEgcGVlci5cbiAgICAgKiBPbmUgY2F2ZWF0LCB0aGUgcG9zaXRpb24gYW5kIG9yaWVuYXRpb25RdWF0IGZpZWxkcyBjYWNoZWQgZm9yIGEgcGVlciBhcmUgZXhwcmVzc2VkIGluIHRoZSAnTWl4ZXJTcGFjZScsIG5vdCB0cmFuc2Zvcm1lZCB5ZXQgaW4gdGhlICdDbGllbnRVc2VyU3BhY2UnLlxuICAgICAqIFxuICAgICAqIFRodXMsIHRoZSBMaWJyYXJ5IHVzZXIgc2hvdWxkIG5ldmVyIGhhdmUgdG8gY2FyZSBhYm91dCB0aGUgYF9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0YC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0OiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBXZSB3aWxsIHRyYWNrIHdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBzdHJlYW0gaXMgc3RlcmVvLCBzbyB0aGF0XG4gICAgICogd2UgY2FuIGFkdmlzZSB0aGUgc2VydmVyIHRvIG1peCBpdCBhcHByb3ByaWF0ZWx5XG4gICAgICovXG4gICAgcHJpdmF0ZSBfaW5wdXRBdWRpb01lZGlhU3RyZWFtSXNTdGVyZW86IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIF9hZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nOiBib29sZWFuO1xuICAgIHByaXZhdGUgX2xhc3RTdWNjZXNzZnVsSW5wdXRBdWRpb011dGVkVmFsdWU6IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIG9uTXV0ZUNoYW5nZWQ6IE9uTXV0ZUNoYW5nZWRDYWxsYmFjaztcblxuICAgIC8qKlxuICAgICAqIE9ubHkgdmFsaWQgZm9yIHVzZXJzIGNvdmVyZWQgYnkgYSB1c2VyIGRhdGEgc3Vic2NyaXB0aW9uLiBSZW1haW5zIGNvbnN0YW50IGF0IGRpc2Nvbm5lY3QgdW50aWwgdGhlIG5leHQgY29ubmVjdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29uY3VycmVuY3k6bnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBXZWJSVEMgU3RhdHMgT2JzZXJ2ZXIgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIF9zdGF0c09ic2VydmVyQ2FsbGJhY2s6IEZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU2VlIHtAbGluayBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXN9LlxuICAgICAqL1xuICAgIHVzZXJEYXRhU3RyZWFtaW5nU2NvcGU6IEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3BlcztcblxuICAgIC8qKlxuICAgICAqIFRoZSBXZWJSVEMgQWRkcmVzcyB0byB3aGljaCB3ZSB3YW50IHRvIGNvbm5lY3QgYXMgYSBwYXJ0IG9mIHRoaXMgU2Vzc2lvbi4gVGhpcyBXZWJSVEMgQWRkcmVzcyBpcyBvYnRhaW5lZCBmcm9tIHRoZSBNaXhlciBEaXNjb3ZlcnkgQWRkcmVzcyBkdXJpbmdcbiAgICAgKiB0aGUgYEhpRmlDb21tdW5pY2F0b3IuY29ubmVjdFRvSGlGaUF1ZGlvQVBJU2VydmVyKClgIGNhbGwuXG4gICAgICovXG4gICAgd2ViUlRDQWRkcmVzczogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gUGVlciBkYXRhIGlzIHJldHVybmVkIGZyb20gdGhlIFNlcnZlci5cbiAgICAgKi9cbiAgICBvblVzZXJEYXRhVXBkYXRlZDogRnVuY3Rpb247XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhIFBlZXIgZGlzY29ubmVjdHMgZnJvbSB0aGUgU2VydmVyLlxuICAgICAqL1xuICAgIG9uVXNlcnNEaXNjb25uZWN0ZWQ6IEZ1bmN0aW9uO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIFwiY29ubmVjdGlvbiBzdGF0ZVwiIGNoYW5nZXMuXG4gICAgICogUmlnaHQgbm93LCB0aGlzIGlzIGNhbGxlZCB3aGVuIHRoZSB0aGUgUkFWSSBzZXNzaW9uIHN0YXRlIGNoYW5nZXMgdG9cbiAgICAgKiBgUmF2aVNlc3Npb25TdGF0ZXMuQ09OTkVDVEVEYCwgYFJhdmlTZXNzaW9uU3RhdGVzLkRJU0NPTk5FQ1RFRGAsIGFuZCBgUmF2aVNlc3Npb25TdGF0ZXMuRkFJTEVEYC5cbiAgICAgKi9cbiAgICBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQ6IEZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1peGVyIHRvIHdoaWNoIHdlIGFyZSBjdXJyZW50bHkgY29ubmVjdGVkLlxuICAgICAqL1xuICAgIG1peGVySW5mbzogYW55O1xuXG4gICAgcHJpdmF0ZSBfcmF2aURpYWdub3N0aWNzOiBEaWFnbm9zdGljcztcbiAgICBwcml2YXRlIF9oaWZpRGlhZ25vc3RpY3M6IERpYWdub3N0aWNzO1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIF9fbmFtZWRQYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHVzZXJEYXRhU3RyZWFtaW5nU2NvcGUgLSBTZWUge0BsaW5rIEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3Blc30uXG4gICAgICogXG4gICAgICogSWYgc2V0IHRvIGBmYWxzZWAsIFVzZXIgRGF0YSBTdWJzY3JpcHRpb25zIHdpbGwgc2VydmUgbm8gcHVycG9zZS5cbiAgICAgKiBAcGFyYW0gb25Vc2VyRGF0YVVwZGF0ZWQgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBzZXJ2ZXIgc2VuZHMgdXNlciBkYXRhIHRvIHRoZSBjbGllbnQuIElycmVsZXZhbnQgaWYgYHVzZXJEYXRhU3RyZWFtaW5nU2NvcGVgIGlzIGBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXMuTm9uZWAuXG4gICAgICogQHBhcmFtIG9uVXNlcnNEaXNjb25uZWN0ZWQgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBzZXJ2ZXIgc2VuZHMgdXNlciBkYXRhIGFib3V0IHBlZXJzIHdobyBqdXN0IGRpc2Nvbm5lY3RlZCB0byB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgdXNlckRhdGFTdHJlYW1pbmdTY29wZSA9IEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3Blcy5BbGwsIG9uVXNlckRhdGFVcGRhdGVkLCBvblVzZXJzRGlzY29ubmVjdGVkLCBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIG9uTXV0ZUNoYW5nZWQgfTogeyB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlPzogSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzLCBvblVzZXJEYXRhVXBkYXRlZD86IEZ1bmN0aW9uLCBvblVzZXJzRGlzY29ubmVjdGVkPzogRnVuY3Rpb24sIG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZD86IEZ1bmN0aW9uLCBvbk11dGVDaGFuZ2VkPzogT25NdXRlQ2hhbmdlZENhbGxiYWNrIH0pIHtcbiAgICAgICAgdGhpcy53ZWJSVENBZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnVzZXJEYXRhU3RyZWFtaW5nU2NvcGUgPSB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlO1xuICAgICAgICB0aGlzLm9uVXNlckRhdGFVcGRhdGVkID0gb25Vc2VyRGF0YVVwZGF0ZWQ7XG4gICAgICAgIHRoaXMub25Vc2Vyc0Rpc2Nvbm5lY3RlZCA9IG9uVXNlcnNEaXNjb25uZWN0ZWQ7XG4gICAgICAgIHRoaXMuX21peGVyUGVlcktleVRvU3RhdGVDYWNoZURpY3QgPSB7fTtcbiAgICAgICAgdGhpcy5fbGFzdFN1Y2Nlc3NmdWxJbnB1dEF1ZGlvTXV0ZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uTXV0ZUNoYW5nZWQgPSBvbk11dGVDaGFuZ2VkO1xuXG4gICAgICAgIFJhdmlVdGlscy5zZXREZWJ1ZyhmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24gPSBuZXcgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24oKTtcbiAgICAgICAgdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24uYWRkU3RhdGVDaGFuZ2VIYW5kbGVyKChldmVudDogYW55KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uUkFWSVNpZ25hbGluZ1N0YXRlQ2hhbmdlZChldmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3JhdmlTZXNzaW9uID0gbmV3IFJhdmlTZXNzaW9uKCk7XG4gICAgICAgIHRoaXMuX3JhdmlTZXNzaW9uLmFkZFN0YXRlQ2hhbmdlSGFuZGxlcigoZXZlbnQ6IGFueSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vblJBVklTZXNzaW9uU3RhdGVDaGFuZ2VkKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQgPSBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQ7XG5cbiAgICAgICAgdGhpcy5fcmVzZXRNaXhlckluZm8oKTtcbiAgICAgICAgdGhpcy5fcmF2aURpYWdub3N0aWNzID0gbmV3IERpYWdub3N0aWNzKHtsYWJlbDogJ3JhdmknLCBzZXNzaW9uOiB0aGlzLCByYXZpOiB0aGlzLl9yYXZpU2Vzc2lvbn0pO1xuICAgICAgICB0aGlzLl9oaWZpRGlhZ25vc3RpY3MgPSBuZXcgRGlhZ25vc3RpY3Moe2xhYmVsOiAnYXBwJywgc2Vzc2lvbjogdGhpcywgcmF2aTogdGhpcy5fcmF2aVNlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGlzIHRoZSBzdGFuZGFyZCB3YXkgdG8gdGVsbCwgYnV0IGJyb3dzZXIgaGF2ZSBidWdzIGluIHdoaWNoIHRoZXkgZG9uJ3QgZmlyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2Vjb25kIGlzIGVub3VnaCBmb3IgYWxsIGtub3duIGJyb3dzZXIgYnVncywgZXhjZXB0IGZvciBTYWZhcmkgZGVza3RvcCBjbG9zaW5nIGEgdmlzaWJsZSB0YWIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZU9uOiBbJ3Zpc2liaWxpdHljaGFuZ2UnLCAncGFnZWhpZGUnLCAnYmVmb3JldW5sb2FkJ119KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyB0aGUgY29tbWFuZCBgYXVkaW9uZXQuaW5pdGAgdG8gdGhlIG1peGVyLlxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIElmIHRoaXMgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWwsIHRoZSBQcm9taXNlIHdpbGwgcmVzb2x2ZSB3aXRoIGB7IHN1Y2Nlc3M6IHRydWUsIGF1ZGlvbmV0SW5pdFJlc3BvbnNlOiA8VGhlIHJlc3BvbnNlIHRvIGBhdWRpb25ldC5pbml0YCBmcm9tIHRoZSBzZXJ2ZXIgaW4gT2JqZWN0IGZvcm1hdD59YC5cbiAgICAgKiBJZiB1bnN1Y2Nlc3NmdWwsIHRoZSBQcm9taXNlIHdpbGwgcmVqZWN0IHdpdGggYHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiA8YW4gZXJyb3IgbWVzc2FnZT4gfWAuXG4gICAgICovXG4gICAgYXN5bmMgcHJvbWlzZVRvUnVuQXVkaW9Jbml0KCk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5pdERhdGEgPSB7XG4gICAgICAgICAgICAgICAgcHJpbWFyeTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWl4ZXIgd2lsbCBoYXNoIHRoaXMgcmFuZG9tbHktZ2VuZXJhdGVkIFVVSUQsIHRoZW4gZGlzc2VtaW5hdGUgaXQgdG8gYWxsIGNsaWVudHMgdmlhIGBwZWVyRGF0YS5lYC5cbiAgICAgICAgICAgICAgICB2aXNpdF9pZDogdGhpcy5fcmF2aVNlc3Npb24uZ2V0VVVJRCgpLFxuICAgICAgICAgICAgICAgIHNlc3Npb246IHRoaXMuX3JhdmlTZXNzaW9uLmdldFVVSUQoKSwgLy8gU3RpbGwgcmVxdWlyZWQgZm9yIG9sZCBtaXhlcnMuIFdpbGwgZXZlbnR1YWxseSBnbyBhd2F5LlxuICAgICAgICAgICAgICAgIHN0cmVhbWluZ19zY29wZTogdGhpcy51c2VyRGF0YVN0cmVhbWluZ1Njb3BlLFxuICAgICAgICAgICAgICAgIGlzX2lucHV0X3N0cmVhbV9zdGVyZW86IHRoaXMuX2lucHV0QXVkaW9NZWRpYVN0cmVhbUlzU3RlcmVvXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGNvbW1hbmRDb250cm9sbGVyID0gdGhpcy5fcmF2aVNlc3Npb24uZ2V0Q29tbWFuZENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIGlmICghY29tbWFuZENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBDb3VsZG4ndCBjb25uZWN0IHRvIG1peGVyOiBubyBcXGBjb21tYW5kQ29udHJvbGxlclxcYCFgXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpbml0VGltZW91dCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBlcnJNc2cgPSBgQ291bGRuJ3QgY29ubmVjdCB0byBtaXhlcjogQ2FsbCB0byBcXGBpbml0XFxgIHRpbWVkIG91dCFgXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGlzY29ubmVjdEZyb21IaUZpTWl4ZXIoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvckNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyTXNnICs9IGBcXG5BZGRpdGlvbmFsbHksIHRoZXJlIHdhcyBhbiBlcnJvciB0cnlpbmcgdG8gY2xvc2UgdGhlIGZhaWxlZCBjb25uZWN0aW9uLiBFcnJvcjpcXG4ke2Vycm9yQ2xvc2luZ31gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyck1zZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgSU5JVF9USU1FT1VUX01TKTtcblxuICAgICAgICAgICAgY29tbWFuZENvbnRyb2xsZXIucXVldWVDb21tYW5kKFwiYXVkaW9uZXQuaW5pdFwiLCBpbml0RGF0YSwgYXN5bmMgKHJlc3BvbnNlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaW5pdFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRSZXNwb25zZTogYW55O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWl4ZXJJbmZvW1wiY29ubmVjdGVkXCJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhlckluZm9bXCJidWlsZF9udW1iZXJcIl0gPSBwYXJzZWRSZXNwb25zZS5idWlsZF9udW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWl4ZXJJbmZvW1wiYnVpbGRfdHlwZVwiXSA9IHBhcnNlZFJlc3BvbnNlLmJ1aWxkX3R5cGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWl4ZXJJbmZvW1wiYnVpbGRfdmVyc2lvblwiXSA9IHBhcnNlZFJlc3BvbnNlLmJ1aWxkX3ZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWl4ZXJJbmZvW1widmlzaXRfaWRfaGFzaFwiXSA9IHBhcnNlZFJlc3BvbnNlLnZpc2l0X2lkX2hhc2g7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhdmlEaWFnbm9zdGljcy5wcmltZSh0aGlzLm1peGVySW5mby52aXNpdF9pZF9oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlmaURpYWdub3N0aWNzLnByaW1lKHRoaXMubWl4ZXJJbmZvLnZpc2l0X2lkX2hhc2gpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb25ldEluaXRSZXNwb25zZTogcGFyc2VkUmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYENvdWxkbid0IHBhcnNlIGluaXQgcmVzcG9uc2UhIFBhcnNlIGVycm9yOlxcbiR7ZX1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgbWl4ZXJgIGFuZCBgcGVlcmAgZGF0YSBpcyBzZW50IGZyb20gdGhlIE1peGVyIHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyB3aGVuIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgYGd6aXBwZWRgIGRhdGEgZnJvbSB0aGUgTWl4ZXIuXG4gICAgICovXG4gICAgaGFuZGxlUkFWSVNlc3Npb25CaW5hcnlEYXRhKGRhdGE6IGFueSkge1xuICAgICAgICBsZXQgdW5HWmlwcGVkRGF0YSA9IHBha28udW5nemlwKGRhdGEsIHsgdG86ICdzdHJpbmcnIH0pO1xuICAgICAgICBsZXQganNvbkRhdGEgPSBKU09OLnBhcnNlKHVuR1ppcHBlZERhdGEpO1xuXG4gICAgICAgIGlmIChqc29uRGF0YS5kZWxldGVkX3Zpc2l0X2lkcykge1xuICAgICAgICAgICAgbGV0IGFsbERlbGV0ZWRVc2VyRGF0YTogQXJyYXk8UmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhPiA9IFtdO1xuXG4gICAgICAgICAgICBsZXQgZGVsZXRlZFZpc2l0SURzID0ganNvbkRhdGEuZGVsZXRlZF92aXNpdF9pZHM7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlbGV0ZWRWaXNpdElEIG9mIGRlbGV0ZWRWaXNpdElEcykge1xuICAgICAgICAgICAgICAgIGxldCBoYXNoZWRWaXNpdElEID0gZGVsZXRlZFZpc2l0SUQ7XG5cbiAgICAgICAgICAgICAgICBsZXQgZGVsZXRlZFVzZXJEYXRhID0gbmV3IFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hlZFZpc2l0SUQ6IGhhc2hlZFZpc2l0SURcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxldCBtaXhlclBlZXJLZXlzID0gT2JqZWN0LmtleXModGhpcy5fbWl4ZXJQZWVyS2V5VG9TdGF0ZUNhY2hlRGljdCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtaXhlclBlZXJLZXkgb2YgbWl4ZXJQZWVyS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWl4ZXJQZWVyS2V5VG9TdGF0ZUNhY2hlRGljdFttaXhlclBlZXJLZXldLmhhc2hlZFZpc2l0SUQgPT09IGhhc2hlZFZpc2l0SUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0W21peGVyUGVlcktleV0ucHJvdmlkZWRVc2VySUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVkVXNlckRhdGEucHJvdmlkZWRVc2VySUQgPSB0aGlzLl9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0W21peGVyUGVlcktleV0ucHJvdmlkZWRVc2VySUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFsbERlbGV0ZWRVc2VyRGF0YS5wdXNoKGRlbGV0ZWRVc2VyRGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGUgZW50cnkgZnJvbSB0aGUgcGVlciBzdGF0ZSBjYWNoZVxuICAgICAgICAgICAgdGhpcy5jb25jdXJyZW5jeSAtPSBhbGxEZWxldGVkVXNlckRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMub25Vc2Vyc0Rpc2Nvbm5lY3RlZCAmJiBhbGxEZWxldGVkVXNlckRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Vc2Vyc0Rpc2Nvbm5lY3RlZChhbGxEZWxldGVkVXNlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGpzb25EYXRhLnBlZXJzKSB7XG4gICAgICAgICAgICBsZXQgYWxsTmV3VXNlckRhdGE6IEFycmF5PFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YT4gPSBbXTtcblxuICAgICAgICAgICAgbGV0IHBlZXJLZXlzID0gT2JqZWN0LmtleXMoanNvbkRhdGEucGVlcnMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaXRyID0gMDsgaXRyIDwgcGVlcktleXMubGVuZ3RoOyBpdHIrKykge1xuICAgICAgICAgICAgICAgIGxldCBwZWVyRGF0YUZyb21NaXhlciA9IGpzb25EYXRhLnBlZXJzW3BlZXJLZXlzW2l0cl1dO1xuXG4gICAgICAgICAgICAgICAgLy8gU2VlIHtAbGluayB0aGlzLl9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0fS5cbiAgICAgICAgICAgICAgICBsZXQgdXNlckRhdGFDYWNoZTogUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhO1xuICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIGEga25vd24gcGVlciwgd2Ugc2hvdWxkIGhhdmUgYW4gZW50cnkgZm9yIGl0IGluIHRoZSBjYWNoZSBkaWN0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21peGVyUGVlcktleVRvU3RhdGVDYWNoZURpY3RbcGVlcktleXNbaXRyXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZSA9IHRoaXMuX21peGVyUGVlcktleVRvU3RhdGVDYWNoZURpY3RbcGVlcktleXNbaXRyXV0gYXMgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgbGV0J3MgY3JlYXRlIGl0LlxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlID0gbmV3IFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0W3BlZXJLZXlzW2l0cl1dID0gdXNlckRhdGFDYWNoZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25jdXJyZW5jeSArPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgZW1wdHkgZGF0YSB0aGF0IHdpbGwgY29sbGVjdCB0aGUgY2hhbmdlcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICAgICAgLy8gYXMgd2UgY29sbGVjdCB0aGUgY2hhbmdlcyBmcm9tIHRoZSByZWNlaXZlZCBkYXRhLCB3ZSB3aWxsIGFsc28gdXBkYXRlIHRoZSB1c2VyRGF0YUNhY2hlIGFzc29jaWF0ZWQgd2l0aCB0aGF0IHBlZXIuXG4gICAgICAgICAgICAgICAgbGV0IG5ld1VzZXJEYXRhID0gbmV3IFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gYC5KYCBpcyB0aGUgJ3Byb3ZpZGVkVXNlcklEJ1xuICAgICAgICAgICAgICAgIGlmICh1c2VyRGF0YUNhY2hlLnByb3ZpZGVkVXNlcklEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgIGRlZmluZWQsIHNob3VsZCBiZSB0aGUgc2FtZSBpbml0aWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5wcm92aWRlZFVzZXJJRCA9IHVzZXJEYXRhQ2FjaGUucHJvdmlkZWRVc2VySUQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLkopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUucHJvdmlkZWRVc2VySUQgPSBwZWVyRGF0YUZyb21NaXhlci5KO1xuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5wcm92aWRlZFVzZXJJRCA9IHBlZXJEYXRhRnJvbU1peGVyLko7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYC5lYCBpcyB0aGUgYGhhc2hlZFZpc2l0SURgLCB3aGljaCBpcyBhIGhhc2hlZCB2ZXJzaW9uIG9mIHRoZSByYW5kb20gVVVJRCB0aGF0IGEgY29ubmVjdGluZyBjbGllbnRcbiAgICAgICAgICAgICAgICAvLyBzZW5kcyBhcyB0aGUgYHNlc3Npb25gIGtleSBpbnNpZGUgdGhlIGFyZ3VtZW50IHRvIHRoZSBgYXVkaW9uZXQuaW5pdGAgY29tbWFuZC5cbiAgICAgICAgICAgICAgICAvLyBJdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGEgZ2l2ZW4gY2xpZW50IGFjcm9zcyBhIGNsb3VkIG9mIG1peGVycy5cbiAgICAgICAgICAgICAgICBpZiAodXNlckRhdGFDYWNoZS5oYXNoZWRWaXNpdElEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgIGRlZmluZWQsIHNob3VsZCBiZSB0aGUgc2FtZSBpbml0aWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5oYXNoZWRWaXNpdElEID0gdXNlckRhdGFDYWNoZS5oYXNoZWRWaXNpdElEO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci5lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLmhhc2hlZFZpc2l0SUQgPSBwZWVyRGF0YUZyb21NaXhlci5lO1xuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5oYXNoZWRWaXNpdElEID0gcGVlckRhdGFGcm9tTWl4ZXIuZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgc2VydmVyU2VudE5ld1VzZXJEYXRhID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLipgXG4gICAgICAgICAgICAgICAgbGV0IHNlcnZlclNlbnROZXdQb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLngpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlckRhdGFDYWNoZS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5wb3NpdGlvbiA9IG5ldyBQb2ludDNEKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTWl4ZXIgc2VuZHMgcG9zaXRpb24gZGF0YSBpbiBtaWxsaW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLnBvc2l0aW9uLnggPSBwZWVyRGF0YUZyb21NaXhlci54IC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld1Bvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocGVlckRhdGFGcm9tTWl4ZXIueSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyRGF0YUNhY2hlLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLnBvc2l0aW9uID0gbmV3IFBvaW50M0QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBNaXhlciBzZW5kcyBwb3NpdGlvbiBkYXRhIGluIG1pbGxpbWV0ZXJzXG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUucG9zaXRpb24ueSA9IHBlZXJEYXRhRnJvbU1peGVyLnkgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3UG9zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci56KSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJEYXRhQ2FjaGUucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUucG9zaXRpb24gPSBuZXcgUG9pbnQzRCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE1peGVyIHNlbmRzIHBvc2l0aW9uIGRhdGEgaW4gbWlsbGltZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5wb3NpdGlvbi56ID0gcGVlckRhdGFGcm9tTWl4ZXIueiAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIHJlY2VpdmVkIGEgbmV3IHBvc2l0aW9uIGFuZCB1cGRhdGVkIHRoZSBjYWNoZSBlbnRyeS5cbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGFkZCB0aGUgbmV3IHBvc2l0aW9uIHZhbHVlIGluIHRoZSBuZXdVc2VyRGF0YVxuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJTZW50TmV3UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgcG9zaXRpb24gdmFsdWUgZm9yIHRoZSBuZXdVc2VyRGF0YSBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCB0aGUgcmVjZWl2ZWQgcG9zaXRpb24gKGlmIGFueSkgdG8gdGhlIHVzZXIgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgbmV3VXNlckRhdGEucG9zaXRpb24gPSBIaUZpQXhpc1V0aWxpdGllcy50cmFuc2xhdGVQb2ludDNERnJvbU1peGVyU3BhY2Uob3VySGlGaUF4aXNDb25maWd1cmF0aW9uLCB1c2VyRGF0YUNhY2hlLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld1VzZXJEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uLipgXG4gICAgICAgICAgICAgICAgbGV0IHNlcnZlclNlbnROZXdPcmllbnRhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLlcpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUub3JpZW50YXRpb25RdWF0ID0gbmV3IE9yaWVudGF0aW9uUXVhdDNEKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQudyA9IHBlZXJEYXRhRnJvbU1peGVyLlcgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3T3JpZW50YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci5YKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJEYXRhQ2FjaGUub3JpZW50YXRpb25RdWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLm9yaWVudGF0aW9uUXVhdCA9IG5ldyBPcmllbnRhdGlvblF1YXQzRCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUub3JpZW50YXRpb25RdWF0LnggPSBwZWVyRGF0YUZyb21NaXhlci5YIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld09yaWVudGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocGVlckRhdGFGcm9tTWl4ZXIuWSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyRGF0YUNhY2hlLm9yaWVudGF0aW9uUXVhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQgPSBuZXcgT3JpZW50YXRpb25RdWF0M0QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLm9yaWVudGF0aW9uUXVhdC55ID0gcGVlckRhdGFGcm9tTWl4ZXIuWSAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdPcmllbnRhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLlopID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUub3JpZW50YXRpb25RdWF0ID0gbmV3IE9yaWVudGF0aW9uUXVhdDNEKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQueiA9IHBlZXJEYXRhRnJvbU1peGVyLlogLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3T3JpZW50YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSByZWNlaXZlZCBhIG5ldyBvcmllbnRhdGlvbiBhbmQgdXBkYXRlZCB0aGUgY2FjaGUgZW50cnkuXG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBhZGQgdGhlIG5ldyBvcmllbnRhdGlvbiB2YWx1ZSBpbiB0aGUgbmV3VXNlckRhdGFcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyU2VudE5ld09yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IG9yaWVudGF0aW9uIHZhbHVlIGZvciB0aGUgbmV3VXNlckRhdGEgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIHJlY2VpdmVkIG9yaWVudGF0aW9uIChpZiBhbnkpIHRvIHRoZSB1c2VyIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLm9yaWVudGF0aW9uUXVhdCA9IEhpRmlBeGlzVXRpbGl0aWVzLnRyYW5zbGF0ZU9yaWVudGF0aW9uUXVhdDNERnJvbU1peGVyU3BhY2Uob3VySGlGaUF4aXNDb25maWd1cmF0aW9uLCB1c2VyRGF0YUNhY2hlLm9yaWVudGF0aW9uUXVhdCk7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdVc2VyRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YS52b2x1bWVEZWNpYmVsc2BcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci52KSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLnZvbHVtZURlY2liZWxzID0gcGVlckRhdGFGcm9tTWl4ZXIudjtcbiAgICAgICAgICAgICAgICAgICAgbmV3VXNlckRhdGEudm9sdW1lRGVjaWJlbHMgPSBwZWVyRGF0YUZyb21NaXhlci52O1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3VXNlckRhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEuaXNTdGVyZW9gXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocGVlckRhdGFGcm9tTWl4ZXIucykgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUuaXNTdGVyZW8gPSBwZWVyRGF0YUZyb21NaXhlci5zO1xuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5pc1N0ZXJlbyA9IHBlZXJEYXRhRnJvbU1peGVyLnM7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdVc2VyRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdGhlIG5ld1VzZXJEYXRhIEFORCB0aGUgdXNlckRhdGFDYWNoZSBoYXZlIGJlZW4gdXBkYXRlZCB3aXRoIHRoZSBuZXcgdmFsdWVzXG4gICAgICAgICAgICAgICAgLy8gcHJvcGFnYXRlIG5ld1VzZXJEYXRhIHRvIHVzZXIgc3BhY2VcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyU2VudE5ld1VzZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbE5ld1VzZXJEYXRhLnB1c2gobmV3VXNlckRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub25Vc2VyRGF0YVVwZGF0ZWQgJiYgYWxsTmV3VXNlckRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Vc2VyRGF0YVVwZGF0ZWQoYWxsTmV3VXNlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoanNvbkRhdGEuaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGpzb25EYXRhLmluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0cnVjdGlvbikgfHwgIWluc3RydWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgaW5zdHJ1Y3Rpb25OYW1lID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAgICAgICAgICAgICAgbGV0IGluc3RydWN0aW9uQXJndW1lbnRzID0gaW5zdHJ1Y3Rpb24uc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uTmFtZSA9PT0gXCJtdXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZEJlTXV0ZWQ6IGJvb2xlYW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbkFyZ3VtZW50cy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihpbnN0cnVjdGlvbkFyZ3VtZW50c1swXSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQmVNdXRlZCA9IGluc3RydWN0aW9uQXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRCZU11dGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldE11dGVkQnlBZG1pbihzaG91bGRCZU11dGVkLCBNdXRlUmVhc29uLkFETUlOKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gdGhlIE1peGVyIGdpdmVuIGB0aGlzLndlYlJUQ0FkZHJlc3NgLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBfX25hbWVkUGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB3ZWJSVENTZXNzaW9uUGFyYW1zIC0gUGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIFJBVkkgc2Vzc2lvbiB3aGVuIG9wZW5pbmcgdGhhdCBzZXNzaW9uLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlamVjdHMgd2l0aCBhbiBlcnJvciBtZXNzYWdlIHN0cmluZyB1cG9uIGZhaWx1cmUsIG9yIHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIGZyb20gYGF1ZGlvbmV0LmluaXRgIGFzIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3RUb0hpRmlNaXhlcih7IHdlYlJUQ1Nlc3Npb25QYXJhbXMsIGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnIH06IHsgd2ViUlRDU2Vzc2lvblBhcmFtcz86IFdlYlJUQ1Nlc3Npb25QYXJhbXMsIGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnPzogQ3VzdG9tU1RVTmFuZFRVUk5Db25maWcgfSk6IFByb21pc2U8YW55PiB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlID09PSBIaUZpQ29ubmVjdGlvblN0YXRlcy5Db25uZWN0ZWQgJiYgdGhpcy5taXhlckluZm9bXCJjb25uZWN0ZWRcIl0pIHtcbiAgICAgICAgICAgIGxldCBtc2cgPSBgQWxyZWFkeSBjb25uZWN0ZWQhIElmIGEgcmVjb25uZWN0IGlzIG5lZWRlZCwgcGxlYXNlIGhhbmcgdXAgYW5kIHRyeSBhZ2Fpbi5gO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLndlYlJUQ0FkZHJlc3MpIHtcbiAgICAgICAgICAgIGxldCBlcnJNc2cgPSBgQ291bGRuJ3QgY29ubmVjdDogXFxgdGhpcy53ZWJSVENBZGRyZXNzXFxgIGlzIGZhbHNleSFgO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kaXNjb25uZWN0RnJvbUhpRmlNaXhlcigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3JDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgZXJyTXNnICs9IGBcXG5BZGRpdGlvbmFsbHksIHRoZXJlIHdhcyBhbiBlcnJvciB0cnlpbmcgdG8gY2xvc2UgdGhlIGZhaWxlZCBjb25uZWN0aW9uLiBFcnJvcjpcXG4ke2Vycm9yQ2xvc2luZ31gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVyck1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBsZXQgbWl4ZXJJc1VuYXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHRlbXBVbmF2YWlsYWJsZVN0YXRlSGFuZGxlciA9IChldmVudDogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuc3RhdGUgPT09IFJhdmlTaWduYWxpbmdTdGF0ZXMuVU5BVkFJTEFCTEUpIHtcbiAgICAgICAgICAgICAgICBtaXhlcklzVW5hdmFpbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uLnJlbW92ZVN0YXRlQ2hhbmdlSGFuZGxlcih0ZW1wVW5hdmFpbGFibGVTdGF0ZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdmlTZXNzaW9uLmNsb3NlUkFWSVNlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbi5hZGRTdGF0ZUNoYW5nZUhhbmRsZXIodGVtcFVuYXZhaWxhYmxlU3RhdGVIYW5kbGVyKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24ub3BlblJBVklTaWduYWxpbmdDb25uZWN0aW9uKHRoaXMud2ViUlRDQWRkcmVzcylcbiAgICAgICAgfSBjYXRjaCAoZXJyb3JPcGVuaW5nU2lnbmFsaW5nQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgbGV0IGVyck1zZyA9IGBDb3VsZG4ndCBvcGVuIHNpZ25hbGluZyBjb25uZWN0aW9uIHRvIFxcYCR7dGhpcy53ZWJSVENBZGRyZXNzLnNsaWNlKDAsIHRoaXMud2ViUlRDQWRkcmVzcy5pbmRleE9mKFwidG9rZW49XCIpKX08dG9rZW4gcmVkYWN0ZWQ+XFxgISBFcnJvcjpcXG4ke2Vycm9yT3BlbmluZ1NpZ25hbGluZ0Nvbm5lY3Rpb259YDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGlzY29ubmVjdEZyb21IaUZpTWl4ZXIoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yQ2xvc2luZykge1xuICAgICAgICAgICAgICAgIGVyck1zZyArPSBgXFxuQWRkaXRpb25hbGx5LCB0aGVyZSB3YXMgYW4gZXJyb3IgdHJ5aW5nIHRvIGNsb3NlIHRoZSBmYWlsZWQgY29ubmVjdGlvbi4gRXJyb3I6XFxuJHtlcnJvckNsb3Npbmd9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uLnJlbW92ZVN0YXRlQ2hhbmdlSGFuZGxlcih0ZW1wVW5hdmFpbGFibGVTdGF0ZUhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVyck1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmF2aVNlc3Npb24ub3BlblJBVklTZXNzaW9uKHsgc2lnbmFsaW5nQ29ubmVjdGlvbjogdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24sIHBhcmFtczogd2ViUlRDU2Vzc2lvblBhcmFtcywgY3VzdG9tU3R1bkFuZFR1cm46IGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvck9wZW5pbmdSQVZJU2Vzc2lvbikge1xuICAgICAgICAgICAgbGV0IGVyck1zZyA9IGBDb3VsZG4ndCBvcGVuIFJBVkkgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggXFxgJHt0aGlzLndlYlJUQ0FkZHJlc3Muc2xpY2UoMCwgdGhpcy53ZWJSVENBZGRyZXNzLmluZGV4T2YoXCJ0b2tlbj1cIikpfTx0b2tlbiByZWRhY3RlZD5cXGAhIEVycm9yOlxcbiR7ZXJyb3JPcGVuaW5nUkFWSVNlc3Npb259YDtcbiAgICAgICAgICAgIGlmIChtaXhlcklzVW5hdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICBlcnJNc2cgPSBgSGlnaCBGaWRlbGl0eSBzZXJ2ZXIgaXMgYXQgY2FwYWNpdHk7IHNlcnZpY2UgaXMgdW5hdmFpbGFibGUuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGlzY29ubmVjdEZyb21IaUZpTWl4ZXIoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yQ2xvc2luZykge1xuICAgICAgICAgICAgICAgIGVyck1zZyArPSBgXFxuQWRkaXRpb25hbGx5LCB0aGVyZSB3YXMgYW4gZXJyb3IgdHJ5aW5nIHRvIGNsb3NlIHRoZSBjb25uZWN0aW9uLiBFcnJvcjpcXG4ke2Vycm9yQ2xvc2luZ31gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24ucmVtb3ZlU3RhdGVDaGFuZ2VIYW5kbGVyKHRlbXBVbmF2YWlsYWJsZVN0YXRlSGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyTXNnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhdWRpb25ldEluaXRSZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF1ZGlvbmV0SW5pdFJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9taXNlVG9SdW5BdWRpb0luaXQoKTtcbiAgICAgICAgfSBjYXRjaCAoaW5pdEVycm9yKSB7XG4gICAgICAgICAgICBsZXQgZXJyTXNnID0gYFxcYGF1ZGlvbmV0LmluaXRcXGAgY29tbWFuZCBmYWlsZWQhIEVycm9yOlxcbiR7aW5pdEVycm9yLmVycm9yfWA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2Rpc2Nvbm5lY3RGcm9tSGlGaU1peGVyKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvckNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICBlcnJNc2cgKz0gYFxcbkFkZGl0aW9uYWxseSwgdGhlcmUgd2FzIGFuIGVycm9yIHRyeWluZyB0byBjbG9zZSB0aGUgZmFpbGVkIGNvbm5lY3Rpb24uIEVycm9yOlxcbiR7ZXJyb3JDbG9zaW5nfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbi5yZW1vdmVTdGF0ZUNoYW5nZUhhbmRsZXIodGVtcFVuYXZhaWxhYmxlU3RhdGVIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJNc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24ucmVtb3ZlU3RhdGVDaGFuZ2VIYW5kbGVyKHRlbXBVbmF2YWlsYWJsZVN0YXRlSGFuZGxlcik7XG5cbiAgICAgICAgdGhpcy5jb25jdXJyZW5jeSA9IDA7XG4gICAgICAgIHRoaXMuX3JhdmlTZXNzaW9uLmdldENvbW1hbmRDb250cm9sbGVyKCkuYWRkQmluYXJ5SGFuZGxlcigoZGF0YTogYW55KSA9PiB7IHRoaXMuaGFuZGxlUkFWSVNlc3Npb25CaW5hcnlEYXRhKGRhdGEpIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYXVkaW9uZXRJbml0UmVzcG9uc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIGZyb20gdGhlIE1peGVyLiBDbG9zZXMgdGhlIFJBVkkgU2lnbmFsaW5nIENvbm5lY3Rpb24gYW5kIHRoZSBSQVZJIFNlc3Npb24uXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgX2Fsd2F5c18gUmVzb2x2ZXMgd2l0aCBhIFwic3VjY2Vzc1wiIHN0YXR1cyBzdHJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgZGlzY29ubmVjdEZyb21IaUZpTWl4ZXIoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdGhpcy5fcmF2aURpYWdub3N0aWNzLm5vdGVFeHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2UoKTtcbiAgICAgICAgdGhpcy5faGlmaURpYWdub3N0aWNzLm5vdGVFeHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2Nvbm5lY3RGcm9tSGlGaU1peGVyKCk7XG4gICAgfVxuICAgIGFzeW5jIF9kaXNjb25uZWN0RnJvbUhpRmlNaXhlcigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBjbG9zZSh0aGluZ1RvQ2xvc2U6IChSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiB8IFJhdmlTZXNzaW9uKSwgbmFtZU9mVGhpbmdUb0Nsb3NlOiBzdHJpbmcsIGNsb3NlZFN0YXRlOiBzdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGluZ1RvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGluZ1RvQ2xvc2UuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaW5nVG9DbG9zZSB8fCBzdGF0ZSA9PT0gY2xvc2VkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFRoZSBSQVZJICR7bmFtZU9mVGhpbmdUb0Nsb3NlfSB3YXMgYWxyZWFkeSBjbG9zZWQuYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGluZ1RvQ2xvc2UgaW5zdGFuY2VvZiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaW5nVG9DbG9zZS5jbG9zZVJBVklTaWduYWxpbmdDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaW5nVG9DbG9zZSBpbnN0YW5jZW9mIFJhdmlTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpbmdUb0Nsb3NlLmNsb3NlUkFWSVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIubG9nKGBUaGUgUkFWSSAke25hbWVPZlRoaW5nVG9DbG9zZX0gY2xvc2VkIHN1Y2Nlc3NmdWxseSBmcm9tIHN0YXRlICR7c3RhdGV9LmApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYFRoZSBSQVZJICR7bmFtZU9mVGhpbmdUb0Nsb3NlfSBkaWRuJ3QgY2xvc2Ugc3VjY2Vzc2Z1bGx5IGZyb20gc3RhdGUgJHtzdGF0ZX0hIEVycm9yOlxcbiR7ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBUaGUgUkFWSSAke25hbWVPZlRoaW5nVG9DbG9zZX0gd2FzIG1pc3NpbmcuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaW5nVG9DbG9zZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBjbG9zZSh0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiwgXCJTaWduYWxpbmcgQ29ubmVjdGlvblwiLCBSYXZpU2lnbmFsaW5nU3RhdGVzLkNMT1NFRCk7XG4gICAgICAgIGF3YWl0IGNsb3NlKHRoaXMuX3JhdmlTZXNzaW9uLCBcIlNlc3Npb25cIiwgUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VEKTtcblxuICAgICAgICB0aGlzLl9yZXNldE1peGVySW5mbygpO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuX3NldE11dGVkQnlBZG1pbihmYWxzZSwgTXV0ZVJlYXNvbi5JTlRFUk5BTCk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShgU3VjY2Vzc2Z1bGx5IGRpc2Nvbm5lY3RlZC5gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhdWRpbyBgTWVkaWFTdHJlYW1gIHRoYXQgaXMgc2VudCB0byBSQVZJIHRvIGJlIG1peGVkLlxuICAgICAqIEBwYXJhbSBpbnB1dEF1ZGlvTWVkaWFTdHJlYW0gVGhlIGBNZWRpYVN0cmVhbWAgdGhhdCBpcyBzZW50IHRvIFJBVkkgdG8gYmUgbWl4ZWQuXG4gICAgICogQHBhcmFtIGlzU3RlcmVvIC0gYHRydWVgIGlmIHRoZSBpbnB1dCBzdHJlYW0gc2hvdWxkIGJlIHRyZWF0ZWQgYXMgc3RlcmVvLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbmV3IHN0cmVhbSB3YXMgc3VjY2Vzc2Z1bGx5IHNldDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgYXN5bmMgc2V0UkFWSUlucHV0QXVkaW8oaW5wdXRBdWRpb01lZGlhU3RyZWFtOiBNZWRpYVN0cmVhbSwgaXNTdGVyZW86IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXG4gICAgICAgIGxldCByZXR2YWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX3JhdmlTZXNzaW9uKSB7XG4gICAgICAgICAgICBsZXQgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuX3JhdmlTZXNzaW9uLmdldFN0cmVhbUNvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIGlmICghc3RyZWFtQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IGlucHV0IGF1ZGlvIG9uIF9yYXZpU2Vzc2lvbi5zdHJlYW1Db250cm9sbGVyOiBObyBcXGBzdHJlYW1Db250cm9sbGVyXFxgIWApO1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnNldElucHV0QXVkaW8oaW5wdXRBdWRpb01lZGlhU3RyZWFtLCBpc1N0ZXJlbyk7XG4gICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFN1Y2Nlc3NmdWxseSBzZXQgaW5wdXQgYXVkaW8gb24gX3JhdmlTZXNzaW9uLnN0cmVhbUNvbnRyb2xsZXIhYCk7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IGlucHV0IGF1ZGlvIG9uIF9yYXZpU2Vzc2lvbi5zdHJlYW1Db250cm9sbGVyOiBObyBcXGBfcmF2aVNlc3Npb25cXGAhYCk7XG4gICAgICAgICAgICByZXR2YWwgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXR2YWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW1Jc1N0ZXJlbyAhPSBpc1N0ZXJlbykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yYXZpU2Vzc2lvbi5nZXRTdGF0ZSgpID09PSBSYXZpU2Vzc2lvblN0YXRlcy5DT05ORUNURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RlcmVvIHN0YXR1cyBoYXMgY2hhbmdlZDsgbWF5IG5lZWQgdG8gY2FsbCBhdWRpb25ldC5pbml0IGFnYWluLlxuICAgICAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYFN0ZXJlbyBzdGF0dXMgaGFzIGNoYW5nZWQgZnJvbSAke3RoaXMuX2lucHV0QXVkaW9NZWRpYVN0cmVhbUlzU3RlcmVvfSB0byAke2lzU3RlcmVvfTsgYXR0ZW1wdGluZyB0byByZS1pbml0aWFsaXplIHdpdGggdGhlIG1peGVyYCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhdWRpb25ldEluaXRSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0QXVkaW9NZWRpYVN0cmVhbUlzU3RlcmVvID0gaXNTdGVyZW87XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb25ldEluaXRSZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvbWlzZVRvUnVuQXVkaW9Jbml0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGluaXRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBnb2VzIHdyb25nLCBkbyB3ZSBhY3R1YWxseSBjYXJlIGFsbCB0aGF0IG11Y2g/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBqdXN0IG1lYW5zIHRoYXQgdGhlIG1peGVyIHdpbGwgY29udGludWUgdG8gdHJlYXQgdGhlIG5ldyBzdHJlYW0gYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoYXRldmVyIHNldHRpbmcgaXQgd2FzIGJlZm9yZS4gRm9yIG5vdywganVzdCByZXR1cm4gdGhlIGVycm9yIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IHRoZSB1c2VyIHRyeSBhZ2FpbiBpZiB0aGV5IHdhbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyTXNnID0gYEF0dGVtcHQgdG8gY2FsbCBcXGBhdWRpb25ldC5pbml0XFxgIGZvciBjaGFuZ2UgaW4gc3RlcmVvIHN0YXR1cyBmYWlsZWQhIEVycm9yOlxcbiR7aW5pdEVycm9yLmVycm9yfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgYWxyZWFkeSBjb25uZWN0ZWQsIGl0J2xsIGp1c3QgcGljayB1cCB0aGUgcmlnaHQgc3RlcmVvIHZhbHVlIHdoZW4gd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBpdCB0aGUgZmlyc3QgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXRBdWRpb01lZGlhU3RyZWFtSXNTdGVyZW8gPSBpc1N0ZXJlbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbnB1dCBhdWRpbyBzdHJlYW0gdG8gXCJtdXRlZFwiIGJ5IF9laXRoZXJfOlxuICAgICAqIDEuIENhbGxpbmcgYHN0b3AoKWAgb24gYWxsIG9mIHRoZSBgTWVkaWFTdHJlYW1UcmFja2BzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlcidzIGlucHV0IGF1ZGlvIHN0cmVhbSBPUlxuICAgICAqIDIuIFNldHRpbmcgYHRyYWNrLmVuYWJsZWQgPSBmYWxzZXx0cnVlYCBvbiBhbGwgb2YgdGhlIHRyYWNrcyBvbiB0aGUgdXNlcidzIGlucHV0IGF1ZGlvIHN0cmVhbSAodGhlIGRlZmF1bHQgYmVoYXZpb3IpXG4gICAgICogXG4gICAgICogTWV0aG9kIDEgd2lsbCB3b3JrIGlmIGFuZCBvbmx5IGlmOlxuICAgICAqIDEuIFRoZSBkZXZlbG9wZXIgaGFzIHNldCB0aGUgYHRyeVRvU3RvcE1pY1N0cmVhbWAgYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvbiB0byBgdHJ1ZWAgQU5EXG4gICAgICogMi4gVGhlIGFwcGxpY2F0aW9uIGNvZGUgaXMgcnVubmluZyBpbiB0aGUgYnJvd3NlciBjb250ZXh0IChub3QgdGhlIE5vZGVKUyBjb250ZXh0KSBBTkRcbiAgICAgKiAzLiBUaGUgdXNlcidzIGJyb3dzZXIgZ2l2ZXMgdGhlIHVzZXIgdGhlIGFiaWxpdHkgdG8gcGVybWFuZW50bHkgYWxsb3cgYSB3ZWJzaXRlIHRvIGFjY2VzcyB0aGUgdXNlcidzIG1pY3JvcGhvbmVcbiAgICAgKiAgICBhbmQgcHJvdmlkZXMgdGhlIGBuYXZpZ2F0b3IucGVybWlzc2lvbnNgIGFuZCBgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5YCBvYmplY3RzL21ldGhvZHMuXG4gICAgICogICAgKFJlZmVyIHRvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QZXJtaXNzaW9ucyAtIGFzIG9mIE1hcmNoIDIwMjEsIHRoaXNcbiAgICAgKiAgICBsaXN0IGRvZXMgbm90IGluY2x1ZGUgU2FmYXJpIG9uIGRlc2t0b3Agb3IgaU9TLilcbiAgICAgKiBcbiAgICAgKiBSZWFzb25zIHRvIHVzZSBNZXRob2QgMTpcbiAgICAgKiAtIEJsdWV0b290aCBBdWRpbyBJL08gZGV2aWNlcyB3aWxsIHN3aXRjaCBtb2RlcyBiZXR3ZWVuIG1vbm8gb3V0IGFuZCBzdGVyZW8gb3V0IHdoZW4gdGhlIHVzZXIgaXMgbXV0ZWQsXG4gICAgICogd2hpY2ggeWllbGRzIHNpZ25pZmljYW50bHkgaW1wcm92ZWQgYXVkaW8gb3V0cHV0IHF1YWxpdHkgYW5kIHByb3BlciBhdWRpbyBzcGF0aWFsaXphdGlvbi5cbiAgICAgKiAtIFdoZW4gdGhlIHVzZXIgaXMgbXV0ZWQsIHRoZSBicm93c2VyIHdpbGwgcmVwb3J0IHRoYXQgdGhlaXIgbWljcm9waG9uZSBpcyBub3QgaW4gdXNlLCB3aGljaCBjYW4gaW1wcm92ZVxuICAgICAqIHVzZXIgdHJ1c3QgaW4gdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqIFxuICAgICAqIFJlYXNvbnMgX25vdF8gdG8gdXNlIE1ldGhvZCAxOlxuICAgICAqIC0gQmVjYXVzZSBNZXRob2QgMSByZXF1aXJlcyByZS1vYnRhaW5pbmcgYW4gYXVkaW8gaW5wdXQgc3RyZWFtIHZpYSBgZ2V0VXNlck1lZGlhKClgLCB0aGVyZSBpcyBhIHNtYWxsIGRlbGF5XG4gICAgICogYmV0d2VlbiB0aGUgbW9tZW50IHRoZSB1c2VyIHVuLW11dGVzIGFuZCB3aGVuIHRoZSB1c2VyIGlzIGFibGUgdG8gYmUgaGVhcmQgYnkgb3RoZXIgdXNlcnMgaW4gdGhlIFNwYWNlLlxuICAgICAqIC0gSWYgYSB1c2VyIGlzIHVzaW5nIGEgQmx1ZXRvb3RoIEF1ZGlvIEkvTyBkZXZpY2UsIHRoZXJlIGlzIGEgZGVsYXkgYmV0d2VlbiB0aGUgbW9tZW50IHRoZSB1c2VyIHVuLW11dGVzXG4gICAgICogYW5kIHdoZW4gYSB1c2VyIGNhbiBoZWFyIG90aGVyIHVzZXJzIGluIGEgU3BhY2UgZHVlIHRvIHRoZSBmYWN0IHRoYXQgdGhlIEJsdWV0b290aCBhdWRpbyBkZXZpY2UgbXVzdFxuICAgICAqIHN3aXRjaCBJL08gcHJvZmlsZXMuXG4gICAgICogLSBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdGhlIGBuYXZpZ2F0b3IucGVybWlzc2lvbnNgIEFQSVxuICAgICAqIFxuICAgICAqIEBwYXJhbSBuZXdNdXRlZFZhbHVlIElmIGB0cnVlYCwgdGhlIGlucHV0IGF1ZGlvIHN0cmVhbSB3aWxsIGJlIG11dGVkLiBJZiBgZmFsc2VgLCB0aGUgaW5wdXQgc3RyZWFtIHdpbGwgYmUgdW5tdXRlZC5cbiAgICAgKiBAcGFyYW0gdHJ5VG9TdG9wTWljU3RyZWFtIElmIGBmYWxzZWAsIHRoaXMgZnVuY3Rpb24gd2lsbCB1c2UgTWV0aG9kIDIgZGVzY3JpYmVkIGFib3ZlIHRvIG11dGUgb3IgdW5tdXRlIHRoZSBpbnB1dCBhdWRpbyBzdHJlYW0uIElmIGB0cnVlYCwgdGhpcyBmdW5jdGlvbiB3aWxsIHVzZSBNZXRob2QgMS5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHN0cmVhbSB3YXMgc3VjY2Vzc2Z1bGx5IG11dGVkL3VubXV0ZWQsIGBmYWxzZWAgaWYgaXQgd2FzIG5vdC5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRJbnB1dEF1ZGlvTXV0ZWQobmV3TXV0ZWRWYWx1ZTogYm9vbGVhbiwgdHJ5VG9TdG9wTWljU3RyZWFtOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NldE11dGVkKG5ld011dGVkVmFsdWUsIHRyeVRvU3RvcE1pY1N0cmVhbSwgTXV0ZVJlYXNvbi5DTElFTlQpO1xuICAgIH1cblxuICAgIGFzeW5jIF9zZXRNdXRlZEJ5QWRtaW4obXV0ZWRCeUFkbWluOiBib29sZWFuLCBtdXRlUmVhc29uOiBNdXRlUmVhc29uKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIC8vIEZvciBub3c6XG4gICAgICAgIC8vIC0gQWRtaW4gbXV0aW5nIHNob3VsZCBtdXRlIHRoZSBjbGllbnQsIGFuZCBwcmV2ZW50IHRoZSBjbGllbnQgZnJvbSB1bm11dGluZ1xuICAgICAgICAvLyAtIEFkbWluIHVubXV0aW5nIHNob3VsZCBub3QgdW5tdXRlIHRoZSBjbGllbnQsIGJ1dCBzaW1wbHkgYWxsb3cgdGhlIGNsaWVudCB0byB1bm11dGVcbiAgICAgICAgLy8gLSBXaGVuIHRoZSBjb25uZWN0aW9uIGVuZHMsIHRoZSBjbGllbnQgaXMgYWxsb3dlZCB0byB1bm11dGUsIHdoaWNoIGZvciBub3cgaXMgZXF1aXZhbGVudCB0byBhbiBhZG1pbiB1bm11dGVcbiAgICAgICAgdGhpcy5fYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZyA9IG11dGVkQnlBZG1pbjtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NldE11dGVkKG11dGVkQnlBZG1pbiB8fCB0aGlzLl9sYXN0U3VjY2Vzc2Z1bElucHV0QXVkaW9NdXRlZFZhbHVlLCBmYWxzZSwgbXV0ZVJlYXNvbik7XG4gICAgfVxuXG4gICAgYXN5bmMgX3NldE11dGVkKG5ld011dGVkVmFsdWU6IGJvb2xlYW4sIHRyeVRvU3RvcE1pY1N0cmVhbTogYm9vbGVhbiwgbXV0ZVJlYXNvbjogTXV0ZVJlYXNvbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBsZXQgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIGlmIChtdXRlUmVhc29uID09IE11dGVSZWFzb24uQ0xJRU5UKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZyAmJiAhbmV3TXV0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IG11dGUgc3RhdGU6IE11dGVkIGJ5IGFkbWluLmApO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgc3VjY2VzcyA9IGF3YWl0IHRoaXMuX3RyeVNldElucHV0QXVkaW9NdXRlZChuZXdNdXRlZFZhbHVlLCB0cnlUb1N0b3BNaWNTdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0U3VjY2Vzc2Z1bElucHV0QXVkaW9NdXRlZFZhbHVlID0gbmV3TXV0ZWRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uTXV0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25NdXRlQ2hhbmdlZChuZXcgTXV0ZUNoYW5nZWRFdmVudCh7XG4gICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICB0YXJnZXRJbnB1dEF1ZGlvTXV0ZWRWYWx1ZTogbmV3TXV0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5wdXRBdWRpb011dGVkVmFsdWU6IHRoaXMuX2xhc3RTdWNjZXNzZnVsSW5wdXRBdWRpb011dGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZzogdGhpcy5fYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZyxcbiAgICAgICAgICAgICAgICBtdXRlUmVhc29uOiBtdXRlUmVhc29uXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfVxuXG4gICAgYXN5bmMgX3RyeVNldElucHV0QXVkaW9NdXRlZChuZXdNdXRlZFZhbHVlOiBib29sZWFuLCB0cnlUb1N0b3BNaWNTdHJlYW06IGJvb2xlYW4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgbGV0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRTdHJlYW1Db250cm9sbGVyKCk7XG4gICAgICAgIGlmICh0aGlzLl9yYXZpU2Vzc2lvbiAmJiBzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgICAgICAgICBsZXQgaGFzTWljUGVybWlzc2lvbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIChuYXZpZ2F0b3IpICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5wZXJtaXNzaW9ucyAmJiBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0OiBQZXJtaXNzaW9uU3RhdHVzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7IG5hbWU6ICdtaWNyb3Bob25lJyB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIHsgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnN0YXRlID09PSBcImdyYW50ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBoYXNNaWNQZXJtaXNzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdHJ5VG9TdG9wTWljU3RyZWFtIHx8ICFoYXNNaWNQZXJtaXNzaW9uIHx8IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIERldmVsb3BlciBoYXMgZXhwbGljaXRseSBvciBpbXBsaWNpdGx5IHNldCBgdHJ5VG9TdG9wTWljU3RyZWFtYCB0byBgZmFsc2VgIE9SXG4gICAgICAgICAgICAgICAgLy8gd2UncmUgaW4gdGhlIE5vZGVKUyBjb250ZXh0IE9SXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVzZXIgaGFzbid0IGdyYW50ZWQgb3IgY2FuJ3QgZ3JhbnQgcGVybWFuZW50IG1pYyBwZXJtaXNzaW9ucyB0byBvdXIgc2NyaXB0Li4uXG4gICAgICAgICAgICAgICAgLy8gT24gaU9TIFNhZmFyaSwgdGhlIHVzZXIgX2Nhbid0XyBncmFudCBwZXJtYW5lbnQgbWljIHBlcm1pc3Npb25zIHRvIG91ciBzY3JpcHQuXG4gICAgICAgICAgICAgICAgbGV0IHJhdmlBdWRpb1N0cmVhbSA9IHN0cmVhbUNvbnRyb2xsZXIuX2lucHV0QXVkaW9TdHJlYW07XG5cbiAgICAgICAgICAgICAgICBpZiAocmF2aUF1ZGlvU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhdmlBdWRpb1N0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9ICFuZXdNdXRlZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFN1Y2Nlc3NmdWxseSBzZXQgbXV0ZSBzdGF0ZSB0byAke25ld011dGVkVmFsdWV9IG9uIF9yYXZpU2Vzc2lvbi5zdHJlYW1Db250cm9sbGVyLl9pbnB1dEF1ZGlvU3RyZWFtYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IG11dGUgc3RhdGU6IE5vIFxcYF9pbnB1dEF1ZGlvU3RyZWFtXFxgIG9uIFxcYF9yYXZpU2Vzc2lvbi5zdHJlYW1Db250cm9sbGVyXFxgLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJyb3dzZXIgY29udGV4dCwgaWYgYW5kIG9ubHkgaWYgdGhlIHVzZXIgaGFzIGdyYW50ZWQgbWljIHBlcm1pc3Npb25zIHRvIG91ciBzY3JpcHQsXG4gICAgICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBjYWxsIGBzdG9wKClgIG9uIGFsbCBgTWVkaWFTdHJlYW1UcmFja2BzIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyB1c2VyJ3MgYXVkaW8gaW5wdXQgZGV2aWNlIHN0cmVhbS4gVGhpcyBpcyB0byBob3BlZnVsbHkgYWxsb3cgdGhlIE9TIHRvIHN3aXRjaCB0aGUgdXNlcidzIG91dHB1dCBhdWRpbyBkZXZpY2VcbiAgICAgICAgICAgICAgICAvLyBpbnRvIGhhbGYtZHVwbGV4IChpLmUuIHN0ZXJlbykgbW9kZSBpbiB0aGUgY2FzZSB3aGVyZSB0aGF0IG91dHB1dCBkZXZpY2UgaXMgQmx1ZXRvb3RoLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGhhc24ndCBncmFudGVkIHBlcm1hbmVudCBtaWMgcGVybWlzc2lvbnMgdG8gb3VyIHNjcmlwdCwgZG9pbmcgdGhpcyB3b3VsZCBicmVhayBmZWF0dXJlcyBsaWtlIHB1c2gtdG8tdGFsayxcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGUgYnJvd3NlciB3b3VsZCBwcm9tcHQgdGhlIHVzZXIgZm9yIHBlcm1pc3Npb24gdG8gYWNjZXNzIHRoZSBtaWNyb3Bob25lIGV2ZXJ5IHRpbWUgdGhleSB1bm11dGVkLlxuICAgICAgICAgICAgICAgIGxldCByYXZpQXVkaW9TdHJlYW0gPSBzdHJlYW1Db250cm9sbGVyLl9pbnB1dEF1ZGlvU3RyZWFtO1xuICAgICAgICAgICAgICAgIGlmIChyYXZpQXVkaW9TdHJlYW0gJiYgbmV3TXV0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByYXZpQXVkaW9TdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2s6IE1lZGlhU3RyZWFtVHJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBgTWVkaWFUcmFja0NvbnN0cmFpbnRzYCBhcmUgdmVyeSBsaWtlbHkgdG8gYmUgdGhlIHNhbWUgYWNyb3NzIGFsbCBgTWVkaWFTdHJlYW1UcmFja3NgLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGh1cywgaW4gdGhlIGNhc2Ugb2Ygb3ZlcndyaXRpbmcgdGhpcyB2YWx1ZSBtdWx0aXBsZSB0aW1lcyBkdWUgdG8gbXVsdGlwbGUgdHJhY2tzIGNvbnRhaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aGluIHRoZSBgcmF2aUF1ZGlvU3RyZWFtYCwgdGhlcmUgc2hvdWxkIGJlIG5vIHByb2JsZW1zLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkTWVkaWFUcmFja0NvbnN0cmFpbnRzID0gdHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc2V0SW5wdXRBdWRpbyhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFN1Y2Nlc3NmdWxseSBzZXQgbXV0ZSBzdGF0ZSB0byBcXGB0cnVlXFxgIGJ5IHN0b3BwaW5nIGFsbCBpbnB1dCBtZWRpYSB0cmFja3MhYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJhdmlBdWRpb1N0cmVhbSAmJiAhbmV3TXV0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TWVkaWFTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0aGlzLl9jYWNoZWRNZWRpYVRyYWNrQ29uc3RyYWludHMsIHZpZGVvOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zZXRJbnB1dEF1ZGlvKG5ld01lZGlhU3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFN1Y2Nlc3NmdWxseSBzZXQgbXV0ZSBzdGF0ZSB0byBcXGBmYWxzZVxcYCBieSBnZXR0aW5nIG5ldyBpbnB1dCBtZWRpYSBzdHJlYW0hYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmF2aUF1ZGlvU3RyZWFtICYmICFuZXdNdXRlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhdmlBdWRpb1N0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgU3VjY2Vzc2Z1bGx5IHNldCBtdXRlIHN0YXRlIHRvIFxcYGZhbHNlXFxgIGJ5IGVuYWJsaW5nIGFsbCB0cmFja3Mgb24gXFxgX3JhdmlTZXNzaW9uLnN0cmVhbUNvbnRyb2xsZXIuX2lucHV0QXVkaW9TdHJlYW1cXGAhYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IG11dGUgc3RhdGU6IE5vIFxcYF9pbnB1dEF1ZGlvU3RyZWFtXFxgIG9uIFxcYF9yYXZpU2Vzc2lvbi5zdHJlYW1Db250cm9sbGVyXFxgLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IG11dGUgc3RhdGU6IE5vIFxcYF9yYXZpU2Vzc2lvblxcYCwgb3IgXFxgX3JhdmlTZXNzaW9uLmdldFN0cmVhbUNvbnRyb2xsZXIoKVxcYCByZXR1cm5lZCBudWxsLmApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgb3V0cHV0IGBNZWRpYVN0cmVhbWAgZnJvbSB0aGUgTWl4ZXIuIFRoaXMgaXMgdGhlIGZpbmFsLCBtaXhlZCwgc3BhdGlhbGl6ZWQgYXVkaW8gc3RyZWFtIGNvbnRhaW5pbmdcbiAgICAgKiBhbGwgc291cmNlcyBzZW50IHRvIHRoZSBNaXhlci5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWl4ZWQsIHNwYXRpYWxpemVkIGBNZWRpYVN0cmVhbWAgZnJvbSB0aGUgTWl4ZXIuIFJldHVybnMgYG51bGxgIGlmIGl0J3Mgbm90IHBvc3NpYmxlIHRvIG9idGFpbiB0aGF0IGBNZWRpYVN0cmVhbWAuXG4gICAgICovXG4gICAgZ2V0T3V0cHV0QXVkaW9NZWRpYVN0cmVhbSgpOiBNZWRpYVN0cmVhbSB7XG4gICAgICAgIGlmICghdGhpcy5fcmF2aVNlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRTdHJlYW1Db250cm9sbGVyKCk7XG5cbiAgICAgICAgaWYgKCFzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHJlYW1Db250cm9sbGVyLmdldEF1ZGlvU3RyZWFtKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiwgYW5kXG4gICAgICogZmlyZXMgdGhlIG9uQ2hhbmdlIGhhbmRsZXIgaWYgdGhhdCBzdGF0ZSBoYXMsIGluIGZhY3QsIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHN0YXRlXG4gICAgICovXG4gICAgX3NldEN1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlKHN0YXRlOiBIaUZpQ29ubmVjdGlvblN0YXRlcyk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgaWYgKHRoaXMub25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQodGhpcy5fY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faGlmaURpYWdub3N0aWNzLmZpcmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXRDdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSgpOiBIaUZpQ29ubmVjdGlvblN0YXRlcyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBSQVZJIFNpZ25hbGluZyBTdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBldmVudCBcbiAgICAgKi9cbiAgICBhc3luYyBvblJBVklTaWduYWxpbmdTdGF0ZUNoYW5nZWQoZXZlbnQ6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgTmV3IFJBVkkgc2lnbmFsaW5nIHN0YXRlOiBcXGAke2V2ZW50LnN0YXRlfVxcYGApO1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFJhdmlTaWduYWxpbmdTdGF0ZXMuVU5BVkFJTEFCTEU6XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUoSGlGaUNvbm5lY3Rpb25TdGF0ZXMuVW5hdmFpbGFibGUpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2Rpc2Nvbm5lY3RGcm9tSGlGaU1peGVyKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3JDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIubG9nKGBFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSB0cnlpbmcgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb24uIEVycm9yOlxcbiR7ZXJyb3JDbG9zaW5nfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIFJBVkkgU2Vzc2lvbiBTdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqL1xuICAgIGFzeW5jIG9uUkFWSVNlc3Npb25TdGF0ZUNoYW5nZWQoZXZlbnQ6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgTmV3IFJBVkkgc2Vzc2lvbiBzdGF0ZTogXFxgJHtldmVudC5zdGF0ZX1cXGBgKTtcbiAgICAgICAgdGhpcy5fcmF2aURpYWdub3N0aWNzLmZpcmUoKTtcbiAgICAgICAgc3dpdGNoIChldmVudC5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBSYXZpU2Vzc2lvblN0YXRlcy5DT05ORUNURUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fbWl4ZXJQZWVyS2V5VG9TdGF0ZUNhY2hlRGljdCA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEN1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlKEhpRmlDb25uZWN0aW9uU3RhdGVzLkNvbm5lY3RlZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkRJU0NPTk5FQ1RFRDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUgPT09IEhpRmlDb25uZWN0aW9uU3RhdGVzLlVuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZShIaUZpQ29ubmVjdGlvblN0YXRlcy5EaXNjb25uZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2Rpc2Nvbm5lY3RGcm9tSGlGaU1peGVyKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3JDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIubG9nKGBFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSB0cnlpbmcgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb24uIEVycm9yOlxcbiR7ZXJyb3JDbG9zaW5nfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmF2aVNlc3Npb25TdGF0ZXMuRkFJTEVEOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSA9PT0gSGlGaUNvbm5lY3Rpb25TdGF0ZXMuVW5hdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEN1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlKEhpRmlDb25uZWN0aW9uU3RhdGVzLkZhaWxlZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkNMT1NFRDpcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIGFuIFwiVW5hdmFpbGFibGVcIiBzdGF0ZS4gKFRoaXMgd2lsbCBob3BlZnVsbHlcbiAgICAgICAgICAgICAgICAvLyBiZSBhYmxlIHRvIGdvIGF3YXkgb25jZSBjaGFuZ2VzIGZyb20gSElGSS02MjkgYXJlIGNvbXBsZXRlLCBidXQgaXMgc2FmZSB0byBsZWF2ZSBpbiBmb3Igbm93LilcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUgPT09IEhpRmlDb25uZWN0aW9uU3RhdGVzLlVuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZShIaUZpQ29ubmVjdGlvblN0YXRlcy5EaXNjb25uZWN0ZWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnRDb2xsZWN0aW5nV2ViUlRDU3RhdHMoY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmF2aVNlc3Npb24pIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYENvdWxkbid0IHN0YXJ0IGNvbGxlY3RpbmcgV2ViUlRDIHN0YXRzOiBObyBcXGBfcmF2aVNlc3Npb25cXGAhYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc3RhdHNPYnNlcnZlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BDb2xsZWN0aW5nV2ViUlRDU3RhdHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXRzT2JzZXJ2ZXJDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgICAgIHRoaXMuX3JhdmlTZXNzaW9uLmFkZFN0YXRzT2JzZXJ2ZXIodGhpcy5fc3RhdHNPYnNlcnZlckNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBzdG9wQ29sbGVjdGluZ1dlYlJUQ1N0YXRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JhdmlTZXNzaW9uKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBDb3VsZG4ndCBzdG9wIGNvbGxlY3RpbmcgV2ViUlRDIHN0YXRzOiBObyBcXGBfcmF2aVNlc3Npb25cXGAhYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yYXZpU2Vzc2lvbi5yZW1vdmVTdGF0c09ic2VydmVyKHRoaXMuX3N0YXRzT2JzZXJ2ZXJDYWxsYmFjayk7XG5cbiAgICAgICAgdGhpcy5fc3RhdHNPYnNlcnZlckNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YSAtIFRoZSBuZXcgdXNlciBkYXRhIHRoYXQgd2Ugd2FudCB0byBzZW5kIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBzZXJ2ZXIuXG4gICAgICogQHJldHVybnMgSWYgdGhpcyBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bCwgcmV0dXJucyBgeyBzdWNjZXNzOiB0cnVlLCBzdHJpbmdpZmllZERhdGFGb3JNaXhlcjogPHRoZSByYXcgZGF0YSB0aGF0IHdhcyB0cmFuc21pdHRlZCB0byB0aGUgc2VydmVyPn1gLiBJZiB1bnN1Y2Nlc3NmdWwsIHJldHVybnNcbiAgICAgKiBgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IDxhbiBlcnJvciBtZXNzYWdlPiB9YC5cbiAgICAgKi9cbiAgICBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIoY3VycmVudEhpZmlBdWRpb0FQSURhdGE6IEhpRmlBdWRpb0FQSURhdGEsIHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YT86IEhpRmlBdWRpb0FQSURhdGEpOiBhbnkge1xuICAgICAgICBpZiAoIXRoaXMubWl4ZXJJbmZvW1wiY29ubmVjdGVkXCJdIHx8ICF0aGlzLl9yYXZpU2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogYENhbid0IHRyYW5zbWl0IGRhdGEgdG8gbWl4ZXI7IG5vdCBjb25uZWN0ZWQgdG8gbWl4ZXIuYFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkYXRhRm9yTWl4ZXI6IGFueSA9IHt9O1xuXG4gICAgICAgIC8vIGlmIGEgcG9zaXRpb24gaXMgc3BlY2lmaWVkIHdpdGggdmFsaWQgY29tcG9uZW50cywgbGV0J3MgY29uc2lkZXIgYWRkaW5nIHBvc2l0aW9uIHBheWxvYWRcbiAgICAgICAgaWYgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnBvc2l0aW9uICYmICh0eXBlb2YgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLngpID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgJiYgKHR5cGVvZiAoY3VycmVudEhpZmlBdWRpb0FQSURhdGEucG9zaXRpb24ueSkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAmJiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi56KSA9PT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgICAgIC8vIERldGVjdCB0aGUgcG9zaXRpb24gY29tcG9uZW50cyB3aGljaCBoYXZlIHJlYWxseSBjaGFuZ2VkIGNvbXBhcmVkIHRvIHRoZSBwcmV2aW91cyBzdGF0ZSBrbm93biBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkQ29tcG9uZW50czogeyB4OiBib29sZWFuLCB5OiBib29sZWFuLCB6OiBib29sZWFuLCBjaGFuZ2VkOiBib29sZWFuIH0gPSB7IHg6IGZhbHNlLCB5OiBmYWxzZSwgejogZmFsc2UsIGNoYW5nZWQ6IGZhbHNlIH07XG4gICAgICAgICAgICBpZiAocHJldmlvdXNIaWZpQXVkaW9BUElEYXRhICYmIHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi54ICE9PSBwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEucG9zaXRpb24ueCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy54ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi55ICE9PSBwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEucG9zaXRpb24ueSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy55ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi56ICE9PSBwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEucG9zaXRpb24ueikge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy56ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy54ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy55ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy56ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU29tZSBwb3NpdGlvbiBjb21wb25lbnRzIGhhdmUgY2hhbmdlZCwgbGV0J3MgZmlsbCBpbiB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgaWYgKGNoYW5nZWRDb21wb25lbnRzLmNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhbnNsYXRlZFBvc2l0aW9uID0gSGlGaUF4aXNVdGlsaXRpZXMudHJhbnNsYXRlUG9pbnQzRFRvTWl4ZXJTcGFjZShvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24sIGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uIGRhdGEgaXMgc2VudCBpbiBtaWxsaW1ldGVycyBpbnRlZ2VycyB0byByZWR1Y2UgSlNPTiBzaXplLlxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkQ29tcG9uZW50cy54KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcInhcIl0gPSBNYXRoLnJvdW5kKHRyYW5zbGF0ZWRQb3NpdGlvbi54ICogMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkQ29tcG9uZW50cy55KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcInlcIl0gPSBNYXRoLnJvdW5kKHRyYW5zbGF0ZWRQb3NpdGlvbi55ICogMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkQ29tcG9uZW50cy56KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcInpcIl0gPSBNYXRoLnJvdW5kKHRyYW5zbGF0ZWRQb3NpdGlvbi56ICogMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgb3JpZW50YXRpb24gaXMgc3BlY2lmaWVkIHdpdGggdmFsaWQgY29tcG9uZW50cywgbGV0J3MgY29uc2lkZXIgYWRkaW5nIG9yaWVudGF0aW9uIHBheWxvYWRcbiAgICAgICAgaWYgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdCAmJiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQudykgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAmJiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueCkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAmJiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueSkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAmJiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueikgPT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgICAgICAvLyBEZXRlY3QgdGhlIG9yaWVudGF0aW9uIGNvbXBvbmVudHMgd2hpY2ggaGF2ZSByZWFsbHkgY2hhbmdlZCBjb21wYXJlZCB0byB0aGUgcHJldmlvdXMgc3RhdGUga25vd24gZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAgICBsZXQgY2hhbmdlZENvbXBvbmVudHM6IHsgdzogYm9vbGVhbiwgeDogYm9vbGVhbiwgeTogYm9vbGVhbiwgejogYm9vbGVhbiwgY2hhbmdlZDogYm9vbGVhbiB9ID0geyB3OiBmYWxzZSwgeDogZmFsc2UsIHk6IGZhbHNlLCB6OiBmYWxzZSwgY2hhbmdlZDogZmFsc2UgfTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEgJiYgcHJldmlvdXNIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQudyAhPT0gcHJldmlvdXNIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC53KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLncgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC54ICE9PSBwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LngpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMueCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEhpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnkgIT09IHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy55ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueiAhPT0gcHJldmlvdXNIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC56KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnogPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLncgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnogPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTb21lIG9yaWVudGF0aW9uIGNvbXBvbmVudHMgaGF2ZSBjaGFuZ2VkLCBsZXQncyBmaWxsIGluIHRoZSBwYXlsb2FkXG4gICAgICAgICAgICBpZiAoY2hhbmdlZENvbXBvbmVudHMuY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBtaXhlciBleHBlY3RzIFF1YXRlcm5pb24gY29tcG9uZW50cyBpbiBpdHMgc3BhY2UgYW5kIHRvIGJlIG11bGl0aXBsaWVkIGJ5IDEwMDAuXG4gICAgICAgICAgICAgICAgbGV0IHRyYW5zbGF0ZWRPcmllbnRhdGlvbiA9IEhpRmlBeGlzVXRpbGl0aWVzLnRyYW5zbGF0ZU9yaWVudGF0aW9uUXVhdDNEVG9NaXhlclNwYWNlKG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbiwgY3VycmVudEhpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0KTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkQ29tcG9uZW50cy53KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcIldcIl0gPSB0cmFuc2xhdGVkT3JpZW50YXRpb24udyAqIDEwMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkQ29tcG9uZW50cy54KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcIlhcIl0gPSB0cmFuc2xhdGVkT3JpZW50YXRpb24ueCAqIDEwMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkQ29tcG9uZW50cy55KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcIllcIl0gPSB0cmFuc2xhdGVkT3JpZW50YXRpb24ueSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIChjaGFuZ2VkQ29tcG9uZW50cy56KSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBzZW5kIFogYWxsIHRoZSB0aW1lIGF0IHRoZSBtb21lbnQgdW50aWwgd2UgbWVyZ2UgdGhlIGZpeCBodHRwczovL2dpdGh1Yi5jb20vaGlnaGZpZGVsaXR5L2F1ZGlvbmV0LWhpZmkvcHVsbC8yNzFcbiAgICAgICAgICAgICAgICBkYXRhRm9yTWl4ZXJbXCJaXCJdID0gdHJhbnNsYXRlZE9yaWVudGF0aW9uLnogKiAxMDAwO1xuICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiAoY3VycmVudEhpZmlBdWRpb0FQSURhdGEudm9sdW1lVGhyZXNob2xkKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgZGF0YUZvck1peGVyW1wiVFwiXSA9IGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnZvbHVtZVRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLmhpRmlHYWluKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgZGF0YUZvck1peGVyW1wiZ1wiXSA9IE1hdGgubWF4KDAsIGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLmhpRmlHYWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnVzZXJBdHRlbnVhdGlvbikgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcImFcIl0gPSBjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS51c2VyQXR0ZW51YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS51c2VyUm9sbG9mZikgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcInJcIl0gPSBNYXRoLm1heCgwLCBjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS51c2VyUm9sbG9mZik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWUpID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkVXNlckdhaW5zOiBPdGhlclVzZXJHYWluTWFwID0ge307XG4gICAgICAgICAgICBsZXQgaWRUb0dhaW5zID0gT2JqZWN0LmVudHJpZXMoY3VycmVudEhpZmlBdWRpb0FQSURhdGEuX290aGVyVXNlckdhaW5RdWV1ZSk7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNPdGhlclVzZXJHYWlucyA9IHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YSA/IHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YS5fb3RoZXJVc2VyR2FpblF1ZXVlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZFRvR2FpbiBvZiBpZFRvR2FpbnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFzaGVkVmlzaXRJZCA9IGlkVG9HYWluWzBdO1xuICAgICAgICAgICAgICAgIGxldCBnYWluID0gaWRUb0dhaW5bMV07XG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mKGdhaW4pID09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNPdGhlclVzZXJHYWlucyAmJiBwcmV2aW91c090aGVyVXNlckdhaW5zW2hhc2hlZFZpc2l0SWRdID09PSBnYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFuZ2VkVXNlckdhaW5zW2hhc2hlZFZpc2l0SWRdID0gZ2FpbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5lbnRyaWVzKGNoYW5nZWRVc2VyR2FpbnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcIlZcIl0gPSBjaGFuZ2VkVXNlckdhaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRhdGFGb3JNaXhlcikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBjYWxsIHRoaXMgYSBcInN1Y2Nlc3NcIiBldmVuIHRob3VnaCB3ZSBkaWRuJ3Qgc2VuZCBhbnl0aGluZyB0byB0aGUgbWl4ZXIuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZWREYXRhRm9yTWl4ZXI6IEpTT04uc3RyaW5naWZ5KHt9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb21tYW5kQ29udHJvbGxlciA9IHRoaXMuX3JhdmlTZXNzaW9uLmdldENvbW1hbmRDb250cm9sbGVyKCk7XG5cbiAgICAgICAgICAgIGlmIChjb21tYW5kQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGxldCBzdHJpbmdpZmllZERhdGFGb3JNaXhlciA9IEpTT04uc3RyaW5naWZ5KGRhdGFGb3JNaXhlcik7XG4gICAgICAgICAgICAgICAgY29tbWFuZENvbnRyb2xsZXIuc2VuZElucHV0KHN0cmluZ2lmaWVkRGF0YUZvck1peGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZmllZERhdGFGb3JNaXhlcjogc3RyaW5naWZpZWREYXRhRm9yTWl4ZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBDYW4ndCB0cmFuc21pdCBkYXRhIHRvIG1peGVyOyBubyBcXGBjb21tYW5kQ29udHJvbGxlclxcYCEuYFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgb3VyIFwiTWl4ZXIgSW5mb1wiLiBIYXBwZW5zIHVwb24gaW5zdGFudGlhdGlvbiBhbmQgd2hlbiBkaXNjb25uZWN0aW5nIGZyb20gdGhlIG1peGVyLlxuICAgICAqL1xuICAgIHByaXZhdGUgX3Jlc2V0TWl4ZXJJbmZvKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1peGVySW5mbyA9IHtcbiAgICAgICAgICAgIFwiY29ubmVjdGVkXCI6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsIi8qKlxuICogVGhpcyBtb2R1bGUgcGVydGFpbnMgdG8gVXNlciBEYXRhIFN1YnNjcmlwdGlvbnMsIHdoaWNoIGFsbG93IGNsaWVudHMgdG8gcmVjZWl2ZSB1cGRhdGVzIGZyb20gdGhlIFNlcnZlciBhYm91dCBhbGwgbmV3IFVzZXIgRGF0YS5cbiAqIFNlZSBbW2FkZFVzZXJEYXRhU3Vic2NyaXB0aW9uXV0uXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG4vKipcbiAqIFdoZW4gYWRkaW5nIGEgbmV3IFVzZXIgRGF0YSBTdWJzY3JpcHRpb24sIGEgY2xpZW50IG11c3Qgc3BlY2lmeSBvbmUgb2YgdGhlIFwiY29tcG9uZW50c1wiIGxpc3RlZCBhcyBhIHBhcnQgb2YgdGhpcyBgZW51bWAuXG4gKiBGb3IgZXhhbXBsZSwgc3Vic2NyaWJpbmcgdG8gYFBvc2l0aW9uYCB1cGRhdGVzIGVuc3VyZXMgdGhhdCBhIFN1YnNjcmliZXIgd2lsbCByZWNlaXZlIGFsbCBjaGFuZ2VzIHRvIHRoYXQgdXNlcidzIHBvc2l0aW9uLlxuICovXG5leHBvcnQgZW51bSBBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHMge1xuICAgIFBvc2l0aW9uID0gXCJQb3NpdGlvblwiLFxuICAgIE9yaWVudGF0aW9uRXVsZXIgPSBcIk9yaWVudGF0aW9uIChFdWxlcilcIixcbiAgICBPcmllbnRhdGlvblF1YXQgPSBcIk9yaWVudGF0aW9uIChRdWF0ZXJuaW9uKVwiLFxuICAgIFZvbHVtZURlY2liZWxzID0gXCJWb2x1bWUgKERlY2liZWxzKVwiLFxuICAgIElzU3RlcmVvID0gXCJJc1N0ZXJlb1wiXG59XG5cbi8qKlxuICogVXNlciBEYXRhIFN1YnNjcmlwdGlvbnMgYWxsb3cgY2xpZW50IEFQSSB1c2VycyB0byBwZXJmb3JtIGFjdGlvbnMsIHN1Y2ggYXMgbG9nZ2luZywgd2hlbiB0aGUgY2xpZW50XG4gKiByZWNlaXZlcyBuZXcgVXNlciBEYXRhIGZyb20gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIFNlcnZlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFVzZXJEYXRhU3Vic2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdXNlcidzIGBwcm92aWRlZFVzZXJJRGAgYXNzb2NpYXRlZCB3aXRoIHRoZSBTdWJzY3JpcHRpb24uIFNlZSB7QGxpbmsgSGlGaUF1ZGlvQVBJRGF0YX0uIE9wdGlvbmFsLiBJZiB1bnNldCwgdGhlIFN1YnNjcmlwdGlvbiBjYWxsYmFja1xuICAgICAqIHdpbGwgYmUgY2FsbGVkIGZvciBhbGwgdXNlcnMnIGRhdGEgd2hlbiBpdCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHByb3ZpZGVkVXNlcklEOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIFVzZXIgRGF0YSBjb21wb25lbnRzIHRvIHdoaWNoIHdlIHdhbnQgdG8gc3Vic2NyaWJlLCBzdWNoIGFzIFBvc2l0aW9uLCBPcmllbnRhdGlvbkV1bGVyLCBvciBWb2x1bWVEZWNpYmVscy5cbiAgICAgKi9cbiAgICBjb21wb25lbnRzOiBBcnJheTxBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHM+O1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGNsaWVudCByZWNlaXZlcyBuZXcgVXNlciBEYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgYGNvbXBvbmVudGAgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIFRoZSBmaXJzdCBhbmQgb25seSBhcmd1bWVudCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBvZiB0eXBlIGBBcnJheTxSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE+YC5cbiAgICAgKi9cbiAgICBjYWxsYmFjazogRnVuY3Rpb247XG4gICAgXG4gICAgY29uc3RydWN0b3IoeyBwcm92aWRlZFVzZXJJRCA9IG51bGwsIGNvbXBvbmVudHMsIGNhbGxiYWNrIH06IHsgcHJvdmlkZWRVc2VySUQ/OiBzdHJpbmcsIGNvbXBvbmVudHM6IEFycmF5PEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cz4sIGNhbGxiYWNrOiBGdW5jdGlvbiB9KSB7XG4gICAgICAgIHRoaXMucHJvdmlkZWRVc2VySUQgPSBwcm92aWRlZFVzZXJJRDtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbn0iLCIvKipcbiAqIFRoaXMgbW9kdWxlIGRlZmluZXMgYSBudW1iZXIgb2YgY29uc3RhbnRzIHVzZWQgdGhyb3VnaG91dCB0aGUgQVBJIGNvZGUuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG4vKipcbiAqIERlZmluZXMgYSBudW1iZXIgb2YgY29uc3RhbnRzIHVzZWQgdGhyb3VnaG91dCB0aGUgQVBJIGNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBIaUZpQ29uc3RhbnRzIHtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIHRoYXQgbXVzdCBwYXNzIGJldHdlZW4gQVBJIHRyYW5zbWlzc2lvblxuICAgICAqIG9mIGRhdGEgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgc3RhdGljIE1JTl9UUkFOU01JVF9SQVRFX0xJTUlUX1RJTUVPVVRfTVM6IG51bWJlciA9IDEwO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGRlZmF1bHQgYW1vdW50IG9mIHRpbWUgdGhhdCBtdXN0IHBhc3MgYmV0d2VlbiBBUEkgdHJhbnNtaXNzaW9uXG4gICAgICogb2YgZGF0YSBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgREVGQVVMVF9UUkFOU01JVF9SQVRFX0xJTUlUX1RJTUVPVVRfTVM6IG51bWJlciA9IDUwO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9kdWN0aW9uIGVuZHBvaW50IGZvciBvdXIgSGlnaCBGaWRlbGl0eSBhdWRpbyBjb25uZWN0aW9ucy5cbiAgICAgKi9cbiAgICBzdGF0aWMgREVGQVVMVF9QUk9EX0hJR0hfRklERUxJVFlfRU5EUE9JTlQ6IHN0cmluZyA9IFwiYXBpLmhpZ2hmaWRlbGl0eS5jb21cIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBwb3J0IGZvciBzaWduYWxpbmcgY29ubmVjdGlvbnMgdG8gb3VyIEhpZ2ggRmlkZWxpdHkgYXVkaW8gc2VydmVycy5cbiAgICAgKi9cbiAgICBzdGF0aWMgREVGQVVMVF9QUk9EX0hJR0hfRklERUxJVFlfUE9SVDogbnVtYmVyID0gNDQzO1xuXG4gICAgY29uc3RydWN0b3IoKSB7fVxufTtcbiIsImltcG9ydCB7IEhpRmlNaXhlclNlc3Npb24gfSBmcm9tIFwiLi4vY2xhc3Nlcy9IaUZpTWl4ZXJTZXNzaW9uXCI7XG5pbXBvcnQgeyBSYXZpU2Vzc2lvbiwgU1RBVFNfV0FUQ0hFUl9GSUxURVIgfSBmcm9tIFwiLi4vbGlicmF2aS9SYXZpU2Vzc2lvblwiO1xuXG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IG5vb3AgPSAoXzphbnkpOmFueSA9PiB1bmRlZmluZWQ7XG5jb25zdCB4U3RvcmFnZSA9IGlzQnJvd3NlciA/IHdpbmRvdy5sb2NhbFN0b3JhZ2UgOiB7Z2V0SXRlbTogbm9vcCwgc2V0SXRlbTogbm9vcCwgcmVtb3ZlSXRlbTogbm9vcH07XG5jb25zdCB4QWRkRXZlbnRMaXN0ZW5lcjphbnkgPSBpc0Jyb3dzZXIgPyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA6IG5vb3A7XG5jb25zdCB4UmVtb3ZlRXZlbnRMaXN0ZW5lcjphbnkgPSBpc0Jyb3dzZXIgPyB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciA6IG5vb3A7XG5jb25zdCB4RG9jdW1lbnQgPSBpc0Jyb3dzZXIgPyB3aW5kb3cuZG9jdW1lbnQgOiB7dmlzaWJpbGl0eVN0YXRlOiB0cnVlLCBhZGRFdmVudExpc3RlbmVyOiBub29wLCByZW1vdmVFdmVudExpc3RlbmVyOiBub29wfTtcbmNvbnN0IHhOYXZpZ2F0b3IgPSBpc0Jyb3dzZXIgPyB3aW5kb3cubmF2aWdhdG9yIDoge29uTGluZTogdHJ1ZSwgdXNlckFnZW50OiBgTm9kZUpTICR7KHByb2Nlc3MucmVwb3J0LmdldFJlcG9ydCgpIGFzIGFueSkuaGVhZGVyLm5vZGVqc1ZlcnNpb259YH07XG5sZXQgeGZldGNoID0gaXNCcm93c2VyICYmIHdpbmRvdy5mZXRjaDtcbmlmICghaXNCcm93c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgeGZldGNoID0gcmVxdWlyZSgnbm9kZS1mZXRjaCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgOyAvLyBSZW1haW5zIGZhbHNleS4gRG9uJ3QgcmVwb3J0LCBkb24ndCBsb2dcbiAgICB9XG59XG5cbmNvbnN0IG5vbk9wZXJhdGl2ZSA9IFwibm9uLW9wZXJhdGl2ZVwiO1xuXG5TVEFUU19XQVRDSEVSX0ZJTFRFUi5zZXQoJ3JlbW90ZS1pbmJvdW5kLXJ0cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU1RBVFNfV0FUQ0hFUl9GSUxURVIuZ2V0KCdyZW1vdGUtaW5ib3VuZC1ydHAnKS5jb25jYXQoWydwYWNrZXRzTG9zdCcsICd0b3RhbFJvdW5kVHJpcFRpbWUnXSkpO1xuU1RBVFNfV0FUQ0hFUl9GSUxURVIuc2V0KCdpbmJvdW5kLXJ0cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU1RBVFNfV0FUQ0hFUl9GSUxURVIuZ2V0KCdpbmJvdW5kLXJ0cCcpLmNvbmNhdChbJ3BhY2tldHNMb3N0JywgJ3BhY2tldHNSZWNlaXZlZCcsICdqaXR0ZXInXSkpO1xuU1RBVFNfV0FUQ0hFUl9GSUxURVIuc2V0KCdvdXRib3VuZC1ydHAnLCBbJ3R5cGUnLCAncmV0cmFuc21pdHRlZFBhY2tldHNTZW50JywgJ3BhY2tldHNTZW50J10pO1xuXG5TVEFUU19XQVRDSEVSX0ZJTFRFUi5zZXQoJ2NhbmRpZGF0ZS1wYWlyJywgWyd3cml0YWJsZScsICdzdGF0ZScsICdub21pbmF0ZWQnLCAnbG9jYWxDYW5kaWRhdGVJZCcsICdyZW1vdGVDYW5kaWRhdGVJZCddKTtcblNUQVRTX1dBVENIRVJfRklMVEVSLnNldCgncmVtb3RlLWNhbmRpZGF0ZScsIFsnaWQnLCAnYWRkcmVzcycsICdpcCcsICdjYW5kaWRhdGVUeXBlJywgJ3Byb3RvY29sJ10pO1xuU1RBVFNfV0FUQ0hFUl9GSUxURVIuc2V0KCdsb2NhbC1jYW5kaWRhdGUnLCBbJ2lkJywgJ2FkZHJlc3MnLCAnaXAnLCAnY2FuZGlkYXRlVHlwZScsICdwcm90b2NvbCddKTtcblxuaW50ZXJmYWNlIENhbmRpZGF0ZVJlcG9ydCB7XG4gICAgaXA/OiBzdHJpbmc7XG4gICAgYWRkcmVzcz86IHN0cmluZztcbiAgICBjYW5kaWRhdGVUeXBlPzogc3RyaW5nO1xuICAgIHByb3RvY29sPzogc3RyaW5nO1xufVxubGV0IG5TdGF0c0NsaWVudHMgPSAwO1xubGV0IGJyb3dzZXJTdGF0czogQ2FuZGlkYXRlUmVwb3J0ID0ge307XG5sZXQgcmVtb3RlU3RhdHM6IENhbmRpZGF0ZVJlcG9ydCA9IHt9O1xubGV0IHJlcG9ydHM6YW55O1xuY29uc3QgdXNlRGVidWdQcmVmaXhlcyA9IGZhbHNlO1xuXG4vKiogXG4gKiBAaW50ZXJuYWxcbiAqIFRoaXMgaXMgbm90IGdlbmVyYWwgcHVycG9zZSwgYnV0IHNwZWNpZmljYWxseSBpbiBzdXBwb3J0IG9mIGludGVybmFsIEhpRmlkZWxpdHkgY29ubmVjdGlvbiBmYWlsdXJlcy5cbiAqIEl0IGlzIG5vdCBpbnRlbmRlZCB0byBiZSBzdXBwb3J0ZWQgZm9yIGxvbmcgdGVybS5cbiAqXG4gKiBBbiBpbnN0YW5jZSBvZiBEaWFnbm9zdGljcyBtYWludGFpbnMgYSBzZXQgb2YgaW5mb3JtYXRpb24sIGFuZCBoYXMgb3BlcmF0aW9ucyB0byB1cGRhdGUgdGhhdCBpbmZvcm1hdGlvbiwgYW5kIHRvIHJlcG9ydCBpdC5cbiAqIFRoZXJlIGNhbiBiZSBtdWx0aXBsZSBzdWNoIGluc3RhbmNlcywgdGhhdCBhcmUgcmVwb3J0ZWQgaW4gZGlmZmVyZW50IGNpcmN1bXN0YW5jZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEaWFnbm9zdGljcyB7XG4gICAgbGFiZWw6IHN0cmluZztcbiAgICB1cmw6IHN0cmluZztcbiAgICBpZGVudGlmaWVyOiBzdHJpbmc7XG4gICAgc2Vzc2lvbjogSGlGaU1peGVyU2Vzc2lvbjtcbiAgICByYXZpOiBSYXZpU2Vzc2lvbjtcbiAgICBleHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2U6IGJvb2xlYW47XG4gICAgd2ViU29ja2V0OiBhbnk7XG4gICAgcnRjOiBhbnk7XG4gICAgZmlyZU9uOiBBcnJheTxzdHJpbmc+O1xuICAgIGZpcmVMaXN0ZW5lcjogRnVuY3Rpb247XG4gICAgb25saW5lTGlzdGVuZXI6IEZ1bmN0aW9uO1xuXG4gICAgY29uc3RydWN0b3Ioe3VybCA9IFwiaHR0cHM6Ly93ZWJydGMtZGlhZy5oaWdoZmlkZWxpdHkuY29tL2FwaS92MS9sb2dzL3Bvc3RfbG9nc1wiLFxuICAgICAgICAgICAgICAgICBsYWJlbCwgc2Vzc2lvbiwgcmF2aSwgZmlyZU9uID0gW119Ont1cmw/OnN0cmluZywgbGFiZWw6c3RyaW5nLCBzZXNzaW9uOkhpRmlNaXhlclNlc3Npb24sIHJhdmk6UmF2aVNlc3Npb24sIGZpcmVPbj86QXJyYXk8c3RyaW5nPn0pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7dXJsLCBsYWJlbCwgc2Vzc2lvbiwgcmF2aSwgZmlyZU9ufSk7XG4gICAgICAgIHRoaXMuY2hlY2tQZXJzaXN0ZWQoKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLmZpcmVMaXN0ZW5lciA9ICgpID0+IHRoaXMuZmlyZSgpO1xuICAgICAgICB0aGlzLm9ubGluZUxpc3RlbmVyID0gKCkgPT4gdGhpcy5jaGVja1BlcnNpc3RlZCgpO1xuICAgIH1cbiAgICAvKiogXG4gICAgICogQW4gaW5zdGFuY2UgaXMgcHJpbWVkIHdoZW4gZW50ZXJpbmcgdGhlIHN0YXRlIHdlIGFyZSBpbnRlcmVzdGVkIGluLCB1bnRpbCB0aGUgcmVwb3J0IGlzIGZpcmVkLlxuICAgICAqL1xuICAgIHByaW1lKGlkZW50aWZpZXI6c3RyaW5nKSB7IC8vIGUuZy4sIGhhc2hlZFZpc2l0SUQuIERvIE5PVCB1c2UgYW55IHBlcnNvbmFsbHkgaWRlbnRpZmlhYmxlIGluZm9ybWF0aW9uLiBEYXRhIGlzIGEgbGlhYmlsaXR5LCBub3QgYW4gYXNzZXQuXG4gICAgICAgIGlmICh0aGlzLmlzUHJpbWVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5jaGVja1BlcnNpc3RlZCgpOyAvLyBCZWNhdXNlIHRoaXMgaXMgYSBsaWtlbHkgdGltZSB0byBiZSBzdWNjZXNzZnVsLlxuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICAgICAgICB0aGlzLmdyYWJSVENJbnRlcm5hbHMoKTtcbiAgICAgICAgRGlhZ25vc3RpY3Muc3RhcnRTdGF0cyh0aGlzLnNlc3Npb24pO1xuICAgICAgICB0aGlzLmZpcmVPbi5mb3JFYWNoKGV2ZW50ID0+ICh4RG9jdW1lbnQgYXMgYW55KS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmZpcmVMaXN0ZW5lcikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoaXMgd2hlbiB3ZSBnZXQgaW50byBhIHN0YXRlIHRoYXQgd2Ugd2FudCB0byBrbm93IG1vcmUgYWJvdXQsIGUuZy4sIHdoZW4gbGVhdmluZyB0aGUgdGhpbmcgdGhhdCBjYXVzZWQgdXMgdG8gcHJpbWUoKS5cbiAgICAgKi9cbiAgICBhc3luYyBmaXJlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNQcmltZWQoKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCByZXBvcnRTdHJpbmcgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghIGF3YWl0IHRoaXMucmVwb3J0KHJlcG9ydFN0cmluZykpIHtcbiAgICAgICAgICAgIHRoaXMucGVyc2lzdChyZXBvcnRTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIG5vdGVFeHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZXhwbGljaXRBcHBsaWNhdGlvbkNsb3NlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBNb3N0bHkgaW50ZXJuYWwgc3R1ZmYuXG4gICAgLy8gc3RhdGUuLi5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgcHJpbWUoKS4gVXN1YWxseSBpbnRlcm5hbCB0byB0aGUgb3BlcmF0aW9ucyBvZiB0aGUgRGlhZ25vc3RpY3MsIGJ1dCBjYW4gYmUgY2FsbGVkIGZyb20gb3V0c2lkZS5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgRGlhZ25vc3RpY3Muc3RvcFN0YXRzKHRoaXMuc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IG5vbk9wZXJhdGl2ZTtcbiAgICAgICAgdGhpcy5leHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXQgPSB0aGlzLnJ0YyA9IHt9O1xuICAgICAgICAvLyBkb24ndCBsZWF2ZSB0aGVtIGhhbmdpbmcgYXJvdW5kLiBFLmcuLCBiZWZvcmV1bmxvYWQgY2FuIG1lc3Mgd2l0aCB0aGUgYmZjYWNoZS5cbiAgICAgICAgdGhpcy5maXJlT24uZm9yRWFjaChldmVudCA9PiAoeERvY3VtZW50IGFzIGFueSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5maXJlTGlzdGVuZXIpKTtcbiAgICAgICAgcmVwb3J0cyA9IHtcbiAgICAgICAgICAgICdvdXRib3VuZC1ydHAnOiB7fSxcbiAgICAgICAgICAgICdpbmJvdW5kLXJ0cCc6IHt9LFxuICAgICAgICAgICAgJ3JlbW90ZS1pbmJvdW5kLXJ0cCc6IHt9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNQcmltZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkZW50aWZpZXIgIT09IG5vbk9wZXJhdGl2ZTtcbiAgICB9XG4gICAgLy8gc3RyaW5ncy4uLlxuICAgIC8qKlxuICAgICAqIEFuc3dlciBhIHNpbmdsZSAobG9uZykgbG9nIGxpbmUgdG8gcmVwb3J0LlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfSAke3RoaXMuaWRlbnRpZmllcn0gYCArXG4gICAgICAgICAgICB0aGlzLnMoJ2xvZ1JlYXNvbicsICdzZXNzaW9uRU5EJykgK1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdHMoJ2Jyb3dzZXJTdGF0cycpICtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXRzKCdtaXhlclN0YXRzJykgK1xuICAgICAgICAgICAgdGhpcy5ydHBTdGF0cygpICtcbiAgICAgICAgICAgIHRoaXMucnRjU3RhdGVzKCkgK1xuICAgICAgICAgICAgdGhpcy5zKCdOVU1fQ09OTkVDVEVEJywgdGhpcy5zZXNzaW9uLmNvbmN1cnJlbmN5LCAnXFxuJykgK1xuICAgICAgICAgICAgdGhpcy5zKCdBUFBTVEFURScsIHRoaXMuc2Vzc2lvbi5nZXRDdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSgpLCAnXFxuJykgK1xuICAgICAgICAgICAgdGhpcy5zKCdSQVZJU1RBVEUnLCB0aGlzLnJhdmkuZ2V0U3RhdGUoKSkgK1xuICAgICAgICAgICAgdGhpcy5zKCdPTkxJTkUnLCB4TmF2aWdhdG9yLm9uTGluZSA/ICd5ZXMnIDogJ25vJykgK1xuICAgICAgICAgICAgdGhpcy5zKCdYUExJQ0lUQ0xPU0VEJywgdGhpcy5leHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2UgPyAneWVzJyA6ICdubycpICtcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eUluZm8oKSArXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JbmZvKCkgK1xuICAgICAgICAgICAgKHVzZURlYnVnUHJlZml4ZXMgPyAnXFxuJyA6ICcnKSArXG4gICAgICAgICAgICBgIFske3hOYXZpZ2F0b3IudXNlckFnZW50fV1gO1xuICAgIH1cbiAgICBzKG5hbWU6c3RyaW5nLCB2YWx1ZTphbnksIGRlYnVnUHJlZml4ID0gJycpIHtcbiAgICAgICAgbGV0IHNlcGFyYXRvciA9IGlzTmFOKHZhbHVlKSA/ICdfJyA6ICc6JztcbiAgICAgICAgcmV0dXJuIGAke3VzZURlYnVnUHJlZml4ZXMgPyBkZWJ1Z1ByZWZpeCA6ICcnfSAke3RoaXMubGFiZWx9JHtuYW1lfSR7c2VwYXJhdG9yfSR7dmFsdWV9YDtcbiAgICB9XG4gICAgY29ubmVjdGlvbkluZm8oKSB7XG4gICAgICAgIGNvbnN0IGluZm86YW55ID0gKHhOYXZpZ2F0b3IgYXMgYW55KS5jb25uZWN0aW9uIHx8ICh4TmF2aWdhdG9yIGFzIGFueSkubW96Q29ubmVjdGlvbiB8fCAoeE5hdmlnYXRvciBhcyBhbnkpLndlYmtpdENvbm5lY3Rpb24gfHwge307XG4gICAgICAgIHJldHVybiB0aGlzLnMoJ0RFVklDRScsIGluZm8udHlwZSwgJ1xcbicpICtcbiAgICAgICAgICAgIHRoaXMucygnUkFUSU5HJywgaW5mby5lZmZlY3RpdmVUeXBlKSArXG4gICAgICAgICAgICB0aGlzLnMoJ0RMJywgaW5mby5kb3dubGluaykgK1xuICAgICAgICAgICAgdGhpcy5zKCdSVFQnLCBpbmZvLnJ0dCk7XG4gICAgfVxuICAgIHZpc2liaWxpdHlJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zKCdWSVNJQkxJVFknLCB4RG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSBmaXJlLCBJJ2QgbGlrZSB0byBkaXJlY3RseSBhc2sgdGhlIFJUQ1BlZXJDb25uZWN0aW9uIGFuZCBvdXIgc2lnbmFsaW5nIFdlYlNvY2tldCBzb21lIHF1ZXN0aW9ucywgYXMgYSBzYW5pdHkgY2hlY2tcbiAgICAgKiB0aGF0IHRoaW5ncyBtYXRjaCB0aGUgUmF2aSBzdGF0ZS4gQnV0IGlmIGFsbCBnb2VzIHdlbGwsIHdlJ3ZlIGFscmVhZHkgcmVsZWFzZWQgdGhlbS4gU28gaGVyZSB3ZSBncmFiIHRoZW0gd2hpbGUgd2UgY2FuIGFuZFxuICAgICAqIGhvbGQgb3VyIG93biByZWZlcmVuY2VzLCB0byBiZSBjbGVhcmVkIG9uIHJlc2V0KCk7XG4gICAgICovIFxuICAgIGdyYWJSVENJbnRlcm5hbHMoKSB7XG4gICAgICAgIGxldCByYXZpOmFueSA9IHRoaXMucmF2aSxcbiAgICAgICAgICAgIHJhdmlSVEM6YW55ID0gcmF2aS5fcmF2aUltcGxlbWVudGF0aW9uLFxuICAgICAgICAgICAgc2lnbmFsaW5nOmFueSA9IHJhdmlSVEMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24uX3NpZ25hbGluZ0ltcGxlbWVudGF0aW9uO1xuICAgICAgICB0aGlzLndlYlNvY2tldCA9IHNpZ25hbGluZy5fd2ViU29ja2V0O1xuICAgICAgICB0aGlzLnJ0YyA9IHJhdmlSVEMuX3J0Y0Nvbm5lY3Rpb247XG4gICAgfVxuICAgIHJ0Y1N0YXRlcygpIHtcbiAgICAgICAgLy8gVGhpcyBiaXphcnJlIHBhdHRlcm4gaXMgdG8gZ2V0IGFzIG11Y2ggaW5mbyBhcyBwb3NzaWJsZSwgZXZlbiBmcm9tIGJyb3dzZXJzIHN1Y2ggYXMgRmlyZWZveCB0aGF0XG4gICAgICAgIC8vIHRocm93IGVycm9ycyBmb3Igc29tZSBwcm9wZXJ0aWVzLlxuICAgICAgICBsZXQgY29sbGVjdG9yOmFueSA9IHt9LFxuICAgICAgICAgICAgc2FmZWx5R2V0ID0gKHByb3BlcnR5OnN0cmluZywgc291cmNlOmFueSA9IHRoaXMucnRjKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdG9yW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3JbcHJvcGVydHldID0gZS5uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIHNhZmVseUdldCgncmVhZHlTdGF0ZScsIHRoaXMud2ViU29ja2V0KTtcbiAgICAgICAgWydjb25uZWN0aW9uU3RhdGUnLCAnc2lnbmFsaW5nU3RhdGUnLCAnaWNlQ29ubmN0aW9uU3RhdGUnLCdpY2VHYXRoZXJpbmdTdGF0ZSddLmZvckVhY2gocCA9PiBzYWZlbHlHZXQocCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zKCdXZWJTb2NrZXQnLCBjb2xsZWN0b3IucmVhZHlTdGF0ZSwgJ1xcbicpICtcbiAgICAgICAgICAgIHRoaXMucygnUlRDJywgY29sbGVjdG9yLmNvbm5lY3Rpb25TdGF0ZSkgK1xuICAgICAgICAgICAgdGhpcy5zKCdTSUdOQUxJTkcnLCBjb2xsZWN0b3Iuc2lnbmFsaW5nU3RhdGUpICtcbiAgICAgICAgICAgIHRoaXMucygnSUNFJywgY29sbGVjdG9yLmljZUNvbm5lY3Rpb25TdGF0ZSkgK1xuICAgICAgICAgICAgdGhpcy5zKCdHQVRIRVJJTkcnLCBjb2xsZWN0b3IuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgIH1cbiAgICBjb25uZWN0aW9uU3RhdHMoa2luZDpzdHJpbmcpIHtcbiAgICAgICAgbGV0IHJlcG9ydCA9IGtpbmQgPT09ICdicm93c2VyU3RhdHMnID8gIGJyb3dzZXJTdGF0cyA6IHJlbW90ZVN0YXRzO1xuICAgICAgICByZXR1cm4gdGhpcy5zKGtpbmQrJ0lQJywgcmVwb3J0LmlwIHx8IHJlcG9ydC5hZGRyZXNzLCAnXFxuJykgK1xuICAgICAgICAgICAgdGhpcy5zKGtpbmQrJ1RZUEUnLCByZXBvcnQuY2FuZGlkYXRlVHlwZSkgK1xuICAgICAgICAgICAgdGhpcy5zKGtpbmQrJ1BST1RPQ09MJywgcmVwb3J0LnByb3RvY29sKTtcbiAgICB9XG4gICAgcnRwU3RhdHMoKSB7XG4gICAgICAgIGxldCBzOnN0cmluZyA9ICcnO1xuICAgICAgICBPYmplY3Qua2V5cyhyZXBvcnRzKS5mb3JFYWNoKHJlcG9ydE5hbWUgPT4ge1xuICAgICAgICAgICAgbGV0IHJlcG9ydCA9IHJlcG9ydHNbcmVwb3J0TmFtZV0sXG4gICAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocmVwb3J0KS5mb3JFYWNoKHByb3BlcnR5TmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgcyArPSB0aGlzLnMoYCR7cmVwb3J0TmFtZX1fJHtwcm9wZXJ0eU5hbWV9YCwgcmVwb3J0W3Byb3BlcnR5TmFtZV0sIGZpcnN0ID8gJ1xcbicgOiAnJyk7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIFxuICAgIC8vIFBob25pbmcgaG9tZS4uLlxuICAgIC8qKlxuICAgICAqIFJldHVybiBzdWNjZXNzLCBvciBhIHByb21pc2UgZm9yIHN1Y2Nlc3MuXG4gICAgICovXG4gICAgcmVwb3J0KHJlcG9ydFN0cmluZzpzdHJpbmcpIHtcbiAgICAgICAgaWYgKCF4TmF2aWdhdG9yLm9uTGluZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXhmZXRjaCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIGJlYWNvbiBpcyBzdWNjZXNzZnVsbHkgcXVldWVkLCBub3Qgc2VudC5cbiAgICAgICAgLy8gVWx0aW1hdGVseSwgd2Ugd291bGQgbmVlZCBhIHZlcmlmaWNhdGlvbiAoZS5nLiwgbmV4dCBzZXNzaW9uKSB0byBzZWUgaWYgdGhlIHByZXZpb3VzIGlkZW50aWZpZXIgd2FzIGxvZ2dlZC5cbiAgICAgICAgLy8gQSBmYWlsdXJlIGdldHMgbG9nZ2VkIHRvIGNvbnNvbGUgaW4gc29tZSBicm93c2VycywgYnV0IHRoZXkgZG9uJ3QgYWN0dWFsbHkgZW1pdCBhbiBlcnJvciBldmVudC5cbiAgICAgICAgLy8gcmV0dXJuIG5hdmlnYXRvci5zZW5kQmVhY29uKHRoaXMudXJsLCByZXBvcnRTdHJpbmcpO1xuICAgICAgICAvLyBJbnN0ZWFkLCBsZXQncyBQT1NUIGV4YWN0bHkgYXMgc2VuZEJlYWNvbiB3b3VsZCwgYW5kIGNoZWNrIHN1Y2Nlc3M6XG4gICAgICAgIHJldHVybiB4ZmV0Y2godGhpcy51cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ3RleHQvcGxhaW4nIH0sXG4gICAgICAgICAgICBib2R5OiByZXBvcnRTdHJpbmdcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2U6UmVzcG9uc2UpID0+IHJlc3BvbnNlLm9rLCAoeDphbnkpID0+IGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHJlcG9ydFN0cmluZyB0byB0aGUgc2V0IG9mIGRhdGEgYmVpbmcgc2F2ZWQgZm9yIGxhdGVyIHJlcG9ydGluZy5cbiAgICAgKi9cbiAgICBwZXJzaXN0KHJlcG9ydFN0cmluZzpzdHJpbmcpIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nID0geFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmxhYmVsKSB8fCBcIlwiO1xuICAgICAgICAvLyBCeSBjb25zdHJ1Y3Rpb24gZXhpc3RpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgZW1wdHkgb3Igb25lIGxpbmUuIEl0IGNvdWxkIGhhdmUgbXVsdGlwbGUgbGluZXMgaWZcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBidWcsIG9yIGlmIHRoZSBhcHBsaWNhdGlvbiBzaXRlIGxpbWl0cyB0aGUgY29ubmVjdC1zcmMgKG9yIGRlZmF1bHQtc3JjKVxuICAgICAgICAvLyBpbiBpdHMgQ29udGVudC1TZWN1cml0eS1Qb2xpY3kgaGVhZGVyIHdpdGhvdXQgYWxsb3dpbmcgdGhpcy51cmwuXG4gICAgICAgIC8vIElmIGl0IGlzIG1vcmUgdGhhbiBhIGxpbmUsIHdlIGFyZSBhY2N1bXVsYXRpbmcgc3R1ZmYgYW5kIHJlYWxseSBvdWdodCB0byBwaG9uZSBob21lIHRocm91Z2ggdGhlIG1peGVyIHdoZW4gY29ubmVjdGVkLlxuICAgICAgICBpZiAoZXhpc3RpbmcpIGV4aXN0aW5nICs9IFwiXFxuXCI7XG4gICAgICAgIHhTdG9yYWdlLnNldEl0ZW0odGhpcy5sYWJlbCwgZXhpc3RpbmcgKyByZXBvcnRTdHJpbmcpO1xuICAgICAgICAvLyBBbiBvcHRpbWl6YXRpb24gdG8gZ2V0IGNhdWdodCB1cCBvbiBkYXRhIHF1aWNrZXIgaW4gdGhlIGNhc2Ugd2hlcmUgbmV0d29yayBpcyBsb3N0IGFuZCByZXR1cm5zIHdoaWxlIHRhYiBpcyBzdGlsbCB1cC5cbiAgICAgICAgeEFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMub25saW5lTGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSdzIGFueXRoaW5nIHBlcnNpc3RlZCwgdHJ5IHRvIHJlcG9ydCBpdC4gSWYgc3VjY2Vzc2Z1bCwgY2xlYXIgcGVyc2lzdGVuY2UuXG4gICAgICovXG4gICAgYXN5bmMgY2hlY2tQZXJzaXN0ZWQoKSB7XG4gICAgICAgIHhSZW1vdmVFdmVudExpc3RlbmVyKCdvbmxpbmUnLCB0aGlzLm9ubGluZUxpc3RlbmVyKTtcbiAgICAgICAgbGV0IGV4aXN0aW5nID0geFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmxhYmVsKTtcbiAgICAgICAgaWYgKCFleGlzdGluZykgcmV0dXJuO1xuICAgICAgICBpZiAoISBhd2FpdCB0aGlzLnJlcG9ydChleGlzdGluZykpIHJldHVybjtcbiAgICAgICAgeFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmxhYmVsKTtcbiAgICB9XG4gICAgLy8gUlRDIHN0YXRzLi4uXG4gICAgLy8gUmF2aSBvbmx5IGFsbG93cyBvbmUgc3RhdHMgY29sbGVjdGlvbiBmdW5jdGlvbiBhdCBhIHRpbWUsIHNvIHdlJ2xsIGhhdmUgdG8gc2hhcmVcbiAgICAvLyBhbW9uZyBhbGwgdGhlIGRpYWdub3N0aWNzLlxuICAgIHN0YXRpYyBzdGFydFN0YXRzKHNlc3Npb246SGlGaU1peGVyU2Vzc2lvbikgeyAvLyBSZXN1bHRzIG5vdCBkZWZpbmVkIGlmIGNhbGxlZCB3aXRoIGRpZmZlcmVudCBzZXNzaW9uLlxuICAgICAgICBpZiAoblN0YXRzQ2xpZW50cysrID4gMCkgcmV0dXJuOyAvLyBTb21lb25lIHByaW1lZCBiZWZvcmUgdGhpcyBjYWxsIChhbmQgc2luY2UgdGhlIGZpbmFsIHJlc2V0KS5cbiAgICAgICAgc2Vzc2lvbi5zdGFydENvbGxlY3RpbmdXZWJSVENTdGF0cygobmV4dDphbnksIHByZXZpb3VzOmFueSkgPT4ge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gbmV4dC5maW5kKChyZXBvcnQ6YW55KSA9PiByZXBvcnQud3JpdGFibGUgfHwgcmVwb3J0Lm5vbWluYXRlZCksXG4gICAgICAgICAgICAgICAgbG9jYWxSZXBvcnQgPSBuZXh0LmZpbmQoKHJlcG9ydDphbnkpID0+IHJlcG9ydC5pZCA9PT0gc2VsZWN0ZWQubG9jYWxDYW5kaWRhdGVJZCksXG4gICAgICAgICAgICAgICAgcmVtb3RlUmVwb3J0ID0gbmV4dC5maW5kKChyZXBvcnQ6YW55KSA9PiByZXBvcnQuaWQgPT09IHNlbGVjdGVkLnJlbW90ZUNhbmRpZGF0ZUlkKTtcbiAgICAgICAgICAgIGlmIChsb2NhbFJlcG9ydCkgIGJyb3dzZXJTdGF0cyA9IGxvY2FsUmVwb3J0O1xuICAgICAgICAgICAgaWYgKHJlbW90ZVJlcG9ydCkgcmVtb3RlU3RhdHMgPSByZW1vdGVSZXBvcnQ7XG4gICAgICAgICAgICBmdW5jdGlvbiBub3RlKHR5cGU6c3RyaW5nLCBkZWx0YVByb3BlcnRpZXM6QXJyYXk8c3RyaW5nPiwgYWJzb2x1dGVQcm9wZXJ0aWVzOkFycmF5PHN0cmluZz4gPSBbXSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRSZXBvcnQobGlzdDphbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QuZmluZCgocmVwb3J0OmFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcG9ydC50eXBlID09IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXNSZXBvcnQgPSBmaW5kUmVwb3J0KHByZXZpb3VzKSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlcG9ydCA9IGZpbmRSZXBvcnQobmV4dCk7XG4gICAgICAgICAgICAgICAgZGVsdGFQcm9wZXJ0aWVzLmZvckVhY2gocHJvcGVydHkgPT4gcmVwb3J0c1t0eXBlXVtwcm9wZXJ0eV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXBvcnQgJiYgKG5leHRSZXBvcnRbcHJvcGVydHldIC0gKHByZXZpb3VzUmVwb3J0ID8gcHJldmlvdXNSZXBvcnRbcHJvcGVydHldIDogMCkpKTtcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVByb3BlcnRpZXMuZm9yRWFjaChwcm9wZXJ0eSA9PiByZXBvcnRzW3R5cGVdW3Byb3BlcnR5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJlcG9ydCAmJiBuZXh0UmVwb3J0W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3RlKCdvdXRib3VuZC1ydHAnLCBbJ3JldHJhbnNtaXR0ZWRQYWNrZXRzU2VudCcsICdwYWNrZXRzU2VudCddKTtcbiAgICAgICAgICAgIG5vdGUoJ2luYm91bmQtcnRwJywgWydwYWNrZXRzTG9zdCcsICdwYWNrZXRzUmVjZWl2ZWQnXSwgWydqaXR0ZXInXSk7XG4gICAgICAgICAgICBub3RlKCdyZW1vdGUtaW5ib3VuZC1ydHAnLCBbJ3BhY2tldHNMb3N0J10sIFsncm91bmRUcmlwVGltZScsICd0b3RhbFJvdW5kVHJpcFRpbWUnLCAnaml0dGVyJ10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHN0b3BTdGF0cyhzZXNzaW9uOkhpRmlNaXhlclNlc3Npb24pIHtcbiAgICAgICAgaWYgKCFuU3RhdHNDbGllbnRzKSByZXR1cm47XG4gICAgICAgIGlmICgtLW5TdGF0c0NsaWVudHMgPiAwKSByZXR1cm47ICAgLy8gU29tZW9uZSBpcyBzdGlsbCBwcmltZWQuICAgICBcbiAgICAgICAgc2Vzc2lvbi5zdG9wQ29sbGVjdGluZ1dlYlJUQ1N0YXRzKCk7XG4gICAgICAgIGJyb3dzZXJTdGF0cyA9IHJlbW90ZVN0YXRzID0ge307XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgeyBSYXZpVXRpbHMgfSBmcm9tICcuL1JhdmlVdGlscyc7XG5cbi8qKlxuICogVXNlZCBmb3Igc3RvcmluZyB0aGUgYmluYXJ5IGNvbW1hbmQgaGFuZGxlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IF9CSU5BUllfQ09NTUFORF9LRVkgPSBcIl9CSU5BUllcIjtcblxuXG4vKipcbiAqIE1vdXNlIHN0YXRlIG1lc3NhZ2UgaXMgNyBmbG9hdHMgYWthIDcgKiA0ID0gMjggYnl0ZXNcbiAqL1xuY29uc3QgX01PVVNFX1NUQVRFX0JVRkZFUl9TSVpFID0gMjg7XG5cbmVudW0gX0tFWV9DT0RFX1RBQkxFIHtcbiAgXCJDb250cm9sTGVmdFwiID0gMCxcbiAgXCJBbHRMZWZ0XCIgPSAxLFxuICBcIk9TTGVmdFwiID0gMixcbiAgXCJTcGFjZVwiID0gMyxcbiAgXCJPU1JpZ2h0XCIgPSA0LFxuICBcIkFsdFJpZ2h0XCIgPSA1LFxuICBcIkNvbnRyb2xSaWdodFwiID0gNixcblxuICBcIlNoaWZ0TGVmdFwiID0gNyxcbiAgXCJTaGlmdFJpZ2h0XCIgPSA4LFxuICBcIkNvbW1hXCIgPSA5LFxuICBcIlBlcmlvZFwiID0gMTAsXG4gIFwiU2xhc2hcIiA9IDExLFxuIFxuICBcIkNhcHNMb2NrXCIgPSAxMixcbiAgXCJFbnRlclwiID0gMTMsXG4gIFwiU2VtaWNvbG9uXCIgPSAxNCxcbiAgXCJRdW90ZVwiID0gMTUsXG5cbiAgXCJUYWJcIiA9IDE2LFxuICBcIkJyYWNrZXRMZWZ0XCIgPSAxNyxcbiAgXCJCcmFja2V0UmlnaHRcIiA9IDE4LFxuICBcIkJhY2tzbGFzaFwiID0gMTksXG5cbiAgXCJCYWNrcXVvdGVcIiA9IDIwLFxuICBcIk1pbnVzXCIgPSAyMSxcbiAgXCJFcXVhbFwiID0gMjIsXG5cbiAgXCJEaWdpdDBcIiA9IDIzLFxuICBcIkRpZ2l0MVwiID0gMjQsXG4gIFwiRGlnaXQyXCIgPSAyNSxcbiAgXCJEaWdpdDNcIiA9IDI2LFxuICBcIkRpZ2l0NFwiID0gMjcsXG4gIFwiRGlnaXQ1XCIgPSAyOCxcbiAgXCJEaWdpdDZcIiA9IDI5LFxuICBcIkRpZ2l0N1wiID0gMzAsXG4gIFwiRGlnaXQ4XCIgPSAzMSxcbiAgXCJEaWdpdDlcIiA9IDMyLFxuXG4gIFwiQmFja3NwYWNlXCIgPSAzMyxcblxuICBcIkVzY2FwZVwiID0gMzQsXG4gXG4gIFwiQXJyb3dMZWZ0XCIgPSAzNSxcbiAgXCJBcnJvd1JpZ2h0XCIgPSAzNixcbiAgXCJBcnJvd0Rvd25cIiA9IDM3LFxuICBcIkFycm93VXBcIiA9IDM4LFxuICBcIlBhZ2VEb3duXCIgPSAzOSxcbiAgXCJQYWdlVXBcIiA9IDQwLFxuICBcIkVuZFwiID0gNDEsXG4gIFwiSG9tZVwiID0gNDIsXG4gIFwiRGVsZXRlXCIgPSA0MyxcbiAgXCJJbnNlcnRcIiA9IDQ0LFxuXG4gIFwiTnVtcGFkMFwiID0gNDUsXG4gIFwiTnVtcGFkMVwiID0gNDYsXG4gIFwiTnVtcGFkMlwiID0gNDcsXG4gIFwiTnVtcGFkM1wiID0gNDgsXG4gIFwiTnVtcGFkNFwiID0gNDksXG4gIFwiTnVtcGFkNVwiID0gNTAsXG4gIFwiTnVtcGFkNlwiID0gNTEsXG4gIFwiTnVtcGFkN1wiID0gNTIsXG4gIFwiTnVtcGFkOFwiID0gNTMsXG4gIFwiTnVtcGFkOVwiID0gNTQsXG4gXG4gIFwiTnVtcGFkRGVjaW1hbFwiID0gNTUsXG4gIFwiTnVtcGFkRW50ZXJcIiA9IDU2LFxuICBcIk51bXBhZEFkZFwiID0gNTcsXG4gIFwiTnVtcGFkU3VidHJhY3RcIiA9IDU4LFxuICBcIk51bUxvY2tcIiA9IDU5LFxuICBcIk51bXBhZEVxdWFsXCIgPSA2MCxcbiAgXCJOdW1wYWRNdWx0aXBseVwiID0gNjEsXG4gIFwiTnVtcGFkRGl2aWRlXCIgPSA2MixcbiBcbiAgXCJLZXlBXCIgPSA2MyxcbiAgXCJLZXlCXCIgPSA2NCxcbiAgXCJLZXlDXCIgPSA2NSxcbiAgXCJLZXlEXCIgPSA2NixcbiAgXCJLZXlFXCIgPSA2NyxcbiAgXCJLZXlGXCIgPSA2OCxcbiAgXCJLZXlHXCIgPSA2OSxcbiAgXCJLZXlIXCIgPSA3MCxcbiAgXCJLZXlJXCIgPSA3MSxcbiAgXCJLZXlKXCIgPSA3MixcbiAgXCJLZXlLXCIgPSA3MyxcbiAgXCJLZXlMXCIgPSA3NCxcbiAgXCJLZXlNXCIgPSA3NSxcbiAgXCJLZXlOXCIgPSA3NixcbiAgXCJLZXlPXCIgPSA3NyxcbiAgXCJLZXlQXCIgPSA3OCxcbiAgXCJLZXlRXCIgPSA3OSxcbiAgXCJLZXlSXCIgPSA4MCxcbiAgXCJLZXlTXCIgPSA4MSxcbiAgXCJLZXlUXCIgPSA4MixcbiAgXCJLZXlVXCIgPSA4MyxcbiAgXCJLZXlWXCIgPSA4NCxcbiAgXCJLZXlXXCIgPSA4NSxcbiAgXCJLZXlYXCIgPSA4NixcbiAgXCJLZXlZXCIgPSA4NyxcbiAgXCJLZXlaXCIgPSA4OCxcbn07XG5jb25zdCBfS0VZQk9BUkRfU1RBVEVfQlVGRkVSX1NJWkUgPSAxMjtcblxuLyoqIFxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIFRoaXMgY2xhc3MgaGFuZGxlcyBxdWV1aW5nLCBtYW5hZ2luZywgYW5kIHRyYW5zbWl0dGluZyBjb21tYW5kcyBmcm9tIGEgUkFWSSBKYXZhU2NyaXB0IGNsaWVudFxuICogdG8gYSBSQVZJIHNlcnZlci4gXG4gKiBUaGlzIGNsYXNzIGlzIHByb3ZpZGVkIGJ5IGEge0BsaW5rIFJhdmlTZXNzaW9ufSBhbmQgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gKlxuICogRXhhbXBsZSB1c2FnZSAoc2VuZGluZyBpbmZvcm1hdGlvbiBvbiBtb3VzZSBkb3VibGUtY2xpY2spOlxuICogXG4gKiBgYGBcbiAqIHZhciBjb21tYW5kQ29udHJvbGxlciA9IHJhdmlTZXNzaW9uLmdldENvbW1hbmRDb250cm9sbGVyKCk7XG4gKiBsZXQgaGFuZGxlTW91c2VEb3VibGVDbGljayA9IChldmVudCkgPT4ge1xuICogICB2YXIgcG9zID0gbW91c2VIYW5kbGVyKGV2ZW50KVxuICogICBjb21tYW5kQ29udHJvbGxlci5zZW5kSW5wdXQoe1wiY1wiOiBcIkRvdWJsZUNsaWNrXCIsIFwicFwiOiBwb3MgfSlcbiAqIH07XG4gKmBgYFxuICovXG5leHBvcnQgY2xhc3MgUmF2aUNvbW1hbmRDb250cm9sbGVyIHtcbiAgX2NvbW1hbmRRdWV1ZU1hcDogTWFwPHN0cmluZywgYW55PjtcbiAgX251bVF1ZXVlZENvbW1hbmRzOiBudW1iZXI7XG4gIF9jb21tYW5kUXVldWVJbnRlcnZhbDogbnVtYmVyO1xuICBfY29tbWFuZFB1bXBUaW1lcjogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+O1xuXG4gIF9pbnB1dFRhcmdldDogSFRNTEVsZW1lbnQ7XG4gIF9rZXlib2FyZFRhcmdldDogSFRNTEVsZW1lbnQ7XG5cbiAgX21vdXNlU3RhdGVCdWZmZXI6IEFycmF5QnVmZmVyO1xuICBfbW91c2VTdGF0ZVVpbnQ4OiBVaW50OEFycmF5O1xuICBfbW91c2VTdGF0ZUZsb2F0OiBGbG9hdDMyQXJyYXk7XG5cbiAgX2tleWJvYXJkU3RhdGVCdWZmZXI6IEFycmF5QnVmZmVyO1xuICBfa2V5Ym9hcmRTdGF0ZTogVWludDhBcnJheTtcblxuICBfaW5wdXREYXRhQ2hhbm5lbDogUlRDRGF0YUNoYW5uZWw7XG4gIF9jb21tYW5kRGF0YUNoYW5uZWw6IFJUQ0RhdGFDaGFubmVsO1xuXG4gIC8qKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKlxuICAgKiBDb21tYW5kLWNoYW5uZWwgcmVsYXRlZDogXG4gICAqIHRoaXMuX2NvbW1hbmREYXRhQ2hhbm5lbDtcbiAgICogdGhpcy5fY29tbWFuZFF1ZXVlTWFwO1xuICAgKiB0aGlzLl9udW1RdWV1ZWRDb21tYW5kcztcbiAgICogdGhpcy5fY29tbWFuZFB1bXBUaW1lcjtcbiAgICogdGhpcy5fY29tbWFuZFF1ZXVlSW50ZXJ2YWw7XG4gICAqXG4gICAqIElucHV0LWNoYW5uZWwgcmVsYXRlZDpcbiAgICogdGhpcy5faW5wdXREYXRhQ2hhbm5lbDtcbiAgICogdGhpcy5faW5wdXRUYXJnZXQ7XG4gICAqIHRoaXMuX2tleWJvYXJkVGFyZ2V0O1xuICAgKi9cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUkFWSSBjb21tYW5kIGNvbnRyb2xsZXIuIFxuICAgKiBEZWZhdWx0cyB0aGUgY29tbWFuZFF1ZXVlSW50ZXJ2YWwgdG8gMSBzZWNvbmRcbiAgICogYW5kIGluaXRpYWxpemVzIHZhcmlhYmxlcy5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiY29uc3RydWN0b3JcIiwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgXG4gICAgdGhpcy5fY29tbWFuZFF1ZXVlTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX251bVF1ZXVlZENvbW1hbmRzID0gMDtcbiAgICB0aGlzLl9jb21tYW5kUXVldWVJbnRlcnZhbCA9IDEwMDA7XG4gICAgdGhpcy5fY29tbWFuZFB1bXBUaW1lciA9IG51bGw7XG5cbiAgICB0aGlzLl9pbnB1dFRhcmdldDtcbiAgICB0aGlzLl9rZXlib2FyZFRhcmdldDtcblxuICAgIC8vIE1vdXNlIHN0YXRlIGJ1ZmZlciBjb250YWlucyB0aGUgJ00nIGNoYXIgdG8gaW5kaWNhdGUgdGhlIHBheWxvYWQgb24gdGhlIGlucHV0IGRhdGEgY2hhbm5lbFxuICAgIHRoaXMuX21vdXNlU3RhdGVCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoX01PVVNFX1NUQVRFX0JVRkZFUl9TSVpFICsgNCk7XG4gICAgLy8gc2V0ICdNJyBhcyB0aGUgZmlyc3QgY2hhciBvZiB0aGUgTW91c2VkU3RhdGUgYnVmZmVyXG4gICAgdGhpcy5fbW91c2VTdGF0ZVVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fbW91c2VTdGF0ZUJ1ZmZlcik7XG4gICAgdGhpcy5fbW91c2VTdGF0ZVVpbnQ4WzBdID0gMHg0RFxuICAgIC8vIEFsbG9jYXRlIHRoZSB2aWV3IG9uIHRoZSBtb3VzZSBidWZmZXIgYXMgZmxvYXRzIHN0YXJ0aW5nIG9uIHRoZSAybmQgYnl0ZVxuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdCA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fbW91c2VTdGF0ZUJ1ZmZlciwgNCApO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFswXSA9IC0xLjA7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzFdID0gLTEuMDtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMl0gPSAtMS4wO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFszXSA9IC0xLjA7XG4gICAgXG4gICAgLy8gS2V5Ym9hcmQgc3RhdGUgYnVmZmVyIGNvbnRhaW5zIHRoZSAnaycgY2hhciB0byBpbmRpY2F0ZSB0aGUgcGF5bG9hZFxuICAgIHRoaXMuX2tleWJvYXJkU3RhdGVCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoX0tFWUJPQVJEX1NUQVRFX0JVRkZFUl9TSVpFICsgMSk7XG4gICAgdGhpcy5fa2V5Ym9hcmRTdGF0ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2tleWJvYXJkU3RhdGVCdWZmZXIpO1xuICAgIHRoaXMuX2tleWJvYXJkU3RhdGVbMF0gPSAweDRCOyAvLyBzZXQgJ0snIGFzIHRoZSBmaXJzdCBjaGFyIG9mIHRoZSBLZXlib2FyZFN0YXRlIGJ1ZmZlclxuICB9XG4gIFxuICAvKipcbiAgICogU2V0IHRoZSBpbnRlcnZhbCBhdCB3aGljaCB3ZSBzaG91bGQgc2VuZCBjb21tYW5kc1xuICAgKiB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge2ludH0gcXVldWVJbnRlcnZhbCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJldHdlZW5cbiAgICogc2VuZGluZyBjb21tYW5kcy4gRGVmYXVsdHMgdG8gMTAwMCAoMSBzZWNvbmQpLlxuICAgKi9cbiAgc2V0Q29tbWFuZFF1ZXVlSW50ZXJ2YWwocXVldWVJbnRlcnZhbDogbnVtYmVyKSB7XG4gICAgdGhpcy5fY29tbWFuZFF1ZXVlSW50ZXJ2YWwgPSBxdWV1ZUludGVydmFsO1xuICAgIC8vIElmIHRoZSBjb21tYW5kIHF1ZXVlIGlzIHJ1bm5pbmcsIHN0b3AgaXQgYW5kXG4gICAgLy8gcmVzdGFydCBpdC5cbiAgICBpZiAodGhpcy5fY29tbWFuZFB1bXBUaW1lcikge1xuICAgICAgdGhpcy5zdG9wTW9uaXRvcmluZ1F1ZXVlcygpO1xuICAgICAgdGhpcy5tb25pdG9yUXVldWVzKCk7XG4gICAgfVxuICB9XG4gIFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgbGlzdGVuaW5nIGZvciByZXNwb25zZXMgdG8gcXVldWVkIGNvbW1hbmRzXG4gICAqIEBjYWxsYmFjayBSYXZpQ29tbWFuZENvbnRyb2xsZXJ+Y29tbWFuZENhbGxiYWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZSBUaGUgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyXG4gICAqL1xuICAvKipcbiAgICogUXVldWUgdXAgYSBjb21tYW5kIHRvIGJlIHNlbnQgd2hlbiByZWFkeSwgYWxvbmdcbiAgICogdGhlIFwiY29tbWFuZFwiIGRhdGEgY2hhbm5lbC5cbiAgICogU2VlIGFsc28ge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI3NlbmRJbnB1dH1cbiAgICogdG8gc2VuZCBpbW1lZGlhdGUgaW5wdXQgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGhlcmUgaXMgYSByZXF1ZXN0IGZvciBhIG5ldyB2aWRlbyBrZXlmcmFtZTpcbiAgICogYGBgXG4gICAqIGNvbW1hbmRDb250cm9sbGVyLnF1ZXVlQ29tbWFuZChcInZpZGVvLmZvcmNlS2V5RnJhbWVcIiwge30sIGhhbmRsZXIpXG4gICAqXG4gICAqIGBgYFxuICAgKiBOT1RFOiBUaGVzZSBjb21tYW5kcyBzZW50IHRvIHRoZSBSQVZJIHNlcnZlciB3aWxsIGJlIHNlbnQgYXMgSlNPTixcbiAgICogYW5kIGhhbmRsZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGVzZSBjb21tYW5kcyBhcmUgZXhwZWN0ZWQgdG9cbiAgICogcmVjZWl2ZSBKU09OIGFzIGEgcmVzcG9uc2UuIElmIHlvdSBuZWVkIHRvIHByb2Nlc3MgYmluYXJ5IGRhdGFcbiAgICogcmVjZWl2ZWQgaW4gcmVzcG9uc2UgdG8gYSBjb21tYW5kLCB5b3Ugc2hvdWxkIHNlbmQgdGhlIGNvbW1hbmQgXG4gICAqIHdpdGhvdXQgYSBoYW5kbGVyLCBhbmQgdGhlbiBBTFNPIHNwZWNpZnkgYSBnbG9iYWwgYmluYXJ5IGxpc3RlbmVyXG4gICAqIHdpdGgge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI2FkZEJpbmFyeUhhbmRsZXJ9XG4gICAqIHRvIGlkZW50aWZ5IGFuZCBhcHByb3ByaWF0ZWx5IHByb2Nlc3MgdGhlIHJlc3BvbnNlLiBCaW5hcnlcbiAgICogZGF0YSBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIGEgY29tbWFuZCwgYW5kIHNvIGFsbCBiaW5hcnkgaGFuZGxlcnNcbiAgICogYXJlIGV4ZWN1dGVkIGZvciBhbGwgYmluYXJ5IGRhdGEgcmVjZWl2ZWQ7IGJpbmFyeSBoYW5kbGVycyBzaG91bGRcbiAgICogdGhlbXNlbHZlcyBkZXRlcm1pbmUgaWYgdGhlIGRhdGEgdGhleSd2ZSBiZWVuIGdpdmVuIGlzIHRoZSBkYXRhXG4gICAqIHRoZXkncmUgZXhwZWN0aW5nLiAoQW5kIGlmIHlvdSB3YW50IHRvIHNlbmQgdGhlIGNvbW1hbmQgYXMgYmluYXJ5XG4gICAqIGZyb20gdGhlIEpTIHNpZGUsIHVzZSB7bGluayBSYXZpQ29tbWFuZENvbnRyb2xsZXIjcXVldWVCaW5hcnlDb21tYW5kfSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmQgVGhlIGNvbW1hbmQgdG8gYWRkIHRvIHRoZSBxdWV1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gICBQYXJhbWV0ZXJzIHRvIGluY2x1ZGUgYWxvbmcgd2l0aCB0aGUgY29tbWFuZFxuICAgKiBAcGFyYW0ge1JhdmlDb21tYW5kQ29udHJvbGxlcn5jb21tYW5kQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhbnkgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXG4gICAqL1xuICBxdWV1ZUNvbW1hbmQoY29tbWFuZDogc3RyaW5nLCBwYXJhbTogYW55LCBoYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIC8vIEFkZCB0aGUgY29tbWFuZCB0byB0aGUgcXVldWUgZm9yIHRoaXMgcGFydGljdWxhclxuICAgIC8vIHR5cGUgb2YgY29tbWFuZFxuICAgIHZhciBjb21tYW5kUXVldWUgPSB0aGlzLl9jb21tYW5kUXVldWVNYXAuZ2V0KGNvbW1hbmQpO1xuICAgIGlmICghY29tbWFuZFF1ZXVlKSB7XG4gICAgICBjb21tYW5kUXVldWUgPSB7IHRvU2VuZDogW10sIGxpc3RlbmVyOiBbXSB9O1xuICAgICAgdGhpcy5fY29tbWFuZFF1ZXVlTWFwLnNldChjb21tYW5kLCBjb21tYW5kUXVldWUpO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVySW5zdGFuY2UgPSBudWxsO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAvLyBGb3Igbm93LCBhbGwgaGFuZGxlcnMgYXNzb2NpYXRlZCB3aXRoIGFjdHVhbCBzZW50IGNvbW1hbmRzXG4gICAgICAvLyBhcmUgbm90IFwic3RpY2t5XCIgKGkuZS4gdGhleSBvbmx5IGV4ZWN1dGUgb25jZSwgd2hlbiB0aGUgY29tbWFuZCByZXR1cm5zKVxuICAgICAgLy8gYW5kIHRoZXkgRE8gaGF2ZSBhIFwibWF0Y2hpbmcgc2VudCBjb21tYW5kXCJcbiAgICAgIGhhbmRsZXJJbnN0YW5jZSA9IG5ldyBSYXZpQ29tbWFuZEhhbmRsZXJJbnN0YW5jZShoYW5kbGVyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGNvbW1hbmRRdWV1ZS50b1NlbmQucHVzaCggbmV3IFJhdmlDb21tYW5kSW5zdGFuY2UoY29tbWFuZCwgcGFyYW0sIGhhbmRsZXJJbnN0YW5jZSkgKTtcblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiB3YWl0aW5nIGNvbW1hbmRzIHNlcGFyYXRlbHkgc28gd2UgZG9uJ3QgaGF2ZVxuICAgIC8vIHRvIGtlZXAgY2FsY3VsYXRpbmcgaXQgd2hlbiB3ZSBjaGVjayBmb3IgcXVldWVkIGNvbW1hbmRzXG4gICAgdGhpcy5fbnVtUXVldWVkQ29tbWFuZHMrKztcbiAgICBcbiAgICBSYXZpVXRpbHMubG9nKFwiQWRkZWQgY29tbWFuZCBcIiArIGNvbW1hbmQsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXVlIHVwIGEgYmluYXJ5IG1lc3NhZ2UgdG8gYmUgc2VudCB3aGVuIHJlYWR5LCBhbG9uZ1xuICAgKiB0aGUgXCJjb21tYW5kXCIgZGF0YSBjaGFubmVsLlxuICAgKiBTZWUgYWxzbyB7bGluayBSYXZpQ29tbWFuZENvbnRyb2xsZXIjc2VuZElucHV0fVxuICAgKiB0byBzZW5kIGltbWVkaWF0ZSBpbnB1dCB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBOT1RFOiBZb3UgY2FuIG5vdCBpbmNsdWRlIGEgaGFuZGxlciBpbiB0aGlzIG1ldGhvZCwgYmVjYXVzZVxuICAgKiBiaW5hcnkgbWVzc2FnZXMgYXJlIG5vdCBjdXJyZW50bHkgZGlzdGluZ3Vpc2hhYmxlIGZyb20gZWFjaFxuICAgKiBvdGhlciBhcyByZWdhcmRzIGhhbmRsZXJzIChpLmUuIHRoZXJlIGlzIG5vIFwiY29tbWFuZFwiIGFzc29jaWF0ZWRcbiAgICogd2l0aCBhIGJpbmFyeSBtZXNzYWdlKS4gSWYgeW91IHdhbnQgdG8gYXNzaWduIGEgaGFuZGxlciB0aGF0XG4gICAqIHdpbGwgcHJvY2VzcyBiaW5hcnkgbWVzc2FnZXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLCB1c2VcbiAgICoge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI2FkZEJpbmFyeUhhbmRsZXJ9XG4gICAqIHRvIGlkZW50aWZ5IGFuZCBhcHByb3ByaWF0ZWx5IHByb2Nlc3MgdGhlIHJlc3BvbnNlLiBCaW5hcnlcbiAgICogZGF0YSBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIGFuIGluZGl2aWR1YWwgY29tbWFuZCwgYW5kIHNvIGFsbCBiaW5hcnkgaGFuZGxlcnNcbiAgICogYXJlIGV4ZWN1dGVkIGZvciBhbGwgYmluYXJ5IGRhdGEgcmVjZWl2ZWQ7IGJpbmFyeSBoYW5kbGVycyBzaG91bGRcbiAgICogdGhlbXNlbHZlcyBkZXRlcm1pbmUgaWYgdGhlIGRhdGEgdGhleSd2ZSBiZWVuIGdpdmVuIGlzIHRoZSBkYXRhXG4gICAqIHRoZXkncmUgZXhwZWN0aW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBtZXNzYWdlIEFuIEFycmF5QnVmZmVyIChleHBlY3RlZCBieSB0aGUgc2VydmVyIHRvIGJlIGEgVWludDhBcnJheSkgdGhhdCBzaG91bGQgYmUgc2VudCB0byB0aGUgc2VydmVyXG4gICAqL1xuICBxdWV1ZUJpbmFyeUNvbW1hbmQobWVzc2FnZTogQXJyYXlCdWZmZXIpIHtcbiAgICAvLyBBZGQgdGhlIGNvbW1hbmQgdG8gdGhlIGJpbmFyeSBxdWV1ZSBcbiAgICBsZXQgY29tbWFuZCA9IF9CSU5BUllfQ09NTUFORF9LRVk7XG4gICAgdmFyIGNvbW1hbmRRdWV1ZSA9IHRoaXMuX2NvbW1hbmRRdWV1ZU1hcC5nZXQoY29tbWFuZCk7XG4gICAgaWYgKCEgY29tbWFuZFF1ZXVlKSB7XG4gICAgICBjb21tYW5kUXVldWUgPSB7IHRvU2VuZDogW10sIGxpc3RlbmVyOiBbXSB9O1xuICAgICAgdGhpcy5fY29tbWFuZFF1ZXVlTWFwLnNldChjb21tYW5kLCBjb21tYW5kUXVldWUpO1xuICAgIH1cblxuICAgIGNvbW1hbmRRdWV1ZS50b1NlbmQucHVzaCggbmV3IFJhdmlDb21tYW5kSW5zdGFuY2UobWVzc2FnZSwgbnVsbCwgbnVsbCkgKTtcblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiB3YWl0aW5nIGNvbW1hbmRzIHNlcGFyYXRlbHkgc28gd2UgZG9uJ3QgaGF2ZVxuICAgIC8vIHRvIGtlZXAgY2FsY3VsYXRpbmcgaXQgd2hlbiB3ZSBjaGVjayBmb3IgcXVldWVkIGNvbW1hbmRzXG4gICAgdGhpcy5fbnVtUXVldWVkQ29tbWFuZHMrKztcbiAgICBcbiAgICBSYXZpVXRpbHMubG9nKFwiQWRkZWQgYmluYXJ5IGNvbW1hbmRcIiwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gIH1cblxuICBcbiAgLyoqXG4gICAqIEFkZCBhIGNvbW1hbmQgaGFuZGxlciBvbmx5LCB3aXRob3V0IGFsc28gcXVldWluZyB1cCBhIGNvbW1hbmQgdG8gc2VuZC5cbiAgICogVGhpcyBsaXN0ZW5lciB3aWxsIHdhdGNoIGZvciBhIG1lc3NhZ2UgdG8gYmUgcmVjZWl2ZWQgZnJvbSB0aGVcbiAgICogc2VydmVyIChvbiB0aGUgXCJjb21tYW5kXCIgZGF0YSBjaGFubmVsKSB0aGF0IG1hdGNoZXMgdGhlIGV4cGVjdGVkXG4gICAqIG1lc3NhZ2UgbmFtZS4gV2hlbiByZWNlaXZlZCwgdGhlIGxpc3RlbmVyIHdpbGwgZXhlY3V0ZSwgYW5kIHRoZW4gZWl0aGVyIHN0aWNrIGFyb3VuZCBhbmRcbiAgICoga2VlcCB3YXRjaGluZyAoaWYgdGhlIFwiaXNTdGlja3lcIiBmbGFnIGlzIHNldCB0byB0cnVlKVxuICAgKiBvciBkZS1yZWdpc3RlciBpdHNlbGYgKGlmIFwiaXNTdGlja3lcIiBpcyBmYWxzZSkgYW5kIHN0b3AgbGlzdGVuaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRNZXNzYWdlIFRoZSBzdHJpbmcgdG8gd2F0Y2ggZm9yIGZyb20gdGhlIHNlcnZlciwgc29tZXRoaW5nIGxpa2UgXCJtZXNzYWdlLmxvY2F0aW9uXCJcbiAgICogQHBhcmFtIHtSYXZpQ29tbWFuZENvbnRyb2xsZXJ+Y29tbWFuZENhbGxiYWNrfSBoYW5kbGVyIEEgaGFuZGxlciB0aGF0IHNob3VsZCBwcm9jZXNzIGFueSBldmVudHMgbGFiZWxlZCB3aXRoIGV4cGVjdGVkTWVzc2FnZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RpY2t5IFdoZXRoZXIgdGhlIGhhbmRsZXIgc2hvdWxkIGV4ZWN1dGUgZXZlcnkgdGltZSB0aGUgbWVzc2FnZSBpcyByZWNlaXZlZCAodHJ1ZSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBqdXN0IHRoZSBmaXJzdCB0aW1lIChmYWxzZSlcbiAgICovXG4gIGFkZE1lc3NhZ2VIYW5kbGVyKGV4cGVjdGVkTWVzc2FnZTogc3RyaW5nLCBoYW5kbGVyOiBGdW5jdGlvbiwgaXNTdGlja3k6IGJvb2xlYW4pIHtcblxuICAgIC8vIFRoZSBjb21tYW5kIHF1ZXVlIG1hcCBpcyB1c2VkIHRvIHRyYWNrIGFsbCBjb21tYW5kcy9saXN0ZW5lcnM7XG4gICAgLy8gZW5zdXJlIHRoYXQgdGhpcyBwYXJ0aWN1bGFyIFwiZXhwZWN0ZWRNZXNzYWdlXCIgaGFzIGFuIGVudHJ5XG4gICAgdmFyIG1lc3NhZ2VFbnRyeSA9IHRoaXMuX2NvbW1hbmRRdWV1ZU1hcC5nZXQoZXhwZWN0ZWRNZXNzYWdlKTtcbiAgICBpZiAoISBtZXNzYWdlRW50cnkpIHtcbiAgICAgIG1lc3NhZ2VFbnRyeSA9IHsgdG9TZW5kOiBbXSwgbGlzdGVuZXI6IFtdIH07XG4gICAgICB0aGlzLl9jb21tYW5kUXVldWVNYXAuc2V0KGV4cGVjdGVkTWVzc2FnZSwgbWVzc2FnZUVudHJ5KTtcbiAgICB9XG4gICAgXG4gICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgd2FudCB0byBwdXQgYW55dGhpbmcgaW4gaXRzIFwidG9TZW5kXCIgYXJyYXksIGJ1dFxuICAgIC8vIHdlIGRvIHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIuXG4gICAgdmFyIGhhbmRsZXJJbnN0YW5jZSA9IG5ldyBSYXZpQ29tbWFuZEhhbmRsZXJJbnN0YW5jZShoYW5kbGVyLCBpc1N0aWNreSwgZmFsc2UpO1xuICAgIG1lc3NhZ2VFbnRyeS5saXN0ZW5lci5wdXNoKGhhbmRsZXJJbnN0YW5jZSk7IFxuXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGxpc3RlbmluZyBmb3IgYmluYXJ5IHNlcnZlciBtZXNzYWdlc1xuICAgKiBAY2FsbGJhY2sgUmF2aUNvbW1hbmRDb250cm9sbGVyfmJpbmFyeUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBhcyBhIFVpbnQ4QXJyYXkgdHlwZWQgYXJyYXlcbiAgICovXG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIGZvciBiaW5hcnkgZGF0YSBvbmx5LCB3aXRob3V0IGFsc28gcXVldWluZyB1cCBhIGNvbW1hbmQgdG8gc2VuZC5cbiAgICogVGhpcyBsaXN0ZW5lciB3aWxsIHdhdGNoIGZvciBhIGJpbmFyeSBtZXNzYWdlIHRvIGJlIHJlY2VpdmVkIGZyb20gdGhlXG4gICAqIHNlcnZlciAob24gdGhlIFwiY29tbWFuZFwiIGRhdGEgY2hhbm5lbCkuXG4gICAqIFdoZW4gcmVjZWl2ZWQsIHRoZSBsaXN0ZW5lciB3aWxsIGV4ZWN1dGUsIGFuZCB0aGVuIGVpdGhlciBzdGljayBhcm91bmQgYW5kXG4gICAqIGtlZXAgd2F0Y2hpbmcgKGlmIHRoZSBcImlzU3RpY2t5XCIgZmxhZyBpcyBzZXQgdG8gdHJ1ZSlcbiAgICogb3IgZGUtcmVnaXN0ZXIgaXRzZWxmIChpZiBcImlzU3RpY2t5XCIgaXMgZmFsc2UpIGFuZCBzdG9wIGxpc3RlbmluZy5cbiAgICpcbiAgICogTk9URTogQmluYXJ5IGRhdGEgaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhIGNvbW1hbmQsIGFuZCBzbyBhbGwgYmluYXJ5IGhhbmRsZXJzXG4gICAqIGFyZSBleGVjdXRlZCBmb3IgYWxsIGJpbmFyeSBkYXRhIHJlY2VpdmVkOyBiaW5hcnkgaGFuZGxlcnMgc2hvdWxkXG4gICAqIHRoZW1zZWx2ZXMgZGV0ZXJtaW5lIGlmIHRoZSBkYXRhIHRoZXkndmUgYmVlbiBnaXZlbiBpcyB0aGUgZGF0YVxuICAgKiB0aGV5J3JlIGV4cGVjdGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtSYXZpQ29tbWFuZENvbnRyb2xsZXJ+YmluYXJ5Q2FsbGJhY2t9IGhhbmRsZXIgQSBoYW5kbGVyIHRoYXQgc2hvdWxkIHByb2Nlc3MgYW55IGV2ZW50cyBsYWJlbGVkIHdpdGggZXhwZWN0ZWRNZXNzYWdlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdGlja3kgV2hldGhlciB0aGUgaGFuZGxlciBzaG91bGQgZXhlY3V0ZSBldmVyeSB0aW1lIHRoZSBtZXNzYWdlIGlzIHJlY2VpdmVkICh0cnVlKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGp1c3QgdGhlIGZpcnN0IHRpbWUgKGZhbHNlKVxuICAgKi9cbiAgYWRkQmluYXJ5SGFuZGxlcihoYW5kbGVyOiBGdW5jdGlvbiwgaXNTdGlja3k6IGJvb2xlYW4pIHtcbiAgICAvLyBTdG9yZSB0aGVzZSBoYW5kbGVycyBpbiB0aGUgc2FtZSBtYXAgYXMgdGhlIG90aGVyIGxpc3RlbmVyLW9ubHkgaGFuZGxlcnMsXG4gICAgLy8gYnV0IGp1c3QgdXNlIGEgc2luZ2xlIGNvbnN0YW50IGtleS5cbiAgICB0aGlzLmFkZE1lc3NhZ2VIYW5kbGVyKF9CSU5BUllfQ09NTUFORF9LRVksIGhhbmRsZXIsIGlzU3RpY2t5KTtcbiAgICAvLyBOT1RFOiBDdXJyZW50bHksIHdlIGRvbid0IHN1cHBvcnQgYW55IHNvcnQgb2YgXCJjb21tYW5kXCIgYXNzb2NpYXRlZFxuICAgIC8vIHdpdGggYmluYXJ5IG1lc3NhZ2VzIC0tIHdoZW4gd2UgZ2V0IGEgYmluYXJ5IG1lc3NhZ2UsIGFsbCBiaW5hcnlcbiAgICAvLyBoYW5kbGVycyBhcmUgY2FsbGVkLiBXZSBtYXkgZGVjaWRlIHRvIHJldGhpbmsgdGhpcyBpbiB0aGUgZnV0dXJlLlxuICB9XG4gIFxuICAvKipcbiAgICogU2VuZCBhbiBpbnB1dCBldmVudCBkaXJlY3RseSBmcm9tIHRoZSB1c2VyIHRvIHRoZSBSQVZJIHNlcnZlciBhbG9uZ1xuICAgKiB0aGUgXCJpbnB1dFwiIGRhdGEgY2hhbm5lbC5cbiAgICogU2VlIGFsc28ge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI3F1ZXVlQ29tbWFuZH0sIHdoaWNoIHF1ZXVlcyBjb21tYW5kcyBmb3IgbGF0ZXIgc2VuZGluZy5cbiAgICogVGhpcyBtZXRob2QgZG9lcyBub3QgZGVmaW5lIGNhbGxiYWNrcy5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGhlcmUgaXMgYW4gZXZlbnQgaGFuZGxlciBmb3Igc2VuZGluZyBtb3VzZSBtb3ZlbWVudDpcbiAgICogYGBgXG4gICAqIGxldCBoYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICogICB2YXIgcG9zID0gbW91c2VIYW5kbGVyKGV2ZW50KVxuICAgKiAgIGNvbW1hbmRDb250cm9sbGVyLnNlbmRJbnB1dCh7XCJjXCI6IFwiTW91c2VNb3ZlXCIsIFwicFwiOiBwb3MgfSlcbiAgICogfTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dEV2ZW50IEFuIGV2ZW50IHRvIHNlbmQuXG4gICAqL1xuICBzZW5kSW5wdXQoaW5wdXRFdmVudDogYW55KSB7XG4gICAgaWYgKHRoaXMuX2lucHV0RGF0YUNoYW5uZWwgJiYgdGhpcy5faW5wdXREYXRhQ2hhbm5lbC5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIC8vIFRoaXMgZ2V0cyBqdXN0IFdBWSB0b28gbm9pc3kgdG9vIHF1aWNrbHksXG4gICAgICAvLyBidXQgdW5jb21tZW50IGlmIG5lZWRlZDpcbiAgICAgIC8vIFJhdmlVdGlscy5sb2coXCJTZW5kaW5nIGlucHV0OlwiICsgSlNPTi5zdHJpbmdpZnkoaW5wdXRFdmVudCksIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgdGhpcy5faW5wdXREYXRhQ2hhbm5lbC5zZW5kKGlucHV0RXZlbnQpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEtpY2sgb2ZmIHBvbGxpbmcgZm9yIHF1ZXVlZCBjb21tYW5kcy5cbiAgICogRXZlcnkgc2Vjb25kLCB0aGlzIHdpbGwgc2VuZCB0aGVcbiAgICogbmV4dCBxdWV1ZWQgY29tbWFuZCBmcm9tIHRoZSBjb21tYW5kUXVldWUuXG4gICAqIFRoaXMgZG9lcyBub3QgbmVlZCB0byBiZSBjYWxsZWQgZXh0ZXJuYWxseTtcbiAgICogaXQgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBhcHByb3ByaWF0ZVxuICAgKiBjb21tYW5kIGRhdGEgY2hhbm5lbCBpcyBvcGVuZWQuIChTZWUge0BsaW5rIFJhdmlDb21tYW5kQ29udHJvbGxlciNfc2V0Q29tbWFuZERhdGFDaGFubmVsfSlcbiAgICogSG93ZXZlciwgaXQgY2FuIGJlIGNhbGxlZCBleHRlcm5hbGx5IGlmIGF0IGFueSBwb2ludFxuICAgKiB5b3UgbmVlZCB0byBzdG9wIGFuZCB0aGVuIHJlc3RhcnQgdGhlIHF1ZXVlIG1vbml0b3JpbmdcbiAgICogcHJvY2Vzcy5cbiAgICovXG4gIG1vbml0b3JRdWV1ZXMoKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIkJlZ2luIG1vbml0b3JpbmcgZm9yIHF1ZXVlZCBjb21tYW5kc1wiLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICB0aGlzLl9jb21tYW5kUHVtcFRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5fcHJvY2Vzc1NlbmRpbmdRdWV1ZWRDb21tYW5kcy5iaW5kKHRoaXMpLCB0aGlzLl9jb21tYW5kUXVldWVJbnRlcnZhbCk7ICBcbiAgfVxuICBcbiAgLyoqXG4gICAqIFN0b3AgcG9sbGluZyBmb3IgcXVldWVkIGNvbW1hbmRzIGFuZFxuICAgKiBubyBsb25nZXIgc2VuZCB0aGVtLiBDYWxsZWQgd2hlbiBhIFJBVkkgc2Vzc2lvbiBpcyBjbG9zZWRcbiAgICogKHNlZSB7QGxpbmsgUmF2aVNlc3Npb24jY2xvc2V9KS4gQ2FuIGFsc28gYmUgY2FsbGVkXG4gICAqIGV4dGVybmFsbHkgdG8gaGFsdCBjb21tYW5kIHByb2Nlc3NpbmcgaWYgbmVlZGVkLlxuICAgKi9cbiAgc3RvcE1vbml0b3JpbmdRdWV1ZXMoKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIlN0b3AgbW9uaXRvcmluZyBmb3IgcXVldWVkIGNvbW1hbmRzXCIsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY29tbWFuZFB1bXBUaW1lcik7XG4gICAgdGhpcy5fY29tbWFuZFB1bXBUaW1lciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgbmV4dCBxdWV1ZWQgY29tbWFuZC5cbiAgICogdGhpcyBnZXRzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgcXVldWUgbW9uaXRvclxuICAgKiBhbmQsIGluIGdlbmVyYWwsIHNob3VsZCBub3QgYmUgY2FsbGVkIGV4dGVybmFsbHkuXG4gICAqIFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NTZW5kaW5nUXVldWVkQ29tbWFuZHMoKSB7XG4gICAgaWYgKHRoaXMuX251bVF1ZXVlZENvbW1hbmRzIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gRm9yIGVhY2ggdHlwZSBvZiBjb21tYW5kIGluIHRoZSBtYXAsIHdlIGNhbiBzZW5kIHRoZSBmaXJzdCBvbmUgb2YgdGhlbS5cbiAgICB0aGlzLl9jb21tYW5kUXVldWVNYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZTogYW55LCBrZXk6IGFueSwgbWFwOiBhbnkpIHtcbiAgICAgIC8vIGlmIHRoaXMgcGFydGljdWxhciBjb21tYW5kIGhhcyBhIHF1ZXVlIG9mIGluc3RhbmNlcy4uLlxuICAgICAgaWYgKHZhbHVlLnRvU2VuZC5sZW5ndGgpIHtcbiAgICAgICAgLy8gR3JhYiB0aGUgZmlyc3Qgb25lIG9mZiB0aGUgcXVldWVcbiAgICAgICAgdmFyIGNvbW1hbmRJbnN0YW5jZSA9IHZhbHVlLnRvU2VuZC5zaGlmdCgpO1xuXG4gICAgICAgIC8vIElmIGEgaGFuZGxlciBpcyBkZWZpbmVkIHRoZW4gcHV0IGl0IG9uIHRoZSBsaXN0ZW5lciBtYXBcbiAgICAgICAgaWYgKGNvbW1hbmRJbnN0YW5jZS5faGFuZGxlcikge1xuICAgICAgICAgIC8vIEFkZCBpdCB0byB0aGUgbGlzdCBvZiBsaXN0ZW5lcnMgZm9yIGxhdGVyIGhhbmRsZXIgaGFuZGxpbmdcbiAgICAgICAgICB2YWx1ZS5saXN0ZW5lci5wdXNoKGNvbW1hbmRJbnN0YW5jZS5faGFuZGxlcik7ICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGV0J3Mgc2VuZCB0aGUgY29tbWFuZCFcbiAgICAgICAgaWYgKCB0aGlzLl9zZW5kQ29tbWFuZEluc3RhbmNlKGNvbW1hbmRJbnN0YW5jZSkgKSB7XG4gICAgICAgICAgdGhpcy5fbnVtUXVldWVkQ29tbWFuZHMtLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2VuZCBmYWlsZWQuIENvbW1hbmREYXRhQ2hhbm5lbCBtYXkgaGF2ZSBiZWVuIGRpc2Nvbm5lY3RlZC4gV2lsbCBub3QgcmV0cnkuXCIsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgICAgIC8vIElmIHdlIGRpZCB3YW50IHRvIHJldHJ5LCB0aG91Z2g6XG4gICAgICAgICAgLy92YWx1ZS50b1NlbmQucHVzaChjb21tYW5kSW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgYSBwYWlyIHsgY29tbWFuZCwgcGF5bG9hZCB9IHRvIGJlIHNlbnQgaGFzIGEgbWVzc2FnZSBvbiB0aGUgQ29tbWFuZERhdGFDaGFubmVsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb21tYW5kIC0gVGhlIGFjdHVhbCBzdHJpbmcgY29tbWFuZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF5bG9hZCAtIEFueSBwYXJhbWV0ZXJzIHRvIGJlIHNlbnQgb3IgcmVjZWl2ZWQgdGhlIGNvbW1hbmRcbiAgICogXG4gICAqIEByZXR1cm4gdGhlIG1lc3NhZ2UgYXMgYSB7c3RyaW5nfSBhcyBleHBlY3RlZCBieSB0aGUgc2VydmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplSnNvbkNvbW1hbmRNZXNzYWdlVG9TZW5kKGNvbW1hbmQ6IHN0cmluZywgcGF5bG9hZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcImNcIjogY29tbWFuZCwgXCJwXCI6IHBheWxvYWR9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnNlcmlhbGl6ZSBhIHJlY2VpdmVkIGNvbW1hbmQgbWVzc2FnZSBcbiAgICogSWYgdGhlIG1lc3NhZ2UgaXMgcGFyc2VkIGNvcnJlY3RseSB0aGVuIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgdmFsaWQgXCJDb21tYW5kTWVzc2FnZVwiIG9iamVjdFxuICAgKiBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcga2V5c1xuICAgKiAtIHtzdHJpbmd9ICdjb21tYW5kJyAtIFRoZSBjb21tYW5kIHRva2VuIGlkZW50aWZ5aW5nIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgbWVzc2FnZVxuICAgKiAtIHtzdHJpbmd9ICdwYXlsb2FkJyAtIFRoZSBhY3R1YWwgZGF0YSByZWNlaXZlZCBmcm9tIHRoZSBtZXNzYWdlXG4gICAqIFxuICAgKiBJZiB0aGUgcGFyc2luZyBkb2Vzbid0IG1hdGNoIGEgdmFsaWQgY29tbWFuZE1lc3NhZ2UgdGhlbiB0aGUgZnVuY3Rpb24gcmV0dXJucyBudWxsIGFuZCBsb2cgdGhlIHByb2JsZW1cbiAgICogXG4gICAqIEByZXR1cm4gQSB2YWxpZCBcIkNvbW1hbmRNZXNzYWdlXCIgb2JqZWN0IGFzIGRldGFpbGVkIGFib3ZlIG9yIG51bGxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91bnNlcmlhbGl6ZUpzb25Db21tYW5kTWVzc2FnZUZyb21SZWNlaXZlZChtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBsZXQgY29tbWFuZE1lc3NhZ2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1hbmRNZXNzYWdlID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKGBDb3VsZG4ndCBwYXJzZSBjb21tYW5kIG1lc3NhZ2UhIEVycm9yOlxcbiR7ZX1cXG4gRnVsbCBtZXNzYWdlIGNvbnRlbnRzOlxcbiR7bWVzc2FnZX1gLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjb21tYW5kTWVzc2FnZSBpcyBleHBlY3RlZCB0byBoYXZlIDIga2V5czpcbiAgICAvLyAnYyc6IHRoZSBjb21tYW5kIG5hbWUsIHRoZSB0b2tlbiBpZGVudGlmeWluZyB0aGUgY29tbWFuZCBkZXN0aW5hdGlvbiBmb3IgdGhpcyBtZXNzYWdlXG4gICAgLy8gJ3AnOiB0aGUgcGF5bG9hZCBkYXRhLCB0aGUgYWN0dWFsIGluZm9ybWF0aW9uIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlclxuICAgIGlmIChjb21tYW5kTWVzc2FnZSAmJiBjb21tYW5kTWVzc2FnZS5jICYmIGNvbW1hbmRNZXNzYWdlLnApIHtcbiAgICAgIHJldHVybiB7J2NvbW1hbmQnOiBjb21tYW5kTWVzc2FnZS5jLCAncGF5bG9hZCc6IGNvbW1hbmRNZXNzYWdlLnAgfTtcbiAgICB9XG4gICAgUmF2aVV0aWxzLmVycihcIk1lc3NhZ2UgY2Fubm90IGJlIHVuc2VyaWFsaXplZCBpbnRvIGEgQ29tbWFuZE1lc3NhZ2U6IFwiICsgbWVzc2FnZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBcbiAgICogU2VuZCBhIHBhcnRpY3VsYXIgY29tbWFuZCBpbnN0YW5jZSBpbW1lZGlhdGVseSAtLVxuICAgKiB0aGlzIGdldHMgdXNlZCBpbnRlcm5hbGx5IGJ5IHtAbGluayBSYXZpQ29tbWFuZENvbnRyb2xsZXIjX3Byb2Nlc3NTZW5kaW5nUXVldWVkQ29tbWFuZHN9XG4gICAqIGFuZCBpbiBnZW5lcmFsLCBzaG91bGQgbm90IGJlIGNhbGxlZCBleHRlcm5hbGx5LlxuICAgKiBcbiAgICogQHBhcmFtIHtSYXZpQ29tbWFuZEluc3RhbmNlfSBjb21tYW5kSW5zdGFuY2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZW5kQ29tbWFuZEluc3RhbmNlKGNvbW1hbmRJbnN0YW5jZTogUmF2aUNvbW1hbmRJbnN0YW5jZSkge1xuICAgIC8vIFJhdGhlciB0aGFuIGNoZWNraW5nIGZvciBhbiBvcGVuIGNoYW5uZWwgZXZlcnkgdGltZSwganVzdCB0cnkgaXQgYW5kXG4gICAgLy8gY2F0Y2ggYW55IGVycm9yc1xuICAgIHRyeSB7XG4gICAgICBsZXQgbWVzc2FnZSA9IGNvbW1hbmRJbnN0YW5jZS5fY29tbWFuZDtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gdGhpcy5fc2VyaWFsaXplSnNvbkNvbW1hbmRNZXNzYWdlVG9TZW5kKGNvbW1hbmRJbnN0YW5jZS5fY29tbWFuZCwgY29tbWFuZEluc3RhbmNlLl9wYXJhbSk7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJTZW5kaW5nIGNvbW1hbmQgXCIgKyBtZXNzYWdlLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJTZW5kaW5nIGJpbmFyeSBjb21tYW5kXCIsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tbWFuZERhdGFDaGFubmVsLnNlbmQobWVzc2FnZSk7XG4gICAgICAvLyB3ZSBkb24ndCBnZXQgYW55dGhpbmcgYmFjaywgc28ganVzdCBhc3N1bWUgaXQgc2VudCBpZiBpdCBkaWRuJ3QgdGhyb3cgYW4gZXJyb3IuLi5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIlJlY2VpdmVkIGVycm9yIHdoaWxlIHNlbmRpbmc6IFwiICsgZXJyLm1lc3NhZ2UsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFxuICAgKiBQcm9jZXNzIHRoZSBsaXN0ZW5lciBmb3IgdGhlIG1lc3NhZ2UgZnJvbSB0aGUgUkFWSSBzZXJ2ZXIgLS1cbiAgICogdGhpcyBnZXRzIHVzZWQgaW50ZXJuYWxseSBieSB7QGxpbmsgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9ufVxuICAgKiBhbmQgaW4gZ2VuZXJhbCwgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZXh0ZXJuYWxseS5cbiAgICogXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tU2VydmVyTWVzc2FnZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NMaXN0ZW5pbmdDb21tYW5kKGZyb21TZXJ2ZXJNZXNzYWdlOiBhbnkpIHtcblxuICAgIGxldCBzZXJ2ZXJEYXRhID0gZnJvbVNlcnZlck1lc3NhZ2UuZGF0YTtcbiAgICBsZXQgY29tbWFuZE1lc3NhZ2UgPSBudWxsO1xuXG4gICAgLy8gRmlyc3Qgb2ZmLCBpcyB0aGlzIGEgYmluYXJ5IG1lc3NhZ2Ugb3IgYSBKU09OIG1lc3NhZ2U/XG4gICAgLy8gSWYgaXQncyBhIEpTT04gbWVzc2FnZSwgaXQnbGwgYmUgYSBzdHJpbmc7IGlmIGl0J3MgYVxuICAgIC8vIGJpbmFyeSBtZXNzYWdlLCBpdCdsbCBiZSBhbiBBcnJheUJ1ZmZlci5cbiAgICAvLyAoQW5kIGlmIGl0J3MgbmVpdGhlciBvZiB0aG9zZSwgd2UnbGwgbGVhdmUgY29tbWFuZE1lc3NhZ2VcbiAgICAvLyB1bnNldCBhbmQgcGljayBpdCB1cCBsYXRlci4pXG4gICAgaWYgKHNlcnZlckRhdGEpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VydmVyRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSXQncyBKU09OLiBUaGUgY29tbWFuZCBpbmZvIGlzIGFscmVhZHkgaW4gdGhlIG1lc3NhZ2UuXG4gICAgICAgIGNvbW1hbmRNZXNzYWdlID0gdGhpcy5fdW5zZXJpYWxpemVKc29uQ29tbWFuZE1lc3NhZ2VGcm9tUmVjZWl2ZWQoc2VydmVyRGF0YSk7XG4gICAgICAgIHRoaXMuX2NvbnRpbnVlUHJvY2Vzc2luZ0xpc3RlbmluZ0NvbW1hbmQoY29tbWFuZE1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIGlmIChzZXJ2ZXJEYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe1xuICAgICAgICAvLyBJdCdzIGJpbmFyeS4gV2UnbGwgd3JhcCBpdCBpbiBhIHR5cGVkIGFycmF5XG4gICAgICAgIC8vIGFuZCB0aGVuIGluIGEgSmF2YVNjcmlwdCBzdHJ1Y3RcbiAgICAgICAgLy8gc28gdGhhdCBpdCBjYW4gYmUgcHJvY2Vzc2VkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgLy8gXCJwYXlsb2FkXCIgY29kZSBwYXRoIGFzIHRoZSBKU09OIGRhdGFcbiAgICAgICAgY29tbWFuZE1lc3NhZ2UgPSB7ICdjb21tYW5kJyA6IF9CSU5BUllfQ09NTUFORF9LRVksICdwYXlsb2FkJyA6IG5ldyBVaW50OEFycmF5KHNlcnZlckRhdGEpfTtcbiAgICAgICAgLy8gTk9URTogQ3VycmVudGx5LCB3ZSBkb24ndCBuYXRpdmVseSBpbmNsdWRlIGFueSBzb3J0IG9mIFwiY29tbWFuZFwiIGFzc29jaWF0ZWRcbiAgICAgICAgLy8gd2l0aCBiaW5hcnkgbWVzc2FnZXMgLS0gd2hlbiB3ZSBnZXQgYSBiaW5hcnkgbWVzc2FnZSwgYWxsIGJpbmFyeVxuICAgICAgICAvLyBoYW5kbGVycyBhcmUgY2FsbGVkLiBXZSBtYXkgZGVjaWRlIHRvIHJldGhpbmsgdGhpcyBpbiB0aGUgZnV0dXJlLlxuICAgICAgICB0aGlzLl9jb250aW51ZVByb2Nlc3NpbmdMaXN0ZW5pbmdDb21tYW5kKGNvbW1hbmRNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VydmVyRGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgc2VydmVyRGF0YS5hcnJheUJ1ZmZlcigpXG4gICAgICAgICAgLnRoZW4oKHByb2Nlc3NlZEFycmF5QnVmZmVyKSA9PiB7XG4gICAgICAgICAgICBjb21tYW5kTWVzc2FnZSA9IHsgJ2NvbW1hbmQnIDogX0JJTkFSWV9DT01NQU5EX0tFWSwgJ3BheWxvYWQnIDogbmV3IFVpbnQ4QXJyYXkocHJvY2Vzc2VkQXJyYXlCdWZmZXIpfTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRpbnVlUHJvY2Vzc2luZ0xpc3RlbmluZ0NvbW1hbmQoY29tbWFuZE1lc3NhZ2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jb250aW51ZVByb2Nlc3NpbmdMaXN0ZW5pbmdDb21tYW5kKGNvbW1hbmRNZXNzYWdlOiBhbnkpIHtcbiAgICBpZiAoIWNvbW1hbmRNZXNzYWdlKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKFwiUmVjZWl2ZWQgaW52YWxpZCBjb21tYW5kIG1lc3NhZ2UsIGlnbm9yaW5nOiBcIiArIEpTT04uc3RyaW5naWZ5KGNvbW1hbmRNZXNzYWdlKSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTGV0J3MgdHJ5IHRvIGZpbmQgdGhlIG1hdGNoaW5nIGxpc3RlbmVyKHMpIGZvciB0aGUgY29tbWFuZE1lc3NhZ2UgcmVjZWl2ZWQ6XG4gICAgdmFyIGZvdW5kQ29tbWFuZEluc3RhbmNlID0gdGhpcy5fY29tbWFuZFF1ZXVlTWFwLmdldChjb21tYW5kTWVzc2FnZS5jb21tYW5kKTtcbiAgICBpZiAoZm91bmRDb21tYW5kSW5zdGFuY2UpIHtcbiAgICAgIC8vIEhvdyBtYW55IGxpc3RlbmVycyBkb2VzIGl0IGhhdmU/XG4gICAgICB2YXIgbGVuZ3RoID0gZm91bmRDb21tYW5kSW5zdGFuY2UubGlzdGVuZXIubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgLyoqXG4gICAgICAgIFRPRE86IFdlIG5lZWQgdG8gYWRkIGJvdGggc2VydmVyICYgY2xpZW50IGZ1bmN0aW9uYWxpdHkgdGhhdFxuICAgICAgICB3aWxsIHRyYWNrIHRoZSBcImluc3RhbmNlXCIgb2YgYSBjb21tYW5kIGFuZCB0cmlnZ2VyIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgICBsaXN0ZW5lci4gUmlnaHQgbm93IHRoaXMgY291bGQgYmVoYXZlIHVuZXhwZWN0ZWRseSBpbiB0aGUgc2l0dWF0aW9uXG4gICAgICAgIHdoZXJlIHdlIHJlZ2lzdGVyIHR3byBkaWZmZXJlbnQgbGlzdGVuZXJzIGZvciB0aGUgc2FtZSBjb21tYW5kXG4gICAgICAgIGFuZCB0aGUgXCJ3cm9uZ1wiIG9uZSByZXR1cm5zIGZpcnN0LiBTZWUgQklHV09STEQtNDU2LiBXZSBjYW4gbWFrZVxuICAgICAgICB0aGlzIGNvZGUgY2xlYW5lciBvbmNlIHRoYXQncyBpbXBsZW1lbnRlZC5cblxuICAgICAgICBJbiB0aGUgbWVhbnRpbWUsIHdlJ2xsIGxlYXZlIHRoZSBcImluc3RhbmNlIG9mIGEgY29tbWFuZFwiIGJlaGF2aW9yIGFzIGlzLlxuICAgICAgICBBbmQgaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIgd2l0aCBhIFwibWF0Y2hpbmcgc2VudCBjb21tYW5kXCIsIHdlJ2xsXG4gICAgICAgIGV4ZWN1dGUgYWxsIHRoZSByZWxldmFudCBcImxpc3Rlbi1vbmx5XCIgbGlzdGVuZXJzLlxuXG4gICAgICAgIE5PVEU6IFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgYSBnaXZlbiBjb21tYW5kTWVzc2FnZSBcImNvbW1hbmRcIiBzdHJpbmdcbiAgICAgICAgKGUuZy4gXCJjb21tYW5kLmFib3V0XCIgb3IgXCJtZXNzYWdlLmxvY2F0aW9uXCIpIHdpbGwgb25seSBoYXZlIE9ORSBUWVBFXG4gICAgICAgIG9mIGxpc3RlbmVyOiBcIm1hdGNoaW5nIHNlbnQgY29tbWFuZFwiIG9yIFwibGlzdGVuLW9ubHlcIi4gSWYgeW91IHF1ZXVlXG4gICAgICAgIGEgY29tbWFuZCB3aXRoIGEgbGlzdGVuZXIsIGFuZCB0aGVuIEFMU08gdHJ5IHRvXG4gICAgICAgIGFzc29jaWF0ZSBhIGxpc3Rlbi1vbmx5IGxpc3RlbmVyIHdpdGggdGhhdCBzYW1lIGNvbW1hbmQgbmFtZSxcbiAgICAgICAgc3RyYW5nZSB0aGluZ3Mgd2lsbCBoYXBwZW4uIChTcGVjaWZpY2FsbHksIHRoZSBjb21tYW5kIGhhbmRsZXIgZm9yXG4gICAgICAgIHRoZSBzZW50IGNvbW1hbmQgd2lsbCBiZSB0aGUgb25seSB0aGluZyBleGVjdXRlZCB3aGVuIHlvdSBnZXQgdGhlIGZpcnN0XG4gICAgICAgIHJlc3BvbnNlIGJhY2ssIGJ1dCBpZiB5b3UgZ2V0IHN1YnNlcXVlbnQgcmVzcG9uc2VzIGJhY2ssIHRoZW4gdGhlXG4gICAgICAgIGxpc3Rlbi1vbmx5IGxpc3RlbmVyKHMpIHdpbGwgZXhlY3V0ZS4pIFdlIGNhbiByZW1vdmUgdGhpcyByZXN0cmljdGlvblxuICAgICAgICBvbmNlIEJJR1dPUkxELTQ1NiBpcyBpbXBsZW1lbnRlZC5cbiAgICAgICAgKiovXG4gICAgICAgIGlmIChmb3VuZENvbW1hbmRJbnN0YW5jZS5saXN0ZW5lclswXSAmJiBmb3VuZENvbW1hbmRJbnN0YW5jZS5saXN0ZW5lclswXS5faGFzTWF0Y2hpbmdTZW50Q29tbWFuZCkge1xuICAgICAgICAgIC8vIFRoZXJlIHdhcyBhbiBvcmlnaW5hbCBjb21tYW5kIHNlbnQgdGhhdCB3ZSdyZSBsaXN0ZW5pbmcgZm9yIGEgcmVzcG9uc2UgZm9yLCBcbiAgICAgICAgICAvLyBjb21tYW5kIHNlbnQsIHNvIHRoYXQgbWVhbnMgd2UganVzdCBleGVjdXRlIHRoZSBmaXJzdCBoYW5kbGVyLFxuICAgICAgICAgIC8vIHdoYXRldmVyIGl0IGlzLlxuICAgICAgICAgIHZhciBjb21tYW5kSW5zdGFuY2UgPSBmb3VuZENvbW1hbmRJbnN0YW5jZS5saXN0ZW5lci5zaGlmdCgpO1xuICAgICAgICAgIGlmIChjb21tYW5kSW5zdGFuY2UgJiYgY29tbWFuZEluc3RhbmNlLl9oYW5kbGVyKSB7XG4gICAgICAgICAgICBjb21tYW5kSW5zdGFuY2UuX2hhbmRsZXIoY29tbWFuZE1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICByZXR1cm47IC8vIHN1Y2Nlc3MsIGVuZCBvZiB0aGUgKGZpcnN0KSBsaXN0ZW5lclxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSYXZpVXRpbHMuZXJyKFwiVW5kZWZpbmVkIGNvbW1hbmQgaGFuZGxlcjogXCIgKyBjb21tYW5kTWVzc2FnZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld0xpc3RlbmVycyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZvdW5kQ29tbWFuZEluc3RhbmNlLmxpc3RlbmVyW2ldO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICYmIGxpc3RlbmVyLl9oYW5kbGVyKSB7XG4gICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gZXhlY3V0ZSB0aGUgaGFuZGxlclxuICAgICAgICAgICAgICBsaXN0ZW5lci5faGFuZGxlcihjb21tYW5kTWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIFJhdmlVdGlscy5lcnIoXCJVbmRlZmluZWQgbWVzc2FnZSBoYW5kbGVyOiBcIiArIGNvbW1hbmRNZXNzYWdlLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGl0J3Mgc3RpY2t5LCBhZGQgaXQgdG8gdGhlIFwibmV3XCIgbGlzdFxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICYmIGxpc3RlbmVyLl9pc1N0aWNreSkge1xuICAgICAgICAgICAgICBuZXdMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSB3aXRoIG9ubHkgdGhlIHN0aWNreSBvbmVzXG4gICAgICAgICAgZm91bmRDb21tYW5kSW5zdGFuY2UubGlzdGVuZXIgPSBuZXdMaXN0ZW5lcnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG5vIGxpc3RlbmVyIGRlZmluZWQsIGp1c3QgbW92ZSBvbiwgdGhpcyBpcyBhbiBvayBwYXRoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFxuICAgKiBTZXQgdGhlIGlucHV0IGRhdGEgY2hhbm5lbC5cbiAgICpcbiAgICogQHBhcmFtIHtSVENEYXRhQ2hhbm5lbH0gaW5wdXREYXRhQ2hhbm5lbCBUaGUgZGF0YUNoYW5uZWwgdG8gdXNlLiBXaGlsZSB0aGlzIGlzIGRlZmluZWQgYXMgYW4gUlRDRGF0YUNoYW5uZWwsXG4gICAqIGh5cG90aGV0aWNhbGx5IHNvbWUgb3RoZXIga2luZCBvZiBzdHJlYW0gdGhhdCBvZmZlcnMgdGhlIHNhbWUgQVBJIGFuZCBjYWxsYmFja3MgYXMgYW4gUlRDRGF0YUNoYW5uZWxcbiAgICogY291bGQgYWxzbyBiZSB1c2VkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldElucHV0RGF0YUNoYW5uZWwoaW5wdXREYXRhQ2hhbm5lbDogUlRDRGF0YUNoYW5uZWwpIHtcbiAgICB0aGlzLl9pbnB1dERhdGFDaGFubmVsID0gaW5wdXREYXRhQ2hhbm5lbDtcbiAgICBSYXZpVXRpbHMubG9nKFwiUmVjZWl2ZWQgbmV3IGlucHV0IGRhdGEgY2hhbm5lbCB3aXRoIGlkIFwiICsgdGhpcy5faW5wdXREYXRhQ2hhbm5lbC5pZCwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG5cbiAgICB0aGlzLl9pbnB1dERhdGFDaGFubmVsLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIFJhdmlVdGlscy5sb2coXCJfaW5wdXREYXRhQ2hhbm5lbCBvbm9wZW4sIHN0YXRlIGlzIFwiICsgdGhpcy5faW5wdXREYXRhQ2hhbm5lbC5yZWFkeVN0YXRlLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9pbnB1dERhdGFDaGFubmVsLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiX2lucHV0RGF0YUNoYW5uZWwgb25jbG9zZSwgc3RhdGUgaXMgXCIgKyB0aGlzLl9pbnB1dERhdGFDaGFubmVsLnJlYWR5U3RhdGUsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2lucHV0RGF0YUNoYW5uZWwub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2U6IGFueSkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIl9pbnB1dERhdGFDaGFubmVsIGdvdCBtZXNzYWdlOiBcIiArIChtZXNzYWdlLmRhdGEpLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogXG4gICAqIFNldCB0aGUgY29tbWFuZCBkYXRhIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7UlRDRGF0YUNoYW5uZWx9IGNvbW1hbmREYXRhQ2hhbm5lbCBUaGUgZGF0YUNoYW5uZWwgdG8gdXNlLiBXaGlsZSB0aGlzIGlzIGRlZmluZWQgYXMgYW4gUlRDRGF0YUNoYW5uZWwsXG4gICAqIGh5cG90aGV0aWNhbGx5IHNvbWUgb3RoZXIga2luZCBvZiBzdHJlYW0gdGhhdCBvZmZlcnMgdGhlIHNhbWUgQVBJIGFuZCBjYWxsYmFja3MgYXMgYW4gUlRDRGF0YUNoYW5uZWxcbiAgICogY291bGQgYWxzbyBiZSB1c2VkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldENvbW1hbmREYXRhQ2hhbm5lbChjb21tYW5kRGF0YUNoYW5uZWw6IFJUQ0RhdGFDaGFubmVsKSB7XG4gICAgdGhpcy5fY29tbWFuZERhdGFDaGFubmVsID0gY29tbWFuZERhdGFDaGFubmVsO1xuICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCBuZXcgZGF0YSBjaGFubmVsIHdpdGggaWQgXCIgKyB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwuaWQsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICBcbiAgICB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIl9jb21tYW5kRGF0YUNoYW5uZWwgb25vbnBlbiwgc3RhdGUgaXMgXCIgKyB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwucmVhZHlTdGF0ZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICAvLyBLaWNrIG9mZiB0aGUgbW9uaXRvcmluZyBvZiB0aGUgY29tbWFuZCBxdWV1ZXMgaW4gdGhlIGNvbW1hbmQgY29udHJvbGxlci5cbiAgICAgIHRoaXMubW9uaXRvclF1ZXVlcygpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2NvbW1hbmREYXRhQ2hhbm5lbC5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIl9jb21tYW5kRGF0YUNoYW5uZWwgb25jbG9zZSwgc3RhdGUgaXMgXCIgKyB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwucmVhZHlTdGF0ZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICAvLyBTdG9wIG1vbml0b3JpbmcgdGhlIGNvbW1hbmQgcXVldWVcbiAgICAgIHRoaXMuc3RvcE1vbml0b3JpbmdRdWV1ZXMoKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2U6IGFueSkge1xuICAgICAgdGhpcy5fcHJvY2Vzc0xpc3RlbmluZ0NvbW1hbmQobWVzc2FnZSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgXG4gIC8qKlxuICAgKiBTZXQgYSBET00gZWxlbWVudCB0aGF0IGlzIHVzZWQgdG8gdHJhY2sgaW5wdXQgZXZlbnQgKG1vdXNlICYgdG91Y2gpXG4gICAqIHNldmVyYWwgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byB0aGUgZWxlbWVudCBhbmQgY29tbXVuaWNhdGUgaW5wdXQgZXZlbnRzIHRvIFJhdmkgU2VydmVyIHRocm91Z2ggdGhlIGlucHV0IGNoYW5uZWxcbiAgICogQHBhcmFtIHtFbGVtZW50fSBpbnB1dFRhcmdldEVsZW1lbnQgUmVmZXJlbmNlIHRvIHRoZSBKYXZhU2NyaXB0IERPTSBlbGVtZW50IHVzZWQgdG8gdHJhY2sgaW5wdXQgZXZlbnRzIFxuICAgKi9cbiAgc2V0SW5wdXRUYXJnZXQoaW5wdXRUYXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9pbnB1dFRhcmdldCkge1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZW1vdmUgPSBudWxsO1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZWVudGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX2lucHV0VGFyZ2V0Lm9ubW91c2VsZWF2ZSA9IG51bGw7XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNlZG93biA9IG51bGw7XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNldXAgPSBudWxsO1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub253aGVlbCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5faW5wdXRUYXJnZXQgPSBpbnB1dFRhcmdldEVsZW1lbnQ7XG5cbiAgICBpZiAodGhpcy5faW5wdXRUYXJnZXQpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZW1vdmUgPSAgZnVuY3Rpb24oZXZlbnQpIHsgdGhhdC5fdHJhY2tNb3VzZShldmVudCk7IH07XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNlZW50ZXIgPSBudWxsO1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZWxlYXZlID0gbnVsbDtcbiAgICAgIHRoaXMuX2lucHV0VGFyZ2V0Lm9ubW91c2Vkb3duID0gZnVuY3Rpb24oZXZlbnQpIHsgdGhhdC5fY2FwdHVyZU1vdXNlRG93bihldmVudCk7IH07XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNldXAgPSBmdW5jdGlvbihldmVudCkgeyB0aGF0Ll9yZXNldE1vdXNlRG93bihldmVudCk7IH07XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbndoZWVsID0gIGZ1bmN0aW9uKGV2ZW50KSB7IHRoYXQuX3doZWVsTW91c2UoZXZlbnQpOyB9O1xuICAgIH1cbiAgfVxuXG4gc2V0S2V5Ym9hcmRUYXJnZXQoaW5wdXRUYXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9rZXlib2FyZFRhcmdldCkge1xuICAgICAgdGhpcy5fa2V5Ym9hcmRUYXJnZXQub25rZXlkb3duID0gbnVsbDtcbiAgICAgIHRoaXMuX2tleWJvYXJkVGFyZ2V0Lm9ua2V5dXAgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX2tleWJvYXJkVGFyZ2V0ID0gaW5wdXRUYXJnZXRFbGVtZW50O1xuXG4gICAgaWYgKHRoaXMuX2tleWJvYXJkVGFyZ2V0KSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2tleWJvYXJkVGFyZ2V0Lm9ua2V5ZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7IHRoYXQuX29uS2V5Ym9hcmREb3duKGV2ZW50KTsgfTtcbiAgICAgIHRoaXMuX2tleWJvYXJkVGFyZ2V0Lm9ua2V5dXAgPSBmdW5jdGlvbihldmVudCkgeyB0aGF0Ll9vbktleWJvYXJkVXAoZXZlbnQpOyB9O1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFxuICAgKi9cbiAgX2NhcHR1cmVNb3VzZURvd24oZTogTW91c2VFdmVudCkge1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFswXSA9IGUub2Zmc2V0WDtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMV0gPSBlLm9mZnNldFk7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzJdID0gZS5vZmZzZXRYO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFszXSA9IGUub2Zmc2V0WTtcblxuICAgIHRoaXMuX21vdXNlU3RhdGVVaW50OFsxXSA9IGUuYnV0dG9ucztcblxuICAgIC8vIEFuZCBzZW5kIHN0YXRlXG4gICAgdGhpcy5fc2VuZE1vdXNlU3RhdGUoKTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogXG4gICAqL1xuICBfcmVzZXRNb3VzZURvd24oZTogTW91c2VFdmVudCkge1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFswXSA9IC0xLjA7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzFdID0gLTEuMDtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMl0gPSAtMS4wO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFszXSA9IC0xLjA7XG5cbiAgICB0aGlzLl9tb3VzZVN0YXRlVWludDhbMV0gPSBlLmJ1dHRvbnM7XG5cbiAgICAvLyBBbmQgc2VuZCBzdGF0ZVxuICAgIHRoaXMuX3NlbmRNb3VzZVN0YXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFxuICAgKi9cbiAgX3RyYWNrTW91c2UoZTogTW91c2VFdmVudCkge1xuICAgIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBtb3VzZSBwb3MgaW4gdGhlIG91c2VTdGF0ZUJ1ZmZmZXJcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMF0gPSBlLm9mZnNldFg7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzFdID0gZS5vZmZzZXRZO1xuXG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzRdID0gdGhpcy5faW5wdXRUYXJnZXQub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzVdID0gdGhpcy5faW5wdXRUYXJnZXQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgdGhpcy5fbW91c2VTdGF0ZVVpbnQ4WzFdID0gZS5idXR0b25zO1xuXG4gICAgLy8gQW5kIHNlbmQgc3RhdGVcbiAgICB0aGlzLl9zZW5kTW91c2VTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFxuICAgKi9cbiAgX3doZWVsTW91c2UoZTogV2hlZWxFdmVudCkge1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFs2XSA9IGUuZGVsdGFZO1xuICAgIHRoaXMuX3NlbmRNb3VzZVN0YXRlKCk7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzZdID0gMDtcbiAgfVxuXG4gIF9zZW5kTW91c2VTdGF0ZSgpIHtcbiAgICB0aGlzLnNlbmRJbnB1dCh0aGlzLl9tb3VzZVN0YXRlQnVmZmVyKTtcbiAgfVxuXG4gIF9rZXlCeXRlTnVtKGM6IGFueSkge1xuICAgIHJldHVybiBjID4+IDM7XG4gIH1cbiAgX2tleUJpdE1hc2soYzogYW55KSB7XG4gICAgcmV0dXJuICgxIDw8IChjICUgOCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25LZXlib2FyZERvd24oZTogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBjID0gX0tFWV9DT0RFX1RBQkxFWzxhbnk+IGUuY29kZV07XG4gICAgbGV0IGtleUJ5dGVOdW0gPSAxICsgdGhpcy5fa2V5Qnl0ZU51bShjKTtcbiAgICBsZXQga2V5Qnl0ZU1hc2sgPSB0aGlzLl9rZXlCaXRNYXNrKGMpO1xuICAgIGlmICgodGhpcy5fa2V5Ym9hcmRTdGF0ZVtrZXlCeXRlTnVtXSAmIGtleUJ5dGVNYXNrKSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9rZXlib2FyZFN0YXRlW2tleUJ5dGVOdW1dIHw9IGtleUJ5dGVNYXNrO1xuICAgICAgICB0aGlzLl9zZW5kS2V5Ym9hcmRTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uS2V5Ym9hcmRVcChlOiBLZXlib2FyZEV2ZW50KSB7XG4gICAgbGV0IGMgPSBfS0VZX0NPREVfVEFCTEVbPGFueT4gZS5jb2RlXTtcbiAgICBsZXQga2V5Qnl0ZU51bSA9IDEgKyB0aGlzLl9rZXlCeXRlTnVtKGMpO1xuICAgIGxldCBrZXlCeXRlTWFzayA9IHRoaXMuX2tleUJpdE1hc2soYyk7XG4gICAgaWYgKCh0aGlzLl9rZXlib2FyZFN0YXRlW2tleUJ5dGVOdW1dICYga2V5Qnl0ZU1hc2spICE9PSAwKSB7XG4gICAgICAgIHRoaXMuX2tleWJvYXJkU3RhdGVba2V5Qnl0ZU51bV0gXj0ga2V5Qnl0ZU1hc2s7XG4gICAgICAgIHRoaXMuX3NlbmRLZXlib2FyZFN0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX3NlbmRLZXlib2FyZFN0YXRlKCkge1xuICAgIHRoaXMuc2VuZElucHV0KHRoaXMuX2tleWJvYXJkU3RhdGVCdWZmZXIpO1xuICB9XG5cbn0gLy8gRW5kIG9mIHRoZSBSYXZpQ29tbWFuZENvbnRyb2xsZXIgY2xhc3NcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiogXG4gKlxuICogQSBjb21tYW5kIGluc3RhbmNlIGZvciB1c2Ugd2l0aCB0aGUgXG4gKiBSYXZpQ29tbWFuZENvbnRyb2xsZXIuIFRoaXMgaXMganVzdFxuICogYSBzcGVjaWFsaXplZCBvYmplY3QgdG8gdHJhY2sgdGhlIGNvbWJpbmF0aW9uIG9mXG4gKiBhIGNvbW1hbmQgdHlwZSwgdGhlIHBhcmFtZXRlcnMgZm9yIHRoYXQgY29tbWFuZCxcbiAqIGFuZCB0aGUgaGFuZGxlciB0byBiZSB1c2VkIGZvciB0aGUgY29tbWFuZCByZXN1bHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZCAtIFRoZSBhY3R1YWwgc3RyaW5nIGNvbW1hbmQgdG8gc2VuZFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtIC0gQW55IHBhcmFtZXRlcnMgdG8gYmUgc2VudCB0byB0aGUgY29tbWFuZFxuICogQHBhcmFtIHtSYXZpQ29tbWFuZENvbnRyb2xsZXIuUmF2aUNvbW1hbmRIYW5kbGVySW5zdGFuY2V9IGhhbmRsZXIgLSBBIGNhbGxiYWNrIGhhbmRsZXIgdG8gdXNlIHdoZW4gdGhlIGNvbW1hbmQgcmV0dXJucyBmcm9tIHRoZSBzZXJ2ZXJcbiAqIFxuICogQGNsYXNzIFJhdmlDb21tYW5kQ29udHJvbGxlci5SYXZpQ29tbWFuZEluc3RhbmNlXG4gKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBjb21tYW5kIHRoYXQgc2hvdWxkIGJlIFxuICogcXVldWVkIHVwIGluIHRoZSBSYXZpQ29tbWFuZENvbnRyb2xsZXIncyBjb21tYW5kIHF1ZXVlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJhdmlDb21tYW5kSW5zdGFuY2Uge1xuICBfY29tbWFuZDogYW55O1xuICBfcGFyYW06IGFueTtcbiAgX2hhbmRsZXI6IGFueTtcblxuICAvKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKiB0aGlzLl9jb21tYW5kO1xuICAgKiB0aGlzLl9wYXJhbTtcbiAgICogdGhpcy5faGFuZGxlcjtcbiAgICovXG4gIFxuICAvKiogXG4gICAqIEBwcml2YXRlIFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29tbWFuZDogYW55LCBwYXJhbTogYW55LCBoYW5kbGVyOiBhbnkpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiY29uc3RydWN0b3JcIiwgXCJSYXZpQ29tbWFuZEluc3RhbmNlXCIpO1xuICAgIHRoaXMuX2NvbW1hbmQgPSBjb21tYW5kO1xuICAgIHRoaXMuX3BhcmFtID0gcGFyYW07XG4gICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XG4gIH1cbn1cblxuLyoqIFxuICpcbiAqIEEgaGFuZGxlciBpbnN0YW5jZSBmb3IgdXNlIHdpdGggdGhlIFxuICogUmF2aUNvbW1hbmRDb250cm9sbGVyLiBUaGlzIGp1c3RcbiAqIHRyYWNrcyB0aGUgaGFuZGxlciBmdW5jdGlvbiBhbmQgd2hldGhlciBvciBcbiAqIG5vdCBpdCdzIFwic3RpY2t5LlwiIEhhbmRsZXJzIHRoYXQgYXJlIGFzc29jaWF0ZWRcbiAqIHdpdGggYSBwYXJ0aWN1bGFyIFNFTlQgY29tbWFuZCBhcmUgTk9UIHN0aWNreSBieVxuICogZGVmYXVsdCAoaS5lLiB0aGV5IGV4ZWN1dGUgb25jZSwgYW5kIHRoZW4gc3RvcFxuICogbGlzdGVuaW5nKSwgYnV0IGxpc3RlbmVycyB0aGF0IGFyZSByZWdpc3RlcmVkXG4gKiBieSB0aGVtc2VsdmVzIGNhbiBiZSBlaXRoZXIgc3RpY2t5IG9yIG5vdCBzdGlja3kuXG4gKiBAcGFyYW0ge1JhdmlDb21tYW5kQ29udHJvbGxlcn5jb21tYW5kQ2FsbGJhY2t9IGhhbmRsZXIgLSBBIGNhbGxiYWNrIGhhbmRsZXIgdG8gdXNlIHdoZW4gdGhlIGNvbW1hbmQgcmV0dXJucyBmcm9tIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdGlja3kgLSBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBzdGlja3MgYXJvdW5kIGZvcmV2ZXIgKHRydWUpIG9yIHN0b3BzIGxpc3RlbmluZyBhZnRlciBpdCBnZXRzXG4gKiBpdHMgZmlyc3QgcmVzcG9uc2UgKGZhbHNlKVxuICogQHBhcmFtIHtib29sZWFufSBoYXNNYXRjaGluZ1NlbnRDb21tYW5kIC0gV2hldGhlciBvciBub3QgdGhpcyBoYW5kbGVyIGhhcyBhIG1hdGNoaW5nIGNvbW1hbmQgdGhhdCB3YXMvaXMgZ29pbmcgdG8gYmUgXG4gKiBzZW50IHRvIHRoZSBzZXJ2ZXIgKHRydWUpLCBvciBpZiBpdCdzIGp1c3QgbGlzdGVuaW5nIGZvciBzb21ldGhpbmcgdGhlIHNlcnZlciBtaWdodCBzZW5kIG9uIGl0cyBvd24gKGZhbHNlKVxuICogXG4gKiBAY2xhc3MgUmF2aUNvbW1hbmRDb250cm9sbGVyLlJhdmlDb21tYW5kSGFuZGxlckluc3RhbmNlXG4gKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBoYW5kbGVyIHRoYXQgY2FuIGJlIFxuICogdXNlZCB0byBwcm9jZXNzIG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlclxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJhdmlDb21tYW5kSGFuZGxlckluc3RhbmNlIHtcbiAgX2hhbmRsZXI6IGFueTtcbiAgX2lzU3RpY2t5OiBib29sZWFuO1xuICBfaGFzTWF0Y2hpbmdTZW50Q29tbWFuZDogYm9vbGVhbjtcblxuICAvKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzOlxuICAgKiB0aGlzLl9oYW5kbGVyO1xuICAgKiB0aGlzLl9pc1N0aWNreTtcbiAgICogdGhpcy5faGFzTWF0Y2hpbmdTZW50Q29tbWFuZDtcbiAgICovXG4gIC8qKiBcbiAgICogQHByaXZhdGUgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihoYW5kbGVyOiBhbnksIGlzU3RpY2t5OiBib29sZWFuLCBoYXNNYXRjaGluZ1NlbnRDb21tYW5kOiBib29sZWFuKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aUNvbW1hbmRIYW5kbGVySW5zdGFuY2VcIik7XG4gICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdGhpcy5faXNTdGlja3kgPSBpc1N0aWNreTtcbiAgICB0aGlzLl9oYXNNYXRjaGluZ1NlbnRDb21tYW5kID0gaGFzTWF0Y2hpbmdTZW50Q29tbWFuZDtcbiAgfVxufVxuIiwiXG5pbXBvcnQgeyBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiwgUmF2aVNpZ25hbGluZ1N0YXRlcyB9IGZyb20gJy4vUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24nO1xuaW1wb3J0IHsgUmF2aVN0cmVhbUNvbnRyb2xsZXIgfSBmcm9tICcuL1JhdmlTdHJlYW1Db250cm9sbGVyJztcbmltcG9ydCB7IFJhdmlVdGlscyB9IGZyb20gJy4vUmF2aVV0aWxzJztcbmltcG9ydCB7IFJhdmlDb21tYW5kQ29udHJvbGxlciB9IGZyb20gJy4vUmF2aUNvbW1hbmRDb250cm9sbGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBXZWJSVENTZXNzaW9uUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGppdHRlciBidWZmZXIgZHVyYXRpb24uIFVuaXRzIGFyZSBzZWNvbmRzLiBUaGUgZGVmYXVsdCBpcyAwIHNlY29uZHMuXG4gICAqIFxuICAgKiBJbiBwcmFjdGljZSwgdGhpcyBzaG91bGQgYWx3YXlzIGJlIHNldCB0byAwIHNlY29uZHMsIHdoaWNoIGlzIHRoZSBkZWZhdWx0LiBTZXR0aW5nIHRoZSBtaW5pbXVtIGppdHRlciBidWZmZXIgZHVyYXRpb24gdG8gWCBzZWNvbmRzIG1lYW5zXG4gICAqIHRoYXQgYWxsIGF1ZGlvIHNlbnQgdG8gdGhlIHNlcnZlciB3aWxsIGFsd2F5cyBiZSBidWZmZXJlZCBhdCBsZWFzdCBieSBYIHNlY29uZHMuIFRoaXMgaXMgcmFyZWx5IGRlc2lyYWJsZTsgbG93ZXIgbGF0ZW5jeSBpcyBhbG1vc3QgYWx3YXlzIHByZWZlcnJlZC5cbiAgICogWW91IG1heSwgaG93ZXZlciwgd2FudCB0byBzZXQgdGhlIG1heGltdW0gaml0dGVyIGJ1ZmZlciBkdXJhdGlvbiBpZiB5b3VyIHVzZXJzIGFyZSBleHBlcmllbmNpbmcgZnJlcXVlbnQgYXVkaW8gZHJvcC1vdXRzOyByZWZlciB0byBgYXVkaW9NYXhKaXR0ZXJCdWZmZXJEdXJhdGlvbmAgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGF1ZGlvTWluSml0dGVyQnVmZmVyRHVyYXRpb24/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBqaXR0ZXIgYnVmZmVyIGR1cmF0aW9uLiBVbml0cyBhcmUgc2Vjb25kcy4gVGhlIGRlZmF1bHQgaXMgMSBzZWNvbmQuXG4gICAqIFxuICAgKiBTZXQgdGhlIGppdHRlciBidWZmZXIgZHVyYXRpb24gaGlnaCB0byByZWR1Y2UgdGhlIHBvc3NpYmlsaXR5IG9mIGF1ZGlvIGRyb3BvdXRzIGF0IHRoZSBjb3N0XG4gICAqIG9mIHBvdGVudGlhbGx5IGhpZ2hlciByb3VuZC10cmlwIGF1ZGlvIGxhdGVuY3kgb24gcG9vciBjb25uZWN0aW9ucy5cbiAgICovXG4gIGF1ZGlvTWF4Sml0dGVyQnVmZmVyRHVyYXRpb24/OiBudW1iZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIGEgdXNlciB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCAob3Igc2VydmVyLXByb3ZpZGVkKVxuICogU1RVTiBhbmQgVFVSTiBjb25maWd1cmF0aW9uIHRoYXQgaXMgb2ZmZXJlZCBieSB0aGUgY2xpZW50LiBOb3RlIHRoYXQgaWYgYSBjdXN0b20gc3R1biBhbmQgdHVybiBjb25maWd1cmF0aW9uIGlzXG4gKiB1c2VkLCBhbGwgb2YgaXRzIHZhbHVlcyBtdXN0IGJlIHByb3ZpZGVkIVxuICogKFNldHRpbmcgdGhlc2UgdmFsdWVzIGRvZXMgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB3aGF0IHRoZSBzZXJ2ZXIgb2ZmZXJzIGZvciBpdHMgc3R1biBhbmQgdHVybiBjb25maWd1cmF0aW9uO1xuICogaG93ZXZlciwgdGhlIHNlcnZlcnMgYXJlIGdlbmVyYWxseSBleHBlY3RlZCB0byBiZSBjb25maWd1cmVkIHNvIGFzIHRvIGJlIGVhc2lseSByZWFjaGFibGUgd2l0aG91dCB0aGUgbmVlZCBmb3IgVFVSTlxuICogb3IgdGhyb3VnaCB0aGUgdXNlIG9mIHRoZSBzdGFuZGFyZCBUVVJOIHNlcnZlcnMuKVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBTVFVOIHNlcnZlciBVUkxzIHRvIHVzZS4gVGhpcyBzaG91bGQgYmUgYSBsaXN0IG9mIHN0cmluZ3MsIGVhY2ggb2Ygd2hpY2ggaXMgaW4gdGhlXG4gICAqIGZvcm1hdCBcInN0dW46eC55LnpcIiBvciBcInN0dW46eC55Lno6cG9ydFwiLiBGb3IgaW5zdGFuY2U6XG4gICAqXG4gICAqIFsgXCJzdHVuOmZvby5iYXIuY29tOjE5MzAyXCIsIFwic3R1bjpiYXIuYmF6LmNvbVwiIF1cbiAgICovXG4gICBzdHVuVXJsczogc3RyaW5nW107XG4gICAvKipcbiAgICAqIEEgbGlzdCBvZiBUVVJOIHNlcnZlciBVUkxzIHRvIHVzZS4gVGhpcyBzaG91bGQgYmUgYSBsaXN0IG9mIHN0cmluZ3MsIGVhY2ggb2Ygd2hpY2ggaXMgaW4gdGhlXG4gICAgKiBmb3JtYXQgXCJ0dXJuOngueS56XCIgb3IgXCJ0dXJuOngueS56OnBvcnRcIi4gRm9yIGluc3RhbmNlOlxuICAgICpcbiAgICAqIFsgXCJ0dXJuOmZvby5iYXIuY29tOjM0NzhcIiwgXCJ0dXJuOmJhci5iYXouY29tXCIgXVxuICAgICpcbiAgICAqL1xuICAgdHVyblVybHM6IHN0cmluZ1tdO1xuICAgLyoqXG4gICAgKiBBIFRVUk4gdXNlcm5hbWUgdG8gdXNlIHdoZW4gY29ubmVjdGluZyB0byB0aGUgc3BlY2lmaWVkIFRVUk4gc2VydmVyKHMpLlxuICAgICovXG4gICB0dXJuVXNlcm5hbWU6IHN0cmluZztcbiAgIC8qKlxuICAgICogQSBUVVJOIGNyZWRlbnRpYWwgKHBhc3N3b3JkKSB0byB1c2Ugd2hlbiBjb25uZWN0aW5nIHRvIHRoZSBzcGVjaWZpZWQgVFVSTiBzZXJ2ZXIocykuXG4gICAgKi9cbiAgIHR1cm5DcmVkZW50aWFsOiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogRW51bSBmb3IgcmVwcmVzZW50aW5nIGRpZmZlcmVudCBwb3NzaWJsZSBzdGF0ZXNcbiAqIHRoYXQgYSBSQVZJIHNlc3Npb24gbWlnaHQgYmUgaW4uXG4gKiBcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGVudW0gUmF2aVNlc3Npb25TdGF0ZXMge1xuICBORVcgPSBcIm5ld1wiLFxuICBDT05ORUNUSU5HID0gXCJjaGVja2luZ1wiLFxuICBDT05ORUNURUQgPSBcImNvbm5lY3RlZFwiLFxuICBDT01QTEVURUQgPSBcImNvbXBsZXRlZFwiLFxuICBESVNDT05ORUNURUQgPSBcImRpc2Nvbm5lY3RlZFwiLFxuICBGQUlMRUQgPSBcImZhaWxlZFwiLFxuICBDTE9TRUQgPSBcImNsb3NlZFwiXG59O1xuXG4vKiogXG4gKiBAaW50ZXJuYWxcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgY29tbXVuaWNhdGlvbnMgc2Vzc2lvbiBiZXR3ZWVuIGEgUkFWSSBKUyBjbGllbnQgYW5kIGEgUkFWSSBzZXJ2ZXIuXG4gKiBUaGlzIGNsYXNzIHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgYnkgdGhlIFJBVkkgY29uc3VtZXIsIGFuZCB0aGVuIHVzZWQgdG8gb3Blbiwgd29yayB3aXRoLCBhbmQgY2xvc2UgXG4gKiBSQVZJIHNlc3Npb25zIGFzIG5lZWRlZC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBSYXZpU2Vzc2lvbiB7XG4gIC8qKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKlxuICAgKiB0aGlzLl91dWlkICAgICAgICAgICAgICAgICAvLyBBIFVVSUQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcGFydGljdWxhciBSYXZpU2Vzc2lvblxuICAgKiB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzICAvLyBBIGxpc3Qgb2YgaGFuZGxlcnMgdG8gY2FsbCB3aGVuIHNvbWV0aGluZyAoZS5nLiBzdGF0ZSksIFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMsIGluY2x1ZGluZyB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZFxuICAgKlxuICAgKiB0aGlzLl9yYXZpSW1wbGVtZW50YXRpb24gICAvLyBUaGUgaW1wbGVtZW50YXRpb24gb2YgZXhhY3RseSBob3cgdG8gaW1wbGVtZW50IHRoZSBSQVZJIGNvbm5lY3Rpb24gKGUuZy4gd2l0aCBXZWJSVEMpXG4gICAqIHRoaXMuX2NvbW1hbmRDb250cm9sbGVyXG4gICAqIHRoaXMuX3N0cmVhbUNvbnRyb2xsZXJcbiAgICpcbiAgICogdGhpcy5fc3RhdGUgICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgY29ubmVjdGlvblxuICAgKlxuICAgKiBfcmVzb2x2ZU9wZW4sIF9yZWplY3RPcGVuLCBfcmVzb2x2ZUNsb3NlLCBhbmQgX3JlamVjdENsb3NlOiBVc2VkIGZvciByZXNvbHZpbmcgdGhlIFByb21pc2VzXG4gICAqICAgICBtYWRlIGJ5IHRoZSBvcGVuIGFuZCBjbG9zZSBmdW5jdGlvbnMsIHdoaWNoIGdldCBoYW5kbGVkIG91dHNpZGUgb2YgdGhvc2UgZnVuY3Rpb25zIHRoZW1zZWx2ZXNcbiAgICovXG4gIF9zdGF0ZUNoYW5nZUhhbmRsZXJzOiBTZXQ8RnVuY3Rpb24+O1xuICBfdXVpZDogc3RyaW5nO1xuXG4gIF9jb21tYW5kQ29udHJvbGxlcjogUmF2aUNvbW1hbmRDb250cm9sbGVyO1xuICBfc3RyZWFtQ29udHJvbGxlcjogUmF2aVN0cmVhbUNvbnRyb2xsZXI7XG5cbiAgX3N0YXRlOiBSYXZpU2Vzc2lvblN0YXRlcztcblxuICBfcmF2aUltcGxlbWVudGF0aW9uOiBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb247XG5cbiAgX3Jlc29sdmVPcGVuOiBGdW5jdGlvbjsgX3JlamVjdE9wZW46IEZ1bmN0aW9uO1xuICBfcmVzb2x2ZUNsb3NlOiBGdW5jdGlvbjsgX3JlamVjdENsb3NlOiBGdW5jdGlvbjtcbiAgXG4gIF9vcGVuaW5nVGltZW91dDogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSYXZpU2Vzc2lvbi5cbiAgICogRGVmYXVsdHMgdG8gdXNpbmcgbmV3IFJhdmlDb21tYW5kQ29udHJvbGxlciBhbmQgUmF2aVN0cmVhbUNvbnRyb2xsZXJzXG4gICAqIGFuZCBpbml0aWFsaXplcyB0aGUgc3RhdGUgdG8gUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VELlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIEluaXRpYWxpemUgdGhlIGxpc3Qgb2YgaGFuZGxlcnMgYW5kIHRoZSBVVUlEXG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl91dWlkID0gUmF2aVV0aWxzLmNyZWF0ZVVVSUQoKTtcbiAgICBcbiAgICAvLyBBbmQgdGhlIGNvbW1hbmQgY29udHJvbGxlciBhbmQgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICB0aGlzLl9jb21tYW5kQ29udHJvbGxlciA9IG5ldyBSYXZpQ29tbWFuZENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyID0gbmV3IFJhdmlTdHJlYW1Db250cm9sbGVyKHRoaXMuX2NvbW1hbmRDb250cm9sbGVyKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuICAgIHRoaXMuX3N0YXRlID0gUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VEO1xuICAgIFxuICAgIC8vIElmIHdlIHdhbnRlZCB0byB1c2UgYSBkaWZmZXJlbnQgY29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbixcbiAgICAvLyB3ZSB3b3VsZCBuZXcoKSBpdCBoZXJlLiAoVE9ETzogTWFrZSB0aGlzIGNvbmZpZ3VyYWJsZSBpbiBzb21lXG4gICAgLy8gaW50ZXJlc3Rpbmcgd2F5LiBGb3Igbm93LCBpdCdzIGVub3VnaCBqdXN0IHRvIG1ha2UgaXQgZWFzaWx5IFxuICAgIC8vIHN3YXBwYWJsZSBpbiB0aGUgY29kZSBoZXJlLilcbiAgICB0aGlzLl9yYXZpSW1wbGVtZW50YXRpb24gPSBuZXcgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uKHRoaXMpO1xuICAgIC8vIFdoZW4gc29tZW9uZSBzZXRzIGFuIGlucHV0IGF1ZGlvIHN0cmVhbSBvbiB0aGUgc3RyZWFtIGNvbnRyb2xsZXIsXG4gICAgLy8gcGFzcyB0aGF0IGFsb25nIHRvIHRoZSBpbXBsZW1lbnRhdGlvbidzIF9hZGRBdWRpb0lucHV0U3RyZWFtIG1ldGhvZC5cbiAgICBjb25zdCByYXZpSW1wbCA9IHRoaXMuX3JhdmlJbXBsZW1lbnRhdGlvbjtcbiAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyLnNldElucHV0QXVkaW9DaGFuZ2VIYW5kbGVyKHJhdmlJbXBsLl9hZGRBdWRpb0lucHV0U3RyZWFtLmJpbmQocmF2aUltcGwpKTtcbiAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyLnNldElucHV0VmlkZW9DaGFuZ2VIYW5kbGVyKHJhdmlJbXBsLl9hZGRWaWRlb0lucHV0U3RyZWFtLmJpbmQocmF2aUltcGwpKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgUkFWSSBzZXNzaW9uLlxuICAgKiBcbiAgICogQHJldHVybnMge1JhdmlTZXNzaW9uU3RhdGVzfVxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgVVVJRCBvZiB0aGUgc2Vzc2lvblxuICAgKiBcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldFVVSUQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3V1aWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGxpc3RlbmluZyB0byBzdGF0ZSBjaGFuZ2VzXG4gICAqIEBjYWxsYmFjayBSYXZpU2Vzc2lvbn5zdGF0ZUNoYW5nZUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBBbiBvYmplY3QgdGhhdCB3aWxsIGNvbnRhaW4gaW5mb3JtYXRpb25cbiAgICogYWJvdXQgdGhlIHN0YXRlIGNoYW5nZS4gVGhpcyBpbmNsdWRlcyB0aGUgXCJldmVudC5zdGF0ZVwiIGtleSxcbiAgICogd2hpY2ggd2lsbCBoYXZlIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZSBmcm9tIHRoZSBSYXZpU2Vzc2lvblN0YXRlcyBlbnVtLlxuICAgKi9cbiAgLyoqXG4gICAqIEFkZCBhIGhhbmRsZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBzdGF0ZVxuICAgKiBjaGFuZ2UgZXZlbnRzLlxuICAgKiBUaGVzZSBhcmUgc3RvcmVkIGluIGEgU2V0IG9mIEZ1bmN0aW9uczsgdGhlcmVmb3JlLCBhIGdpdmVuIGZ1bmN0aW9uXG4gICAqIGNhbiBvbmx5IGV4aXN0IG9uY2UgaW4gdGhpcyBTZXQuXG4gICAqIFxuICAgKiBAcGFyYW0ge1JhdmlTZXNzaW9ufnN0YXRlQ2hhbmdlQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGFkZCBzdWNjZWVkZWRcbiAgICovXG4gIGFkZFN0YXRlQ2hhbmdlSGFuZGxlcihjaGFuZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzLmFkZChjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIGFkZGluZyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyOiBcIiArXG4gICAgICAgIGVyci5tZXNzYWdlLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgaGFuZGxlciBzbyB0aGF0IGl0IHN0b3BzIGxpc3RlbmluZyBmb3Igc3RhdGVcbiAgICogY2hhbmdlIGV2ZW50cy5cbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aVNlc3Npb25+c3RhdGVDaGFuZ2VDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBoYXMgYmVlbiBoYW5kbGluZyBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHJlbW92YWwgd2FzIHN1Y2Nlc3NmdWwgKGkuZS4gZGlkIG5vdCB0aHJvdyBhbiBlcnJvciAtLSBub3RlIHRoYXQgdGhpcyBkb2VzXG4gICAqIE5PVCBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciB3YXMgaW4gdGhlIHNldCBpbiB0aGUgZmlyc3QgcGxhY2UpXG4gICAqL1xuICByZW1vdmVTdGF0ZUNoYW5nZUhhbmRsZXIoY2hhbmdlSGFuZGxlcjogRnVuY3Rpb24pIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycy5kZWxldGUoY2hhbmdlSGFuZGxlcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIFJhdmlVdGlscy5lcnIoXCJFcnJvciByZW1vdmluZyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyOiBcIiArXG4gICAgICAgIGVyci5tZXNzYWdlLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgdGhlIFJhdmlDb21tYW5kQ29udHJvbGxlciBmb3IgdXNlIHdpdGggdGhpcyBSYXZpU2Vzc2lvbi5cbiAgICogVGhlIHtsaW5rIFJhdmlDb21tYW5kQ29udHJvbGxlcn0gaXMgdXNlZCB0byBzZW5kIGNvbW1hbmRzIGFuZCBpbnB1dCB0byB0aGUgUkFWSSBzZXJ2ZXIuXG4gICAqIFxuICAgKiBAcmV0dXJucyB7UmF2aUNvbW1hbmRDb250cm9sbGVyfVxuICAgKi9cbiAgZ2V0Q29tbWFuZENvbnRyb2xsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRDb250cm9sbGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgUmF2aVN0cmVhbUNvbnRyb2xsZXIgZm9yIHVzZSB3aXRoIHRoaXMgUmF2aVNlc3Npb24uXG4gICAqIFRoZSB7bGluayBSYXZpU3RyZWFtQ29udHJvbGxlcn0gaXMgdXNlZCB0byBzZW5kIGNvbW1hbmRzIGFuZCBpbnB1dCB0byB0aGUgUkFWSSBzZXJ2ZXIuXG4gICAqIFxuICAgKiBAcmV0dXJucyB7UmF2aVN0cmVhbUNvbnRyb2xsZXJ9XG4gICAqL1xuICBnZXRTdHJlYW1Db250cm9sbGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW1Db250cm9sbGVyO1xuICB9XG4gIFxuICAvKipcbiAgICogT3BlbiBhIFJBVkkgY29ubmVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24uIFJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgd2lsbCByZXNvbHZlIHdpdGggdGhlIGNvbm5lY3RlZCBzdGF0ZSBvbmNlIHRoZSBSYXZpU2Vzc2lvbiBpcyBjb25uZWN0ZWQuXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gX19uYW1lZFBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHNpZ25hbGluZ0Nvbm5lY3Rpb25cbiAgICogQHBhcmFtIHRpbWVvdXQgQSB0aW1vdXQgaW4gbXMgYWZ0ZXIgd2hpY2ggdG8gdGltZW91dCB0aGUgYXR0ZW1wdCB0byBjb25uZWN0LiBEZWZhdWx0cyB0byA1MDAwICg1IHNlY29uZHMpLlxuICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGFwcGxpZWQgdG8gdGhlIHNlcnZlciBzaWRlIG9mIHRoZSBzZXNzaW9uLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLFxuICAgKiBtZWFuaW5nIHRoYXQgd2UnbGwgcmVseSBvbiB0aGUgZGVmYXVsdCB2YWx1ZXMgYXMgZGVmaW5lZCBvbiB0aGUgc2VydmVyLlxuICAgKiAgICAgICAgICAgIFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIG9wZW5SQVZJU2Vzc2lvbih7c2lnbmFsaW5nQ29ubmVjdGlvbiwgdGltZW91dCA9IDUwMDAsIHBhcmFtcyA9IG51bGwsIGN1c3RvbVN0dW5BbmRUdXJuID0gbnVsbH06IHsgc2lnbmFsaW5nQ29ubmVjdGlvbjogUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24sIHRpbWVvdXQ/OiBudW1iZXIsIHBhcmFtcz86IFdlYlJUQ1Nlc3Npb25QYXJhbXMsIGN1c3RvbVN0dW5BbmRUdXJuPzogQ3VzdG9tU1RVTmFuZFRVUk5Db25maWd9KSB7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFJhdmlTZXNzaW9uU3RhdGVzLkNPTk5FQ1RFRCB8fCB0aGlzLl9zdGF0ZSA9PT0gUmF2aVNlc3Npb25TdGF0ZXMuQ09NUExFVEVEKSB7XG4gICAgICAgIC8vIFJlZi4gaWNlY29ubmVjdGlvbnN0YXRlcyBhdCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDUGVlckNvbm5lY3Rpb24vaWNlQ29ubmVjdGlvblN0YXRlXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgICBcIlRoZXJlIGlzIGFscmVhZHkgYW4gb3BlbiBSQVZJIHNlc3Npb24uIFRvIHJlY29ubmVjdCwgZmlyc3QgY2xvc2UgdGhlIGV4aXN0aW5nIGNvbm5lY3Rpb24sIGFuZCB0aGVuIGF0dGVtcHQgdG8gb3BlbiBhZ2Fpbi5cIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXZpU2Vzc2lvbiA9IHRoaXM7XG4gICAgLy8gVGVsbCBvdXIgY29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbiBhYm91dCB0aGlzIHNpZ25hbGluZyBjb25uZWN0aW9uIC0tXG4gICAgLy8gaXQgbWF5IG5lZWQgdG8gdGFsayB0byBpdCBkaXJlY3RseSB3aGlsZSBpdCdzIGF0dGVtcHRpbmcgdG8gbmVnb3RpYXRlXG4gICAgLy8gdGhlIGNvbm5lY3Rpb24uXG4gICAgdGhpcy5fcmF2aUltcGxlbWVudGF0aW9uLl9hc3NpZ25TaWduYWxpbmdDb25uZWN0aW9uKHNpZ25hbGluZ0Nvbm5lY3Rpb24pO1xuXG4gICAgLy8gU2V0IGEgdGltZW91dCBpbiBjYXNlIHRoZSBzZXNzaW9uIGdldHMgaHVuZyB1cCBzb21ld2hlcmVcbiAgICB0aGlzLl9vcGVuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJSYXZpU2Vzc2lvbi5vcGVuIHRpbWVkIG91dCBhZnRlciBcIiArIHRpbWVvdXQgKyBcIiBtc1wiO1xuICAgICAgICBSYXZpVXRpbHMubG9nKGVycm9yTWVzc2FnZSwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgICAgcmF2aVNlc3Npb24uX2Z1bGZpbGxQcm9taXNlcyh7IG1lc3NhZ2U6IGVycm9yTWVzc2FnZSB9LCBSYXZpU2Vzc2lvblN0YXRlcy5GQUlMRUQpO1xuICAgICAgICAvLyBDbG9zZSB0aGUgc2Vzc2lvbiB0byBjbGVhbiB1cCBvYmplY3RzLiBXZSd2ZSBhbHJlYWR5IHJlamVjdGVkIHRoZSBwcm9taXNlIGFib3ZlLlxuICAgICAgICByYXZpU2Vzc2lvbi5jbG9zZVJBVklTZXNzaW9uKCk7XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmF2aVNlc3Npb24uX3Jlc29sdmVPcGVuID0gcmVzb2x2ZTtcbiAgICAgIHJhdmlTZXNzaW9uLl9yZWplY3RPcGVuID0gcmVqZWN0O1xuXG4gICAgICAvLyBTdGFydCB0aGUgXCJvcGVuaW5nXCIgcHJvY2Vzc1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIk9wZW5pbmcgUkFWSSBzZXNzaW9uXCIsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgICB0aGlzLl9zdGF0ZSA9IFJhdmlTZXNzaW9uU3RhdGVzLk5FVztcbiAgICAgIHJhdmlTZXNzaW9uLl9yYXZpSW1wbGVtZW50YXRpb24uX29wZW4ocGFyYW1zLCBjdXN0b21TdHVuQW5kVHVybik7XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDbG9zZSBhIFJBVkkgY29ubmVjdGlvbiwgaW5jbHVkaW5nIHNodXR0aW5nIGRvd24gdGhlIFxuICAgKiByZWxldmFudCBSYXZpU3RyZWFtQ29udHJvbGxlciBhbmQgUmF2aUNvbW1hbmRDb250cm9sbGVyLiBSZXR1cm5zIGEgUHJvbWlzZVxuICAgKiB0aGF0IHdpbGwgcmVzb2x2ZSB3aXRoIHRoZSBjbG9zZWQgc3RhdGUgb25jZSB0aGUgUmF2aVNlc3Npb24gaXMgY2xvc2VkLlxuICAgKiBcbiAgICogQHBhcmFtIHtSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbn0gc2lnbmFsaW5nQ29ubmVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGNsb3NlUkFWSVNlc3Npb24oKSB7XG4gICAgdmFyIHJhdmlTZXNzaW9uID0gdGhpcztcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFJhdmlTZXNzaW9uU3RhdGVzLkNMT1NFRCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgXCJSQVZJIHNlc3Npb24gaXMgYWxyZWFkeSBjbG9zZWQuXCJcbiAgICApO1xuICAgXG4gICAgLy8gU3RhcnQgYnkgY2xvc2luZyBvdXQgY29tbWFuZCBjb250cm9sbGVyXG4gICAgLy8gYW5kIHRoZSBzdHJlYW0gY29udHJvbGxlci5cbiAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyLl9zdG9wKCk7XG4gICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIuc3RvcE1vbml0b3JpbmdRdWV1ZXMoKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByYXZpU2Vzc2lvbi5fcmVzb2x2ZUNsb3NlID0gcmVzb2x2ZTtcbiAgICAgIHJhdmlTZXNzaW9uLl9yZWplY3RDbG9zZSA9IHJlamVjdDtcblxuICAgICAgUmF2aVV0aWxzLmxvZyhcIkNsb3NpbmcgUkFWSSBzZXNzaW9uXCIsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgICByYXZpU2Vzc2lvbi5fcmF2aUltcGxlbWVudGF0aW9uLl9jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBHZXRzIGNhbGxlZCB3aGVuZXZlciB0aGUgc3RhdGUgY2hhbmdlcyAoYW5kIHNvbWV0aW1lcyB3aGVuIGl0IGRvZXNuJ3QsXG4gICAqIGJ1dCB3aGVuIHdlIGp1c3Qgd2FudCB0byBtYWtlIHN1cmUpLiBEZXBlbmRpbmcgb24gdGhlIG5ldyAob3IgY3VycmVudCkgc3RhdGUsXG4gICAqIHRoaXMgd2lsbCBhcHByb3ByaWF0ZWx5IGZ1bGZpbGwgb3V0c3RhbmRpbmcgcHJvbWlzZXMgdGhhdCBhcmUgcGVuZGluZ1xuICAgKiBpbiBlaXRoZXIgdGhlIG9wZW4gb3IgY2xvc2UgbWV0aG9kIChvciBib3RoKS5cbiAgICovXG4gIF9mdWxmaWxsUHJvbWlzZXMoZXZlbnQ6IGFueSA9IHt9LCBzdGF0ZTogUmF2aVNlc3Npb25TdGF0ZXMpIHtcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gZXZlbnQucmVhc29uIHx8IGV2ZW50Lm1lc3NhZ2UgfHwgc3RhdGU7XG4gICAgc3dpdGNoKHN0YXRlKSB7XG4gICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkNPTk5FQ1RFRDpcbiAgICAgIGNhc2UgUmF2aVNlc3Npb25TdGF0ZXMuQ09NUExFVEVEOlxuICAgICAgICBpZiAodGhpcy5fb3BlbmluZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9vcGVuaW5nVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl9vcGVuaW5nVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVPcGVuKSB0aGlzLl9yZXNvbHZlT3BlbigpO1xuICAgICAgICBpZiAodGhpcy5fcmVqZWN0Q2xvc2UpIHRoaXMuX3JlamVjdENsb3NlKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2Vzc2lvblN0YXRlcy5ESVNDT05ORUNURUQ6XG4gICAgICAgIC8vIE5PVEU6IFBlciBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDUGVlckNvbm5lY3Rpb24jUlRDSWNlQ29ubmVjdGlvblN0YXRlX2VudW1cbiAgICAgICAgLy8gXCJkaXNjb25uZWN0ZWRcIiBpcyBhIHBvdGVudGlhbGx5IHRyYW5zaWVudCBzdGF0ZSwgc28gaW4gdGhpcyBjYXNlIHdlIHdpbGwgc2ltcGx5IHdhaXQgdW50aWwgd2VcbiAgICAgICAgLy8gZ2V0IHRvIGNvbm5lY3RlZCwgY29tcGxldGUsIG9yIGZhaWxlZC5cbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIl9mdWxmaWxsUHJvbWlzZXM6IFBvc3NpYmxlIHRyYW5zaXRvcnkgc3RhdGUgRElTQ09OTkVDVEVEOyBsZWF2aW5nIHByb21pc2VzIHBlbmRpbmdcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkZBSUxFRDpcbiAgICAgICAgaWYgKHRoaXMuX29wZW5pbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb3BlbmluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5fb3BlbmluZ1RpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZWplY3RPcGVuKSB0aGlzLl9yZWplY3RPcGVuKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGlmICh0aGlzLl9yZWplY3RDbG9zZSkgdGhpcy5fcmVqZWN0Q2xvc2UoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgLy8gRXhwbGljaXRseSBjYWxsIHRoZSBpbXBsZW1lbnRhdGlvbidzIFwiY2xvc2VcIiBtZXRob2QgdG8gbWFrZVxuICAgICAgICAvLyByZWFsbHksIHJlYWxseSBzdXJlIGl0J3MgY2xvc2VkIGluIGFkZGl0aW9uIHRvIGJlaW5nIFwiZmFpbGVkXCIuXG4gICAgICAgIC8vIFRoZXNlIGFyZSBOT1QgdGhlIHNhbWUgc3RhdGUhIEEgXCJmYWlsZWRcIiBjb25uZWN0aW9uIG1heSBzdGlsbCBiZVxuICAgICAgICAvLyBhd2FyZSBvZiBpdHMgc2lnbmFsaW5nIGNvbm5lY3Rpb24gYW5kIG90aGVyIG5pY2V0aWVzLlxuICAgICAgICAvLyBLaWNrIG9mZiB0aGF0IGNsb3NlIGluIGEgdGltZW91dCB0byBnZXQgaXQgdG8gcnVuIGFzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGZyb20gdGhlIFByb21pc2UgcmVqZWN0aW9uLlxuICAgICAgICBsZXQgcmF2aVNlc3Npb24gPSB0aGlzO1xuICAgICAgICBjb25zdCBjbG9zZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByYXZpU2Vzc2lvbi5fcmF2aUltcGxlbWVudGF0aW9uLl9jbG9zZSgpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkNMT1NFRDpcbiAgICAgICAgaWYgKHRoaXMuX29wZW5pbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb3BlbmluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5fb3BlbmluZ1RpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZWplY3RPcGVuKSB0aGlzLl9yZWplY3RPcGVuKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGlmICh0aGlzLl9yZXNvbHZlQ2xvc2UpIHRoaXMuX3Jlc29sdmVDbG9zZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERvIG5vdGhpbmcgZm9yIHRoZSBcImluIHByb2dyZXNzXCIgc3RhdGVzLCBsaWtlIFwiTkVXXCIgb3IgXCJDT05ORUNUSU5HXCJcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIl9mdWxmaWxsUHJvbWlzZXM6IFNraXBwaW5nIGluLXByb2dyZXNzIHN0YXRlIFwiICsgc3RhdGUsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgfVxuICB9XG4gIFxuICBcbiAgXG4gIC8qKlxuICAgKiBIYW5kbGVyIGZvciB3aGVuZXZlciBhIG5ldyBcInRyYWNrIGNoYW5uZWxcIiBzaG93cyB1cC4gKFdoZW4gdGhpcyBldmVudCBoYXBwZW5zXG4gICAqIHNob3VsZCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiwgYW5kIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0cmFjayBzaG91bGQgYmUgXG4gICAqIHN0b3JlZCBpbiB0aGUgcGFzc2VkIGV2ZW50IG9iamVjdC4pXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9PbnRyYWNrKGV2ZW50OiBhbnkpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGNvZGUgaXMgd29ya2luZyBpZiB3ZSBoYXZlIG9ubHkgb25lIG1lZGlhIHRyYWNrICh2aWRlbyBPUiBhdWRpbyksIG5vdCBzdXJlIGl0IHdvcmtzIHdpdGggbW9yZVxuICAgIC8vIE5lZWQgdG8gbWFrZSBpdCBtb3JlIHJvYnVzdCB3aXRoIGRpZmZlcmVudCBicmFuY2hlcyBiYXNlZCBvbiB0aGUgZXZlbnQgaW5mb1xuICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCBuZXcgdHJhY2s6IFwiLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgIFJhdmlVdGlscy5sb2coZXZlbnQsIFwiUmF2aVNlc3Npb25cIik7XG5cbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQudHJhY2sgJiYgZXZlbnQudHJhY2sua2luZCA9PT0gXCJ2aWRlb1wiKSB7IFxuICAgICAgUmF2aVV0aWxzLmxvZyhcIkFkZGluZyByZW1vdGUgdmlkZW8gdHJhY2sgdG8gc3RyZWFtIGNvbnRyb2xsZXJcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgIHRoaXMuX3N0cmVhbUNvbnRyb2xsZXIuX3NldFZpZGVvU3RyZWFtKGV2ZW50LnN0cmVhbXNbMF0pO1xuICAgICAgdGhpcy5fc3RyZWFtQ29udHJvbGxlci5fb25WaWRlb1N0cmVhbVN0YXRlQ2hhbmdlZChcInJlYWR5XCIpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQudHJhY2sgJiYgZXZlbnQudHJhY2sua2luZCA9PT0gXCJhdWRpb1wiKSB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiQWRkaW5nIHJlbW90ZSBhdWRpbyB0cmFjayB0byBzdHJlYW0gY29udHJvbGxlclwiLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgICAgdGhpcy5fc3RyZWFtQ29udHJvbGxlci5fc2V0QXVkaW9TdHJlYW0oZXZlbnQuc3RyZWFtc1swXSk7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogSGFuZGxlciBmb3Igd2hlbmV2ZXIgYSBuZXcgXCJkYXRhIGNoYW5uZWxcIiBzaG93cyB1cC4gKFdoZW4gdGhpcyBldmVudCBoYXBwZW5zIHNob3VsZCBiZSBkZXRlcm1pbmVkXG4gICAqIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiwgYW5kIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGFubmVsIHNob3VsZCBiZSBzdG9yZWQgaW4gdGhlIHBhc3NlZCBldmVudCBvYmplY3QuKVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RvT25kYXRhY2hhbm5lbChldmVudDogYW55KSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIlJlY2VpdmVkIG5ldyBjaGFubmVsOiBcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICBSYXZpVXRpbHMubG9nKGV2ZW50LCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgIFxuICAgIHN3aXRjaCAoZXZlbnQuY2hhbm5lbC5sYWJlbCkge1xuICAgICAgY2FzZSBcInJhdmkuaW5wdXRcIjpcbiAgICAgICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIuX3NldElucHV0RGF0YUNoYW5uZWwoZXZlbnQuY2hhbm5lbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJhdmkuY29tbWFuZFwiOlxuICAgICAgICB0aGlzLl9jb21tYW5kQ29udHJvbGxlci5fc2V0Q29tbWFuZERhdGFDaGFubmVsKGV2ZW50LmNoYW5uZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCB1bmtub3duIGRhdGEgY2hhbm5lbCBuYW1lZCBcIiArIGV2ZW50LmNoYW5uZWwubGFiZWwsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBcbiAgICogR2VuZXJpYyBoYW5kbGVyIFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50OiBhbnkgPSB7fSwgc3RhdGU6IFJhdmlTZXNzaW9uU3RhdGVzKSB7XG4gICAgZXZlbnRbXCJzdGF0ZVwiXSA9IHN0YXRlO1xuXG4gICAgLy8gQWx3YXlzIHRyeSB0byBmdWxmaWxsIGFueSBvcGVuIHByb21pc2VzLCBldmVuIGlmIHRoZSBzdGF0ZSBoYXNuJ3QgY2hhbmdlZFxuICAgIHRoaXMuX2Z1bGZpbGxQcm9taXNlcyhldmVudCwgc3RhdGUpO1xuXG4gICAgLy8gQnV0IG9ubHkgY2FsbCBoYW5kbGVycyBpZiB0aGUgc3RhdGUgZGlkLCBpbiBmYWN0LCBjaGFuZ2VcbiAgICBpZiAoc3RhdGUgIT09IHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIGV2ZW50W1wic3RhdGVcIl0gPSBzdGF0ZTtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIl9oYW5kbGVTdGF0ZUNoYW5nZTogXCIgKyBSYXZpVXRpbHMuc2FmZWx5UHJpbnRhYmxlKGV2ZW50KSwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBsaXN0ZW5pbmcgdG8gc3RhdHNcbiAgICogQGNhbGxiYWNrIFJhdmlTZXNzaW9ufnN0YXRzT2JzZXJ2ZXJDYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdHMgQW4gb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIGluZm9ybWF0aW9uXG4gICAqIGFib3V0IHRoZSBzdGF0cyByZWNvcmRlZFxuICAgKi9cbiAgLyoqXG4gICAqIEFkZCBhIGhhbmRsZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBuZXcgc3RhdHMgZ2VuZXJhdGVkLlxuICAgKiBUaGVzZSBhcmUgc3RvcmVkIGluIGEgU2V0IG9mIEZ1bmN0aW9uczsgdGhlcmVmb3JlLCBhIGdpdmVuIGZ1bmN0aW9uXG4gICAqIGNhbiBvbmx5IGV4aXN0IG9uY2UgaW4gdGhpcyBTZXQuXG4gICAqIFxuICAgKiBAcGFyYW0ge1JhdmlTZXNzaW9ufnN0YXRzT2JzZXJ2ZXJDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBzaG91bGQgaGFuZGxlIGEgc3RhdGUgY2hhbmdlIGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYWRkIHN1Y2NlZWRlZFxuICAgKi9cbiAgYWRkU3RhdHNPYnNlcnZlcihvYnNlcnZlcjogRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fcmF2aUltcGxlbWVudGF0aW9uLl9hZGRTdGF0c09ic2VydmVyKG9ic2VydmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBoYW5kbGVyIHNvIHRoYXQgaXQgc3RvcHMgbGlzdGVuaW5nIGZvciBzdGF0cyB1cGRhdGVzLlxuICAgKiBcbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn5zdGF0c09ic2VydmVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHJlbW92YWwgd2FzIHN1Y2Nlc3NmdWwgKGkuZS4gZGlkIG5vdCB0aHJvdyBhbiBlcnJvciAtLSBub3RlIHRoYXQgdGhpcyBkb2VzXG4gICAqIE5PVCBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciB3YXMgaW4gdGhlIHNldCBpbiB0aGUgZmlyc3QgcGxhY2UpXG4gICAqL1xuICByZW1vdmVTdGF0c09ic2VydmVyKG9ic2VydmVyOiBGdW5jdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9yYXZpSW1wbGVtZW50YXRpb24uX3JlbW92ZVN0YXRzT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICB9XG4gIFxufSAvLyBFbmQgb2YgdGhlIFJhdmlTZXNzaW9uIGNsYXNzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbiAvKipcbiAgKiBAaW50ZXJuYWxcbiAqIENvbnN0YW50cyB1c2VkIGFzIHRoZSBkZWZhdWx0IGZpbHRlciBmb3IgdGhlIHN0YXRzIGNvbGxlY3RlZCBpbiB0aGUgUmF2aVN0YXRzV2F0Y2hlclxuICovXG5leHBvcnQgY29uc3QgU1RBVFNfV0FUQ0hFUl9GSUxURVIgPSBuZXcgTWFwKFtcbiAgW1wicmVtb3RlLWluYm91bmQtcnRwXCIsIFtcImlkXCIsIFwidHlwZVwiLCBcInRpbWVzdGFtcFwiLCBcInJvdW5kVHJpcFRpbWVcIiwgXCJqaXR0ZXJcIl0gXSxcbiAgW1wiaW5ib3VuZC1ydHBcIiwgW1wiaWRcIiwgXCJ0eXBlXCIsIFwidGltZXN0YW1wXCIsIFwiaml0dGVyQnVmZmVyRGVsYXlcIiwgXCJqaXR0ZXJCdWZmZXJFbWl0dGVkQ291bnRcIiwgXCJieXRlc1JlY2VpdmVkXCJdXVxuXSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBTdGF0c1dhdGNoZXIgaXMgdGhlIG9iamVjdCByZXNwb25zaWJsZSBmb3IgY2FsbGluZyBnZXRTdGF0cyBmcm9tIHRoZVxuICogUlRDUGVlckNvbm5lY3Rpb24gYXQgcmVndWxhciBpbnRlcnZhbHMuXG4gKiBUaGUgY2FwdHVyZWQgbWV0cmljcyBhcmUgZmlsdGVyZWQgYW5kIHBhc3NlZCBvbiB0byB0aGUgc3RhdHNPYnNlcnZlcihzKS5cbiAqIFRoZSBmaWx0ZXIgaXMgYSBkaWN0aW9uYXJ5IG9mIHRoZSByZXBvcnQgdHlwZSBhbmQgZmllbGRzLlxuICogQ3VycmVudCBkZWZhdWx0IHZhbHVlIGlzIGRlZmluZWQgaW4gU1RBVFNfV0FUQ0hFUl9GSUxURVIuXG4gKiBTdGF0c09ic2VydmVyIGlzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyAyIHBhcmFtZXRlcnMsIHRoZSBjdXJyZW50IHJlY29yZCBhbmQgdGhlIHByZXZpb3VzIHJlY29yZC5cbiAqIFNldmVyYWwgU3RhdHNPYnNlcnZlciBjYWxsYmFja3MgY2FuIGJlIGFkZGVkL3JlbW92ZWQgYnkgdXNlciBjb2RlIHRocm91Z2ggdGhlIGNvcnJlc3BvbmRpbmcgbWV0aG9kcyBvZiB0aGUgb2JqZWN0LlxuICogdGhlc2UgbWV0aG9kcyBhcmUgZXhwb3NlZCBwdWJsaWNhbGx5IG9uIHRoZSBSYXZpU2Vzc2lvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJhdmlXZWJSVENTdGF0c1dhdGNoZXIge1xuICBfcmF2aUltcGxlbWVudGF0aW9uOiBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb247XG4gIF9vYnNlcnZlcnM6IFNldDxGdW5jdGlvbj47XG4gIF9maWx0ZXI6IE1hcDxzdHJpbmcsIEFycmF5PGFueT4+O1xuICBfaW50ZXJ2YWw6IG51bWJlcjtcbiAgX3ByZXZTdGF0czogQXJyYXk8YW55PjtcblxuICBcbiAgLyoqXG4gICAqIFwiQ2xhc3NcIiB2YXJpYWJsZXMgdG8gYmUgYXdhcmUgb2Y6XG4gICAqIHRoaXMuX29ic2VydmVycyBpcyB0aGUgc2V0IG9mIG9ic2VydmVyIGNhbGxiYWNrcyByZWdpc3RlcmVkIGJ5IHVzZXIgY29kZVxuICAgKiB0aGlzLl9pbnRlcnZhbCBpcyB0aGUgaW50ZXJ2YWwgdGlja2luZyB0aGUgZ2V0U3RhdHMgY2FsbFxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFJhdmlTdGF0c1dhdGNoZXJcbiAgICogQHBhcmFtIHtSYXZpV2ViUlRDSW1wbGVtZW50YXRpb259IHdlYlJUQ0ltcGxlbWVudGF0aW9uIFRoZSBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24gYmVpbmcgd2F0Y2hlZFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdlYlJUQ0ltcGxlbWVudGF0aW9uOiBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24pIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiY29uc3RydWN0b3JcIiwgXCJSYXZpU3RhdHNXYXRjaGVyXCIpO1xuICAgIHRoaXMuX3JhdmlJbXBsZW1lbnRhdGlvbiA9IHdlYlJUQ0ltcGxlbWVudGF0aW9uO1xuICAgIHRoaXMuX29ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9maWx0ZXIgPSBTVEFUU19XQVRDSEVSX0ZJTFRFUjtcbiAgICB0aGlzLl9pbnRlcnZhbCA9IDA7XG4gICAgdGhpcy5fcHJldlN0YXRzID0gW107IFxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSB3YXRjaGVyXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBvYnNlcnZlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG5ldyBzdGF0cyBnZW5lcmF0ZWQuXG4gICAqIFRoZXNlIGFyZSBzdG9yZWQgaW4gYSBTZXQgb2YgRnVuY3Rpb25zOyB0aGVyZWZvcmUsIGEgZ2l2ZW4gZnVuY3Rpb25cbiAgICogY2FuIG9ubHkgZXhpc3Qgb25jZSBpbiB0aGlzIFNldC5cbiAgICogXG4gICAqIHN0YXRzT2JzZXJ2ZXJDYWxsYmFjayBmdW5jdGlvbiByZWNlaXZlcyAyIHBhcmFtZXRlcnMsIHRoZSBjdXJyZW50IHJlY29yZCBhbmQgdGhlIHByZXZpb3VzIHJlY29yZC5cbiAgICogZnVuY3Rpb24obmV3U3RhdHMsIHByZXZTdGF0cylcbiAgICogdGhlIFN0YXRzIHBhcmFtZXRlciBpcyBhbiBBcnJheSBvZiBvYmplY3RzLCBhIGZpbHRlcmVkIGRvd24gdmVyc2lvbiBvZiB0aGUgZGljdGlvbm5hcmllcyByZXR1cm5lZCBieSBcbiAgICogUlRDUGVlckNvbm5lY3Rpb24uZ2V0U3RhdHNcbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aVN0YXRzV2F0Y2hlcn5zdGF0c09ic2VydmVyQ2FsbGJhY2t9IG9ic2VydmVyIEEgY2FsbGJhY2sgd2hpY2ggd2lsbCByZWNlaXZlIHRoZSBzdGF0cyBzYW1wbGVzXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYWRkIHN1Y2NlZWRlZFxuICAgKi9cbiAgYWRkT2JzZXJ2ZXIob2JzZXJ2ZXI6IEZ1bmN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX29ic2VydmVycy5hZGQob2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5fb25PYnNlcnZlckNoYW5nZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKFwiRXJyb3IgYWRkaW5nIGEgc3RhdHMgb2JzZXJ2ZXI6IFwiICtcbiAgICAgICAgZXJyLm1lc3NhZ2UsIFwiUmF2aVN0YXRzV2F0Y2hlclwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBvYnNlcnZlciBzbyB0aGF0IGl0IHN0b3BzIGxpc3RlbmluZyBmb3Igc3RhdHMgdXBkYXRlcy5cbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aVNlc3Npb25+c3RhdHNPYnNlcnZlckNhbGxiYWNrfSBvYnNlcnZlciBBIGNhbGxiYWNrIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgc2V0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcmVtb3ZhbCB3YXMgc3VjY2Vzc2Z1bCAoaS5lLiBkaWQgbm90IHRocm93IGFuIGVycm9yIC0tIG5vdGUgdGhhdCB0aGlzIGRvZXNcbiAgICogTk9UIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIHdhcyBpbiB0aGUgc2V0IGluIHRoZSBmaXJzdCBwbGFjZSlcbiAgICovXG4gIHJlbW92ZU9ic2VydmVyKG9ic2VydmVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9vYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgIHRoaXMuX29uT2JzZXJ2ZXJDaGFuZ2UoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIHJlbW92aW5nIGEgc3RhdHMgb2JzZXJ2ZXIgaGFuZGxlcjogXCIgK1xuICAgICAgICBlcnIubWVzc2FnZSwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgXG4gIC8vIFdoZW5ldmVyIG9ic2VydmVyKHMpIGFyZSBhZGRlZCBvciByZW1vdmUsXG4gIC8vIGxldCdzIG1ha2Ugc3VyZSB0aGUgd2F0Y2hlciBpcyBydW5uaW5nIGlmIHRoZXJlIGlzIGFueSBvYnNlcnZlci5cbiAgLy8gYW5kIGxldCdzIHR1cm4gb2ZmIHRoZSBjb2xsZWN0aW9uIG9mIHN0YXRzIGlmIHRoZSBzZXQgb2Ygb2JzZXJ2ZXJzIGlzIGVtcHR5LlxuICBfb25PYnNlcnZlckNoYW5nZSgpIHtcbiAgICBjb25zdCBJTlRFUlZBTCA9IDEwMDA7XG5cbiAgICB0aGlzLl9wcmV2U3RhdHMgPSBbXTtcbiAgICAvLyBzb21lIG9ic2VydmVycywgdGhlbiBtYWtlIHN1cmUgd2UgcnVuXG4gICAgaWYgKHRoaXMuX29ic2VydmVycy5zaXplID4gMCkge1xuICAgICAgaWYgKCF0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgICBzZXRJbnRlcnZhbChhc3luYyAoaGFuZGxlcjogYW55LCB0aW1lb3V0OiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHRoaXMuX3JhdmlJbXBsZW1lbnRhdGlvbi5fZ2V0U3RhdHMoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBsZXQgZmlsdGVyZWRTdGF0czphbnkgPSBbXTtcbiAgICAgICAgICBpZiAoc3RhdHMpIHtcbiAgICAgICAgICAgIHN0YXRzLmZvckVhY2goKHJlcG9ydDogYW55KSA9PiB7XG4gICAgICAgICAgICAgIC8vIEZpbHRlciBvbiB0aGUgcmVwb3J0IHR5cGVcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbHRlci5oYXMocmVwb3J0LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0ZWQgZmllbGRzIG11c3QgYmUgYSB2YWxpZCBhcnJheSBvZiBmaWVsZHM6XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkRmllbGRzID0gdGhpcy5fZmlsdGVyLmdldChyZXBvcnQudHlwZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gVGhlbiB3aXRoaW4gdGhlIHJlcG9ydCB0eXBlLCBwaWNrIG9uIHRoZSB3YW50ZWQgZmllbGRzXG4gICAgICAgICAgICAgICAgbGV0IGZpbHRlcmVkUmVwb3J0OiBhbnkgPSB7fTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEZpZWxkcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkUmVwb3J0W2tleV0gPSByZXBvcnRba2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZmlsdGVyZWQgcmVwb3J0IGZvdW5kIGluIHRoZSByZXN1bHQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRTdGF0cy5wdXNoKGZpbHRlcmVkUmVwb3J0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFN0YXRzIGhhdmUgYmVlbiBjb2xsZWN0ZWQsIG5vdyBsZXQncyBicm9hZGNhc3RcbiAgICAgICAgICBpZiAoZmlsdGVyZWRTdGF0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVycy5mb3JFYWNoICgob2JzZXJ2ZXIpPT57XG4gICAgICAgICAgICAgIG9ic2VydmVyKGZpbHRlcmVkU3RhdHMsIHRoaXMuX3ByZXZTdGF0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZWNvcmQgdGhlIHByb2R1Y2VkIHN0YXRzIGFzIHRoZSBtb3N0IHJlY2VudCBvbmVcbiAgICAgICAgICB0aGlzLl9wcmV2U3RhdHMgPSBmaWx0ZXJlZFN0YXRzO1xuICAgICAgICB9LCBJTlRFUlZBTCApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyBvYnNlcnZlcnMsIG1ha2Ugc3VyZSB3ZSBhcmUgc3RvcHBlZFxuICAgICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKlxuVE9ETzogQWRkIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYSBSQVZJIFBlZXIgQ29ubmVjdGlvbiBcImNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb25cIlxuY2xhc3Mgc2hvdWxkIGxvb2sgbGlrZS4gU29tZSBpbml0aWFsIG5vdGVzOlxuQ29uc3RydWN0b3I6IFRha2VzIGluIGEgUmF2aVNlc3Npb24gc28gdGhhdCBpdCBjYW4gdXNlIGl0cyBoYW5kbGVycy4gVGhlIGltcGxlbWVudGF0aW9uIGNsYXNzXG5pcyBleHBlY3RlZCB0byBhc3NpZ24gdGhlIFJhdmlTZXNzaW9uJ3MgX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBzdGF0ZSkgXG5oYW5kbGVyIHRvIGFueSBhcHByb3ByaWF0ZSBldmVudHMgdGhyb3duIGJ5IGl0cyBpbXBsZW1lbnRhdGlvbiBcbihhbmQvb3IgdGhyb3duIGJ5IGl0c2VsZikuXG5TaW1pbGFybHksIGl0IGlzIGV4cGVjdGVkIHRvIGNhbGwgdGhlIHBhcmVudCdzIF9kb09uZGF0YWNoYW5uZWwgYW5kIF9kb09udHJhY2tcbm1ldGhvZHMgd2hlbiBpdCBoYXMgZGF0YSBjaGFubmVsIGFuZCB0cmFjayBjaGFubmVscyByZWFkeS5cbiAgRXhwZWN0ZWQgbWV0aG9kczpcbiAgY29uc3RydWN0b3IocmF2aVNlc3Npb24pO1xuICBfYXNzaWduU2lnbmFsaW5nQ29ubmVjdGlvbigpO1xuICBfYWRkQXVkaW9JbnB1dFN0cmVhbShpbnB1dFN0cmVhbSk7XG4gIF9hZGRWaWRlb0lucHV0U3RyZWFtKGlucHV0U3RyZWFtKTtcbiAgX29wZW4oKTsgXG4gIF9jbG9zZSgpO1xuKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFVzZSB0aGUgY29ycmVjdCBjbGFzc2VzIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIGJlaW5nIFxuICogY2FsbGVkIGZyb20gbm9kZSBvciB0aGUgYnJvd3Nlci5cbiAqL1xubGV0IGNyb3NzUGxhdGZvcm1SVENQZWVyQ29ubmVjdGlvbjphbnkgPSBudWxsO1xubGV0IGNyb3NzUGxhdGZvcm1SVENTZXNzaW9uRGVzY3JpcHRpb246YW55ID0gbnVsbDtcbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gbm9kZSBjb250ZXh0XG4gIGNyb3NzUGxhdGZvcm1SVENQZWVyQ29ubmVjdGlvbiA9IHJlcXVpcmUoJ3dydGMnKS5SVENQZWVyQ29ubmVjdGlvbjtcbiAgY3Jvc3NQbGF0Zm9ybVJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IHJlcXVpcmUoJ3dydGMnKS5SVENTZXNzaW9uRGVzY3JpcHRpb247XG59IGVsc2Uge1xuICAvLyBicm93c2VyIGNvbnRleHRcbiAgY3Jvc3NQbGF0Zm9ybVJUQ1BlZXJDb25uZWN0aW9uID0gUlRDUGVlckNvbm5lY3Rpb247XG4gIGNyb3NzUGxhdGZvcm1SVENTZXNzaW9uRGVzY3JpcHRpb24gPSBSVENTZXNzaW9uRGVzY3JpcHRpb247XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBDb25zdGFudHMgdXNlZCBkdXJpbmcgc2Vzc2lvbiBuZWdvdGlhdGlvblxuICovXG5jb25zdCBERUZBVUxUX1NUVU5fQ09ORklHID0ge1xuICAndXJscyc6IFsnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMiddXG59O1xuY29uc3QgTEVHQUNZX1RVUk5fQ09ORklHID0ge1xuICAndXJscyc6IFsndHVybjp0dXJuLmhpZ2hmaWRlbGl0eS5jb206MzQ3OCddLFxuICAndXNlcm5hbWUnOiAnY2xvdWR1c2VyJyxcbiAgJ2NyZWRlbnRpYWwnOiAnY2hhcmlvdC10cmF2ZXN0eS1ob29rJ1xufTtcbmxldCBwZWVyQ29ubmVjdGlvbkNvbmZpZyA9IHtcbiAgJ2ljZVNlcnZlcnMnOiBbXG4gICAgREVGQVVMVF9TVFVOX0NPTkZJRyxcbiAgICBMRUdBQ1lfVFVSTl9DT05GSUdcbiAgXVxufTtcblxuLyoqIFxuICogQGludGVybmFsXG4gKiBBIFdlYlJUQyBpbXBsZW1lbnRhdGlvbiBmb3IgYSBSQVZJIHBlZXIgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uIHtcbiAgX3JhdmlTZXNzaW9uOiBSYXZpU2Vzc2lvbjtcbiAgX25lZ290aWF0b3I6IGFueTtcbiAgX3N0YXRzV2F0Y2hlcjogUmF2aVdlYlJUQ1N0YXRzV2F0Y2hlcjtcbiAgX3J0Y0Nvbm5lY3Rpb246IHR5cGVvZiBjcm9zc1BsYXRmb3JtUlRDUGVlckNvbm5lY3Rpb247XG4gIF9yYXZpQXVkaW9TZW5kZXJzOiBhbnk7XG4gIF9yYXZpVmlkZW9TZW5kZXJzOiBhbnk7XG4gIF9zaWduYWxpbmdDb25uZWN0aW9uOiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgX2N1c3RvbVN0dW5BbmRUdXJuOiBDdXN0b21TVFVOYW5kVFVSTkNvbmZpZztcbiAgXG4gIC8vIE5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgaW5wdXQgc3RyZWFtcyBpbiBjYXNlIHRoZXkgZ2V0IHNldFxuICAvLyBiZWZvcmUgdGhlIGFjdHVhbCBSVEMgY29ubmVjdGlvbiBpcyBhdmFpbGFibGUuXG4gIF9hdWRpb0lucHV0U3RyZWFtOiBNZWRpYVN0cmVhbTtcbiAgX3ZpZGVvSW5wdXRTdHJlYW06IE1lZGlhU3RyZWFtO1xuICBfc2hvcnRDaXJjdWl0SGFuZGxlcjogRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFwiQ2xhc3NcIiB2YXJpYWJsZXMgdG8gYmUgYXdhcmUgb2Y6XG4gICAqIHRoaXMuX3J0Y0Nvbm5lY3Rpb24gICAgICAgLy8gVGhlIGFjdHVhbCBSVENQZWVyQ29ubmVjdGlvblxuICAgKiB0aGlzLl9yYXZpU2Vzc2lvbiAgICAgICAgIC8vIFRoZSBcIm93bmluZ1wiIFJhdmlTZXNzaW9uXG4gICAqIHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24gLy8gQSBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHdoZW4gbmVnb3RpYXRpbmcgdGhlIHNlc3Npb25cbiAgICogdGhpcy5fbmVnb3RpYXRvciAgICAgICAgICAvLyBBIGJvdW5kIHZlcnNpb24gb2YgdGhlIGNvbm5lY3Rpb24gc2V0dXAgbWV0aG9kIHRoYXQgY2FuIGJlIHVzZWQgZm9yIG1lc3NhZ2UgaGFuZGxpbmdcbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn0gcmF2aVNlc3Npb24gVGhlIG93bmVyIG9mIHRoaXMgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocmF2aVNlc3Npb246IFJhdmlTZXNzaW9uKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgIHRoaXMuX3JhdmlTZXNzaW9uID0gcmF2aVNlc3Npb247XG4gICAgdGhpcy5fbmVnb3RpYXRvciA9IHRoaXMuX3NldHVwQ29ubmVjdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3N0YXRzV2F0Y2hlciA9IG5ldyBSYXZpV2ViUlRDU3RhdHNXYXRjaGVyKHRoaXMpO1xuICAgIHRoaXMuX3JhdmlBdWRpb1NlbmRlcnMgPSBbXTtcbiAgICB0aGlzLl9yYXZpVmlkZW9TZW5kZXJzID0gW107XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBSVEMgY29ubmVjdGlvbiB0byBhIG5ldyBmcmVzaCBvbmUuIFRoaXMgZ2V0cyBjYWxsZWQgb25jZSB3ZVxuICAgKiBoYXZlIHJlY2VpdmVkIHRoZSBpbml0aWFsIFNEUCBmcm9tIHRoZSBzZXJ2ZXIgKHNvIHRoYXQgd2UgY2FuIGF0dGFjaFxuICAgKiBkeW5hbWljIFRVUk4gaW5mb3JtYXRpb24gdG8gaXQgd2hlbiBpdCdzIGNyZWF0ZWQsIGFzIG5lZWRlZCkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdFJ0Y0Nvbm5lY3Rpb24oKSB7XG4gICAgY29uc3QgcmF2aVNlc3Npb24gPSB0aGlzLl9yYXZpU2Vzc2lvbjtcbiAgICBjb25zdCBzZXNzaW9uSW1wbGVtZW50YXRpb24gPSB0aGlzO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIG5ldyBSVEMgY29ubmVjdGlvbiAoZm9yIG5vZGUgb3IgdGhlIGJyb3dzZXIpXG4gICAgdGhpcy5fcnRjQ29ubmVjdGlvbiA9IG5ldyBjcm9zc1BsYXRmb3JtUlRDUGVlckNvbm5lY3Rpb24ocGVlckNvbm5lY3Rpb25Db25maWcpO1xuICAgIGNvbnN0IHJ0Y0Nvbm5lY3Rpb24gPSB0aGlzLl9ydGNDb25uZWN0aW9uO1xuICAgIFxuICAgIC8vIENsZWFyIG91dCBhbnkgb2xkIHRyYWNrIHNlbmRlcnNcbiAgICBsZXQgc2VuZGVycyA9IHJ0Y0Nvbm5lY3Rpb24uZ2V0U2VuZGVycygpO1xuICAgIHNlbmRlcnMuZm9yRWFjaCgoc2VuZGVyOiBhbnkpID0+IHtcbiAgICAgIHNlbmRlci5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgfSk7XG4gICAgdGhpcy5fcmF2aUF1ZGlvU2VuZGVycyA9IFtdO1xuICAgIHRoaXMuX3JhdmlWaWRlb1NlbmRlcnMgPSBbXTtcbiAgICBcbiAgICAvLyBUaGlzIG5ldyBSVENDb25uZWN0aW9uJ3Mgc3RhdGUgY2hhbmdlIGV2ZW50cyB3aWxsIGp1c3RcbiAgICAvLyBjYWxsIGJhY2sgdXAgdG8gdGhlIG1haW4gUmF2aVNlc3Npb24ncyBcbiAgICAvLyBzdGF0ZUNoYW5nZUhhbmRsZXJzLlxuICAgIC8vIE5PVEU6IFRha2UgYSBsb29rIGF0IEJJR1dPUkxELTEwNjIgYW5kIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1BlZXJDb25uZWN0aW9uI1JUQ0ljZUNvbm5lY3Rpb25TdGF0ZV9lbnVtXG4gICAgLy8gYW5kXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1BlZXJDb25uZWN0aW9uI1JUQ1BlZXJDb25uZWN0aW9uU3RhdGVfZW51bVxuICAgIC8vIHRvIHNlZSB3aHkgd2UncmUgbGlzdGVuaW5nIG9uIGljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSBpbnN0ZWFkIG9mIHBlZXJjb25uZWN0aW9uc3RhdGVjaGFuZ2VcbiAgICBydGNDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgXG4gICAgICBpZiAocnRjQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUgPT09IFwiY29ubmVjdGVkXCIgfHwgcnRjQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUgPT0gXCJjb21wbGV0ZWRcIikge1xuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2Vzc2lvbiBoYXMgZnVsbHkgY29ubmVjdGVkOyByZW1vdmluZyBzaG9ydC1jaXJjdWl0IGhhbmRsZXJcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIHNlc3Npb25JbXBsZW1lbnRhdGlvbi5fc2lnbmFsaW5nQ29ubmVjdGlvbi5yZW1vdmVTdGF0ZUNoYW5nZUhhbmRsZXIoc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9zaG9ydENpcmN1aXRIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHJhdmlTZXNzaW9uLl9oYW5kbGVTdGF0ZUNoYW5nZShldmVudCwgcnRjQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUpOyBcbiAgICB9KTtcblxuICAgIC8vIFNpbWlsaWFybHksIGxpc3RlbiBhdCB0aGUgUmF2aVNlc3Npb24gbGV2ZWwgZm9yIHRyYWNrIGFuZCBkYXRhIGNoYW5uZWwgZXZlbnRzXG4gICAgcnRjQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdkYXRhY2hhbm5lbCcsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgcmF2aVNlc3Npb24uX2RvT25kYXRhY2hhbm5lbChldmVudCk7IH0pO1xuICAgIHJ0Y0Nvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCBmdW5jdGlvbihldmVudDogYW55KSB7IHJhdmlTZXNzaW9uLl9kb09udHJhY2soZXZlbnQpOyB9KTtcblxuICAgIC8vIEhvd2V2ZXIsIHdlIG5lZWQgdG8gbGlzdGVuIGF0IG91ciBvd24gUlRDIGltcGxlbWVudGF0aW9uIGxldmVsIGZvciBpY2UgY2FuZGlkYXRlIGV2ZW50cywgXG4gICAgLy8gYmVjYXVzZSB0aGV5J3JlIHBhcnQgb2YgdGhlIHNlc3Npb24gbmVnb3RpYXRpb25cbiAgICBydGNDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9kb09uaWNlY2FuZGlkYXRlKGV2ZW50KTsgfSk7XG5cbiAgICAvLyBXaGVuIGEgbmVnb3RpYXRpb25uZWVlZGVkIGlzIHRyaWdnZXJlZCBmcm9tIHRoaXMgcGVlciwgc2lnbmFsIHRoZSBzZXJ2ZXIgc2lkZSB0byBpbml0aWF0ZSBhbiBvZmZlclxuICAgIC8vIEluIFJhdmksIHRoZSB3ZWJydGMgbmVnb3RpYXRpb24gaXMgYWx3YXlzIGluaXRpYXRlZCBmcm9tIHRoZSBzZXJ2ZXIgc2lkZVxuICAgIHJ0Y0Nvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignbmVnb3RpYXRpb25uZWVkZWQnLCBmdW5jdGlvbihldmVudDogYW55KSB7IHNlc3Npb25JbXBsZW1lbnRhdGlvbi5fZG9Pbm5lZ290aWF0aW9ubmVlZGVkKGV2ZW50KTsgfSk7XG5cbiAgICAvLyBXYXRjaCB0aGUgc2lnbmFsaW5nIHN0YXRlIGNoYW5nZXMgZm9yIGRlYnVnLlxuICAgIHJ0Y0Nvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcInNpZ25hbGluZ3N0YXRlY2hhbmdlXCIsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9kb09uc2lnbmFsaW5nc3RhdGVjaGFuZ2VkKGV2ZW50KTsgfSk7XG5cbiAgfVxuICBcbiAgLyoqXG4gICAqIFRlbGwgdGhpcyBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24gd2hhdCBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiB0byB1c2UuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgb3duaW5nIFJhdmlTZXNzaW9uLiBcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2Fzc2lnblNpZ25hbGluZ0Nvbm5lY3Rpb24oc2lnbmFsaW5nQ29ubmVjdGlvbjogUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24pIHtcbiAgICB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uID0gc2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEFkZCBhbiBpbnB1dCBzdHJlYW0gdG8gdGhpcyBjb25uZWN0aW9uLiAoVGhpcyBjYW4gYmUgZG9uZSBhdFxuICAgKiBhbnkgcG9pbnQgZHVyaW5nIHRoZSBjb25uZWN0aW9uLCB3aGljaCBpcyB3aHkgaXQncyBhIHNlcGFyYXRlIG1ldGhvZC4pXG4gICAqIFxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG93bmluZyBSYXZpU2Vzc2lvbiB3aGVuIGl0cyBzdHJlYW0gY29udHJvbGxlclxuICAgKiBnZXRzIGFuIGlucHV0IHN0cmVhbS4gXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9hZGRBdWRpb0lucHV0U3RyZWFtKHN0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICBjb25zdCBydGNDb25uZWN0aW9uID0gdGhpcy5fcnRjQ29ubmVjdGlvbjtcbiAgICBjb25zdCBzZXNzaW9uSW1wbGVtZW50YXRpb24gPSB0aGlzO1xuICAgIHZhciByZXR2YWwgPSBmYWxzZTtcblxuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIHRoaXMuX2F1ZGlvSW5wdXRTdHJlYW0gPSBzdHJlYW07XG4gICAgICBpZiAoISBydGNDb25uZWN0aW9uKSB7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJTZXR0aW5nIGF1ZGlvIGlucHV0IHN0cmVhbSB3aXRob3V0IGF2YWlsYWJsZSBSVEMgY29ubmVjdGlvbjsgd2lsbCBzdG9yZSBpdCB1bnRpbCByZWFkeVwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGtlZXAgdHJhY2sgb2YgdGhlIHNlbmRlcnMgdGhhdCB3ZSBpbnRlcmFjdCB3aXRoXG4gICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gdGhlIGxpc3Qgb2Ygc2VuZGVycyBvbiB0aGUgUlRDIGNvbm5lY3Rpb24sXG4gICAgICAvLyBiZWNhdXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlJ3JlIG9ubHkgd29ya2luZyB3aXRoIFxuICAgICAgLy8gc2VuZGVycyB0aGF0IG1hdGNoIG91ciBvd24gcGFyYW1ldGVycy5cbiAgICAgIGNvbnN0IGN1cnJlbnRTZW5kZXJzID0gdGhpcy5fcmF2aUF1ZGlvU2VuZGVycztcbiAgICAgIFxuICAgICAgLy8gTGlzdCBvZiBuZXcgdHJhY2tzIGluIHRoZSBwYXNzZWQgc3RyZWFtXG4gICAgICBjb25zdCBuZXdBdWRpb1RyYWNrcyA9IHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgICAgY29uc3QgbnVtTmV3VHJhY2tzID0gbmV3QXVkaW9UcmFja3MubGVuZ3RoO1xuXG4gICAgICBsZXQgaT0wO1xuICAgICAgZm9yIChpOyBpIDwgY3VycmVudFNlbmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRm9yIGVhY2ggb2YgdGhlIHRyYWNrcyB0aGF0IHdlIGFscmVhZHkga25vdyBhYm91dCxcbiAgICAgICAgLy8gcmVwbGFjZSB0aGVtIHdpdGggYSB0cmFjayBmcm9tIHRoZSBuZXcgc3RyZWFtLlxuICAgICAgICAvLyAoTm90ZTogdGhpcyBzZWVtcyB0byBhZGQgYSBsaXR0bGUgbGF0ZW5jeSB3aGVuIGl0IGdldHMgY2FsbGVkLFxuICAgICAgICAvLyBidXQgb24gdGhlIHBsdXMgc2lkZSwgZG9lcyBub3QgdHJpZ2dlciBhIHJlbmVnb3RpYXRpb24uIFRoZSBsYXRlbmN5XG4gICAgICAgIC8vIHRlbmRzIHRvIGRpc3NpcGF0ZSBvdmVyIHRpbWUuKVxuICAgICAgICBpZiAoaSA8IG51bU5ld1RyYWNrcykge1xuICAgICAgICAgIFJhdmlVdGlscy5sb2coXCJSZXBsYWNpbmcgYXVkaW8gdHJhY2sgI1wiICsgaSArIFwiICBpbiBydGNDb25uZWN0aW9uXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAgIGN1cnJlbnRTZW5kZXJzW2ldLnJlcGxhY2VUcmFjayhuZXdBdWRpb1RyYWNrc1tpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgdHJhY2tzIGluIHRoZSBvbGQgc3RyZWFtIHRoYW5cbiAgICAgICAgICAvLyBpbiB0aGUgbmV3IG9uZSwgc2V0IHRoZSBleHRyYXMgdG8gbnVsbCBcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2V0dGluZyBhdWRpbyBzZW5kZXIgI1wiICsgaSArIFwiIHRvIG51bGxcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgICAgY3VycmVudFNlbmRlcnNbaV0ucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIHRyYWNrcyBpbiB0aGUgbmV3IHN0cmVhbSB0aGVuXG4gICAgICAvLyBpbiB0aGUgb2xkLCBhZGQgdGhlbVxuICAgICAgZm9yIChpOyBpIDwgbnVtTmV3VHJhY2tzOyBpKyspIHtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIkFkZGluZyBsb2NhbCBhdWRpbyB0cmFjayAjXCIgKyBpICsgXCIgdG8gcnRjQ29ubmVjdGlvblwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgY3VycmVudFNlbmRlcnMucHVzaChydGNDb25uZWN0aW9uLmFkZFRyYWNrKG5ld0F1ZGlvVHJhY2tzW2ldLCBzdHJlYW0pKTtcbiAgICAgICAgLy8gV2UgZXhwZWN0IHRoZSAnbmVnb3RpYXRpb25uZWVkZWQnIGV2ZW50IHRvIGZpcmVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgc3RyZWFtIGFzc2lnbmVkIGlzIG51bGwgbWVhbmluZyB3ZSB3YW50IHRvIGtpbGwgYW55IGlucHV0IGF1ZGlvIHN0cmVhbVxuICAgICAgICBjb25zdCBjdXJyZW50U2VuZGVycyA9IHRoaXMuX3JhdmlBdWRpb1NlbmRlcnM7XG5cbiAgICAgICAgLy8gc2ltcGx5IHNldCBhbGwgdGhlIGV4aXN0aW5nIHNlbmRlcnMgdG8gbnVsbCB0cmFjay5cbiAgICAgICAgbGV0IGk9MDtcbiAgICAgICAgZm9yIChpOyBpIDwgY3VycmVudFNlbmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2V0dGluZyBhdWRpbyBzZW5kZXIgI1wiICsgaSArIFwiIHRvIG51bGxcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgICAgY3VycmVudFNlbmRlcnNbaV0ucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR2YWw7XG4gIH1cblxuICBfYWRkVmlkZW9JbnB1dFN0cmVhbShzdHJlYW06IE1lZGlhU3RyZWFtKSB7XG4gICAgY29uc3QgcnRjQ29ubmVjdGlvbiA9IHRoaXMuX3J0Y0Nvbm5lY3Rpb247XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHJldHZhbCA9IGZhbHNlO1xuXG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgdGhpcy5fdmlkZW9JbnB1dFN0cmVhbSA9IHN0cmVhbTtcbiAgICAgIGlmICghIHJ0Y0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNldHRpbmcgdmlkZW8gaW5wdXQgc3RyZWFtIHdpdGhvdXQgYXZhaWxhYmxlIFJUQyBjb25uZWN0aW9uOyB3aWxsIHN0b3JlIGl0IHVudGlsIHJlYWR5XCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2Uga2VlcCB0cmFjayBvZiB0aGUgc2VuZGVycyB0aGF0IHdlIGludGVyYWN0IHdpdGhcbiAgICAgIC8vIHNlcGFyYXRlbHkgZnJvbSB0aGUgbGlzdCBvZiBzZW5kZXJzIG9uIHRoZSBSVEMgY29ubmVjdGlvbixcbiAgICAgIC8vIGJlY2F1c2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UncmUgb25seSB3b3JraW5nIHdpdGggXG4gICAgICAvLyBzZW5kZXJzIHRoYXQgbWF0Y2ggb3VyIG93biBwYXJhbWV0ZXJzLlxuICAgICAgY29uc3QgY3VycmVudFNlbmRlcnMgPSB0aGlzLl9yYXZpVmlkZW9TZW5kZXJzO1xuICAgICAgXG4gICAgICAvLyBMaXN0IG9mIG5ldyB0cmFja3MgaW4gdGhlIHBhc3NlZCBzdHJlYW1cbiAgICAgIGNvbnN0IG5ld1ZpZGVvVHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICBjb25zdCBudW1OZXdUcmFja3MgPSBuZXdWaWRlb1RyYWNrcy5sZW5ndGg7XG4gICAgICBcbiAgICAgIC8vIEF0IHRoZSBtb21lbnQsIHJhdmkgY2xpZW50IHNlc3Npb24gb25seSBzdXBwb3J0IG9uZSBvdXRib3VuZCB2aWRlbyB0cmFja1xuICAgICAgaWYgKG51bU5ld1RyYWNrcyA+IDApIHtcbiAgICAgICAgLy8gSWYgY3VycmVudCB2aWRlbyBzZW5kZXIgZXhpc3RzIGFscmVhZHksIGp1c3QgcmVwbGFjZSB0cmFja1xuICAgICAgICBpZiAoY3VycmVudFNlbmRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIFJhdmlVdGlscy5sb2coXCJSZXBsYWNpbmcgdmlkZW8gdHJhY2sgIzAgaW4gcnRjQ29ubmVjdGlvblwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgICBjdXJyZW50U2VuZGVyc1swXS5yZXBsYWNlVHJhY2sobmV3VmlkZW9UcmFja3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVsc2UganVzdCBhZGQgdGhlIG5ldyB0cmFjayB0byB0aGUgUGVlckNvbm5lY3Rpb24uXG4gICAgICAgICAgUmF2aVV0aWxzLmxvZyhcIkFkZGluZyB2aWRlbyB0cmFjayAjMCB0byBydGNDb25uZWN0aW9uXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAgIGN1cnJlbnRTZW5kZXJzLnB1c2gocnRjQ29ubmVjdGlvbi5hZGRUcmFjayhuZXdWaWRlb1RyYWNrc1swXSkpO1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCB0aGUgJ25lZ290aWF0aW9ubmVlZGVkJyBldmVudCB0byBmaXJlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dmFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJBc3NpZ25lZCB2aWRlbyBzdHJlYW0gZG9lc24ndCBjb250YWluIHZpZG9lIHRyYWNrXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgfSAgICAgICAgICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlIHN0cmVhbSBhc3NpZ25lZCBpcyBudWxsIG1lYW5pbmcgd2Ugd2FudCB0byBraWxsIGFueSBpbnB1dCB2aWRlbyBzdHJlYW1cbiAgICAgIGNvbnN0IGN1cnJlbnRTZW5kZXJzID0gdGhpcy5fcmF2aVZpZGVvU2VuZGVycztcblxuICAgICAgLy8gc2ltcGx5IHNldCBhbGwgdGhlIGV4aXN0aW5nIHNlbmRlcnMgdG8gbnVsbCB0cmFjay5cbiAgICAgIGxldCBpPTA7XG4gICAgICBmb3IgKGk7IGkgPCBjdXJyZW50U2VuZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2V0dGluZyB2aWRlbyBzZW5kZXIgI1wiICsgaSArIFwiIHRvIG51bGxcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIGN1cnJlbnRTZW5kZXJzW2ldLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIGEgc2Vzc2lvbi4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIHRoaXMgYnkgYWRkaW5nIGEgaGFuZGxlciB0byB0aGUgc2lnbmFsaW5nQ29ubmVjdGlvblxuICAgKiB0aGF0IHdpbGwgbGlzdGVuIGZvciBcInJlYWR5IHRvIG5lZ290aWF0ZSBjb25uZWN0aW9uXCIgbWVzc2FnZXMgc28gdGhhdCB0aGUgXG4gICAqIF9zZXR1cENvbm5lY3Rpb24gbWV0aG9kIGNhbiB0aGVuIG5lZ290aWF0ZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBvd25pbmcgUmF2aVNlc3Npb24uIFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb3BlbihwYXJhbXM6IFdlYlJUQ1Nlc3Npb25QYXJhbXMsIGN1c3RvbVN0dW5BbmRUdXJuOiBDdXN0b21TVFVOYW5kVFVSTkNvbmZpZykge1xuICAgIFJhdmlVdGlscy5sb2coXCJBdHRlbXB0aW5nIHRvIG9wZW4gY29ubmVjdGlvbi4uLlwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICB0aGlzLl9jdXN0b21TdHVuQW5kVHVybiA9IGN1c3RvbVN0dW5BbmRUdXJuO1xuICAgIGlmICh0aGlzLl9ydGNDb25uZWN0aW9uXG4gICAgICAgICYmICh0aGlzLl9ydGNDb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PSAnY29ubmVjdGluZydcbiAgICAgICAgICAgIHx8IHRoaXMuX3J0Y0Nvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlID09ICdjb25uZWN0ZWQnKSlcbiAgICB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiV2UgYWxyZWFkeSBoYXZlIGEgY29ubmVjdGlvbiBpbiBwcm9ncmVzcy4gV2lsbCBub3QgYXR0ZW1wdCBhIG5ldyBvbmUuXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgLy8gVHJpZ2dlciBzdGF0ZSBjaGFuZ2UgaGFuZGxlciBvbiB0aGUgb3duaW5nIHNlc3Npb24gdG8gZmluYWxpemUgYW55IFxuICAgICAgLy8gcmVzaWR1YWwgUHJvbWlzZXNcbiAgICAgIHRoaXMuX3JhdmlTZXNzaW9uLl9oYW5kbGVTdGF0ZUNoYW5nZSh7XCJzdGF0ZVwiOnRoaXMuX3J0Y0Nvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlfSwgdGhpcy5fcnRjQ29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUpOyBcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2lnbmFsaW5nQ29ubmVjdGlvbikge1xuICAgICAgLy8gQWRkIGEgaGFuZGxlciBmb3Igc3RhdGUgY2hhbmdlIGV2ZW50cyBvbnRvIHRoZSBwcm92aWRlZFxuICAgICAgLy8gc2lnbmFsaW5nIGNvbm5lY3Rpb24uIFRoaXMgc2hvdWxkIGxpc3RlbiBmb3IgdGhlIGFwcHJvcHJpYXRlIFxuICAgICAgLy8gXCJyZWFkeSB0byBuZWdvdGlhdGUgY29ubmVjdGlvblwiIG1lc3NhZ2UgZnJvbSB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24uXG4gICAgICB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uLmFkZE1lc3NhZ2VIYW5kbGVyKHRoaXMuX25lZ290aWF0b3IpO1xuICAgICAgXG4gICAgICAvLyBBZGQgYSBzdGF0ZSBjaGFuZ2UgaGFuZGxlciB0byB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24uIElmIHRoZVxuICAgICAgLy8gY29ubmVjdGlvbiBjbG9zZXMgb3IgZmFpbHMgX3doaWxlIHdlJ3JlIGluIHRoZSBwcm9jZXNzIG9mIG5lZ290aWF0aW5nXG4gICAgICAvLyB0aGUgY29ubmVjdGlvbl8gKGkuZS4gYmVmb3JlIHRoZSBjb25uZWN0aW9uIGlzIGZ1bGx5IG9wZW4pLCB3ZSBzaG91bGQgc3RvcCB0cnlpbmcuXG4gICAgICAvLyBXZSByZW1vdmUgdGhpcyBoYW5kbGVyIG9uY2UgdGhlIFdlYlJUQyBjb25uZWN0aW9uIGlzIGZ1bGx5IG9wZW4sIGJlY2F1c2UgaWYgdGhlIFxuICAgICAgLy8gc2lnbmFsaW5nIGNvbm5lY3Rpb24gY2xvc2VzIF9hZnRlcl8gd2UndmUgZ290IGEgc3RhYmxlIGNvbm5lY3Rpb24sIHdlIHdhbnQgdG9cbiAgICAgIC8vIGxlYXZlIG91ciB3ZWJydGMgY29ubmVjdGlvbiBvcGVuIGFzIGxvbmcgYXMgcG9zc2libGUuXG4gICAgICB0aGlzLl9zaG9ydENpcmN1aXRIYW5kbGVyID0gdGhpcy5fY2FuY2VsT3BlbmluZ1Byb2Nlc3NPblNpZ25hbGluZ0Rpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24uYWRkU3RhdGVDaGFuZ2VIYW5kbGVyKHRoaXMuX3Nob3J0Q2lyY3VpdEhhbmRsZXIpO1xuXG4gICAgICAvLyBTZW5kIHRoZSBtYWdpYyBzdHJpbmcgZm9yIG9wZW5pbmcgYSBjb25uZWN0aW9uLlxuICAgICAgLy8gd2l0aCBwYXJhbXMgZXZlbnR1YWxseVxuICAgICAgbGV0IG1lc3NhZ2U6IGFueSA9IHt9O1xuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgIG1lc3NhZ2UgPSBwYXJhbXM7XG4gICAgICAgICAgbWVzc2FnZVtcInNlc3Npb25JRFwiXSA9IHRoaXMuX3JhdmlTZXNzaW9uLmdldFVVSUQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVzc2FnZSA9IHRoaXMuX3JhdmlTZXNzaW9uLmdldFVVSUQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2lnbmFsaW5nQ29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KHsncmVxdWVzdCc6IG1lc3NhZ2V9KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBhIHNlc3Npb24gdGhhdCdzIGluIHRoZSBwcm9jZXNzIG9mIGJlaW5nIG9wZW5lZC4gVGhpcyBnZXRzIGNhbGxlZCBpZlxuICAgKiB3ZSByZWNlaXZlIGEgc3RhdGUgY2hhbmdlIGZyb20gdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uIGFmdGVyIHRoZSBcIm9wZW5cIiBoYXMgYWxyZWFkeVxuICAgKiBiZWVuIGNhbGxlZC4gSWYgc28gKGFuZCBpZiB0aGF0IHN0YXRlIGNoYW5nZSBpcyBhbiBlcnJvci9jbG9zZSksIHdlIHNob3J0LWNpcmN1aXRcbiAgICogdGhlIHByb2Nlc3Mgb2Ygb3BlbmluZyB0aGUgc2Vzc2lvbiBhbmQgY2xvc2Ugb3V0IGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBUaGlzIGhhbmRsZXIgaXMgYWRkZWQgYnkgdGhlIF9vcGVuKCkgbWV0aG9kIGFuZCByZW1vdmVkIHdoZW4gZWl0aGVyIHRoZSBjb25uZWN0aW9uIGlzXG4gICAqIGNvbm5lY3RlZCBvciB3aGVuIHRoZSBfY2xvc2UoKSBtZXRob2QgaXMgY2FsbGVkLCB3aGljaGV2ZXIgY29tZXMgZmlyc3QuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9jYW5jZWxPcGVuaW5nUHJvY2Vzc09uU2lnbmFsaW5nRGlzY29ubmVjdCAoZXZlbnQ6IGFueSkge1xuICAgIGxldCBzdGF0ZSA9IGV2ZW50LnN0YXRlIHx8IFwidW5rbm93blwiO1xuICAgIGNvbnN0IHJhdmlTZXNzaW9uID0gdGhpcy5fcmF2aVNlc3Npb247XG4gICAgc3dpdGNoKHN0YXRlKSB7XG4gICAgICBjYXNlIFJhdmlTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEOlxuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2lnbmFsaW5nIHN0YXRlIGNsb3NlZCBiZWZvcmUgc2Vzc2lvbiB3YXMgZXN0YWJsaXNoZWQ7IGNsb3NpbmcgUmF2aVNlc3Npb25cIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIHJhdmlTZXNzaW9uLl9oYW5kbGVTdGF0ZUNoYW5nZShldmVudCwgUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VEKTtcbiAgICAgICAgLy8gQ2FsbCBfY2xvc2UgdG8gY2xlYW4gdXAgYWZ0ZXIgb3Vyc2VsdmVzXG4gICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2lnbmFsaW5nU3RhdGVzLkVSUk9SOlxuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2lnbmFsaW5nIHN0YXRlIGVycm9yZWQgb3V0IGJlZm9yZSBzZXNzaW9uIHdhcyBlc3RhYmxpc2hlZDsgY2xvc2luZyBSYXZpU2Vzc2lvblwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgcmF2aVNlc3Npb24uX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBSYXZpU2Vzc2lvblN0YXRlcy5GQUlMRUQpO1xuICAgICAgICB0aGlzLl9jbG9zZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUmF2aVNpZ25hbGluZ1N0YXRlcy5VTkFWQUlMQUJMRTpcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNpZ25hbGluZyBzdGF0ZSByZWFjaGVkICd1bmF2YWlsYWJsZScgYmVmb3JlIHNlc3Npb24gd2FzIGVzdGFibGlzaGVkOyBjbG9zaW5nIFJhdmlTZXNzaW9uXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICByYXZpU2Vzc2lvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTZXNzaW9uU3RhdGVzLkZBSUxFRCk7XG4gICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNpZ25hbGluZyBzdGF0ZSBoYXMgY2hhbmdlZCBkdXJpbmcgb3BlbmluZyBvZiBSQVZJIHNlc3Npb24sIGJ1dCBpcyBhbiBPSyBjaGFuZ2UuIE5ldyBzdGF0ZTogXCIgKyBzdGF0ZSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgfVxuICB9XG4gIFxuICBcbiAgLyoqXG4gICAqIENsb3NlIGEgc2Vzc2lvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBvd25pbmcgUmF2aVNlc3Npb24uIFxuICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBBTFdBWVMgZ29lcyB0aHJvdWdoIGl0cyBjbGVhbnVwIHByb2Nlc3MsXG4gICAqIGV2ZW4gaWYgdGhlcmUgaXNuJ3QgYW4gdW5kZXJseWluZyBSVEMgY29ubmVjdGlvbiBvciB0aGUgdW5kZXJseWluZ1xuICAgKiBSVEMgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGNsb3NlZC4gVGhpcyBpcyB0byBtYWtlIHN1cmUgdGhhdCBvdGhlciB0aGluZ3NcbiAgICogKGUuZy4gc3RhdGUgY2hhbmdlIGhhbmRsZXJzIG9uIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBhbmQgcHJvbWlzZXMpIGFsd2F5c1xuICAgKiBnZXQgY2xlYW5lZCB1cCBhcHByb3ByaWF0ZWx5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfY2xvc2UoKSB7XG4gICAgdGhpcy5fc3RhdHNXYXRjaGVyLnN0b3AoKTtcbiAgICBjb25zdCByYXZpU2Vzc2lvbiA9IHRoaXMuX3JhdmlTZXNzaW9uO1xuICAgIFJhdmlVdGlscy5sb2coXCJjbG9zaW5nXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuXG4gICAgaWYgKHRoaXMuX3J0Y0Nvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMuX3J0Y0Nvbm5lY3Rpb24uY2xvc2UoKTsgICAgXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIG91ciBzZXNzaW9uLW5lZ290aWF0aW5nIG1lc3NhZ2UgaGFuZGxlciBmcm9tIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvblxuICAgIHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24ucmVtb3ZlTWVzc2FnZUhhbmRsZXIodGhpcy5fbmVnb3RpYXRvcik7XG5cbiAgICAvLyBSZW1vdmUgdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uJ3Mgc3RhdGUgY2hhbmdlIGhhbmRsZXIgdGhhdCB3b3VsZCBoYXZlXG4gICAgLy8gc2hvcnQtY2lyY3VpdGVkIGNvbm5lY3Rpb24gbG9naWMgaWYgdGhlIHNpZ25hbGluZyBkaXNjb25uZWN0cyB3aGlsZVxuICAgIC8vIHdlJ3JlIHN0aWxsIHRyeWluZyB0byBuZWdvdGlhdGVcbiAgICB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uLnJlbW92ZVN0YXRlQ2hhbmdlSGFuZGxlcih0aGlzLl9zaG9ydENpcmN1aXRIYW5kbGVyKTtcblxuICAgIC8vIF9ydGNDb25uZWN0aW9uIHdpbGwgYmUgcmVpbml0aWFsaXplZCBpZi93aGVuIGl0J3MgbmVlZGVkIGFnYWluLCBuZXh0IHRpbWVcbiAgICAvLyBhIGNvbm5lY3QgaXMgYXR0ZW1wZWQgYW5kIGFuIHNkcCBvZmZlciBhcnJpdmVzLlxuICAgIHRoaXMuX3J0Y0Nvbm5lY3Rpb24gPSBudWxsO1xuXG4gICAgLy8gTWFrZSBhYnNvbHV0ZWx5IHN1cmUgdGhlIG93bmluZyBzZXNzaW9uIGtub3dzIHdlJ3ZlIGNsb3NlZFxuICAgIHJhdmlTZXNzaW9uLl9oYW5kbGVTdGF0ZUNoYW5nZSh7fSwgUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHNlbmQgbG9jYWwgSUNFIGNhbmRpZGF0ZSBwcm9wb3NhbHMgdG8gdGhlIHNlcnZlci5cbiAgICogXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9PbmljZWNhbmRpZGF0ZShldmVudDogYW55KSB7XG4gICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSAmJiBldmVudC5jYW5kaWRhdGUgIT0gXCJcIikge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIlNlbmRpbmcgbG9jYWwgSUNFIGNhbmRpZGF0ZTogXCIgKyBKU09OLnN0cmluZ2lmeShldmVudC5jYW5kaWRhdGUpLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgIHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24uc2VuZChKU09OLnN0cmluZ2lmeSh7J2ljZSc6IGV2ZW50LmNhbmRpZGF0ZSwgJ3V1aWQnOiB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRVVUlEKCl9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJhdmlVdGlscy5sb2coXCJFbmQgb2YgbG9jYWwgSUNFIGNhbmRpZGF0ZXNcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBIYW5kbGUgcmVuZWdvdGlhdGlvbiB3aGVuIG5lZWRlZC5cbiAgICogXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9Pbm5lZ290aWF0aW9ubmVlZGVkKGV2ZW50OiBhbnkpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwibmVlZCByZW5lZ290aWF0aW9uIHBsZWFzZVwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICBjb25zdCBtc2cgPSB7XG4gICAgICByZW5lZ290aWF0ZTogXCJwbGVhc2VcIixcbiAgICAgIHV1aWQ6IHRoaXMuX3JhdmlTZXNzaW9uLmdldFVVSUQoKVxuICAgIH07XG4gICAgY29uc3QgZGVzYyA9IEpTT04uc3RyaW5naWZ5KG1zZyk7XG4gICBcbiAgICAvLyBuZWdvdGlhdGlvbiBuZWVkZWQgYnV0IG9ubHkgaWYgd2UgYXJlIG5vdCBhbHJlYWR5IGN1cnJlbnRseSBuZWdvdGlhdGluZ1xuICAgIGlmICh0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uICYmIHRoaXMuX3J0Y0Nvbm5lY3Rpb24gJiYgdGhpcy5fcnRjQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gXCJzdGFibGVcIikge1xuICAgICAgdGhpcy5fc2lnbmFsaW5nQ29ubmVjdGlvbi5zZW5kKGRlc2MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgc2lnbmFsaW5nIHN0YXRlIGNoYW5nZS5cbiAgICogXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9PbnNpZ25hbGluZ3N0YXRlY2hhbmdlZChldmVudDogYW55KSB7XG4gICAgaWYgKHRoaXMuX3J0Y0Nvbm5lY3Rpb24pIHtcbiAgICAgIC8vIHNpbXBsZSBsb2dnaW5nIGZvciBub3dcbiAgICAgIFJhdmlVdGlscy5sb2coXCJTaWduYWxpbmdTdGF0ZSBjaGFuZ2VkOiBcIiArIHRoaXMuX3J0Y0Nvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2ZvcmNlQml0cmF0ZVVwKHNkcDogc3RyaW5nKSB7XG4gICAgLy8gTmVlZCB0byBmb3JtYXQgdGhlIFNEUCBkaWZmZXJlbnRseSBpZiB0aGUgaW5wdXQgaXMgc3RlcmVvLCBzbyBcbiAgICAvLyByZWFjaCB1cCBpbnRvIG91ciBvd25lcidzIHN0cmVhbSBjb250cm9sbGVyIHRvIGZpbmQgb3V0LlxuICAgIGNvbnN0IGxvY2FsQXVkaW9Jc1N0ZXJlbyA9IHRoaXMuX3JhdmlTZXNzaW9uLl9zdHJlYW1Db250cm9sbGVyLmlzU3RlcmVvSW5wdXQoKTtcbiAgICAvLyBVc2UgMTI4a2JwcyBmb3Igc3RlcmVvIHVwc3RyZWFtIGF1ZGlvLCA2NGticHMgZm9yIG1vbm9cbiAgICBjb25zdCBiaXRyYXRlID0gbG9jYWxBdWRpb0lzU3RlcmVvID8gMTI4MDAwIDogNjQwMDA7XG5cbiAgICAvLyBTRFAgbXVuZ2luZzogdXNlIDEyOGticHMgZm9yIHN0ZXJlbyB1cHN0cmVhbSBhdWRpbywgNjRrYnBzIGZvciBtb25vXG4gICAgcmV0dXJuIHNkcC5yZXBsYWNlKC9hPWZtdHA6MTExIC9nLCAnYT1mbXRwOjExMSBtYXhhdmVyYWdlYml0cmF0ZT0nK2JpdHJhdGUrJzsnKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZm9yY2VTdGVyZW9Eb3duKHNkcDogc3RyaW5nKSB7XG4gICAgLy8gbXVuZ2UgdGhlIFNEUCBhbnN3ZXI6IHJlcXVlc3QgMTI4a2JwcyBzdGVyZW8gZm9yIGRvd25zdHJlYW0gYXVkaW9cbiAgICByZXR1cm4gc2RwLnJlcGxhY2UoL2E9Zm10cDoxMTEgL2csICdhPWZtdHA6MTExIG1heGF2ZXJhZ2ViaXRyYXRlPTEyODAwMDtzcHJvcC1zdGVyZW89MTtzdGVyZW89MTsnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIGFsbCBtZXNzYWdlcyBvbiB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24gKHNlZSB0aGUgX29wZW4oKSBtZXRob2QpLCBhbmRcbiAgICogd2F0Y2hlcyBmb3IgdGhlIGFwcHJvcHJpYXRlIFNEUC1yZWxhdGVkIGV2ZW50cyBzbyB0aGF0IGl0IGNhbiBuZWdvdGlhdGUgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBDb25uZWN0aW9uKGV2ZW50OiBhbnkpIHtcbiAgICBsZXQgZnVsbE1lc3NhZ2U6YW55ID0gXCJcIjtcbiAgICBsZXQgc2lnbmFsOmFueSA9IFwiXCI7XG5cbiAgICBcbiAgICAvLyBMb2NhbCBjb3BpZXMgb2YgdXNlZnVsIHZhcmlhYmxlcyB0byBhdm9pZCBoYXZpbmcgdG8gYmluZFxuICAgIGNvbnN0IHJhdmlTZXNzaW9uID0gdGhpcy5fcmF2aVNlc3Npb247XG4gICAgY29uc3Qgc2lnbmFsaW5nQ29ubmVjdGlvbiA9IHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb247XG4gICAgY29uc3Qgc2Vzc2lvbkltcGxlbWVudGF0aW9uID0gdGhpcztcbiAgICBcbiAgICAvLyBKdXN0IGluIGNhc2UsIG1ha2Ugc3VyZSB3ZSBoYXZlIGV2ZXJ5dGhpbmcgd2UgbmVlZFxuICAgIGlmICghcmF2aVNlc3Npb24gfHwgIXNpZ25hbGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgIFJhdmlVdGlscy5lcnIoXCJNaXNzaW5nIG9uZSBvZiByYXZpU2Vzc2lvbiBvciBzaWduYWxpbmdDb25uZWN0aW9uISBDYW4ndCBzZXQgdXAgY29ubmVjdGlvbi5cIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgbWVzc2FnZSwgYW5kIHRoYXQgaXQncyBmb3IgdGhpcyBwYXJ0aWN1bGFyIFJBVkkgc2Vzc2lvblxuICAgIGlmIChldmVudCAmJiBldmVudC5kYXRhKSB7XG4gICAgICBSYXZpVXRpbHMubG9nKCdNZXNzYWdlIGZyb20gc2VydmVyOiAnICsgZXZlbnQuZGF0YSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICBmdWxsTWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJhdmlVdGlscy5sb2coJ05vIG1lc3NhZ2UgcmVjZWl2ZWQgYnkgb25NZXNzYWdlIGhhbmRsZXInLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgIHJldHVybjsgLy8gTm8gbWVzc2FnZVxuICAgIH1cbiAgICBzaWduYWwgPSBmdWxsTWVzc2FnZVtyYXZpU2Vzc2lvbi5nZXRVVUlEKCldO1xuICAgIGlmICghc2lnbmFsKSByZXR1cm47IC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgZm9yIG1lXG5cbiAgICAvLyBXZSBoYXZlIGEgc2lnbmFsOyBjaGVjayBmaXJzdCB0byBzZWUgaWYgaXQncyBhbiBTRFBcbiAgICBpZiAoc2lnbmFsLnNkcCkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIlJlY2VpdmVkIHNkcCB0eXBlPVwiICsgc2lnbmFsLnR5cGUsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuXG4gICAgICAvLyB1c2UgdXNlci1zcGVjaWZpZWQgVFVSTiBjb25maWcgaWYgZm91bmRcbiAgICAgIGlmIChzZXNzaW9uSW1wbGVtZW50YXRpb24uX2N1c3RvbVN0dW5BbmRUdXJuKSB7XG4gICAgICAgIGNvbnN0IENVU1RPTV9UVVJOX0NPTkZJRyA9IHtcbiAgICAgICAgICAndXJscyc6IHNlc3Npb25JbXBsZW1lbnRhdGlvbi5fY3VzdG9tU3R1bkFuZFR1cm4udHVyblVybHMsXG4gICAgICAgICAgJ3VzZXJuYW1lJzogc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9jdXN0b21TdHVuQW5kVHVybi50dXJuVXNlcm5hbWUsXG4gICAgICAgICAgJ2NyZWRlbnRpYWwnOiBzZXNzaW9uSW1wbGVtZW50YXRpb24uX2N1c3RvbVN0dW5BbmRUdXJuLnR1cm5DcmVkZW50aWFsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IENVU1RPTV9TVFVOX0NPTkZJRyA9IHtcbiAgICAgICAgICAndXJscyc6IHNlc3Npb25JbXBsZW1lbnRhdGlvbi5fY3VzdG9tU3R1bkFuZFR1cm4uc3R1blVybHNcbiAgICAgICAgfTtcbiAgICAgICAgcGVlckNvbm5lY3Rpb25Db25maWcgPSB7XG4gICAgICAgICAgJ2ljZVNlcnZlcnMnOiBbXG4gICAgICAgICAgICBDVVNUT01fU1RVTl9DT05GSUcsXG4gICAgICAgICAgICBDVVNUT01fVFVSTl9DT05GSUdcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICAvLyBncmFiIHRoZSBUVVJOIGNvbmZpZyBpZiBmb3VuZFxuICAgICAgfSBlbHNlIGlmIChzaWduYWwudHVybiAmJiBzaWduYWwudHVybi51cmxzICYmIHNpZ25hbC50dXJuLnVzZXJuYW1lICYmIHNpZ25hbC50dXJuLmNyZWRlbnRpYWwpIHtcbiAgICAgICAgLy8gV2UgYXBwZWFyIHRvIG5lZWQgdG8gaHVtb3IgVHlwZVNjcmlwdCBieSBzZXR0aW5nIHRoaXMgdG8gYSBjb25zdGFudCB0aGVcbiAgICAgICAgLy8gc2FtZSB3YXkgd2UgZG8gZm9yIHRoZSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IERZTkFNSUNfVFVSTl9DT05GSUcgPSB7XG4gICAgICAgICAgJ3VybHMnOiBzaWduYWwudHVybi51cmxzLFxuICAgICAgICAgICd1c2VybmFtZSc6IHNpZ25hbC50dXJuLnVzZXJuYW1lLFxuICAgICAgICAgICdjcmVkZW50aWFsJzogc2lnbmFsLnR1cm4uY3JlZGVudGlhbFxuICAgICAgICB9O1xuICAgICAgICBwZWVyQ29ubmVjdGlvbkNvbmZpZyA9IHtcbiAgICAgICAgICAnaWNlU2VydmVycyc6IFtcbiAgICAgICAgICAgIERFRkFVTFRfU1RVTl9DT05GSUcsXG4gICAgICAgICAgICBEWU5BTUlDX1RVUk5fQ09ORklHXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBTQUQgU1RBVEUgT0YgQUZGQUlSUzogdGhlcmUgaXMgbm8gd2F5IChBRkFJQ1QpIHRvIG1vZGlmeVxuICAgICAgLy8gX3J0Y0Nvbm5lY3Rpb24uY29uZmlndXJhdGlvbiBhZnRlciB0aGUgUnRjQ29ubmVjdGlvbiBjdG9yLlxuICAgICAgLy8gV09SS0FST1VORDogd2Ugd2FpdCB1bnRpbCB0aGUgZmlyc3Qgd2Vic29ja2V0IG1lc3NhZ2UgKGUuZy4gdGhlIHNkcCBvZmZlciksXG4gICAgICAvLyB3aGljaCBjb3VsZCBpbmNsdWRlIFRVUk4gY29uZmlnIGluZm8sIGJlZm9yZSB3ZSBpbml0aWFsaXplIF9ydGNDb25uZWN0aW9uLlxuICAgICAgaWYgKCF0aGlzLl9ydGNDb25uZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2luaXRSdGNDb25uZWN0aW9uKCk7XG4gICAgICAgIC8vIElmIHNvbWVvbmUgaGFzIGFscmVhZHkgc2V0IHRoZSBhdWRpbyBpbnB1dCBzdHJlYW0sIGFkZCBpdCB0byB0aGUgcnRjIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gbm93IHRoYXQgaXQncyBiZWVuIGluaXRpYWxpemVkLlxuICAgICAgICBpZiAodGhpcy5fYXVkaW9JbnB1dFN0cmVhbSkge1xuICAgICAgICAgIHRoaXMuX2FkZEF1ZGlvSW5wdXRTdHJlYW0odGhpcy5fYXVkaW9JbnB1dFN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ZpZGVvSW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICB0aGlzLl9hZGRWaWRlb0lucHV0U3RyZWFtKHRoaXMuX3ZpZGVvSW5wdXRTdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcnRjQ29ubmVjdGlvbiA9IHRoaXMuX3J0Y0Nvbm5lY3Rpb247XG4gICAgXG4gICAgICAvLyBGb3JjZSBvdXIgZGVzaXJlZCBiaXRyYXRlIGJ5IG11bmdpbmcgdGhlIFNEUCwgYW5kIGNyZWF0ZSBhIHNlc3Npb24gZGVzY3JpcHRpb24gZm9yIGl0XG4gICAgICBzaWduYWwuc2RwID0gc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9mb3JjZUJpdHJhdGVVcChzaWduYWwuc2RwKTsgXG4gICAgICBjb25zdCBkZXNjID0gbmV3IGNyb3NzUGxhdGZvcm1SVENTZXNzaW9uRGVzY3JpcHRpb24oc2lnbmFsKTtcblxuICAgICAgLy8gU2V0IHRoZSBkZXNjcmlwdGlvbiBvbiB0aGUgUlRDIGNvbm5lY3Rpb24sIGFuZCBzZW5kIGFuZCBoYW5kbGUgdGhlIHZhcmlvdXMgU0RQc1xuICAgICAgcnRjQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjKVxuICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBhbnN3ZXJcbiAgICAgICByZXR1cm4gcnRjQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgIH0pXG4gICAgICAudGhlbihmdW5jdGlvbihhbnN3ZXI6IGFueSkge1xuICAgICAgICAvLyBGb3JjZSBzdGVyZW8gb24gdGhlIGRvd25zdHJlYW0gc3RyZWFtIGJ5IG11bmdpbmcgdGhlIFNEUFxuICAgICAgICBhbnN3ZXIuc2RwID0gc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9mb3JjZVN0ZXJlb0Rvd24oYW5zd2VyLnNkcCk7IFxuICAgICAgICBSYXZpVXRpbHMubG9nKFwiQW5zd2VyOlwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhhbnN3ZXIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAvLyBzZXQgbG9jYWwgZGVzY3JpcHRpb25cbiAgICAgICAgcmV0dXJuIHJ0Y0Nvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgICAgdHlwZTogXCJhbnN3ZXJcIixcbiAgICAgICAgICBzZHA6IHJ0Y0Nvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbixcbiAgICAgICAgICB1dWlkOiByYXZpU2Vzc2lvbi5nZXRVVUlEKClcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGVzYyA9IEpTT04uc3RyaW5naWZ5KG1zZyk7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJTZW5kaW5nIGFuc3dlciB0byBzZXJ2ZXJcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIC8vIFNlbmQgdGhlIGZpbmFsIHJlc3VsdCBiYWNrIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5zZW5kKGRlc2MpO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKHNpZ25hbC5pY2UpIHtcbiAgICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCByZW1vdGUgSUNFIGNhbmRpZGF0ZTogXCIgKyBKU09OLnN0cmluZ2lmeShzaWduYWwuaWNlKSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICBpZiAodGhpcy5fcnRjQ29ubmVjdGlvbikge1xuICAgICAgICB0aGlzLl9ydGNDb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShzaWduYWwuaWNlKVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiQWRkZWQgcmVtb3RlIGNhbmRpZGF0ZVwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGU6IGFueSkge1xuICAgICAgICAgIFJhdmlVdGlscy5lcnIoXCJFcnJvciBhdHRlbXB0aW5nIHRvIGFkZCByZW1vdGUgSUNFIGNhbmRpZGF0ZTogXCIgKyBlLm1lc3NhZ2UsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEtlZXAgdHJhY2sgb2YgaWNlIGNhbmRpZGF0ZXMgdW50aWwgd2UgaGF2ZSBhbiBydGNDb25uZWN0aW9uXG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJJZ25vcmUgaWNlIGNhbmRpZGF0ZSB1bnRpbCB3ZSBoYXZlIGFuIHJ0Y0Nvbm5lY3Rpb24sIGljZT0nXCIgKyBKU09OLnN0cmluZ2lmeShzaWduYWwpICsgXCInXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb21lIG90aGVyIGhhbmRsZXIncyBwcm9ibGVtXG4gICAgICBSYXZpVXRpbHMubG9nKFwiVW5rbm93biBtZXNzYWdlIFwiICsgSlNPTi5zdHJpbmdpZnkoc2lnbmFsKSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogQWRkIGEgaGFuZGxlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG5ldyBzdGF0cyBnZW5lcmF0ZWQuXG4gICAqIFRoZXNlIGFyZSBzdG9yZWQgaW4gYSBTZXQgb2YgRnVuY3Rpb25zOyB0aGVyZWZvcmUsIGEgZ2l2ZW4gZnVuY3Rpb25cbiAgICogY2FuIG9ubHkgZXhpc3Qgb25jZSBpbiB0aGlzIFNldC5cbiAgICogXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmF2aVNlc3Npb25+c3RhdHNPYnNlcnZlckNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2sgaGFuZGxlciB0aGF0IHNob3VsZCBoYW5kbGUgYSBzdGF0ZSBjaGFuZ2UgZXZlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBhZGQgc3VjY2VlZGVkXG4gICAqL1xuICBfYWRkU3RhdHNPYnNlcnZlcihvYnNlcnZlcjogRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHNXYXRjaGVyLmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBoYW5kbGVyIHNvIHRoYXQgaXQgc3RvcHMgbGlzdGVuaW5nIGZvciBzdGF0cyB1cGRhdGVzLlxuICAgKiBcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn5zdGF0c09ic2VydmVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHJlbW92YWwgd2FzIHN1Y2Nlc3NmdWwgKGkuZS4gZGlkIG5vdCB0aHJvdyBhbiBlcnJvciAtLSBub3RlIHRoYXQgdGhpcyBkb2VzXG4gICAqIE5PVCBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciB3YXMgaW4gdGhlIHNldCBpbiB0aGUgZmlyc3QgcGxhY2UpXG4gICAqL1xuICBfcmVtb3ZlU3RhdHNPYnNlcnZlcihvYnNlcnZlcjogRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHNXYXRjaGVyLnJlbW92ZU9ic2VydmVyKG9ic2VydmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvc2UgdGhlIGdldFN0YXRzIGNhbGwgb24gdGhlIHJ0Y1BlZXJDb25uZWN0aW9uXG4gICAqIHVzZWQgYnkgdGhlIHN0YXRzV2F0Y2hlclxuICAgKi9cbiAgYXN5bmMgX2dldFN0YXRzKHNlbGVjdG9yOiBhbnkgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuX3J0Y0Nvbm5lY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydGNDb25uZWN0aW9uLmdldFN0YXRzKHNlbGVjdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgUmF2aVV0aWxzIH0gZnJvbSBcIi4vUmF2aVV0aWxzXCI7XG5cbi8qKlxuICogRW51bSBmb3IgcmVwcmVzZW50aW5nIGRpZmZlcmVudCBwb3NzaWJsZSBzdGF0ZXNcbiAqIHRoYXQgYSBSQVZJIHNpZ25hbGluZ0Nvbm5lY3Rpb24gbWlnaHQgYmUgaW4uXG4gKlxuICogXCJVTkFWQUlMQUJMRVwiIGlzIGEgY3VzdG9tIHN0YXRlIHRoYXQgZ2V0cyBzZXRcbiAqIGlmIHRoZSBzZXJ2ZXIgaXMgaW4gYSBcInJ1bm5pbmcsIGJ1dCBub3QgY3VycmVudGx5XG4gKiBhY2NlcHRpbmcgaW5jb21pbmcgY29ubmVjdGlvbnNcIiBzdGF0ZS5cbiAqIFxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZW51bSBSYXZpU2lnbmFsaW5nU3RhdGVzIHtcbiAgQ09OTkVDVElORyA9IFwiY29ubmVjdGluZ1wiLFxuICBPUEVOID0gXCJvcGVuXCIsXG4gIEVSUk9SID0gXCJlcnJvclwiLFxuICBDTE9TSU5HID0gXCJjbG9zaW5nXCIsXG4gIENMT1NFRCA9IFwiY2xvc2VkXCIsXG4gIFVOQVZBSUxBQkxFID0gXCJ1bmF2YWlsYWJsZVwiXG59O1xuXG4vKiogXG4gKlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIFNpZ25hbGluZyBjb25uZWN0aW9uIHNwZWNpZmljYWxseSBmb3IgaGFuZGxpbmcgUkFWSSBzZXNzaW9ucy5cbiAqIFRoaXMgZ2V0cyB1c2VkIGJ5IHRoZSBSYXZpU2Vzc2lvbiAoYW5kIGl0cyBQZWVyQ29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbilcbiAqIHRvIHNldCB1cCBhIFJhdmlTZXNzaW9uIGNvbm5lY3Rpb24uXG4gKiBUaGlzIGNsYXNzIHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgYnkgdGhlIFJBVkkgY29uc3VtZXIsIGFuZCB0aGVuIHVzZWQgdG8gb3Blbiwgd29yayB3aXRoLCBhbmQgY2xvc2UgXG4gKiBSQVZJIHNlc3Npb25zIGFzIG5lZWRlZC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiB7XG4gIC8qKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKlxuICAgKiB0aGlzLl9zdGF0ZWNoYW5nZUhhbmRsZXJzICAgLy8gQSBsaXN0IG9mIGhhbmRsZXJzIHRvIGNhbGwgd2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VzXG4gICAqIHRoaXMuX21lc3NhZ2VIYW5kbGVycyAgICAgICAvLyBBIGxpc3Qgb2YgaGFuZGxlcnMgdG8gY2FsbCB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZFxuICAgKlxuICAgKiB0aGlzLl9zaWduYWxpbmdJbXBsZW1lbnRhdGlvbiAgIC8vIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBzaWduYWxpbmcgdG8gdXNlXG4gICAqXG4gICAqIHRoaXMuX3N0YXRlICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIGNvbm5lY3Rpb25cbiAgICpcbiAgICogX3Jlc29sdmVPcGVuLCBfcmVqZWN0T3BlbiwgX3Jlc29sdmVDbG9zZSwgYW5kIF9yZWplY3RDbG9zZTogVXNlZCBmb3IgcmVzb2x2aW5nIHRoZSBQcm9taXNlc1xuICAgKiAgICAgbWFkZSBieSB0aGUgb3BlbiBhbmQgY2xvc2UgZnVuY3Rpb25zLCB3aGljaCBnZXQgaGFuZGxlZCBvdXRzaWRlIG9mIHRob3NlIGZ1bmN0aW9ucyB0aGVtc2VsdmVzXG4gICAqL1xuICBfc3RhdGVDaGFuZ2VIYW5kbGVyczogU2V0PEZ1bmN0aW9uPjtcbiAgX21lc3NhZ2VIYW5kbGVyczogU2V0PEZ1bmN0aW9uPjtcbiAgX3N0YXRlOiBSYXZpU2lnbmFsaW5nU3RhdGVzO1xuICBfc2lnbmFsaW5nSW1wbGVtZW50YXRpb246IFJhdmlTaWduYWxpbmdXZWJTb2NrZXRJbXBsZW1lbnRhdGlvbjtcblxuICBfcmVzb2x2ZU9wZW46IEZ1bmN0aW9uOyBfcmVqZWN0T3BlbjogRnVuY3Rpb247XG4gIF9yZXNvbHZlQ2xvc2U6IEZ1bmN0aW9uOyBfcmVqZWN0Q2xvc2U6IEZ1bmN0aW9uO1xuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblxuICAgKiBEZWZhdWx0cyB0aGUgaGFuZGxlcnNcbiAgICogYW5kIGluaXRpYWxpemVzIHRoZSBzdGF0ZSB0byBSYXZpU2lnbmFsaW5nU3RhdGVzLkNMT1NFRC5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiQ29uc3RydWN0b3JcIiwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHRoZSBsaXN0IG9mIGhhbmRsZXJzXG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlcnMgPSBuZXcgU2V0KCk7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcbiAgICB0aGlzLl9zdGF0ZSA9IFJhdmlTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEO1xuICAgIFxuICAgIC8vIElmIHdlIHdhbnRlZCB0byB1c2UgYSBkaWZmZXJlbnQgc2lnbmFsaW5nIGltcGxlbWVudGF0aW9uLFxuICAgIC8vIHdlIHdvdWxkIG5ldygpIGl0IGhlcmUuIChUT0RPOiBNYWtlIHRoaXMgY29uZmlndXJhYmxlIGluIHNvbWVcbiAgICAvLyBpbnRlcmVzdGluZyB3YXkuIEZvciBub3csIGl0J3MgZW5vdWdoIGp1c3QgdG8gbWFrZSBpdCBlYXNpbHkgXG4gICAgLy8gc3dhcHBhYmxlIGluIHRoZSBjb2RlIGhlcmUuKVxuICAgIHRoaXMuX3NpZ25hbGluZ0ltcGxlbWVudGF0aW9uID0gbmV3IFJhdmlTaWduYWxpbmdXZWJTb2NrZXRJbXBsZW1lbnRhdGlvbih0aGlzKTtcbiAgICBcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uXG4gICAqIFxuICAgKiBAcmV0dXJucyB7UmF2aVNpZ25hbGluZ1N0YXRlc31cbiAgICovXG4gIGdldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBsaXN0ZW5pbmcgdG8gc3RhdGUgY2hhbmdlc1xuICAgKiBAY2FsbGJhY2sgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25+c3RhdGVDaGFuZ2VDYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgQW4gb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIGluZm9ybWF0aW9uXG4gICAqIGFib3V0IHRoZSBzdGF0ZSBjaGFuZ2UuIFRoaXMgaW5jbHVkZXMgdGhlIFwiZXZlbnQuc3RhdGVcIiBrZXksXG4gICAqIHdoaWNoIHdpbGwgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgdmFsdWUgZnJvbSB0aGUgUmF2aVNlc3Npb25TdGF0ZXMgZW51bS5cbiAgICovXG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIHRvIHRoZSBzZXQgb2Ygc3RhdGUgY2hhbmdlIGhhbmRsZXJzLlxuICAgKiBBbGwgaGFuZGxlcnMgaW4gdGhpcyBzZXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2l0aCBhIGNvcHkgb2YgdGhlIGV2ZW50XG4gICAqIGFueSB0aW1lIHRoZSBzdGF0ZSBvZiB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24gY2hhbmdlcy5cbiAgICogVGhlc2UgYXJlIHN0b3JlZCBpbiBhIFNldCBvZiBGdW5jdGlvbnM7IHRoZXJlZm9yZSwgYSBnaXZlbiBmdW5jdGlvblxuICAgKiBjYW4gb25seSBleGlzdCBvbmNlIGluIHRoaXMgU2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1JhdmlTaWduYWxpbmdDb25uZWN0aW9ufnN0YXRlQ2hhbmdlQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGFkZCBzdWNjZWVkZWRcbiAgICovXG4gIGFkZFN0YXRlQ2hhbmdlSGFuZGxlcihjaGFuZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzLmFkZChjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIGFkZGluZyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyOiBcIiArXG4gICAgICAgIGVyci5tZXNzYWdlLCBcIlJhdmlTaWduYWxpbmdDb25uZWN0aW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgaGFuZGxlciBmcm9tIHRoZSBsaXN0IG9mIHN0YXRlIGNoYW5nZSBoYW5kbGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbn5zdGF0ZUNoYW5nZUNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2sgaGFuZGxlciB0aGF0IGhhcyBiZWVuIGhhbmRsaW5nIGEgc3RhdGUgY2hhbmdlIGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcmVtb3ZhbCB3YXMgc3VjY2Vzc2Z1bCAoaS5lLiBkaWQgbm90IHRocm93IGFuIGVycm9yIC0tIG5vdGUgdGhhdCB0aGlzIGRvZXNcbiAgICogTk9UIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIHdhcyBpbiB0aGUgc2V0IGluIHRoZSBmaXJzdCBwbGFjZSlcbiAgICovXG4gIHJlbW92ZVN0YXRlQ2hhbmdlSGFuZGxlcihjaGFuZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXR2YWwgPSB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzLmRlbGV0ZShjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIHJlbW92aW5nIGEgc3RhdGUgY2hhbmdlIGhhbmRsZXI6IFwiICtcbiAgICAgICAgZXJyLm1lc3NhZ2UsIFwiUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25cIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgbGlzdGVuaW5nIGZvciBtZXNzYWdlc1xuICAgKiBAY2FsbGJhY2sgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25+bWVzc2FnZUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEEgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICovXG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIHRvIHRoZSBsaXN0IG9mIG1lc3NhZ2UgcmVjZWl2ZWQgaGFuZGxlcnMuXG4gICAqIEFsbCBoYW5kbGVycyBpbiB0aGlzIGxpc3Qgd2lsbCBiZSB0cmlnZ2VyZWQgd2l0aCBhIGNvcHkgb2YgdGhlIFxuICAgKiBpbmNvbWluZyBtZXNzYWdlIGFueSB0aW1lIGEgbWVzc2FnZSBpcyByZWNlaXZlZC5cbiAgICogVGhlc2UgYXJlIHN0b3JlZCBpbiBhIFNldCBvZiBGdW5jdGlvbnM7IHRoZXJlZm9yZSwgYSBnaXZlbiBmdW5jdGlvblxuICAgKiBjYW4gb25seSBleGlzdCBvbmNlIGluIHRoaXMgU2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1JhdmlTaWduYWxpbmdDb25uZWN0aW9ufm1lc3NhZ2VDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBzaG91bGQgaGFuZGxlIGEgbWVzc2FnZSByZWNlaXZlZCBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGFkZCBzdWNjZWVkZWRcbiAgICovXG4gIGFkZE1lc3NhZ2VIYW5kbGVyKG1lc3NhZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlcnMuYWRkKG1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIGFkZGluZyBhIG1lc3NhZ2UgaGFuZGxlcjogXCIgK1xuICAgICAgICBlcnIubWVzc2FnZSwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGhhbmRsZXIgZnJvbSB0aGUgbGlzdCBvZiBtZXNzYWdlIHJlY2VpdmVkIGhhbmRsZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JhdmlTaWduYWxpbmdDb25uZWN0aW9ufm1lc3NhZ2VDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBoYXMgYmVlbiBoYW5kbGluZyBhIG1lc3NhZ2UgcmVjZWl2ZWQgZXZlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSByZW1vdmFsIHdhcyBzdWNjZXNzZnVsIChpLmUuIGRpZCBub3QgdGhyb3cgYW4gZXJyb3IgLS0gbm90ZSB0aGF0IHRoaXMgZG9lc1xuICAgKiBOT1QgaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgd2FzIGluIHRoZSBzZXQgaW4gdGhlIGZpcnN0IHBsYWNlKVxuICAgKi9cbiAgcmVtb3ZlTWVzc2FnZUhhbmRsZXIobWVzc2FnZUhhbmRsZXI6IEZ1bmN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVycy5kZWxldGUobWVzc2FnZUhhbmRsZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKFwiRXJyb3IgcmVtb3ZpbmcgYSBzdGF0ZSBjaGFuZ2UgaGFuZGxlcjogXCIgK1xuICAgICAgICBlcnIubWVzc2FnZSwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gYSBzaWduYWxpbmcgY29ubmVjdGlvbiB0byBhIHBhcnRpY3VsYXIgVVJMLiBSZXR1cm5zIGEgUHJvbWlzZVxuICAgKiB0aGF0IHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiBpcyBjb25uZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBVUkwgVGhlIFVSTCBvZiB0aGUgc2lnbmFsaW5nIHNlcnZlcidzIGVuZHBvaW50IChlLmcuICd3c3M6Ly9mb28uYmFyLmJhejo4ODg5JylcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBvcGVuUkFWSVNpZ25hbGluZ0Nvbm5lY3Rpb24oVVJMOiBzdHJpbmcpIHtcbiAgICB2YXIgc2lnbmFsaW5nQ29ubmVjdGlvbiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBSYXZpU2lnbmFsaW5nU3RhdGVzLk9QRU4pIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgIFwiVGhlcmUgaXMgYWxyZWFkeSBhbiBvcGVuIFdlYlNvY2tldCBjb25uZWN0aW9uLiBUbyByZWNvbm5lY3QsIGZpcnN0IGNsb3NlIHRoZSBleGlzdGluZyBXZWJTb2NrZXQgYW5kIHRoZW4gYXR0ZW1wdCB0byBvcGVuIGFnYWluLlwiXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9yZXNvbHZlT3BlbiA9IHJlc29sdmU7XG4gICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9yZWplY3RPcGVuID0gcmVqZWN0O1xuICAgICAgLy8gU3RhcnQgdGhlIFwib3BlbmluZ1wiIHByb2Nlc3NcbiAgICAgIFJhdmlVdGlscy5sb2coXCJPcGVuaW5nIHNpZ25hbGluZyBjb25uZWN0aW9uIHRvIFwiICsgVVJMLCBcIlJhdmlTaWduYWxpbmdDb250cm9sbGVyXCIpO1xuICAgICAgbGV0IGV2ZW50ID0ge1wic3RhdGVcIjpSYXZpU2lnbmFsaW5nU3RhdGVzLkNPTk5FQ1RJTkd9O1xuICAgICAgdGhpcy5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuQ09OTkVDVElORyk7IFxuXG4gICAgICAvLyBBbmQgY2FsbCB0aGUgaW1wbGVtZW50YXRpb24ncyBvcGVuIG1ldGhvZFxuICAgICAgdGhpcy5fc2lnbmFsaW5nSW1wbGVtZW50YXRpb24uX29wZW4oVVJMKTtcbiAgICB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBzaWduYWxpbmcgc2VydmVyXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICovXG4gIHNlbmQobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fc2lnbmFsaW5nSW1wbGVtZW50YXRpb24uX3NlbmQobWVzc2FnZSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24uIFJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgdGhlIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjbG9zZVJBVklTaWduYWxpbmdDb25uZWN0aW9uKCkge1xuICAgIHZhciBzaWduYWxpbmdDb25uZWN0aW9uID0gdGhpcztcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFJhdmlTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICBcIlNpZ25hbGluZyBjb25uZWN0aW9uIGlzIGFscmVhZHkgY2xvc2VkLlwiXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9yZXNvbHZlQ2xvc2UgPSByZXNvbHZlO1xuICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5fcmVqZWN0Q2xvc2UgPSByZWplY3Q7XG4gICAgICAvLyBTdGFydCB0aGUgXCJjbG9zaW5nXCIgcHJvY2Vzc1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIkNsb3Npbmcgc2lnbmFsaW5nIGNvbm5lY3Rpb25cIiwgXCJSYXZpU2lnbmFsaW5nQ29udHJvbGxlclwiKTtcbiAgICAgIGxldCBldmVudCA9IHtcInN0YXRlXCI6UmF2aVNpZ25hbGluZ1N0YXRlcy5DTE9TSU5HfTtcbiAgICAgIHRoaXMuX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBSYXZpU2lnbmFsaW5nU3RhdGVzLkNMT1NJTkcpOyBcblxuICAgICAgLy8gQW5kIGNhbGwgdGhlIGltcGxlbWVudGF0aW9uJ3Mgb3BlbiBtZXRob2RcbiAgICAgIHRoaXMuX3NpZ25hbGluZ0ltcGxlbWVudGF0aW9uLl9jbG9zZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEdlbmVyaWMgaGFuZGxlcnMgKi9cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVTdGF0ZUNoYW5nZShldmVudDogYW55ID0ge30sIHN0YXRlOiBSYXZpU2lnbmFsaW5nU3RhdGVzKSB7XG4gICAgLy8gQWx3YXlzIHRyeSB0byBmdWxmaWxsIGFueSBvcGVuIHByb21pc2VzLCBldmVuIGlmIHRoZSBzdGF0ZSBoYXNuJ3QgY2hhbmdlZFxuICAgIHRoaXMuX2Z1bGZpbGxQcm9taXNlcyhldmVudCwgc3RhdGUpO1xuXG4gICAgLy8gQnV0IG9ubHkgY2FsbCBoYW5kbGVycyBpZiB0aGUgc3RhdGUgZGlkLCBpbiBmYWN0LCBjaGFuZ2VcbiAgICBpZiAoc3RhdGUgIT09IHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIGV2ZW50W1wic3RhdGVcIl0gPSBzdGF0ZTtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIl9oYW5kbGVTdGF0ZUNoYW5nZTogXCIgKyBSYXZpVXRpbHMuc2FmZWx5UHJpbnRhYmxlKGV2ZW50KSwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogR2V0cyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHN0YXRlIGNoYW5nZXMgKGFuZCBzb21ldGltZXMgd2hlbiBpdCBkb2Vzbid0LFxuICAgKiBidXQgd2hlbiB3ZSBqdXN0IHdhbnQgdG8gbWFrZSBzdXJlKS4gRGVwZW5kaW5nIG9uIHRoZSBuZXcgKG9yIGN1cnJlbnQpIHN0YXRlLFxuICAgKiB0aGlzIHdpbGwgYXBwcm9wcmlhdGVseSBmdWxmaWxsIG91dHN0YW5kaW5nIHByb21pc2VzIHRoYXQgYXJlIHBlbmRpbmdcbiAgICogaW4gZWl0aGVyIHRoZSBvcGVuIG9yIGNsb3NlIG1ldGhvZCAob3IgYm90aCkuXG4gICAqL1xuICBfZnVsZmlsbFByb21pc2VzKGV2ZW50OiBhbnkgPSB7fSwgc3RhdGU6IFJhdmlTaWduYWxpbmdTdGF0ZXMpIHtcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gZXZlbnQucmVhc29uIHx8IGV2ZW50Lm1lc3NhZ2UgfHwgc3RhdGU7XG4gICAgUmF2aVV0aWxzLmxvZyhcIl9mdWxmaWxsUHJvbWlzZXM6IEhhbmRsaW5nIHN0YXRlIFwiICsgc3RhdGUsIFwiUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25cIik7XG4gICAgc3dpdGNoKHN0YXRlKSB7XG4gICAgICBjYXNlIFJhdmlTaWduYWxpbmdTdGF0ZXMuT1BFTjpcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVPcGVuKSB0aGlzLl9yZXNvbHZlT3BlbigpO1xuICAgICAgICBpZiAodGhpcy5fcmVqZWN0Q2xvc2UpIHRoaXMuX3JlamVjdENsb3NlKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2lnbmFsaW5nU3RhdGVzLkNMT1NFRDpcbiAgICAgICAgaWYgKHRoaXMuX3JlamVjdE9wZW4pIHRoaXMuX3JlamVjdE9wZW4oZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVDbG9zZSkgdGhpcy5fcmVzb2x2ZUNsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2lnbmFsaW5nU3RhdGVzLkVSUk9SOlxuICAgICAgICBpZiAodGhpcy5fcmVqZWN0T3BlbikgdGhpcy5fcmVqZWN0T3BlbihlcnJvck1lc3NhZ2UpO1xuICAgICAgICBpZiAodGhpcy5fcmVqZWN0Q2xvc2UpIHRoaXMuX3JlamVjdENsb3NlKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2lnbmFsaW5nU3RhdGVzLlVOQVZBSUxBQkxFOlxuICAgICAgICBpZiAodGhpcy5fcmVqZWN0T3BlbikgdGhpcy5fcmVqZWN0T3BlbihlcnJvck1lc3NhZ2UpO1xuICAgICAgICBpZiAodGhpcy5fcmVzb2x2ZUNsb3NlKSB0aGlzLl9yZXNvbHZlQ2xvc2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBEbyBub3RoaW5nIGZvciB0aGUgXCJpbiBwcm9ncmVzc1wiIHN0YXRlcywgbGlrZSBcIk9QRU5JTkdcIiBvciBcIkNMT1NJTkdcIlxuICAgICAgICBSYXZpVXRpbHMubG9nKFwiX2Z1bGZpbGxQcm9taXNlczogU2tpcHBpbmcgaW4tcHJvZ3Jlc3Mgc3RhdGUgXCIgKyBzdGF0ZSwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZU1lc3NhZ2UobWVzc2FnZTogYW55KSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIl9kb09ubWVzc2FnZTogXCIgKyBSYXZpVXRpbHMuc2FmZWx5UHJpbnRhYmxlKG1lc3NhZ2UpLCBcIlJhdmlTaWduYWxpbmdDb25uZWN0aW9uXCIpO1xuICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gdGhlIHNlcnZlciBzaWRlIGlzIGluIGFuIFwidW5hdmFpbGFibGVcIiBzdGF0ZSAtLSBpdCB3aWxsXG4gICAgLy8gc2VuZCBiYWNrIGEgc3BlY2lhbCBKU09OIHBhY2tldCBtYXJraW5nIGl0c2VsZiBhcyBcInNlcnZpY2UtdW5hdmFpbGFibGVcIi4gSGFuZGxlIHRoaXMgc2l0dWF0aW9uXG4gICAgLy8gZXhwbGljaXRseSBhcyBhIGN1c3RvbSBzdGF0ZS4gKFRoaXMgaXMga2luZCBvZiBhIGxvdCBvZiBjb2RlIGZvciBhIHJhcmUgb2NjdXJyZW5jZSwgYnV0IHdlXG4gICAgLy8gZG9uJ3Qgc2VuZCBhIHRvbiBvZiBtZXNzYWdlcyBvdmVyIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBhbmQgc28gSSBmZWVsIHJlYXNvbmFibHkgb2theSBhYm91dFxuICAgIC8vIGRvaW5nIHRoaXMgY2hlY2sgb24gZXZlcnkgbWVzc2FnZS4gLU1DSCkpXG4gICAgaWYgKG1lc3NhZ2UuZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VEYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VEYXRhLmVycm9yICYmIG1lc3NhZ2VEYXRhLmVycm9yID09PSBcInNlcnZpY2UtdW5hdmFpbGFibGVcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVN0YXRlQ2hhbmdlKHt9LCBSYXZpU2lnbmFsaW5nU3RhdGVzLlVOQVZBSUxBQkxFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IHBhcnNlIHRoZSBtZXNzYWdlIGFzIEpTT04sIGl0J3MgZGVmaW5pdGVseVxuICAgICAgICAgICAgLy8gbm90IHRoZSBcInVuYXZhaWxhYmxlXCIgbWVzc2FnZSBhbmQgcHJvYmFibHkgbWVhbnQgZm9yIHNvbWVvbmUgZWxzZSxcbiAgICAgICAgICAgIC8vIHNvIG5vLW9wIGhlcmUgYW5kIGp1c3QgbGV0IHRoZSByZXN0IG9mIHRoZSBjb2RlIGRlYWwgd2l0aCBpdC5cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVyKG1lc3NhZ2UpOyBcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbn0gLy8gRW5kIG9mIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLypcblRPRE86IEFkZCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGEgUmF2aVNpZ25hbGluZyBcImNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb25cIlxuY2xhc3Mgc2hvdWxkIGxvb2sgbGlrZS5cblxuQ29uc3RydWN0b3I6IHRha2VzIGEgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24gc28gdGhhdCBpdCBjYW4gdXNlIGl0cyBoYW5kbGVycy4gVGhlIGNsYXNzXG5pcyBleHBlY3RlZCB0byBhc3NpZ24gdGhlIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uJ3MgX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBzdGF0ZSkgYW5kIF9oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpXG5oYW5kbGVycyB0byBhcHByb3ByaWF0ZSBldmVudHMgKGFuZC9vciB0aHJvdyB0aG9zZSBldmVudHMgaXRzZWxmKS5cblxuUmVxdWlyZWQgbWV0aG9kczogX29wZW4oVVJMKSwgX3NlbmQobWVzc2FnZSksIGFuZCBfY2xvc2UoKVxuXG4qL1xuXG4vKipcbiAqIFVzZSB0aGUgY29ycmVjdCBjbGFzc2VzIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIGJlaW5nIFxuICogY2FsbGVkIGZyb20gbm9kZSBvciB0aGUgYnJvd3Nlci5cbiAqL1xubGV0IGNyb3NzUGxhdGZvcm1XZWJTb2NrZXQ6YW55ID0gbnVsbDtcbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gbm9kZSBjb250ZXh0XG4gIGNyb3NzUGxhdGZvcm1XZWJTb2NrZXQgPSByZXF1aXJlKCd3cycpO1xufSBlbHNlIHtcbiAgLy8gYnJvd3NlciBjb250ZXh0XG4gIGNyb3NzUGxhdGZvcm1XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG59XG5cbi8qKiBcbiAqIEEgV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIGZvciB0aGUgUmF2aVNpZ25hbGluZyBjbGFzc1xuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUmF2aVNpZ25hbGluZ1dlYlNvY2tldEltcGxlbWVudGF0aW9uIHtcbiAgX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uOiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgX3dlYlNvY2tldDogYW55O1xuICBcbiAgLyoqXG4gICAqIFwiQ2xhc3NcIiB2YXJpYWJsZXMgdG8gYmUgYXdhcmUgb2Y6XG4gICAqIHRoaXMuX3dlYlNvY2tldCAgICAgIC8vIFRoZSBhY3R1YWwgY29ubmVjdGVkIHdlYiBzb2NrZXRcbiAgICogdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24gLy8gdGhlIFwicGFyZW50XCIgc2lnbmFsaW5nIGNvbm5lY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSYXZpU2lnbmFsaW5nV2ViU29ja2V0SW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn0gcmF2aVNlc3Npb24gVGhlIG93bmVyIG9mIHRoaXMgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb246IFJhdmlTaWduYWxpbmdDb25uZWN0aW9uKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aVNpZ25hbGluZ1dlYlNvY2tldEltcGxlbWVudGF0aW9uXCIpO1xuICAgIHRoaXMuX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uID0gcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb247XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29wZW4oc29ja2V0QWRkcmVzczogc3RyaW5nKSB7XG4gICAgdmFyIHNpZ25hbGluZ0Nvbm5lY3Rpb24gPSB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjtcblxuICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBhbiBvcGVuIHdlYnNvY2tldCwgbWFrZSBzdXJlIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBrbm93cyBhYm91dCBpdCwgYW5kIHJldHVybiBpbW1lZGlhdGVseVxuICAgIGlmICh0aGlzLl93ZWJTb2NrZXQgJiYgdGhpcy5fd2ViU29ja2V0LnJlYWR5U3RhdGUgPT09IGNyb3NzUGxhdGZvcm1XZWJTb2NrZXQuT1BFTikge1xuICAgICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9oYW5kbGVTdGF0ZUNoYW5nZSh7fSwgUmF2aVNpZ25hbGluZ1N0YXRlcy5PUEVOKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3dlYlNvY2tldCA9IG5ldyBjcm9zc1BsYXRmb3JtV2ViU29ja2V0KHNvY2tldEFkZHJlc3MpO1xuXG4gICAgLy8gVGhlIFdlYlNvY2tldCdzIG9wZW4sIGVycm9yLCBhbmQgY2xvc2UgZXZlbnRzIHdpbGwganVzdFxuICAgIC8vIGNhbGwgYmFjayB1cCB0byB0aGUgbWFpbiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbidzIFxuICAgIC8vIHN0YXRlQ2hhbmdlSGFuZGxlcnMuXG4gICAgLy8gKFdlIGNhbid0IHNldCB0aGVzZSB1bnRpbCB3ZSBhdHRlbXB0IHRvIG9wZW4gdGhlXG4gICAgLy8gV2ViU29ja2V0LCBiZWNhdXNlIHRoZXJlJ3Mgbm8gb3RoZXIgV2ViU29ja2V0IGNvbnN0cnVjdG9yLilcbiAgICB0aGlzLl93ZWJTb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgc2lnbmFsaW5nQ29ubmVjdGlvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuT1BFTik7IH0pO1xuICAgIHRoaXMuX3dlYlNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgc2lnbmFsaW5nQ29ubmVjdGlvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuRVJST1IpOyB9KTtcbiAgICB0aGlzLl93ZWJTb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBmdW5jdGlvbihldmVudDogYW55KSB7IFxuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuY29kZSAmJiBldmVudC5jb2RlID4gNDAwMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBcImNsb3NlXCIgZXZlbnQgaXMgcmVhbGx5IGFuIGVycm9yLCBiZWNhdXNlIHdlJ3JlXG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgb25lIG9mIG91ciBjdXN0b20gZXJyb3IgY29kZXMuIFRyZWF0IGl0IGFzIHN1Y2guXG4gICAgICAgICAgICBSYXZpVXRpbHMuZXJyKFwiX2hhbmRsZVN0YXRlQ2hhbmdlOiBzaWduYWxpbmcgZXJyb3IgY29kZSBcIiArIGV2ZW50LmNvZGUgKyBcIjogIFwiICsgZXZlbnQucmVhc29uLCBcIlJhdmlTaWduYWxpbmdDb25uZWN0aW9uXCIpO1xuICAgICAgICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuRVJST1IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQW55IGFkZGl0aW9uYWwgbWVzc2FnaW5nIGhhbmRsaW5nIGdldHMgZG9uZSBieSB0aGUgbWFpblxuICAgIC8vIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uJ3MgbWVzc2FnZUhhbmRsZXJzXG4gICAgdGhpcy5fd2ViU29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihldmVudDogYW55KSB7IHNpZ25hbGluZ0Nvbm5lY3Rpb24uX2hhbmRsZU1lc3NhZ2UoZXZlbnQpOyB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VuZChtZXNzYWdlOiBhbnkpIHtcbiAgICBpZiAodGhpcy5fd2ViU29ja2V0ICYmIHRoaXMuX3dlYlNvY2tldC5yZWFkeVN0YXRlID09PSBjcm9zc1BsYXRmb3JtV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNlbmRpbmcgbWVzc2FnZSB0byBzZXJ2ZXI6IFwiICsgbWVzc2FnZSwgXCJSYXZpU2lnbmFsaW5nV2ViU29ja2V0SW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIHRoaXMuX3dlYlNvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2xvc2UoKSB7XG4gICAgdmFyIHNpZ25hbGluZ0Nvbm5lY3Rpb24gPSB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IGNsb3NlZCwgbWFrZSBzdXJlIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBrbm93cyBhYm91dCBpdCBhbmQgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgaWYgKCEgdGhpcy5fd2ViU29ja2V0IHx8IHRoaXMuX3dlYlNvY2tldC5yZWFkeVN0YXRlID09PSBjcm9zc1BsYXRmb3JtV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9oYW5kbGVTdGF0ZUNoYW5nZSh7fSwgUmF2aVNpZ25hbGluZ1N0YXRlcy5DTE9TRUQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3dlYlNvY2tldC5jbG9zZSgpO1xuICAgIHRoaXMuX3dlYlNvY2tldCA9IG51bGw7XG4gIH1cbn1cblxuIiwiaW1wb3J0IHsgUmF2aUNvbW1hbmRDb250cm9sbGVyIH0gZnJvbSBcIi4vUmF2aUNvbW1hbmRDb250cm9sbGVyXCI7XG5pbXBvcnQgeyBSYXZpVXRpbHMgfSBmcm9tIFwiLi9SYXZpVXRpbHNcIjtcblxuLyoqIFxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIEhhbmRsZXMgaW50ZXJhY3Rpbmcgd2l0aCBtZWRpYSBzdHJlYW1zIGZvciBSQVZJIHNlc3Npb25zLlxuICogVGhpcyBjbGFzcyBpcyBwcm92aWRlZCBieSBhIHtAbGluayBSYXZpU2Vzc2lvbn0gYW5kIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICpcbiAqIEV4YW1wbGUgdXNhZ2UgKHNldHRpbmcgYW4gYXVkaW8gb3V0cHV0IGNvbnRhaW5lcik6IFxuICogXG4gKiBgYGBcbiAqIHZhciBzdHJlYW1Db250cm9sbGVyID0gcmF2aVNlc3Npb24uZ2V0U3RyZWFtQ29udHJvbGxlcigpO1xuICogc3RyZWFtQ29udHJvbGxlci5zZXRBdWRpb0NvbnRhaW5lcihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVtb3RlQXVkaW8nKSk7XG4gKmBgYFxuICogICBcbiAqL1xuZXhwb3J0IGNsYXNzIFJhdmlTdHJlYW1Db250cm9sbGVyIHtcbiAgX2NvbW1hbmRDb250cm9sbGVyOiBSYXZpQ29tbWFuZENvbnRyb2xsZXI7XG4gIF9hdWRpb1N0cmVhbTogTWVkaWFTdHJlYW07XG4gIF92aWRlb1N0cmVhbTogTWVkaWFTdHJlYW07XG4gIF9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkOiBGdW5jdGlvbjtcbiAgX29uSW5wdXRBdWRpb0NoYW5nZWQ6IEZ1bmN0aW9uO1xuICBfb25JbnB1dFZpZGVvQ2hhbmdlZDogRnVuY3Rpb247XG4gIF92aWRlb0NvbnRhaW5lcjogSFRNTFZpZGVvRWxlbWVudDtcbiAgX2F1ZGlvQ29udGFpbmVyOiBIVE1MQXVkaW9FbGVtZW50O1xuICBfaW5wdXRBdWRpb1N0cmVhbTogTWVkaWFTdHJlYW07XG4gIF9pc1N0ZXJlbzogYm9vbGVhbjtcbiAgX2lucHV0VmlkZW9TdHJlYW06IE1lZGlhU3RyZWFtO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUkFWSSBzdHJlYW0gY29udHJvbGxlci4gXG4gICAqIE5lZWRzIGFjY2VzcyB0byBhIFJhdmlDb21tYW5kQ29udHJvbGxlciBzbyBpdCBjYW4gc2VuZCB2aWRlby1yZWxhdGVkIGNvbW1hbmRzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJhdmlDb21tYW5kQ29udHJvbGxlcjogUmF2aUNvbW1hbmRDb250cm9sbGVyKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aVN0cmVhbUNvbnRyb2xsZXJcIik7XG4gICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIgPSByYXZpQ29tbWFuZENvbnRyb2xsZXI7XG4gICAgXG4gICAgLy8gVGhlIGF1ZGlvIHN0cmVhbSBhbmQgdmlkZW8gc3RyZWFtIGdldCBzZXQgYnkgdGhlIFJhdmlTZXNzaW9uIHdoZW4gdGhlXG4gICAgLy8gYXBwcm9wcmlhdGUgZXZlbnRzIGFyZSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICB0aGlzLl9hdWRpb1N0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fdmlkZW9TdHJlYW0gPSBudWxsO1xuICAgIFxuICAgIC8vIERlZmF1bHQgZm9yIHRoZSB2aWRlbyBzdHJlYW0gc3RhdGUgY2hhbmdlIGhhbmRsZXJcbiAgICB0aGlzLl9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24gKHN0YXRlOiBhbnkpIHsgUmF2aVV0aWxzLmxvZyhcIm9udmlkZW9zdHJlYW1zdGF0ZWNoYW5nZWQgXCIgKyBzdGF0ZSwgXCJSYXZpU3RyZWFtQ29udHJvbGxlclwiKTt9XG4gICAgLy8gRGVmYXVsdCBmb3IgdGhlIGlucHV0IGF1ZGlvIHN0cmVhbSBjaGFuZ2UgaGFuZGxlclxuICAgIHRoaXMuX29uSW5wdXRBdWRpb0NoYW5nZWQgPSBudWxsO1xuICAgIHRoaXMuX29uSW5wdXRWaWRlb0NoYW5nZWQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBzdHJlYW0gY29udHJvbGxlciBpcyBhd2FyZSBvZiBhIHZpZGVvIHN0cmVhbSBjb21pbmcgZnJvbSB0aGUgUkFWSSBzZXJ2ZXIsIFxuICAgKiByZXR1cm4gaXQuIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyB2aWRlbyBzdHJlYW0gYXZhaWxhYmxlLlxuICAgKiBAcmV0dXJucyB7TWVkaWFTdHJlYW19XG4gICAqL1xuICBnZXRWaWRlb1N0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlkZW9TdHJlYW07XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZXQgYSB2aWRlbyBzdHJlYW0gZm9yIHRoaXMgc3RyZWFtIGNvbnRyb2xsZXIuIElmIHRoZXJlIGlzIGFsc28gYSB2aWRlbyBjb250YWluZXJcbiAgICogc2V0LCB0aGlzIHdpbGwgYXR0YWNoIHRoZSBzdHJlYW0gdG8gdGhhdCB2aWRlbyBjb250YWluZXIgYXMgd2VsbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRWaWRlb1N0cmVhbSh2aWRlb1N0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICB0aGlzLl92aWRlb1N0cmVhbSA9IHZpZGVvU3RyZWFtO1xuICAgIGlmICh0aGlzLl92aWRlb0NvbnRhaW5lcikge1xuICAgICAgdGhpcy5fdmlkZW9Db250YWluZXIuc3JjT2JqZWN0ID0gdGhpcy5fdmlkZW9TdHJlYW07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBsaXN0ZW5pbmcgdG8gdmlkZW8gc3RyZWFtIHN0YXRlIGNoYW5nZXNcbiAgICogQGNhbGxiYWNrIFJhdmlTdHJlYW1Db250cm9sbGVyfnZpZGVvU3RhdGVDaGFuZ2VDYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgQW4gb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIGluZm9ybWF0aW9uXG4gICAqIGFib3V0IHRoZSBzdGF0ZSBjaGFuZ2UuIFxuICAgKiBUT0RPOiBMaXN0IHRoZSBwb3NzaWJsZSBzdGF0ZXMuIFxuICAgKi9cbiAgLyoqXG4gICAqIFNldCB0aGUgRE9NIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBkaXNwbGF5IGluY29taW5nIFJBVkkgdmlkZW9cbiAgICogQSBjYWxsYmFjayBoYW5kbGVyIGNhbiBhbHNvIGJlIHNwZWNpZmllZCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB2aWRlbyBzdHJlYW0gY2hhbmdlIHN0YXRlXG4gICAqIFRoaXMgY2FsbCBtdXN0IGhhcHBlbiBiZWZvcmUgc3RhcnRpbmcgYSBzZXNzaW9uIGFuZCB0aGUgdmlkZW8gZWxlbWVudCBpcyBpbW11dGFibGVcbiAgICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSB2aWRlb0VsZW1lbnQgUmVmZXJlbmNlIHRvIHRoZSBKYXZhU2NyaXB0IERPTSBlbGVtZW50IGluIHdoaWNoIHRvIGRpc3BsYXkgdmlkZW8uIFxuICAgKiBJdCBpcyBleHBlY3RlZCB0aGF0IHRoaXMgZWxlbWVudCBpcyBhIFwidmlkZW9cIiBlbGVtZW50LiBXaGVuIGEgdmlkZW8gdHJhY2sgaXMgb2J0YWluZWRcbiAgICogZnJvbSB0aGUgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uLCB0aGlzIGVsZW1lbnQncyBzcmNPYmplY3Qgd2lsbCBiZSBzZXQgYWNjb3JkaW5nbHkuXG4gICAqIEBwYXJhbSB7UmF2aVN0cmVhbUNvbnRyb2xsZXJ+dmlkZW9TdGF0ZUNoYW5nZUNhbGxiYWNrfSBvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkIE9wdGlvbmFsIGNhbGxiYWNrIHRvIGNhdGNoIGNoYW5nZXMgb2YgdGhlIHZpZGVvIHN0cmVhbSBjaGFuZ2Ugc3RhdGVzLlxuICAgKi9cbiAgc2V0VmlkZW9Db250YWluZXIodmlkZW9FbGVtZW50OiBIVE1MVmlkZW9FbGVtZW50LCBvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkOiBGdW5jdGlvbikge1xuICAgIHRoaXMuX3ZpZGVvQ29udGFpbmVyID0gdmlkZW9FbGVtZW50O1xuICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBiZWVuIGEgdmlkZW8gc3RyZWFtIGFzc2lnbmVkLCBhdHRhY2ggaXRcbiAgICBpZiAodGhpcy5fdmlkZW9TdHJlYW0pIHtcbiAgICAgIHRoaXMuX3ZpZGVvQ29udGFpbmVyLnNyY09iamVjdCA9IHRoaXMuX3ZpZGVvU3RyZWFtO1xuICAgIH1cbiAgICB0aGlzLnNldFZpZGVvU3RhdGVDaGFuZ2VIYW5kbGVyKG9udmlkZW9zdHJlYW1zdGF0ZWNoYW5nZWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogQXNzaWduIGEgY2FsbGJhY2sgaGFuZGxlciBmb3Igd2hlbiB0aGUgdmlkZW8gc3RyZWFtIHN0YXRlIGNoYW5nZXNcbiAgICogQHBhcmFtIHtSYXZpU3RyZWFtQ29udHJvbGxlcn52aWRlb1N0YXRlQ2hhbmdlQ2FsbGJhY2t9IG9udmlkZW9zdHJlYW1zdGF0ZWNoYW5nZWQgQ2FsbGJhY2sgdG8gY2F0Y2ggY2hhbmdlcyBvZiB0aGUgdmlkZW8gc3RyZWFtIGNoYW5nZSBzdGF0ZXMuXG4gICAqL1xuICBzZXRWaWRlb1N0YXRlQ2hhbmdlSGFuZGxlcihvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkOiBGdW5jdGlvbikge1xuICAgIGlmIChvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkID0gb252aWRlb3N0cmVhbXN0YXRlY2hhbmdlZDtcbiAgICB9IFxuICB9XG5cbiAgLyoqXG4gICAqIFRlbGwgdGhlIFJBVkkgc2VydmVyIHRvIGluY2x1ZGUgdGhlIHZpZGVvIFwiZGFzaGJvYXJkXCIgYXMgcGFydCBvZiB0aGUgdmlkZW8gc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBvciBmYWxzZSwgdG8gc2hvdyBvciBub3Qgc2hvdyB0aGUgZGFzaGJvYXJkLlxuICAgKi9cbiAgc2hvd1ZpZGVvRGFzaGJvYXJkKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9jb21tYW5kQ29udHJvbGxlci5xdWV1ZUNvbW1hbmQoXCJ2aWRlby5zaG93RGFzaGJvYXJkXCIsIHtcImVuYWJsZWRcIjogZW5hYmxlZH0sIG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBUZWxsIHRoZSBSQVZJIHNlcnZlciB0byBpbmNsdWRlIGEgXCJyZW1vdGUgY3Vyc29yXCIgYXMgcGFydCBvZiB0aGUgdmlkZW8gc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBvciBmYWxzZSwgdG8gc2hvdyBvciBub3Qgc2hvdyB0aGUgcmVtb3RlIGN1cnNvci5cbiAgICovXG4gIHNob3dWaWRlb0N1cnNvcihlbmFibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIucXVldWVDb21tYW5kKFwidmlkZW8uc2hvd0N1cnNvclwiLCB7XCJlbmFibGVkXCI6IGVuYWJsZWR9LCBudWxsKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIElmIHRoZSBzdHJlYW0gY29udHJvbGxlciBpcyBhd2FyZSBvZiBhbiBhdWRpbyBzdHJlYW0gY29taW5nIGZyb20gdGhlIFJBVkkgc2VydmVyLCBcbiAgICogcmV0dXJuIGl0LiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gYXVkaW8gc3RyZWFtIGF2YWlsYWJsZS5cbiAgICogQHJldHVybnMge01lZGlhU3RyZWFtfVxuICAgKi9cbiAgZ2V0QXVkaW9TdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1ZGlvU3RyZWFtO1xuICB9XG4gIFxuICAvKipcbiAgICogU2V0IGFuIGF1ZGlvIHN0cmVhbSBmb3IgdGhpcyBzdHJlYW0gY29udHJvbGxlci4gSWYgdGhlcmUgaXMgYWxzbyBhbiBhdWRpbyBjb250YWluZXJcbiAgICogc2V0LCB0aGlzIHdpbGwgYXR0YWNoIHRoZSBzdHJlYW0gdG8gdGhhdCBhdWRpbyBjb250YWluZXIgYXMgd2VsbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRBdWRpb1N0cmVhbShhdWRpb1N0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICB0aGlzLl9hdWRpb1N0cmVhbSA9IGF1ZGlvU3RyZWFtO1xuICAgIGlmICh0aGlzLl9hdWRpb0NvbnRhaW5lcikge1xuICAgICAgdGhpcy5fYXVkaW9Db250YWluZXIuc3JjT2JqZWN0ID0gdGhpcy5fYXVkaW9TdHJlYW07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgRE9NIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBwbGF5IGluY29taW5nIFJBVkkgYXVkaW9cbiAgICogQHBhcmFtIHtFbGVtZW50fSBhdWRpb0VsZW1lbnQgUmVmZXJlbmNlIHRvIHRoZSBKYXZhU2NyaXB0IERPTSBlbGVtZW50IGluIHdoaWNoIHRvIHBsYXkgYXVkaW9cbiAgICogc2VudCBmcm9tIHRoZSByZW1vdGUgUkFWSSBzZXJ2ZXIuIFxuICAgKiBJdCBpcyBleHBlY3RlZCB0aGF0IHRoaXMgZWxlbWVudCBpcyBhbiBcImF1ZGlvXCIgZWxlbWVudC4gV2hlbiBhbiBhdWRpbyB0cmFjayBpcyBvYnRhaW5lZFxuICAgKiBmcm9tIHRoZSBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24sIHRoaXMgZWxlbWVudCdzIHNyY09iamVjdCB3aWxsIGJlIHNldCBhY2NvcmRpbmdseS5cbiAgICovXG4gIHNldEF1ZGlvQ29udGFpbmVyKGF1ZGlvRWxlbWVudDogSFRNTEF1ZGlvRWxlbWVudCkge1xuICAgIHRoaXMuX2F1ZGlvQ29udGFpbmVyID0gYXVkaW9FbGVtZW50O1xuICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBiZWVuIGFuIGF1ZGlvIHN0cmVhbSBhc3NpZ25lZCwgYXR0YWNoIGl0XG4gICAgaWYgKHRoaXMuX2F1ZGlvU3RyZWFtKSB7XG4gICAgICB0aGlzLl9hdWRpb0NvbnRhaW5lci5zcmNPYmplY3QgPSB0aGlzLl9hdWRpb1N0cmVhbTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdHJlYW0gdGhhdCBzaG91bGQgYmUgdXNlZCB0byBzZW5kIFJBVkkgYXVkaW8uXG4gICAqIFxuICAgKiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiBgYGBcbiAgICogICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlLCB2aWRlbzogZmFsc2UgfSlcbiAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgKiAgICAgc3RyZWFtQ29udHJvbGxlci5zZXRJbnB1dEF1ZGlvKHN0cmVhbSk7XG4gICAqICAgfSlcbiAgICogIFxuICAgKmBgYFxuICAgKiBJZiB0aGVyZSBpcyBhIGNhbGxiYWNrIGFzc2lnbmVkIHZpYSBzZXRJbnB1dEF1ZGlvQ2hhbmdlSGFuZGxlcigpLFxuICAgKiBpdCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgc3RyZWFtIGlzIHNldC5cbiAgICogXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbSBUaGUgYXVkaW8gc3RyZWFtIGJlaW5nIHVzZWQgdG8gY2FwdHVyZSBsb2NhbCBtZWRpYS5cbiAgICogR2VuZXJhbGx5IHRoaXMgd2lsbCBiZSByZXR1cm5lZCBmcm9tIGdldFVzZXJNZWRpYSgpICBcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1N0ZXJlbyAtIENhbiBiZSB0cnVlIHRvIGluZGljYXRlIHRoYXQgdGhlIHN0cmVhbSBpcyBzdGVyZW8uXG4gICAqIFRoZSBkZWZhdWx0IGlzIGZhbHNlLlxuICAgKi9cbiAgc2V0SW5wdXRBdWRpbyhzdHJlYW06IE1lZGlhU3RyZWFtLCBpc1N0ZXJlbyA9IGZhbHNlKSB7XG4gICAgdGhpcy5faW5wdXRBdWRpb1N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9pc1N0ZXJlbyA9IGlzU3RlcmVvO1xuICAgIGlmICh0aGlzLl9vbklucHV0QXVkaW9DaGFuZ2VkKSB0aGlzLl9vbklucHV0QXVkaW9DaGFuZ2VkKHN0cmVhbSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBpbnB1dCBhdWRpbyBzdHJlYW0gaXMgY2hhbmdlZFxuICAgKiB2aWEgc2V0SW5wdXRBdWRpbygpIFxuICAgKiBAY2FsbGJhY2sgUmF2aVN0cmVhbUNvbnRyb2xsZXJ+aW5wdXRBdWRpb0NoYW5nZUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW0gVGhlIG5ldyBzdHJlYW1cbiAgICovXG4gIC8qKlxuICAgKiBBc3NpZ24gYSBjYWxsYmFjayBoYW5kbGVyIGZvciB3aGVuIHRoZSBpbnB1dCBhdWRpbyBzdHJlYW0gZ2V0cyBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7UmF2aVN0cmVhbUNvbnRyb2xsZXJ+aW5wdXRBdWRpb0NoYW5nZUNhbGxiYWNrfSBvbmlucHV0YXVkaW9jaGFuZ2VkIENhbGxiYWNrIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgaW5wdXQgYXVkaW8gY2hhbmdlc1xuICAgKi9cbiAgc2V0SW5wdXRBdWRpb0NoYW5nZUhhbmRsZXIob25pbnB1dGF1ZGlvY2hhbmdlZDogRnVuY3Rpb24pIHtcbiAgICBpZiAob25pbnB1dGF1ZGlvY2hhbmdlZCkge1xuICAgICAgdGhpcy5fb25JbnB1dEF1ZGlvQ2hhbmdlZCA9IG9uaW5wdXRhdWRpb2NoYW5nZWQ7XG4gICAgfSBcbiAgfVxuICBcblxuICBzZXRJbnB1dFZpZGVvKHN0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICB0aGlzLl9pbnB1dFZpZGVvU3RyZWFtID0gc3RyZWFtO1xuICAgIGlmICh0aGlzLl9vbklucHV0VmlkZW9DaGFuZ2VkKSB0aGlzLl9vbklucHV0VmlkZW9DaGFuZ2VkKHN0cmVhbSk7XG4gIH1cblxuICBzZXRJbnB1dFZpZGVvQ2hhbmdlSGFuZGxlcihvbmlucHV0dmlkZW9jaGFuZ2VkOiBGdW5jdGlvbikge1xuICAgIGlmIChvbmlucHV0dmlkZW9jaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9vbklucHV0VmlkZW9DaGFuZ2VkID0gb25pbnB1dHZpZGVvY2hhbmdlZDtcbiAgICB9IFxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBpbmNvbWluZyBhdWRpbyBzdHJlYW0gc3VwcG9ydHMgc3RlcmVvIGlucHV0LFxuICAgKiBhcyBzcGVjaWZpZWQgYnkgc2V0SW5wdXRBdWRpby5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhpcyBpbnB1dCBhdWRpbyB0cmFjayBzdXBwb3J0cyBzdGVyZW8gaW5wdXRcbiAgICovXG4gIGlzU3RlcmVvSW5wdXQoKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgc3RhdGUgb2YgcGxheSBpcyB0aGF0IHRoZXJlIGlzIHRvbyBtdWNoIGNvbmZ1c2lvbiBpbiB0cnlpbmcgdG9cbiAgICAvLyBjb21wdXRlIHRoaXMgZnJvbSB0aGUgc3RyZWFtIHRyYWNrczpcbiAgICAvLyBUaGUgYnJvd3NlcidzIGdldFVzZXJNZWRpYSBmYWxzZWx5IHJlcG9ydHMgYSBjaGFubmVsQ291bnQgb2YgMiwgc28gd2Ugd291bGRcbiAgICAvLyBmYWxzZWx5IHJlcG9ydCBzdGVyZW8uXG4gICAgLy8gVGhlIE5vZGVKUyB3cnRjIHBhY2thZ2UgaGFzIGEgTWVkaWFTdHJlYW0gdGhhdCBkb2Vzbid0IHN1cHBvcnQgZ2V0U2V0dGluZ3NcbiAgICAvLyBhdCBhbGwsIHNvIHdlIHdvdWxkIGZhbHNlbHkgcmVwb3J0IG1vbm8uXG4gICAgcmV0dXJuIHRoaXMuX2lzU3RlcmVvO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCB0aGUgY29udmVyc2F0aW9uIGJ5IHN0b3BwaW5nIGFueSBpbmNvbWluZyB2aWRlb1xuICAgKiBhbmQgcmVtb3RlIGF1ZGlvIHN0cmVhbXMgYW5kIFxuICAgKiByZXNldCB0aGUgc291cmNlIG9iamVjdHMgb2YgdGhlaXIgY29udGFpbmVycy5cbiAgICogTm90ZSB0aGF0IHRoaXMgZG9lcyBOT1Qgc3RvcCBhbnkgbG9jYWwgYXVkaW8gc3RyZWFtcyB0aGF0XG4gICAqIG1pZ2h0IGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGVlckNvbm5lY3Rpb24gLS0gaXQgbGVhdmVzXG4gICAqIGhhbmRsaW5nIG9mIHRoYXQgbG9jYWwgYXVkaW8gc3RyZWFtIHRvIHRoZSBpbXBsZW1lbnRpbmcgY2xpZW50LlxuICAgKiBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdG9wKCkge1xuICAgIFJhdmlVdGlscy5sb2coXCJzdG9wcGluZyBzdHJlYW1zXCIsIFwiUmF2aVN0cmVhbUNvbnRyb2xsZXJcIik7XG5cbiAgICBpZiAodGhpcy5fdmlkZW9Db250YWluZXIgJiYgdGhpcy5fdmlkZW9Db250YWluZXIuc3JjT2JqZWN0KSB7XG4gICAgICBsZXQgc3JjT2JqZWN0ID0gPE1lZGlhU3RyZWFtPiB0aGlzLl92aWRlb0NvbnRhaW5lci5zcmNPYmplY3Q7XG4gICAgICBsZXQgdHJhY2tzID0gc3JjT2JqZWN0LmdldFRyYWNrcygpO1xuICAgICAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgIHRoaXMuX3ZpZGVvQ29udGFpbmVyLnNyY09iamVjdCA9IG51bGw7XG4gICAgICB0aGlzLl9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkKFwib3ZlclwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5fYXVkaW9TdHJlYW0pIHtcbiAgICAgIHRoaXMuX2F1ZGlvU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgIHRoaXMuX2F1ZGlvU3RyZWFtID0gbnVsbDtcbiAgICB9XG4gICAgXG4gIH1cblxufVxuIiwidmFyIERFQlVHID0gdHJ1ZTtcblxuLyoqIFxuICpcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBDb2xsZWN0aW9uIG9mIHN0YXRpYyB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJhdmlVdGlscyB7XG5cblxuICAvKipcbiAgICogU2ltcGxlIFVVSUQgaW1wbGVtZW50YXRpb24uXG4gICAqIFRha2VuIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA1MDc0LzUxNTU4NFxuICAgKiBTdHJpY3RseSBzcGVha2luZywgaXQncyBub3QgYSByZWFsIFVVSUQsIGJ1dCBpdCBnaXZlcyB1cyB3aGF0IHdlIG5lZWRcbiAgICogZm9yIFJBVkkgaGFuZGxpbmcuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlVVVJRCgpOiBzdHJpbmcge1xuICAgIGZ1bmN0aW9uIHM0KCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gIH1cbiAgXG4gIFxuICAvKipcbiAgICogV3JhcHMgY29uc29sZS5sb2cgc3VjaCB0aGF0IHdlIHdpbGwgb25seSBvdXRwdXQgYSBtZXNzYWdlIHRvXG4gICAqIGNvbnNvbGUubG9nIGlmIHRoZSBjb25zdGFudCBERUJVRyAoY3VycmVudGx5LCB0aGlzIGlzIHNpbXBseSBkZWZpbmVkXG4gICAqIGFzIGEgZ2xvYmFsIHZhcmlhYmxlIGluaGVyaXRlZCBieSB0aGUgcmF2aS5qcyBmaWxlLCB3aGljaCBpcyBhIGxpdHRsZVxuICAgKiBhd2Z1bCkgaXMgc2V0IHRvIGB0cnVlYC4gKERlZmF1bHRzIHRvIHRydWUuKVxuICAgKiBUaGlzIG1ldGhvZCBkaXNwYXRjaGVzIGEgXCJsb2dnZXJcIiBldmVudCBvbiB0aGUgZG9jdW1lbnQgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBkbyBzb21ldGhpbmcgZWxzZSB3aXRoIHRoZSBtZXNzYWdlLiBJdCB3aWxsIGFsd2F5c1xuICAgKiBkaXNwYXRjaCB0aGlzIGV2ZW50IHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3QgaXQncyBpbiBERUJVRyBtb2RlLFxuICAgKiBiZWNhdXNlIHByZXN1bWFibHkgaWYgeW91J3JlIGxpc3RlbmluZyBmb3IgdGhlIGV2ZW50IGl0J3MgYmVjYXVzZSB5b3VcbiAgICogd2FudCB0byBnZXQgbWVzc2FnZXMuXG4gICAqL1xuICBzdGF0aWMgbG9nKG1lc3NhZ2U6IHN0cmluZywgY2xhc3NuYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIGNsYXNzbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIG1lc3NhZ2UgPSBjbGFzc25hbWUgKyBcIjogXCIgKyBtZXNzYWdlO1xuICAgIGlmIChERUJVRykge1xuICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbG9nZ2VyJywge2RldGFpbDogbWVzc2FnZX0pKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFkZGl0aW9uYWxseSwgYW4gZXJyb3Igd2FzIGVuY291bnRlcmVkIHRyeWluZyB0byBsb2cgdGhhdC5cIilcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgY29uc29sZS5sb2cgc3VjaCB0aGF0IHdlIHdpbGwgQUxXQVlTIG91dHB1dCBhIG1lc3NhZ2UsIGFuZFxuICAgKiB0aGF0IG1lc3NhZ2Ugd2lsbCBiZSBpbiByZWQuXG4gICAqIFRoaXMgbWV0aG9kIGRpc3BhdGNoZXMgYW4gXCJlcnJsb2dnZXJcIiBldmVudCBvbiB0aGUgZG9jdW1lbnQgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBkbyBzb21ldGhpbmcgZWxzZSB3aXRoIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgc3RhdGljIGVycihtZXNzYWdlOiBzdHJpbmcsIGNsYXNzbmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBjbGFzc25hbWUgIT09ICd1bmRlZmluZWQnKSBtZXNzYWdlID0gY2xhc3NuYW1lICsgXCI6IFwiICsgbWVzc2FnZTtcbiAgICBjb25zb2xlLmxvZygnJWMgJXMnLCAnY29sb3I6ICNGQjBBMUMnLCBtZXNzYWdlKTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2VycmxvZ2dlcicsIHtkZXRhaWw6IG1lc3NhZ2V9KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC8vIFJldHVybiBKU09OLnN0cmluZ2lmeShpdGVtKSBpZiBwb3NzaWJsZSwgZWxzZSBpdGVtXG4gICAqL1xuICBzdGF0aWMgc2FmZWx5UHJpbnRhYmxlKGl0ZW06IGFueSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogRmlndXJlcyBvdXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgYSBET00gZWxlbWVudC5cbiAgICovXG4gIHN0YXRpYyBnZXRFbGVtZW50Q1NTU2l6ZShlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBpZiAoIWdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgdmFyIHcgPSBwYXJzZUludChjcy5nZXRQcm9wZXJ0eVZhbHVlKFwid2lkdGhcIiksIDEwKTtcbiAgICB2YXIgaCA9IHBhcnNlSW50KGNzLmdldFByb3BlcnR5VmFsdWUoXCJoZWlnaHRcIiksIDEwKTtcbiAgICByZXR1cm4ge3dpZHRoOiB3LCBoZWlnaHQ6IGh9XG4gIH1cbiAgXG4gIFxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBcImRlYnVnXCIgbW9kZS4gSW4gZGVidWcgbW9kZSwgbW9zdCBldmVyeXRoaW5nIGdldHNcbiAgICogcHJpbnRlZCB0byB0aGUgSlMgY29uc29sZS4gKFNlZSBhbHNvIFJhdmlVdGlscy5qcylcbiAgICogY29ubmVjdHMgdG8gdGhlIHNwZWNpZmllZCBXZWJTb2NrZXQgYWRkcmVzcy5cbiAgICogQHBhcmFtIHtib29sZWFufSBkZWJ1ZyBXaGV0aGVyIG9yIG5vdCB0byBwdXQgdGhlIGxvZ2dlciBpbnRvIGRlYnVnIG1vZGUuXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBzZXREZWJ1ZyhkZWJ1ZzogYm9vbGVhbikge1xuICAgIERFQlVHID0gZGVidWc7XG4gIH1cblxufVxuIiwiLyoqXG4gKiBUaGlzIHV0aWxpdHkgTW9kdWxlIGNvbnRhaW5zIGNvZGUgcmVsYXRlZCB0byBsb2dnaW5nIGZyb20gd2l0aGluIEFQSSBmdW5jdGlvbnMuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG4vKipcbiAqIFVzZWQgZm9yIGRldGVybWluaW5nIHdoYXQgZGF0YSB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBDbGllbnQgQVBJIHNob3VsZCBwcmludCB0byB0aGUgY29uc29sZS4gXG4gKi9cbmV4cG9ydCBlbnVtIEhpRmlMb2dMZXZlbCB7XG4gICAgTm9uZSA9IFwiTm9uZVwiLFxuICAgIEVycm9yID0gXCJFcnJvclwiLFxuICAgIFdhcm4gPSBcIldhcm5cIixcbiAgICBEZWJ1ZyA9IFwiRGVidWdcIixcbn1cblxuLyoqXG4gKiBBIHdyYXBwZXIgZm9yIEFQSS1pbnRlcm5hbCBgY29uc29sZS4qKClgIGNhbGxzLCBnYXRlZCBieSB0aGUgdXNlcidzIGN1cnJlbnQgbG9nIGxldmVsLlxuICovXG5leHBvcnQgY2xhc3MgSGlGaUxvZ2dlciB7XG4gICAgc3RhdGljIGxvZ0xldmVsOiBIaUZpTG9nTGV2ZWwgPSBIaUZpTG9nTGV2ZWwuRXJyb3I7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbG9nTGV2ZWwgVGhlIGluaXRpYWwgTG9nIExldmVsIGZvciBvdXIgTG9nZ2VyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZ0xldmVsPzogSGlGaUxvZ0xldmVsKSB7XG4gICAgICAgIGxvZ0xldmVsID0gbG9nTGV2ZWwgPyBsb2dMZXZlbCA6IEhpRmlMb2dMZXZlbC5EZWJ1ZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IEhpRmkgTG9nIExldmVsLlxuICAgICAqIEBwYXJhbSBuZXdMb2dMZXZlbCBUaGUgbmV3IExvZyBMZXZlbCBmb3Igb3VyIExvZ2dlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0SGlGaUxvZ0xldmVsKG5ld0xvZ0xldmVsOiBIaUZpTG9nTGV2ZWwpOiB2b2lkIHtcbiAgICAgICAgSGlGaUxvZ2dlci5sb2dMZXZlbCA9IG5ld0xvZ0xldmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBMb2dnZXIncyBsb2cgbGV2ZWwgaXMgYERlYnVnYCwgd2lsbCBwcmludCBhIGRlYnVnIGxvZyB0byB0aGUgbG9ncy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2cuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXNzYWdlIHdhcyBvdXRwdXQgdG8gdGhlIGNvbnNvbGU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBsb2cobWVzc2FnZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChIaUZpTG9nZ2VyLmxvZ0xldmVsID09PSBIaUZpTG9nTGV2ZWwuRGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSBzYW1lIHRoaW5nIGFzIHtAbGluayBsb2d9LlxuICAgICAqIEBwYXJhbSBtZXNzYWdlXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXNzYWdlIHdhcyBvdXRwdXQgdG8gdGhlIGNvbnNvbGU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBkZWJ1ZyhtZXNzYWdlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBMb2dnZXIncyBsb2cgbGV2ZWwgaXMgYERlYnVnYCBvciBgV2FybmAsIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGxvZyB0byB0aGUgbG9ncy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2cuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXNzYWdlIHdhcyBvdXRwdXQgdG8gdGhlIGNvbnNvbGU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyB3YXJuKG1lc3NhZ2U6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoSGlGaUxvZ2dlci5sb2dMZXZlbCA9PT0gSGlGaUxvZ0xldmVsLkRlYnVnIHx8IEhpRmlMb2dnZXIubG9nTGV2ZWwgPT09IEhpRmlMb2dMZXZlbC5XYXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBMb2dnZXIncyBsb2cgbGV2ZWwgaXMgYERlYnVnYCBvciBgV2FybmAgb3IgYEVycm9yYCwgd2lsbCBwcmludCBhbiBlcnJvciBsb2cgdG8gdGhlIGxvZ3MuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWVzc2FnZSB3YXMgb3V0cHV0IHRvIHRoZSBjb25zb2xlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZXJyb3IobWVzc2FnZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChIaUZpTG9nZ2VyLmxvZ0xldmVsID09PSBIaUZpTG9nTGV2ZWwuRGVidWcgfHwgSGlGaUxvZ2dlci5sb2dMZXZlbCA9PT0gSGlGaUxvZ0xldmVsLldhcm4gfHwgSGlGaUxvZ2dlci5sb2dMZXZlbCA9PT0gSGlGaUxvZ0xldmVsLkVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqIFRoaXMgTW9kdWxlIGNvbnRhaW5zIGEgbnVtYmVyIG9mIHVzZWZ1bCB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IEFQSSB1c2VycyBjYW4gdXNlIGluIHRoZWlyIGFwcGxpY2F0aW9ucyBpZiB0aGV5IHdpc2guXG4gKiBTb21lIG9mIHRoZW0gYXJlIGFsc28gdXNlZCBpbnRlcm5hbGx5IGluIEFQSSBjb2RlLlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cblxuaW1wb3J0IHsgSGlGaUxvZ2dlciB9IGZyb20gXCIuL0hpRmlMb2dnZXJcIjtcblxuZnVuY3Rpb24gZHluYW1pY1JlcXVpcmUobW9kOiBhbnksIHJlcXVpcmVTdHJpbmc6IHN0cmluZyk6IGFueSB7XG4gICAgcmV0dXJuIG1vZC5yZXF1aXJlKHJlcXVpcmVTdHJpbmcpO1xufVxuXG5sZXQgbm93OmFueTtcbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBub2RlIGNvbnRleHRcbiAgICB0cnkge1xuICAgICAgICBub3cgPSBkeW5hbWljUmVxdWlyZShtb2R1bGUsICdwZXJmX2hvb2tzJykucGVyZm9ybWFuY2Uubm93OyAvLyBVc2VkIHdpdGggYHByZWNpc2VJbnRlcnZhbCgpYC5cbiAgICB9IGNhdGNoIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBIaUZpVXRpbGl0aWVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTIE9iamVjdCBjb250YWluaW5nIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gcGFzc2VkIG9iamVjdHMuXG4gICAgICogXG4gICAgICogVGhpcyBmdW5jdGlvbiB3YXMgYWRhcHRlZCBmcm9tIFt0aGlzIHZlcnkgaGVscGZ1bCBkb2N1bWVudCBvbiBHb01ha2VUaGluZ3Nde0BsaW5rIGh0dHBzOi8vZ29tYWtldGhpbmdzLmNvbS9nZXR0aW5nLXRoZS1kaWZmZXJlbmNlcy1iZXR3ZWVuLXR3by1vYmplY3RzLXdpdGgtdmFuaWxsYS1qcy99LlxuICAgICAqIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAgICogXG4gICAgICogQHBhcmFtIG9iajEgXG4gICAgICogQHBhcmFtIG9iajIgXG4gICAgICovXG4gICAgc3RhdGljIHJlY3Vyc2l2ZWx5RGlmZk9iamVjdHMob2JqMTogYW55LCBvYmoyOiBhbnkpOiBhbnkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgYW4gb2JqZWN0IHRvIGNvbXBhcmUgaXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKCFvYmoyIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmoyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVmFyaWFibGVzXG4gICAgICAgIC8vXG4gICAgICAgIGxldCBkaWZmczogYW55ID0ge307XG4gICAgICAgIGxldCBrZXk7XG5cbiAgICAgICAgbGV0IGRvQXJyYXlzTWF0Y2ggPSAoYXJyMTogQXJyYXk8YW55PiwgYXJyMjogQXJyYXk8YW55PikgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFycmF5cyBhcmUgdGhlIHNhbWUgbGVuZ3RoXG4gICAgICAgICAgICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbGwgaXRlbXMgZXhpc3QgYW5kIGFyZSBpbiB0aGUgc2FtZSBvcmRlclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ29tcGFyZSB0d28gaXRlbXMgYW5kIHB1c2ggbm9uLW1hdGNoZXMgdG8gb2JqZWN0XG4gICAgICAgIGxldCBjb21wYXJlID0gKGl0ZW0xOiBhbnksIGl0ZW0yOiBhbnksIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIG9iamVjdCB0eXBlXG4gICAgICAgICAgICBsZXQgdHlwZTEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlbTEpO1xuICAgICAgICAgICAgbGV0IHR5cGUyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZW0yKTtcblxuICAgICAgICAgICAgLy8gSWYgdHlwZTIgaXMgdW5kZWZpbmVkIGl0IGhhcyBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgIGlmICh0eXBlMiA9PT0gJ1tvYmplY3QgVW5kZWZpbmVkXScpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGl0ZW1zIGFyZSBkaWZmZXJlbnQgdHlwZXNcbiAgICAgICAgICAgIGlmICh0eXBlMSAhPT0gdHlwZTIpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gaXRlbTI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhbiBvYmplY3QsIGNvbXBhcmUgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgIGlmICh0eXBlMSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JqRGlmZiA9IEhpRmlVdGlsaXRpZXMucmVjdXJzaXZlbHlEaWZmT2JqZWN0cyhpdGVtMSwgaXRlbTIpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvYmpEaWZmKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZzW2tleV0gPSBvYmpEaWZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGFuIGFycmF5LCBjb21wYXJlXG4gICAgICAgICAgICBpZiAodHlwZTEgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRvQXJyYXlzTWF0Y2goaXRlbTEsIGl0ZW0yKSkge1xuICAgICAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gaXRlbTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRWxzZSBpZiBpdCdzIGEgZnVuY3Rpb24sIGNvbnZlcnQgdG8gYSBzdHJpbmcgYW5kIGNvbXBhcmVcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwganVzdCBjb21wYXJlXG4gICAgICAgICAgICBpZiAodHlwZTEgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbTEudG9TdHJpbmcoKSAhPT0gaXRlbTIudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gaXRlbTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbTEgIT09IGl0ZW0yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZzW2tleV0gPSBpdGVtMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSBmaXJzdCBvYmplY3RcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqMSkge1xuICAgICAgICAgICAgaWYgKG9iajEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbXBhcmUob2JqMVtrZXldLCBvYmoyW2tleV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIHNlY29uZCBvYmplY3QgYW5kIGZpbmQgbWlzc2luZyBpdGVtc1xuICAgICAgICBmb3IgKGtleSBpbiBvYmoyKSB7XG4gICAgICAgICAgICBpZiAob2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmoxW2tleV0gJiYgb2JqMVtrZXldICE9PSBvYmoyW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZnNba2V5XSA9IG9iajJba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIG9iamVjdCBvZiBkaWZmZXJlbmNlc1xuICAgICAgICByZXR1cm4gZGlmZnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBcImJlc3RcIiBhdWRpbyBjb25zdHJhaW50cyBzdXBwb3J0ZWQgYnkgdGhlIGNsaWVudC4gSW4gdGhpcyBjYXNlLCBcImJlc3RcIiBpcyBkZWZpbmVkIGFzIFwidGhlIGNvbnN0cmFpbnRzIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSBoaWdoZXN0LXF1YWxpdHkgYXVkaW8uXCJcbiAgICAgKiBUaGF0IG1lYW5zIGRpc2FibGluZyBFY2hvIENhbmNlbGxhdGlvbiwgZGlzYWJsaW5nIE5vaXNlIFN1cHByZXNzaW9uLCBhbmQgZGlzYWJsaW5nIEF1dG9tYXRpYyBHYWluIENvbnRyb2wuXG4gICAgICovXG4gICAgc3RhdGljIGdldEJlc3RBdWRpb0NvbnN0cmFpbnRzKCk6IGFueSB7XG4gICAgICAgIGxldCBhdWRpb0NvbnN0cmFpbnRzOiBhbnkgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIChuYXZpZ2F0b3IpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuZWNob0NhbmNlbGxhdGlvbikge1xuICAgICAgICAgICAgYXVkaW9Db25zdHJhaW50cy5lY2hvQ2FuY2VsbGF0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIChuYXZpZ2F0b3IpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkubm9pc2VTdXBwcmVzc2lvbikge1xuICAgICAgICAgICAgYXVkaW9Db25zdHJhaW50cy5ub2lzZVN1cHByZXNzaW9uID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIChuYXZpZ2F0b3IpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuYXV0b0dhaW5Db250cm9sKSB7XG4gICAgICAgICAgICBhdWRpb0NvbnN0cmFpbnRzLmF1dG9HYWluQ29udHJvbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF1ZGlvQ29uc3RyYWludHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYHByZWNpc2VJbnRlcnZhbCgpYCBpcyBhIHZlcnNpb24gb2YgYHNldEludGVydmFsKClgIGZvciBOb2RlSlMgdGhhdCBkb2VzIG5vdCBzcGluIENQVXMgbm9yIGRyaWZ0LlxuICAgICAqIFRoZSByZXR1cm5lZCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhIGBjbGVhcigpYCBtZXRob2RzIHRoYXQgc3RvcHMgdGhlIGludGVydmFsLlxuICAgICAqIEluIHRoZSBicm93c2VyIGNvbnRleHQsIGBwcmVjaXNlSW50ZXJ2YWwoKWAgaXMgc2ltcGx5IGEgd3JhcHBlciBmb3IgYHNldEludGVydmFsKClgLlxuICAgICAqIFxuICAgICAqIFdlIGRvIHRocmVlIHRoaW5nczpcbiAgICAgKiAxLiBLZWVwIGEgcnVubmluZyBjb3VudGVyIG9mIHdoZW4gdGhlIG5leHQgY2FsbCBzaG91bGQgYmUsIHRvIGF2b2lkIGRyaWZ0LlxuICAgICAqIDIuIENvbXB1dGUgdGhlIHRpbWUgdG8gdGhlIG5leHQgY2FsbCBhbmQgZ2l2ZSB0aGF0IHRvIGBzZXRUaW1lb3V0KClgLlxuICAgICAqIDMuIE91ciBhdmVyYWdlIGVycm9yIHdpdGggdGhlIGFib3ZlIGlzIGFib3V0IDFtcyAoc28gaGFsZiB0aGUgaW50ZXJ2YWxzIGFyZSBvZmYgYnkgbW9yZSkuXG4gICAgICogU28gaW4gIzIsIHNob290IGZvciAyIG1zIGxlc3MgdGhhbiB0aGF0LCBhbmQgc3BpbiB3aXRoIHNldEltbWVkaWF0ZSAoYWxsb3dpbmcgb3RoZXIgc3R1ZmYgdG8gcnVuKSB1bnRpbCB3ZSd2ZSByZWFjaGVkIHRoZSBleHBlY3RlZCB0aW1lLlxuICAgICAqIFxuICAgICAqIEZvciBhIDEwbXMgaW50ZXJ2YWwsIHdlIG1lYXN1cmVkIGFuICoqYXZlcmFnZSoqIGVycm9yIHBlciBpbnRlcnZhbCBvZjpcbiAgICAgKiAtIGAxLjY3IG1zYCBmb3IgYHNldEludGVydmFsKClgIChzbyBTT01FVEhJTkcgaXMgdGlja2luZyBhdCA2MCBIeikuXG4gICAgICogLSBgfjEgbXNgIGZvciB0aGlzIGNvZGUgV0lUSE9VVCAjMywgdXNpbmcgYERhdGUuZ2V0VGltZSgpYFxuICAgICAqIC0gYH4xIG1zYCBmb3IgdGhpcyBjb2RlIFdJVEhPVVQgIzMsIHVzaW5nIGBwZXJmX2hvb2tzLnBlcmZvcm1hbmNlLm5vdygpYFxuICAgICAqIC0gYDAuODYgbXNgIGZvciB0aGlzIGNvZGUgdXNpbmcgYERhdGUuZ2V0VGltZSgpYFxuICAgICAqIC0gYDAuMDMgbXNgIGZvciB0aGlzIGNvZGUgdXNpbmcgYHBlcmZfaG9va3MucGVyZm9ybWFuY2Uubm93KClgXG4gICAgICogXG4gICAgICogXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgcHJlY2lzZSBpbnRlcnZhbCBleHBpcmVzLlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbE1TIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuIGVhY2ggaW50ZXJ2YWwuXG4gICAgICovXG4gICAgc3RhdGljIHByZWNpc2VJbnRlcnZhbChjYWxsYmFjazogRnVuY3Rpb24sIGludGVydmFsTVM6IG51bWJlcik6IGFueSB7XG4gICAgICAgIGlmICghbm93KSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYFxcYHByZWNpc2VJbnRlcnZhbCgpXFxgIGlzIGEgd3JhcHBlciBmb3IgXFxgc2V0SW50ZXJ2YWwoKVxcYCBpbiB0aGUgYnJvd3NlciBjb250ZXh0IWApO1xuICAgICAgICAgICAgcmV0dXJuIHNldEludGVydmFsKGNhbGxiYWNrLCBpbnRlcnZhbE1TKTsgICAgXG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgbGV0IG5leHRUaWNrID0gbm93KCk7XG4gICAgICAgIGxldCBjbGVhcjphbnkgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIGxldCB3cmFwcGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRoaXNUaWNrID0gbm93KCk7XG4gICAgICAgICAgICBpZiAodGhpc1RpY2sgPCBuZXh0VGljaykge1xuICAgICAgICAgICAgICAgIGNsZWFyID0gY2xlYXJJbW1lZGlhdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVvdXQgPSBzZXRJbW1lZGlhdGUod3JhcHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0VGljayArPSBpbnRlcnZhbE1TO1xuICAgICAgICAgICAgY2xlYXIgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCh3cmFwcGVyLCBuZXh0VGljayAtIHRoaXNUaWNrIC0gMik7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgdGltZW91dDphbnkgPSBzZXRUaW1lb3V0KHdyYXBwZXIpO1xuICAgICAgICByZXR1cm4geyBjbGVhcjogKCkgPT4gY2xlYXIodGltZW91dCkgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2hlY2tCcm93c2VyQ29tcGF0aWJpbGl0eSgpOiBCb29sZWFuIHtcbiAgICAgICAgbGV0IHJlcXVpcmVkRmVhdHVyZXM6IEFycmF5PHN0cmluZz4gPSBbXG4gICAgICAgICAgICAvLyBOYXZpZ2F0b3IgbWVkaWFEZXZpY2VzXG4gICAgICAgICAgICBcIm5hdmlnYXRvclwiLCAvLyBGb3VuZCBvbiBzb3VyY2UgY29kZSBIaUZpTWl4ZXJTZXNzaW9uLnRzLCBSYXZpU3RyZWFtQ29udHJvbGxlci50c1xuICAgICAgICAgICAgXCJuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYVwiLCAvLyBGb3VuZCBvbiBzb3VyY2UgY29kZSBIaUZpTWl4ZXJTZXNzaW9uLnRzIChsbi41OTApXG4gICAgICAgICAgICBcIm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHNcIiwgLy8gRm91bmQgb24gc291cmNlIGNvZGUgSGlGaVV0aWxpdGllcyAobG4uIDEzMCwgMTM0LCAxMzgpXG4gICAgICAgICAgICAvLyBXZWJSVENcbiAgICAgICAgICAgIFwid2luZG93Lk1lZGlhU3RyZWFtXCIsIC8vIEZvdW5kIG9uIHNvdXJjZSBjb2RlIEhpRmlDb21tdW5pY2F0b3IudHMsIEhpRmlNaXhlclNlc3Npb24udHMsIFJhdmlTZXNzaW9uLnRzLCBSYXZpU3RyZWFtQ29udHJvbGxlci50c1xuICAgICAgICAgICAgXCJ3aW5kb3cuUlRDRGF0YUNoYW5uZWxcIiwgLy8gRm91bmQgb24gc291cmNlIGNvZGUgUmF2aUNvbW1hbmRDb250cm9sbGVyLnRzIChsbi4xNTEpXG4gICAgICAgICAgICBcIndpbmRvdy5SVENQZWVyQ29ubmVjdGlvblwiLCAvLyBGb3VuZCBvbiBzb3VyY2UgY29kZSBSYXZpU2Vzc2lvbi50cyAobG4uNjAzKVxuICAgICAgICAgICAgXCJ3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uXCIgLy8gRm91bmQgb24gc291cmNlIGNvZGUgUmF2aVNlc3Npb24udHMgKGxuLjYwNClcbiAgICAgICAgXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVpcmVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGV2YWwocmVxdWlyZWRGZWF0dXJlc1tpXSkpID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihcIkhpRmkgQXVkaW8gQVBJOiBUaGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0OiBcIiArIHJlcXVpcmVkRmVhdHVyZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZEZlYXR1cmVzW2ldID09PSBcIm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihcIkhpRmkgQXVkaW8gQVBJOiBZb3VyIGJyb3dzZXIgbWF5IGJlIHByZXZlbnRpbmcgYWNjZXNzIHRvIHRoaXMgZmVhdHVyZSBpZiB5b3UgYXJlIHJ1bm5pbmcgaW4gYW4gaW5zZWN1cmUgY29udGV4dCwgaS5lLiBhbiBgaHR0cGAgc2VydmVyLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBub25hbih2OiBudW1iZXIsIGlmbmFuOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gKGlzTmFOKHYpID8gaWZuYW4gOiB2KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xhbXAodjogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICAvLyBpZiB2IGlzIE5hbiByZXR1cm5zIE5hblxuICAgICAgICByZXR1cm4gKHYgPiBtYXggPyBtYXggOiAodiA8IG1pbiA/IG1pbiA6IHYpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xhbXBOb25hbih2OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgaWZuYW46IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAodiA+IG1heCA/IG1heCA6ICh2IDwgbWluID8gbWluIDogSGlGaVV0aWxpdGllcy5ub25hbih2LCBpZm5hbikpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xhbXBOb3JtYWxpemVkKHY6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIC8vIGlmIHYgaXMgTmFuIHJldHVybnMgTmFuXG4gICAgICAgIHJldHVybiAodiA+IDEuMCA/IDEuMCA6ICh2IDwgLTEuMCA/IC0xLjAgOiB2KSk7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd3cyBkb2VzIG5vdCB3b3JrIGluIHRoZSBicm93c2VyLiBCcm93c2VyIGNsaWVudHMgbXVzdCB1c2UgdGhlIG5hdGl2ZSAnICtcbiAgICAgICdXZWJTb2NrZXQgb2JqZWN0J1xuICApO1xufTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uaG1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG1vZHVsZSk7XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgJ2V4cG9ydHMnLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRzZXQ6ICgpID0+IHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignRVMgTW9kdWxlcyBtYXkgbm90IGFzc2lnbiBtb2R1bGUuZXhwb3J0cyBvciBleHBvcnRzLiosIFVzZSBFU00gZXhwb3J0IHN5bnRheCwgaW5zdGVhZDogJyArIG1vZHVsZS5pZCk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImRlY2xhcmUgdmFyIEhJRklfQVBJX1ZFUlNJT046IHN0cmluZztcblxuLy8gQ2hlY2sgZm9yIGJyb3dzZXIgY29tcGF0aWJpbGl0eVxuaW1wb3J0IHsgSGlGaVV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9IaUZpVXRpbGl0aWVzXCI7XG5leHBvcnQgeyBIaUZpVXRpbGl0aWVzIH07XG5sZXQgaXNCcm93c2VyQ29udGV4dCA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJztcbmlmIChpc0Jyb3dzZXJDb250ZXh0KSB7XG4gICAgSGlGaVV0aWxpdGllcy5jaGVja0Jyb3dzZXJDb21wYXRpYmlsaXR5KCk7XG59XG5sZXQgYXBpVmVyc2lvbiA9IHR5cGVvZiAoSElGSV9BUElfVkVSU0lPTikgPT09IFwic3RyaW5nXCIgPyBISUZJX0FQSV9WRVJTSU9OIDogXCJ1bmtub3duXCI7XG5leHBvcnQgeyBhcGlWZXJzaW9uIGFzIGhpRmlBUElWZXJzaW9uIH07IFxuZXhwb3J0IHsgYXBpVmVyc2lvbiB9OyBcblxuXG4vLyBWZXJib3NpdHkgY2FuIGJlIGdvb2Qgc29tZXRpbWVzIVxuLy8gVGhlIGZpcnN0IHNlY3Rpb24gb2YgYGV4cG9ydGBzIGhlcmUgZXhwb3NlIHRoZSBDbGllbnQgTGlicmFyeSdzIGVudHJ5IHBvaW50c1xuLy8gdXNpbmcgdmVyYm9zZSBsYW5ndWFnZS4gVGhpcyB1c3VhbGx5IG1lYW5zIHRoYXQgZXZlcnkgZW50cnkgcG9pbnQgaXMgcHJlcGVudGVkIHdpdGggYEhpRmlgLlxuLy8gRG9pbmcgdGhpcyBoZWxwcyByZWR1Y2UgbmFtZXNwYWNlIGNvbGxpc2lvbnMgaW4gdXNlciBhcHBsaWNhdGlvbnMuXG4vLyBTb21lIHBlb3BsZSBkb24ndCB3YW50IHRvIHR5cGUgYEhpRmlgIGV2ZXJ5IHRpbWUgdGhleSB3YW50IHRvIHVzZSBvdXIgQ2xpZW50IExpYnJhcnksXG4vLyBzbyB3ZSBhbHNvIG9mZmVyIHNob3J0ZXIgc3lub255bXMgZm9yIGV2ZXJ5IExpYnJhcnkgZW50cnkgcG9pbnQuXG4vLyBTY3JvbGwgZG93biB0byBjaGVjayBvdXQgdGhvc2Ugc2hvcnRlciBzeW5vbnltcy5cbmV4cG9ydCB7IEhpRmlBdWRpb0FQSURhdGEsIFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSwgT3JpZW50YXRpb25FdWxlcjNELCBPcmllbnRhdGlvblF1YXQzRCwgUG9pbnQzRCwgZXVsZXJUb1F1YXRlcm5pb24sIGV1bGVyRnJvbVF1YXRlcm5pb259IGZyb20gXCIuL2NsYXNzZXMvSGlGaUF1ZGlvQVBJRGF0YVwiO1xuZXhwb3J0IHsgSGlGaUNvbW11bmljYXRvciwgSGlGaUNvbm5lY3Rpb25TdGF0ZXMsIEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3BlcyB9IGZyb20gXCIuL2NsYXNzZXMvSGlGaUNvbW11bmljYXRvclwiO1xuZXhwb3J0IHsgV2ViUlRDU2Vzc2lvblBhcmFtcyB9IGZyb20gXCIuL2xpYnJhdmkvUmF2aVNlc3Npb25cIjtcbmV4cG9ydCB7IEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cywgVXNlckRhdGFTdWJzY3JpcHRpb24gfSBmcm9tIFwiLi9jbGFzc2VzL0hpRmlVc2VyRGF0YVN1YnNjcmlwdGlvblwiO1xuZXhwb3J0IHsgSGlGaUxvZ0xldmVsLCBIaUZpTG9nZ2VyIH0gZnJvbSBcIi4vdXRpbGl0aWVzL0hpRmlMb2dnZXJcIjtcbmV4cG9ydCB7IEhpRmlDb25zdGFudHMgfSBmcm9tIFwiLi9jb25zdGFudHMvSGlGaUNvbnN0YW50c1wiO1xuZXhwb3J0IHsgSGlGaUF4ZXMsIEhpRmlIYW5kZWRuZXNzLCBIaUZpQXhpc0NvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi9jbGFzc2VzL0hpRmlBeGlzQ29uZmlndXJhdGlvblwiO1xuXG4vLyBIZXJlIGFyZSB2YXJpb3VzIGV4cGxpY2l0IGV4cG9ydHMgZnJvbSB3aXRoaW4gdGhlIGBIaUZpVXRpbGl0aWVzYCBjbGFzcyBmb3IgY29udmVuaWVuY2UuXG5sZXQgZ2V0QmVzdEF1ZGlvQ29uc3RyYWludHMgPSBIaUZpVXRpbGl0aWVzLmdldEJlc3RBdWRpb0NvbnN0cmFpbnRzO1xuZXhwb3J0IHsgZ2V0QmVzdEF1ZGlvQ29uc3RyYWludHMgfTtcbmxldCBwcmVjaXNlSW50ZXJ2YWwgPSBIaUZpVXRpbGl0aWVzLnByZWNpc2VJbnRlcnZhbDtcbmV4cG9ydCB7IHByZWNpc2VJbnRlcnZhbCB9O1xuXG4vLyBTaG9ydCBzeW5vbnltcyBmb3IgdGhlIGFib3ZlIHN0YXJ0IGhlcmUhXG4vLyBQbGVhc2UgbGV0IHVzIGtub3cgaWYgYW55IG9mIHRoZXNlIGBleHBvcnRzYCBjYXVzZSBuYW1lc3BhY2UgY29sbGlzaW9uc1xuLy8gaW4geW91ciBhcHBsaWNhdGlvbi5cbmV4cG9ydCB7IEhpRmlDb21tdW5pY2F0b3IgYXMgQ29tbXVuaWNhdG9yLCBIaUZpQ29ubmVjdGlvblN0YXRlcyBhcyBDb25uZWN0aW9uU3RhdGVzLCBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXMgYXMgVXNlckRhdGFTdHJlYW1pbmdTY29wZXMgfSBmcm9tIFwiLi9jbGFzc2VzL0hpRmlDb21tdW5pY2F0b3JcIjtcbmV4cG9ydCB7IFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSBhcyBSZWNlaXZlZEF1ZGlvQVBJRGF0YSwgSGlGaUF1ZGlvQVBJRGF0YSBhcyBBdWRpb0FQSURhdGEgfSBmcm9tIFwiLi9jbGFzc2VzL0hpRmlBdWRpb0FQSURhdGFcIjtcbmV4cG9ydCB7IEhpRmlMb2dnZXIgYXMgTG9nZ2VyLCBIaUZpTG9nTGV2ZWwgYXMgTG9nTGV2ZWwgfSBmcm9tIFwiLi91dGlsaXRpZXMvSGlGaUxvZ2dlclwiO1xuZXhwb3J0IHsgSGlGaVV0aWxpdGllcyBhcyBVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvSGlGaVV0aWxpdGllc1wiO1xuZXhwb3J0IHsgSGlGaUNvbnN0YW50cyBhcyBDb25zdGFudHMgfSBmcm9tIFwiLi9jb25zdGFudHMvSGlGaUNvbnN0YW50c1wiO1xuZXhwb3J0IHsgSGlGaUF4ZXMgYXMgQXhlcywgSGlGaUhhbmRlZG5lc3MgYXMgSGFuZGVkbmVzcywgSGlGaUF4aXNDb25maWd1cmF0aW9uIGFzIEF4aXNDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4vY2xhc3Nlcy9IaUZpQXhpc0NvbmZpZ3VyYXRpb25cIjtcbiJdLCJzb3VyY2VSb290IjoiIn0=