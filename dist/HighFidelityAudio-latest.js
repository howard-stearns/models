var HighFidelityAudio;HighFidelityAudio =
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../.nvm/versions/node/v14.15.4/lib/node_modules/wrtc/lib/browser.js":
/*!***************************************************************************!*\
  !*** ../.nvm/versions/node/v14.15.4/lib/node_modules/wrtc/lib/browser.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {



exports.MediaStream = window.MediaStream;
exports.MediaStreamTrack = window.MediaStreamTrack;
exports.RTCDataChannel = window.RTCDataChannel;
exports.RTCDataChannelEvent = window.RTCDataChannelEvent;
exports.RTCDtlsTransport = window.RTCDtlsTransport;
exports.RTCIceCandidate = window.RTCIceCandidate;
exports.RTCIceTransport = window.RTCIceTransport;
exports.RTCPeerConnection = window.RTCPeerConnection;
exports.RTCPeerConnectionIceEvent = window.RTCPeerConnectionIceEvent;
exports.RTCRtpReceiver = window.RTCRtpReceiver;
exports.RTCRtpSender = window.RTCRtpSender;
exports.RTCRtpTransceiver = window.RTCRtpTransceiver;
exports.RTCSctpTransport = window.RTCSctpTransport;
exports.RTCSessionDescription = window.RTCSessionDescription;
exports.getUserMedia = window.getUserMedia;
exports.mediaDevices = navigator.mediaDevices;


/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/***/ ((module, exports) => {



// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof global !== 'undefined') { return global; }
	throw new Error('unable to locate global object');
}

var global = getGlobal();

module.exports = exports = global.fetch;

// Needed for TypeScript and Webpack.
if (global.fetch) {
	exports.default = global.fetch.bind(global);
}

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;

/***/ }),

/***/ "./node_modules/pako/index.js":
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Top level file is just a mixin of submodules & constants


const { Deflate, deflate, deflateRaw, gzip } = __webpack_require__(/*! ./lib/deflate */ "./node_modules/pako/lib/deflate.js");

const { Inflate, inflate, inflateRaw, ungzip } = __webpack_require__(/*! ./lib/inflate */ "./node_modules/pako/lib/inflate.js");

const constants = __webpack_require__(/*! ./lib/zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

module.exports.Deflate = Deflate;
module.exports.deflate = deflate;
module.exports.deflateRaw = deflateRaw;
module.exports.gzip = gzip;
module.exports.Inflate = Inflate;
module.exports.inflate = inflate;
module.exports.inflateRaw = inflateRaw;
module.exports.ungzip = ungzip;
module.exports.constants = constants;


/***/ }),

/***/ "./node_modules/pako/lib/deflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {




const zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ "./node_modules/pako/lib/zlib/deflate.js");
const utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
const strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
const msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
const ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED
} = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  let status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = zlib_deflate.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    this.result = utils.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  const deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


module.exports.Deflate = Deflate;
module.exports.deflate = deflate;
module.exports.deflateRaw = deflateRaw;
module.exports.gzip = gzip;
module.exports.constants = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");


/***/ }),

/***/ "./node_modules/pako/lib/inflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {




const zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ "./node_modules/pako/lib/zlib/inflate.js");
const utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
const strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
const msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
const ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");
const GZheader     = __webpack_require__(/*! ./zlib/gzheader */ "./node_modules/pako/lib/zlib/gzheader.js");

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  this.options = utils.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  let status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = zlib_inflate.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      zlib_inflate.inflateReset(strm);
      status = zlib_inflate.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  const inflator = new Inflate(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || msg[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


module.exports.Inflate = Inflate;
module.exports.inflate = inflate;
module.exports.inflateRaw = inflateRaw;
module.exports.ungzip = inflate;
module.exports.constants = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");


/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/***/ ((module) => {




const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

module.exports.assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
module.exports.flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};


/***/ }),

/***/ "./node_modules/pako/lib/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/***/ ((module) => {

// String encode/decode helpers



// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
module.exports.string2buf = (str) => {
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
module.exports.buf2string = (buf, max) => {
  let i, out;
  const len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
module.exports.utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/***/ ((module) => {



// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


module.exports = adler32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/***/ ((module) => {



// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


module.exports = crc32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = __webpack_require__(/*! ./trees */ "./node_modules/pako/lib/zlib/trees.js");
const adler32 = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
const crc32   = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
const msg     = __webpack_require__(/*! ./messages */ "./node_modules/pako/lib/zlib/messages.js");

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK,
  Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,
  Z_DEFAULT_COMPRESSION,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY,
  Z_UNKNOWN,
  Z_DEFLATED
} = __webpack_require__(/*! ./constants */ "./node_modules/pako/lib/zlib/constants.js");

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = msg[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};


/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
const deflate_stored = (s, flush) => {

  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  let max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    const max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
};

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


const deflateResetKeep = (strm) => {

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  _tr_init(s);
  return Z_OK;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
};


const deflate = (strm, flush) => {

  let beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  const s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      let header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      let level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
};


const deflateEnd = (strm) => {

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  const status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
};


module.exports.deflateInit = deflateInit;
module.exports.deflateInit2 = deflateInit2;
module.exports.deflateReset = deflateReset;
module.exports.deflateResetKeep = deflateResetKeep;
module.exports.deflateSetHeader = deflateSetHeader;
module.exports.deflate = deflate;
module.exports.deflateEnd = deflateEnd;
module.exports.deflateSetDictionary = deflateSetDictionary;
module.exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/gzheader.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD = 30;       /* got a data error -- remain here until reset */
const TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32       = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
const crc32         = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
const inflate_fast  = __webpack_require__(/*! ./inffast */ "./node_modules/pako/lib/zlib/inffast.js");
const inflate_table = __webpack_require__(/*! ./inftrees */ "./node_modules/pako/lib/zlib/inftrees.js");

const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH, Z_BLOCK, Z_TREES,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Z_BUF_ERROR,
  Z_DEFLATED
} = __webpack_require__(/*! ./constants */ "./node_modules/pako/lib/zlib/constants.js");


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 1;       /* i: waiting for magic header */
const    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
const    TIME = 3;       /* i: waiting for modification time (gzip) */
const    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 5;      /* i: waiting for extra length (gzip) */
const    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
const    NAME = 7;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
const    HCRC = 9;       /* i: waiting for header crc (gzip) */
const    DICTID = 10;    /* i: waiting for dictionary check value */
const    DICT = 11;      /* waiting for inflateSetDictionary() call */
const        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 14;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 17;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 18;   /* i: waiting for code length code lengths */
const        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 20;      /* i: same as LEN below, but only first time in */
const            LEN = 21;       /* i: waiting for length/lit/eob code */
const            LENEXT = 22;    /* i: waiting for length extra bits */
const            DIST = 23;      /* i: waiting for distance code */
const            DISTEXT = 24;   /* i: waiting for distance extra bits */
const            MATCH = 25;     /* o: waiting for output space to copy string */
const            LIT = 26;       /* o: waiting for output space to write literal */
const    CHECK = 27;     /* i: waiting for 32-bit check value */
const    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 29;      /* finished check, done -- remain here until reset */
const    BAD = 30;       /* got a data error -- remain here until reset */
const    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateResetKeep = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
};


const inflateReset = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
};


module.exports.inflateReset = inflateReset;
module.exports.inflateReset2 = inflateReset2;
module.exports.inflateResetKeep = inflateResetKeep;
module.exports.inflateInit = inflateInit;
module.exports.inflateInit2 = inflateInit2;
module.exports.inflate = inflate;
module.exports.inflateEnd = inflateEnd;
module.exports.inflateGetHeader = inflateGetHeader;
module.exports.inflateSetDictionary = inflateSetDictionary;
module.exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES = 0;
const LENS = 1;
const DISTS = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
  let base_index = 0;
//  let shoextra;    /* extra bits table to use */
  let end;                    /* use base and extra for symbol > end */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;
  let extra_index = 0;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


module.exports = inflate_table;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH    = 3;
const MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS      = 256;
/* number of literal bytes 0..255 */

const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES       = 30;
/* number of distance codes */

const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

const MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) =>
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  const next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
const copy_block = (s, buf, len, header) =>
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
  s.pending += len;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) =>
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) =>
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let lx = 0;         /* running index in l_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) =>
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let black_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
const _tr_flush_block = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally = (s, dist, lc) =>
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //let out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
};

module.exports._tr_init  = _tr_init;
module.exports._tr_stored_block = _tr_stored_block;
module.exports._tr_flush_block  = _tr_flush_block;
module.exports._tr_tally = _tr_tally;
module.exports._tr_align = _tr_align;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;


/***/ }),

/***/ "./src/classes/HiFiAudioAPIData.ts":
/*!*****************************************!*\
  !*** ./src/classes/HiFiAudioAPIData.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Point3D": () => (/* binding */ Point3D),
/* harmony export */   "OrientationQuat3D": () => (/* binding */ OrientationQuat3D),
/* harmony export */   "OrientationEuler3D": () => (/* binding */ OrientationEuler3D),
/* harmony export */   "OrientationEuler3DOrder": () => (/* binding */ OrientationEuler3DOrder),
/* harmony export */   "eulerToQuaternion": () => (/* binding */ eulerToQuaternion),
/* harmony export */   "eulerFromQuaternion": () => (/* binding */ eulerFromQuaternion),
/* harmony export */   "HiFiAudioAPIData": () => (/* binding */ HiFiAudioAPIData),
/* harmony export */   "ReceivedHiFiAudioAPIData": () => (/* binding */ ReceivedHiFiAudioAPIData)
/* harmony export */ });
/* harmony import */ var _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/HiFiUtilities */ "./src/utilities/HiFiUtilities.ts");

class Point3D {
    constructor({ x = 0, y = 0, z = 0 } = {}) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}
class OrientationQuat3D {
    constructor({ w = 1, x = 0, y = 0, z = 0 } = {}) {
        this.w = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNonan(w, -1, 1, 1);
        this.x = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNonan(x, -1, 1, 0);
        this.y = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNonan(y, -1, 1, 0);
        this.z = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNonan(z, -1, 1, 0);
    }
}
function sanitizeAngleDegrees(v) {
    if (isNaN(v) || v === Infinity) {
        return 0;
    }
    else if (v === -Infinity) {
        return -0;
    }
    else {
        return v % 360;
    }
}
class OrientationEuler3D {
    constructor({ pitchDegrees = 0, yawDegrees = 0, rollDegrees = 0 } = {}) {
        this.pitchDegrees = sanitizeAngleDegrees(pitchDegrees);
        this.yawDegrees = sanitizeAngleDegrees(yawDegrees);
        this.rollDegrees = sanitizeAngleDegrees(rollDegrees);
    }
}
var OrientationEuler3DOrder;
(function (OrientationEuler3DOrder) {
    OrientationEuler3DOrder["PitchYawRoll"] = "PitchYawRoll";
    OrientationEuler3DOrder["YawPitchRoll"] = "YawPitchRoll";
    OrientationEuler3DOrder["RollPitchYaw"] = "RollPitchYaw";
    OrientationEuler3DOrder["RollYawPitch"] = "RollYawPitch";
    OrientationEuler3DOrder["YawRollPitch"] = "YawRollPitch";
    OrientationEuler3DOrder["PitchRollYaw"] = "PitchRollYaw";
})(OrientationEuler3DOrder || (OrientationEuler3DOrder = {}));
function eulerToQuaternion(euler, order) {
    const HALF_DEG_TO_RAD = 0.5 * Math.PI / 180.0;
    let cos = { P: Math.cos(euler.pitchDegrees * HALF_DEG_TO_RAD), Y: Math.cos(euler.yawDegrees * HALF_DEG_TO_RAD), R: Math.cos(euler.rollDegrees * HALF_DEG_TO_RAD) };
    let sin = { P: Math.sin(euler.pitchDegrees * HALF_DEG_TO_RAD), Y: Math.sin(euler.yawDegrees * HALF_DEG_TO_RAD), R: Math.sin(euler.rollDegrees * HALF_DEG_TO_RAD) };
    let ax = sin.P * cos.Y * cos.R;
    let ay = cos.P * sin.Y * cos.R;
    let az = cos.P * cos.Y * sin.R;
    let aw = cos.P * cos.Y * cos.R;
    let bx = cos.P * sin.Y * sin.R;
    let by = sin.P * cos.Y * sin.R;
    let bz = sin.P * sin.Y * cos.R;
    let bw = sin.P * sin.Y * sin.R;
    switch (order) {
        case OrientationEuler3DOrder.PitchYawRoll:
            {
                return new OrientationQuat3D({
                    x: ax + bx,
                    y: ay - by,
                    z: az + bz,
                    w: aw - bw,
                });
            }
            break;
        case OrientationEuler3DOrder.YawPitchRoll:
            {
                return new OrientationQuat3D({
                    x: ax + bx,
                    y: ay - by,
                    z: az - bz,
                    w: aw + bw,
                });
            }
            break;
        case OrientationEuler3DOrder.RollPitchYaw:
            {
                return new OrientationQuat3D({
                    x: ax - bx,
                    y: ay + by,
                    z: az + bz,
                    w: aw - bw,
                });
            }
            break;
        case OrientationEuler3DOrder.RollYawPitch:
            {
                return new OrientationQuat3D({
                    x: ax - bx,
                    y: ay + by,
                    z: az - bz,
                    w: aw + bw,
                });
            }
            break;
        case OrientationEuler3DOrder.YawRollPitch:
            {
                return new OrientationQuat3D({
                    x: ax + bx,
                    y: ay + by,
                    z: az - bz,
                    w: aw - bw,
                });
            }
            break;
        case OrientationEuler3DOrder.PitchRollYaw:
            {
                return new OrientationQuat3D({
                    x: ax - bx,
                    y: ay - by,
                    z: az + bz,
                    w: aw + bw,
                });
            }
            break;
    }
}
function eulerFromQuaternion(quat, order) {
    let qx2 = quat.x * quat.x;
    let qy2 = quat.y * quat.y;
    let qz2 = quat.z * quat.z;
    let qwx = quat.w * quat.x;
    let qwy = quat.w * quat.y;
    let qwz = quat.w * quat.z;
    let qxy = quat.x * quat.y;
    let qyz = quat.y * quat.z;
    let qxz = quat.z * quat.x;
    let r00 = 1.0 - 2.0 * (qy2 + qz2);
    let r10 = 2.0 * (qxy + qwz);
    let r20 = 2.0 * (qxz - qwy);
    let r01 = 2.0 * (qxy - qwz);
    let r11 = 1.0 - 2.0 * (qx2 + qz2);
    let r21 = 2.0 * (qyz + qwx);
    let r02 = 2.0 * (qxz + qwy);
    let r12 = 2.0 * (qyz - qwx);
    let r22 = 1.0 - 2.0 * (qx2 + qy2);
    let pitch = 0;
    let yaw = 0;
    let roll = 0;
    const ONE_MINUS_EPSILON = 0.9999999;
    switch (order) {
        case OrientationEuler3DOrder.PitchYawRoll:
            {
                yaw = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(r02));
                if (Math.abs(r02) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(-r12, r22);
                    roll = Math.atan2(-r01, r00);
                }
                else {
                    pitch = Math.atan2(r21, r11);
                }
            }
            break;
        case OrientationEuler3DOrder.YawPitchRoll:
            {
                pitch = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(-r12));
                if (Math.abs(r12) < ONE_MINUS_EPSILON) {
                    yaw = Math.atan2(r02, r22);
                    roll = Math.atan2(r10, r11);
                }
                else {
                    yaw = Math.atan2(-r20, r00);
                }
            }
            break;
        case OrientationEuler3DOrder.RollPitchYaw:
            {
                pitch = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(r21));
                if (Math.abs(r21) < ONE_MINUS_EPSILON) {
                    yaw = Math.atan2(-r20, r22);
                    roll = Math.atan2(-r01, r11);
                }
                else {
                    roll = Math.atan2(r10, r00);
                }
            }
            break;
        case OrientationEuler3DOrder.RollYawPitch:
            {
                yaw = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(-r20));
                if (Math.abs(r20) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(r21, r22);
                    roll = Math.atan2(r10, r00);
                }
                else {
                    roll = Math.atan2(-r01, r11);
                }
            }
            break;
        case OrientationEuler3DOrder.YawRollPitch:
            {
                roll = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(r10));
                if (Math.abs(r10) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(-r12, r11);
                    yaw = Math.atan2(-r20, r00);
                }
                else {
                    yaw = Math.atan2(r02, r22);
                }
            }
            break;
        case OrientationEuler3DOrder.PitchRollYaw:
            {
                roll = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(-r01));
                if (Math.abs(r01) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(r21, r11);
                    yaw = Math.atan2(r02, r00);
                }
                else {
                    yaw = Math.atan2(-r12, r22);
                }
            }
            break;
    }
    const RAD_TO_DEG = 180.0 / Math.PI;
    return new OrientationEuler3D({ pitchDegrees: RAD_TO_DEG * pitch, yawDegrees: RAD_TO_DEG * yaw, rollDegrees: RAD_TO_DEG * roll });
}
class HiFiAudioAPIData {
    constructor({ position = null, orientationQuat = null, orientationEuler = null, volumeThreshold = null, hiFiGain = null, userAttenuation = null, userRolloff = null } = {}) {
        this.position = position;
        this.orientationQuat = orientationQuat;
        this.orientationEuler = orientationEuler;
        this.volumeThreshold = volumeThreshold;
        this.hiFiGain = hiFiGain;
        this.userAttenuation = userAttenuation;
        this.userRolloff = userRolloff;
        this._otherUserGainQueue = {};
    }
}
class ReceivedHiFiAudioAPIData extends HiFiAudioAPIData {
    constructor(params = {}) {
        super(params);
        this.providedUserID = params.providedUserID;
        this.hashedVisitID = params.hashedVisitID;
        this.volumeDecibels = params.volumeDecibels;
        this.isStereo = params.isStereo;
    }
}


/***/ }),

/***/ "./src/classes/HiFiAxisConfiguration.ts":
/*!**********************************************!*\
  !*** ./src/classes/HiFiAxisConfiguration.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiAxes": () => (/* binding */ HiFiAxes),
/* harmony export */   "HiFiHandedness": () => (/* binding */ HiFiHandedness),
/* harmony export */   "HiFiAxisConfiguration": () => (/* binding */ HiFiAxisConfiguration),
/* harmony export */   "ourHiFiAxisConfiguration": () => (/* binding */ ourHiFiAxisConfiguration),
/* harmony export */   "HiFiAxisUtilities": () => (/* binding */ HiFiAxisUtilities)
/* harmony export */ });
/* harmony import */ var _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* harmony import */ var _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");


var HiFiAxes;
(function (HiFiAxes) {
    HiFiAxes["PositiveX"] = "Positive X";
    HiFiAxes["NegativeX"] = "Negative X";
    HiFiAxes["PositiveY"] = "Positive Y";
    HiFiAxes["NegativeY"] = "Negative Y";
    HiFiAxes["PositiveZ"] = "Positive Z";
    HiFiAxes["NegativeZ"] = "Negative Z";
})(HiFiAxes || (HiFiAxes = {}));
var HiFiHandedness;
(function (HiFiHandedness) {
    HiFiHandedness["RightHand"] = "Right Hand";
    HiFiHandedness["LeftHand"] = "Left Hand";
})(HiFiHandedness || (HiFiHandedness = {}));
class HiFiAxisConfiguration {
    constructor({ rightAxis, leftAxis, intoScreenAxis, outOfScreenAxis, upAxis, downAxis, handedness, eulerOrder }) {
        Object.assign(this, { rightAxis, leftAxis, intoScreenAxis, outOfScreenAxis, upAxis, downAxis, handedness, eulerOrder });
    }
}
let ourHiFiAxisConfiguration = new HiFiAxisConfiguration({
    rightAxis: HiFiAxes.PositiveX,
    leftAxis: HiFiAxes.NegativeX,
    intoScreenAxis: HiFiAxes.PositiveY,
    outOfScreenAxis: HiFiAxes.NegativeY,
    upAxis: HiFiAxes.PositiveZ,
    downAxis: HiFiAxes.NegativeZ,
    handedness: HiFiHandedness.RightHand,
    eulerOrder: _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationEuler3DOrder.YawPitchRoll,
});
class HiFiAxisUtilities {
    static verify(axisConfiguration) {
        let isValid = true;
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveX && axisConfiguration.leftAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.leftAxis === HiFiAxes.PositiveX && axisConfiguration.rightAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveY && axisConfiguration.leftAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.leftAxis === HiFiAxes.PositiveY && axisConfiguration.rightAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveZ && axisConfiguration.leftAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.leftAxis === HiFiAxes.PositiveZ && axisConfiguration.rightAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveX && axisConfiguration.outOfScreenAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveX && axisConfiguration.intoScreenAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveY && axisConfiguration.outOfScreenAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveY && axisConfiguration.intoScreenAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveZ && axisConfiguration.outOfScreenAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveZ && axisConfiguration.intoScreenAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.upAxis === HiFiAxes.PositiveX && axisConfiguration.downAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.downAxis === HiFiAxes.PositiveX && axisConfiguration.upAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.upAxis === HiFiAxes.PositiveY && axisConfiguration.downAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.downAxis === HiFiAxes.PositiveY && axisConfiguration.upAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.upAxis === HiFiAxes.PositiveZ && axisConfiguration.downAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.downAxis === HiFiAxes.PositiveZ && axisConfiguration.upAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (!(axisConfiguration.handedness === HiFiHandedness.RightHand || axisConfiguration.handedness === HiFiHandedness.LeftHand)) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nHandedness is ${axisConfiguration.handedness}!`);
            isValid = false;
        }
        return isValid;
    }
    static translatePoint3DToMixerSpace(axisConfiguration, inputPoint3D) {
        let retval = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.Point3D();
        retval = inputPoint3D;
        return retval;
    }
    static translatePoint3DFromMixerSpace(axisConfiguration, mixerPoint3D) {
        let retval = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.Point3D();
        retval = mixerPoint3D;
        return retval;
    }
    static translateOrientationQuat3DToMixerSpace(axisConfiguration, inputOrientationQuat3D) {
        let retval = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationQuat3D();
        retval = inputOrientationQuat3D;
        return retval;
    }
    static translateOrientationQuat3DFromMixerSpace(axisConfiguration, mixerOrientationQuat3D) {
        let retval = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationQuat3D();
        retval = mixerOrientationQuat3D;
        return retval;
    }
}


/***/ }),

/***/ "./src/classes/HiFiCommunicator.ts":
/*!*****************************************!*\
  !*** ./src/classes/HiFiCommunicator.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiConnectionStates": () => (/* binding */ HiFiConnectionStates),
/* harmony export */   "HiFiUserDataStreamingScopes": () => (/* binding */ HiFiUserDataStreamingScopes),
/* harmony export */   "HiFiCommunicator": () => (/* binding */ HiFiCommunicator)
/* harmony export */ });
/* harmony import */ var _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/HiFiConstants */ "./src/constants/HiFiConstants.ts");
/* harmony import */ var _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* harmony import */ var _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/HiFiUtilities */ "./src/utilities/HiFiUtilities.ts");
/* harmony import */ var _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");
/* harmony import */ var _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HiFiAxisConfiguration */ "./src/classes/HiFiAxisConfiguration.ts");
/* harmony import */ var _HiFiMixerSession__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./HiFiMixerSession */ "./src/classes/HiFiMixerSession.ts");
/* harmony import */ var _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./HiFiUserDataSubscription */ "./src/classes/HiFiUserDataSubscription.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







var HiFiConnectionStates;
(function (HiFiConnectionStates) {
    HiFiConnectionStates["Connected"] = "Connected";
    HiFiConnectionStates["Disconnected"] = "Disconnected";
    HiFiConnectionStates["Failed"] = "Failed";
    HiFiConnectionStates["Unavailable"] = "Unavailable";
})(HiFiConnectionStates || (HiFiConnectionStates = {}));
;
var HiFiUserDataStreamingScopes;
(function (HiFiUserDataStreamingScopes) {
    HiFiUserDataStreamingScopes["None"] = "none";
    HiFiUserDataStreamingScopes["Peers"] = "peers";
    HiFiUserDataStreamingScopes["All"] = "all";
})(HiFiUserDataStreamingScopes || (HiFiUserDataStreamingScopes = {}));
;
class HiFiCommunicator {
    constructor({ initialHiFiAudioAPIData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.HiFiAudioAPIData(), onConnectionStateChanged, onUsersDisconnected, transmitRateLimitTimeoutMS = _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.DEFAULT_TRANSMIT_RATE_LIMIT_TIMEOUT_MS, userDataStreamingScope = HiFiUserDataStreamingScopes.All, hiFiAxisConfiguration, webrtcSessionParams, customSTUNandTURNConfig, onMuteChanged } = {}) {
        this._timers = {
            transmitRateLimitTimeout: null,
            wantedToTransmitHiFiAudioAPIData: true
        };
        if (customSTUNandTURNConfig) {
            if (!customSTUNandTURNConfig.hasOwnProperty("stunUrls") || !Array.isArray(customSTUNandTURNConfig.stunUrls) || customSTUNandTURNConfig.stunUrls.length == 0) {
                throw new Error(`\`customSTUNandTURNConfig.stunUrls\` must be specified and must be a list containing at least one STUN server.`);
            }
            if (!customSTUNandTURNConfig.hasOwnProperty("turnUrls") || !Array.isArray(customSTUNandTURNConfig.turnUrls) || customSTUNandTURNConfig.turnUrls.length == 0) {
                throw new Error(`\`customSTUNandTURNConfig.turnUrls\` must be specified and must be a list containing at least one TURN server.`);
            }
            if (!customSTUNandTURNConfig.hasOwnProperty("turnUsername")) {
                throw new Error(`\`customSTUNandTURNConfig.turnUsername\` must be specified.`);
            }
            if (!customSTUNandTURNConfig.hasOwnProperty("turnCredential")) {
                throw new Error(`\`customSTUNandTURNConfig.turnCredential\` must be specified.`);
            }
        }
        this._customSTUNandTURNConfig = customSTUNandTURNConfig;
        if (transmitRateLimitTimeoutMS < _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`\`transmitRateLimitTimeoutMS\` must be >= ${_constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS}ms! Setting to ${_constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS}ms...`);
            transmitRateLimitTimeoutMS = _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS;
        }
        this.transmitRateLimitTimeoutMS = transmitRateLimitTimeoutMS;
        if (onUsersDisconnected) {
            this.onUsersDisconnected = onUsersDisconnected;
        }
        this._mixerSession = new _HiFiMixerSession__WEBPACK_IMPORTED_MODULE_5__.HiFiMixerSession({
            "userDataStreamingScope": userDataStreamingScope,
            "onUserDataUpdated": (data) => { this._handleUserDataUpdates(data); },
            "onUsersDisconnected": (data) => { this._onUsersDisconnected(data); },
            "onConnectionStateChanged": onConnectionStateChanged,
            "onMuteChanged": onMuteChanged
        });
        this._inputAudioMediaStream = undefined;
        this._currentHiFiAudioAPIData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.HiFiAudioAPIData();
        this._lastTransmittedHiFiAudioAPIData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.HiFiAudioAPIData();
        this._userDataSubscriptions = [];
        if (webrtcSessionParams && webrtcSessionParams.audioMinJitterBufferDuration && (webrtcSessionParams.audioMinJitterBufferDuration < 0.0 || webrtcSessionParams.audioMinJitterBufferDuration > 10.0)) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`The value of \`webrtcSessionParams.audioMinJitterBufferDuration\` (${webrtcSessionParams.audioMinJitterBufferDuration}) will be clamped to (0.0, 10.0).`);
            webrtcSessionParams.audioMinJitterBufferDuration = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_2__.HiFiUtilities.clamp(webrtcSessionParams.audioMinJitterBufferDuration, 0.0, 10.0);
        }
        if (webrtcSessionParams && webrtcSessionParams.audioMaxJitterBufferDuration && (webrtcSessionParams.audioMaxJitterBufferDuration < 0.0 || webrtcSessionParams.audioMaxJitterBufferDuration > 10.0)) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`The value of \`webrtcSessionParams.audioMaxJitterBufferDuration\` (${webrtcSessionParams.audioMaxJitterBufferDuration}) will be clamped to (0.0, 10.0).`);
            webrtcSessionParams.audioMaxJitterBufferDuration = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_2__.HiFiUtilities.clamp(webrtcSessionParams.audioMaxJitterBufferDuration, 0.0, 10.0);
        }
        this._webRTCSessionParams = webrtcSessionParams;
        if (hiFiAxisConfiguration) {
            if (_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.HiFiAxisUtilities.verify(hiFiAxisConfiguration)) {
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.rightAxis = hiFiAxisConfiguration.rightAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.leftAxis = hiFiAxisConfiguration.leftAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.intoScreenAxis = hiFiAxisConfiguration.intoScreenAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.outOfScreenAxis = hiFiAxisConfiguration.outOfScreenAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.upAxis = hiFiAxisConfiguration.upAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.downAxis = hiFiAxisConfiguration.downAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.handedness = hiFiAxisConfiguration.handedness;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.eulerOrder = hiFiAxisConfiguration.eulerOrder;
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`There is an error with the passed \`HiFiAxisConfiguration\`, so the new axis configuration was not set. There are more error details in the logs above.`);
            }
        }
        this._updateUserData(initialHiFiAudioAPIData);
    }
    connectToHiFiAudioAPIServer(hifiAuthJWT, signalingHostURL, signalingPort) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._mixerSession) {
                let errMsg = `\`this._mixerSession\` is falsey; try creating a new HiFiCommunicator and starting over.`;
                return Promise.reject({
                    success: false,
                    error: errMsg
                });
            }
            if (this._mixerSession.getCurrentHiFiConnectionState() === HiFiConnectionStates.Connected) {
                let msg = `Session is already connected! If you need to reset the connection, please disconnect fully using \`disconnectFromHiFiAudioAPIServer()\` and call this method again.`;
                return Promise.resolve({
                    success: true,
                    error: msg
                });
            }
            let mixerConnectionResponse;
            let signalingHostURLSafe;
            try {
                let url = new URL(signalingHostURL);
                signalingHostURLSafe = url.hostname;
                if (signalingPort == null && url.port !== "") {
                    signalingPort = Number(url.port);
                }
            }
            catch (e) {
                signalingHostURLSafe = signalingHostURL ? signalingHostURL : _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_ENDPOINT;
            }
            signalingPort = signalingPort ? signalingPort : _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_PORT;
            try {
                let webRTCSignalingAddress = `wss://${signalingHostURLSafe}:${signalingPort}/?token=`;
                this._mixerSession.webRTCAddress = `${webRTCSignalingAddress}${hifiAuthJWT}`;
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Using WebRTC Signaling Address:\n${webRTCSignalingAddress}<token redacted>`);
                mixerConnectionResponse = yield this._mixerSession.connectToHiFiMixer({ webRTCSessionParams: this._webRTCSessionParams, customSTUNandTURNConfig: this._customSTUNandTURNConfig });
            }
            catch (errorConnectingToMixer) {
                let errMsg = `Error when connecting to mixer!\n${errorConnectingToMixer}`;
                return Promise.reject({
                    success: false,
                    error: errMsg
                });
            }
            this._transmitHiFiAudioAPIDataToServer(true);
            return Promise.resolve({
                success: true,
                audionetInitResponse: mixerConnectionResponse.audionetInitResponse
            });
        });
    }
    setOtherUserGainForThisConnection(visitIdHash, gain) {
        return __awaiter(this, void 0, void 0, function* () {
            let otherUserGainMap = {};
            otherUserGainMap[visitIdHash] = gain;
            let result = this.setOtherUserGainsForThisConnection(otherUserGainMap);
            return Promise.resolve(result);
        });
    }
    setOtherUserGainsForThisConnection(otherUserGainMap) {
        return __awaiter(this, void 0, void 0, function* () {
            Object.assign(this._currentHiFiAudioAPIData._otherUserGainQueue, otherUserGainMap);
            let result = this._transmitHiFiAudioAPIDataToServer();
            return Promise.resolve({
                success: result.success,
                error: result.error
            });
        });
    }
    disconnectFromHiFiAudioAPIServer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._mixerSession) {
                return Promise.resolve(`No mixer session from which we can disconnect!`);
            }
            this._inputAudioMediaStream = undefined;
            this.onUsersDisconnected = undefined;
            this._userDataSubscriptions = [];
            this._currentHiFiAudioAPIData = undefined;
            this._lastTransmittedHiFiAudioAPIData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.HiFiAudioAPIData();
            return this._mixerSession.disconnectFromHiFiMixer();
        });
    }
    getOutputAudioMediaStream() {
        if (this._mixerSession) {
            return this._mixerSession.getOutputAudioMediaStream();
        }
        else {
            return null;
        }
    }
    getConnectionState() {
        if (this._mixerSession) {
            return this._mixerSession.getCurrentHiFiConnectionState();
        }
        else {
            return null;
        }
    }
    setInputAudioMediaStream(newInputAudioMediaStream, isStereo = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const retval = yield this._mixerSession.setRAVIInputAudio(newInputAudioMediaStream, isStereo);
            if (retval) {
                this._inputAudioMediaStream = newInputAudioMediaStream;
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Error trying to setRAVIInputAudio on this._mixerSession`);
            }
            return retval;
        });
    }
    setInputAudioMuted(isMuted) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._mixerSession) {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.debug(`Setting mute state to : ${isMuted}`);
                return yield this._mixerSession.setInputAudioMuted(isMuted);
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: No \`_mixerSession\`.`);
                return false;
            }
        });
    }
    getCommunicatorInfo() {
        let retval = {
            "clientInfo": {
                "inputAudioStreamSet": !!this._inputAudioMediaStream,
            }
        };
        let isBrowserContext = typeof self !== 'undefined';
        if (isBrowserContext && "string" === "string") {
            retval.clientInfo["apiVersion"] = "v1.2.2-2";
        }
        if (this._mixerSession && this._mixerSession.mixerInfo) {
            retval["serverInfo"] = this._mixerSession.mixerInfo;
        }
        return retval;
    }
    startCollectingWebRTCStats(callback) {
        if (!this._mixerSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`Couldn't start collecting WebRTC Stats: No \`_mixerSession\`!`);
        }
        this._mixerSession.startCollectingWebRTCStats(callback);
    }
    stopCollectingWebRTCStats() {
        if (!this._mixerSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`Couldn't stop collecting WebRTC Stats: No \`_mixerSession\`!`);
        }
        this._mixerSession.stopCollectingWebRTCStats();
    }
    _updateUserData({ position, orientationQuat, orientationEuler, volumeThreshold, hiFiGain, userAttenuation, userRolloff } = {}) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (position) {
            if (!this._currentHiFiAudioAPIData.position) {
                this._currentHiFiAudioAPIData.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.Point3D();
            }
            this._currentHiFiAudioAPIData.position.x = (_a = position.x) !== null && _a !== void 0 ? _a : this._currentHiFiAudioAPIData.position.x;
            this._currentHiFiAudioAPIData.position.y = (_b = position.y) !== null && _b !== void 0 ? _b : this._currentHiFiAudioAPIData.position.y;
            this._currentHiFiAudioAPIData.position.z = (_c = position.z) !== null && _c !== void 0 ? _c : this._currentHiFiAudioAPIData.position.z;
        }
        if (orientationQuat) {
            if (!this._currentHiFiAudioAPIData.orientationQuat) {
                this._currentHiFiAudioAPIData.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.OrientationQuat3D();
            }
            this._currentHiFiAudioAPIData.orientationQuat.w = (_d = orientationQuat.w) !== null && _d !== void 0 ? _d : this._currentHiFiAudioAPIData.orientationQuat.w;
            this._currentHiFiAudioAPIData.orientationQuat.x = (_e = orientationQuat.x) !== null && _e !== void 0 ? _e : this._currentHiFiAudioAPIData.orientationQuat.x;
            this._currentHiFiAudioAPIData.orientationQuat.y = (_f = orientationQuat.y) !== null && _f !== void 0 ? _f : this._currentHiFiAudioAPIData.orientationQuat.y;
            this._currentHiFiAudioAPIData.orientationQuat.z = (_g = orientationQuat.z) !== null && _g !== void 0 ? _g : this._currentHiFiAudioAPIData.orientationQuat.z;
        }
        else if (orientationEuler) {
            let checkedEuler = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.OrientationEuler3D(orientationEuler);
            this._currentHiFiAudioAPIData.orientationQuat = (0,_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.eulerToQuaternion)(checkedEuler, _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.eulerOrder);
        }
        if (typeof (volumeThreshold) === "number") {
            this._currentHiFiAudioAPIData.volumeThreshold = volumeThreshold;
        }
        if (typeof (hiFiGain) === "number") {
            this._currentHiFiAudioAPIData.hiFiGain = Math.max(0, hiFiGain);
        }
        if (typeof (userAttenuation) === "number") {
            this._currentHiFiAudioAPIData.userAttenuation = userAttenuation;
        }
        if (typeof (userRolloff) === "number") {
            this._currentHiFiAudioAPIData.userRolloff = Math.max(0, userRolloff);
        }
    }
    _maybeClearRateLimitTimeout() {
        if (this._timers.transmitRateLimitTimeout) {
            clearTimeout(this._timers.transmitRateLimitTimeout);
        }
        this._timers.transmitRateLimitTimeout = null;
    }
    _updateLastTransmittedHiFiAudioAPIData(dataJustTransmitted) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (dataJustTransmitted.position) {
            if (!this._lastTransmittedHiFiAudioAPIData.position) {
                this._lastTransmittedHiFiAudioAPIData.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.Point3D();
            }
            this._lastTransmittedHiFiAudioAPIData.position.x = (_a = dataJustTransmitted.position.x) !== null && _a !== void 0 ? _a : this._lastTransmittedHiFiAudioAPIData.position.x;
            this._lastTransmittedHiFiAudioAPIData.position.y = (_b = dataJustTransmitted.position.y) !== null && _b !== void 0 ? _b : this._lastTransmittedHiFiAudioAPIData.position.y;
            this._lastTransmittedHiFiAudioAPIData.position.z = (_c = dataJustTransmitted.position.z) !== null && _c !== void 0 ? _c : this._lastTransmittedHiFiAudioAPIData.position.z;
        }
        if (dataJustTransmitted.orientationQuat) {
            if (!this._lastTransmittedHiFiAudioAPIData.orientationQuat) {
                this._lastTransmittedHiFiAudioAPIData.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.OrientationQuat3D();
            }
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.w = (_d = dataJustTransmitted.orientationQuat.w) !== null && _d !== void 0 ? _d : this._lastTransmittedHiFiAudioAPIData.orientationQuat.w;
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.x = (_e = dataJustTransmitted.orientationQuat.x) !== null && _e !== void 0 ? _e : this._lastTransmittedHiFiAudioAPIData.orientationQuat.x;
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.y = (_f = dataJustTransmitted.orientationQuat.y) !== null && _f !== void 0 ? _f : this._lastTransmittedHiFiAudioAPIData.orientationQuat.y;
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.z = (_g = dataJustTransmitted.orientationQuat.z) !== null && _g !== void 0 ? _g : this._lastTransmittedHiFiAudioAPIData.orientationQuat.z;
        }
        if (typeof (dataJustTransmitted.volumeThreshold) === "number") {
            this._lastTransmittedHiFiAudioAPIData["volumeThreshold"] = dataJustTransmitted.volumeThreshold;
        }
        if (typeof (dataJustTransmitted.hiFiGain) === "number") {
            this._lastTransmittedHiFiAudioAPIData["hiFiGain"] = dataJustTransmitted.hiFiGain;
        }
        if (typeof (dataJustTransmitted.userAttenuation) === "number") {
            this._lastTransmittedHiFiAudioAPIData["userAttenuation"] = dataJustTransmitted.userAttenuation;
        }
        if (typeof (dataJustTransmitted.userRolloff) === "number") {
            this._lastTransmittedHiFiAudioAPIData["userRolloff"] = dataJustTransmitted.userRolloff;
        }
        if (typeof (dataJustTransmitted._otherUserGainQueue) === "object") {
            if (typeof (this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue) !== "object") {
                this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue = {};
            }
            for (const idToGain of Object.entries(dataJustTransmitted._otherUserGainQueue)) {
                this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue[idToGain[0]] = idToGain[1];
            }
        }
    }
    _transmitHiFiAudioAPIDataToServer(forceTransmit) {
        if (this._mixerSession && (!this._timers.transmitRateLimitTimeout || forceTransmit)) {
            this._timers.wantedToTransmitHiFiAudioAPIData = false;
            this._maybeClearRateLimitTimeout();
            if (!forceTransmit) {
                this._timers.transmitRateLimitTimeout = setTimeout(() => {
                    this._maybeClearRateLimitTimeout();
                    if (this._timers.wantedToTransmitHiFiAudioAPIData) {
                        this._transmitHiFiAudioAPIDataToServer(true);
                    }
                }, this.transmitRateLimitTimeoutMS);
            }
            let transmitRetval = this._mixerSession._transmitHiFiAudioAPIDataToServer(this._currentHiFiAudioAPIData, this._lastTransmittedHiFiAudioAPIData);
            if (transmitRetval.success) {
                this._updateLastTransmittedHiFiAudioAPIData(this._currentHiFiAudioAPIData);
                this._cleanUpHiFiAudioAPIDataHistory();
                return {
                    success: true,
                    rawDataTransmitted: transmitRetval.stringifiedDataForMixer
                };
            }
            else {
                return {
                    success: false,
                    error: transmitRetval.error
                };
            }
        }
        else if (this._mixerSession && this._timers.transmitRateLimitTimeout && !forceTransmit) {
            this._timers.wantedToTransmitHiFiAudioAPIData = true;
            return {
                success: true,
                error: `Transfer is rate limited. Transfer will occur shortly automatically.`
            };
        }
        else if (!this._mixerSession) {
            return {
                success: false,
                error: `No server connection yet; can't transmit user data.`
            };
        }
    }
    _cleanUpHiFiAudioAPIDataHistory() {
        this._currentHiFiAudioAPIData._otherUserGainQueue = {};
        let maxCachedOtherUserGains = 1000;
        if (Object.keys(this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue).length > maxCachedOtherUserGains) {
            this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue = {};
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Stored \`_lastTransmittedHiFiAudioAPIData._otherUserGainQueue\` was too large and was cleared to save space.`);
        }
    }
    updateUserDataAndTransmit(newUserData) {
        this._updateUserData(newUserData);
        return this._transmitHiFiAudioAPIDataToServer();
    }
    _handleUserDataUpdates(newUserDataFromServer) {
        if (this._userDataSubscriptions.length === 0) {
            return;
        }
        for (let subItr = 0; subItr < this._userDataSubscriptions.length; subItr++) {
            let currentSubscription = this._userDataSubscriptions[subItr];
            if (!currentSubscription.callback) {
                continue;
            }
            let currentSubscriptionCallbackData = [];
            for (let dataItr = 0; dataItr < newUserDataFromServer.length; dataItr++) {
                let currentDataFromServer = newUserDataFromServer[dataItr];
                if (currentSubscription.providedUserID && currentDataFromServer.providedUserID !== currentSubscription.providedUserID) {
                    continue;
                }
                let newCallbackData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.ReceivedHiFiAudioAPIData();
                if (typeof (currentDataFromServer.providedUserID) === "string") {
                    newCallbackData.providedUserID = currentDataFromServer.providedUserID;
                }
                if (typeof (currentDataFromServer.hashedVisitID) === "string") {
                    newCallbackData.hashedVisitID = currentDataFromServer.hashedVisitID;
                }
                let shouldPushNewCallbackData = false;
                for (let componentItr = 0; componentItr < currentSubscription.components.length; componentItr++) {
                    let currentComponent = currentSubscription.components[componentItr];
                    switch (currentComponent) {
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.Position:
                            if (currentDataFromServer.position) {
                                newCallbackData.position = currentDataFromServer.position;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.OrientationQuat:
                            if (currentDataFromServer.orientationQuat) {
                                newCallbackData.orientationQuat = currentDataFromServer.orientationQuat;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.OrientationEuler:
                            if (currentDataFromServer.orientationQuat) {
                                newCallbackData.orientationEuler = (0,_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.eulerFromQuaternion)(currentDataFromServer.orientationQuat, _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.eulerOrder);
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.VolumeDecibels:
                            if (typeof (currentDataFromServer.volumeDecibels) === "number") {
                                newCallbackData.volumeDecibels = currentDataFromServer.volumeDecibels;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.IsStereo:
                            if (typeof (currentDataFromServer.isStereo) === "boolean") {
                                newCallbackData.isStereo = currentDataFromServer.isStereo;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                    }
                }
                if (shouldPushNewCallbackData) {
                    currentSubscriptionCallbackData.push(newCallbackData);
                }
            }
            if (currentSubscription.callback && currentSubscriptionCallbackData.length > 0) {
                currentSubscription.callback(currentSubscriptionCallbackData);
            }
        }
    }
    _onUsersDisconnected(usersDisconnected) {
        if (this.onUsersDisconnected) {
            this.onUsersDisconnected(usersDisconnected);
        }
    }
    addUserDataSubscription(newSubscription) {
        if (!this._mixerSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`No \`_mixerSession\`! Data subscription not added.`);
            return;
        }
        if (this._mixerSession.userDataStreamingScope === HiFiUserDataStreamingScopes.None) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`During \`HiFiCommunicator\` construction, the server was set up to **not** send user data! Data subscription not added.`);
            return;
        }
        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Adding new User Data Subscription:\n${JSON.stringify(newSubscription)}`);
        this._userDataSubscriptions.push(newSubscription);
    }
}


/***/ }),

/***/ "./src/classes/HiFiMixerSession.ts":
/*!*****************************************!*\
  !*** ./src/classes/HiFiMixerSession.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MuteReason": () => (/* binding */ MuteReason),
/* harmony export */   "MuteChangedEvent": () => (/* binding */ MuteChangedEvent),
/* harmony export */   "HiFiMixerSession": () => (/* binding */ HiFiMixerSession)
/* harmony export */ });
/* harmony import */ var _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");
/* harmony import */ var _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* harmony import */ var _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HiFiCommunicator */ "./src/classes/HiFiCommunicator.ts");
/* harmony import */ var _libravi_RaviUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../libravi/RaviUtils */ "./src/libravi/RaviUtils.ts");
/* harmony import */ var _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../libravi/RaviSession */ "./src/libravi/RaviSession.ts");
/* harmony import */ var _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../libravi/RaviSignalingConnection */ "./src/libravi/RaviSignalingConnection.ts");
/* harmony import */ var _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./HiFiAxisConfiguration */ "./src/classes/HiFiAxisConfiguration.ts");
/* harmony import */ var _diagnostics_diagnostics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../diagnostics/diagnostics */ "./src/diagnostics/diagnostics.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








const pako = __webpack_require__(/*! pako */ "./node_modules/pako/index.js");
const INIT_TIMEOUT_MS = 5000;
const PERSONAL_VOLUME_ADJUST_TIMEOUT_MS = 5000;
var MuteReason;
(function (MuteReason) {
    MuteReason["CLIENT"] = "client";
    MuteReason["ADMIN"] = "admin";
    MuteReason["INTERNAL"] = "internal";
})(MuteReason || (MuteReason = {}));
class MuteChangedEvent {
    constructor({ success, targetInputAudioMutedValue, currentInputAudioMutedValue, adminPreventsInputAudioUnmuting, muteReason }) {
        this.success = success;
        this.targetInputAudioMutedValue = targetInputAudioMutedValue;
        this.currentInputAudioMutedValue = currentInputAudioMutedValue;
        this.adminPreventsInputAudioUnmuting = adminPreventsInputAudioUnmuting;
        this.muteReason = muteReason;
    }
}
class HiFiMixerSession {
    constructor({ userDataStreamingScope = _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiUserDataStreamingScopes.All, onUserDataUpdated, onUsersDisconnected, onConnectionStateChanged, onMuteChanged }) {
        this.concurrency = 0;
        this.webRTCAddress = undefined;
        this.userDataStreamingScope = userDataStreamingScope;
        this.onUserDataUpdated = onUserDataUpdated;
        this.onUsersDisconnected = onUsersDisconnected;
        this._mixerPeerKeyToStateCacheDict = {};
        this._lastSuccessfulInputAudioMutedValue = false;
        this.onMuteChanged = onMuteChanged;
        _libravi_RaviUtils__WEBPACK_IMPORTED_MODULE_3__.RaviUtils.setDebug(false);
        this._raviSignalingConnection = new _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingConnection();
        this._raviSignalingConnection.addStateChangeHandler((event) => {
            this.onRAVISignalingStateChanged(event);
        });
        this._raviSession = new _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSession();
        this._raviSession.addStateChangeHandler((event) => {
            this.onRAVISessionStateChanged(event);
        });
        this.onConnectionStateChanged = onConnectionStateChanged;
        this._resetMixerInfo();
        this._raviDiagnostics = new _diagnostics_diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics({ label: 'ravi', session: this, ravi: this._raviSession });
        this._hifiDiagnostics = new _diagnostics_diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics({ label: 'app', session: this, ravi: this._raviSession,
            fireOn: ['visibilitychange', 'pagehide', 'beforeunload'] });
    }
    promiseToRunAudioInit() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let initData = {
                    primary: true,
                    visit_id: this._raviSession.getUUID(),
                    session: this._raviSession.getUUID(),
                    streaming_scope: this.userDataStreamingScope,
                    is_input_stream_stereo: this._inputAudioMediaStreamIsStereo
                };
                let commandController = this._raviSession.getCommandController();
                if (!commandController) {
                    return Promise.reject({
                        success: false,
                        error: `Couldn't connect to mixer: no \`commandController\`!`
                    });
                }
                let initTimeout = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    let errMsg = `Couldn't connect to mixer: Call to \`init\` timed out!`;
                    try {
                        yield this._disconnectFromHiFiMixer();
                    }
                    catch (errorClosing) {
                        errMsg += `\nAdditionally, there was an error trying to close the failed connection. Error:\n${errorClosing}`;
                    }
                    return Promise.reject({
                        success: false,
                        error: errMsg
                    });
                }), INIT_TIMEOUT_MS);
                commandController.queueCommand("audionet.init", initData, (response) => __awaiter(this, void 0, void 0, function* () {
                    clearTimeout(initTimeout);
                    let parsedResponse;
                    try {
                        parsedResponse = JSON.parse(response);
                        this.mixerInfo["connected"] = true;
                        this.mixerInfo["build_number"] = parsedResponse.build_number;
                        this.mixerInfo["build_type"] = parsedResponse.build_type;
                        this.mixerInfo["build_version"] = parsedResponse.build_version;
                        this.mixerInfo["visit_id_hash"] = parsedResponse.visit_id_hash;
                        this._raviDiagnostics.prime(this.mixerInfo.visit_id_hash);
                        this._hifiDiagnostics.prime(this.mixerInfo.visit_id_hash);
                        resolve({
                            success: true,
                            audionetInitResponse: parsedResponse
                        });
                    }
                    catch (e) {
                        reject({
                            success: false,
                            error: `Couldn't parse init response! Parse error:\n${e}`
                        });
                    }
                }));
            });
        });
    }
    handleRAVISessionBinaryData(data) {
        let unGZippedData = pako.ungzip(data, { to: 'string' });
        let jsonData = JSON.parse(unGZippedData);
        if (jsonData.deleted_visit_ids) {
            let allDeletedUserData = [];
            let deletedVisitIDs = jsonData.deleted_visit_ids;
            for (const deletedVisitID of deletedVisitIDs) {
                let hashedVisitID = deletedVisitID;
                let deletedUserData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.ReceivedHiFiAudioAPIData({
                    hashedVisitID: hashedVisitID
                });
                let mixerPeerKeys = Object.keys(this._mixerPeerKeyToStateCacheDict);
                for (const mixerPeerKey of mixerPeerKeys) {
                    if (this._mixerPeerKeyToStateCacheDict[mixerPeerKey].hashedVisitID === hashedVisitID) {
                        if (this._mixerPeerKeyToStateCacheDict[mixerPeerKey].providedUserID) {
                            deletedUserData.providedUserID = this._mixerPeerKeyToStateCacheDict[mixerPeerKey].providedUserID;
                        }
                        break;
                    }
                }
                allDeletedUserData.push(deletedUserData);
            }
            this.concurrency -= allDeletedUserData.length;
            if (this.onUsersDisconnected && allDeletedUserData.length > 0) {
                this.onUsersDisconnected(allDeletedUserData);
            }
        }
        if (jsonData.peers) {
            let allNewUserData = [];
            let peerKeys = Object.keys(jsonData.peers);
            for (let itr = 0; itr < peerKeys.length; itr++) {
                let peerDataFromMixer = jsonData.peers[peerKeys[itr]];
                let userDataCache;
                if (this._mixerPeerKeyToStateCacheDict[peerKeys[itr]]) {
                    userDataCache = this._mixerPeerKeyToStateCacheDict[peerKeys[itr]];
                }
                else {
                    userDataCache = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.ReceivedHiFiAudioAPIData();
                    this._mixerPeerKeyToStateCacheDict[peerKeys[itr]] = userDataCache;
                    this.concurrency += 1;
                }
                let newUserData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.ReceivedHiFiAudioAPIData();
                if (userDataCache.providedUserID) {
                    newUserData.providedUserID = userDataCache.providedUserID;
                }
                else if (typeof (peerDataFromMixer.J) === "string") {
                    userDataCache.providedUserID = peerDataFromMixer.J;
                    newUserData.providedUserID = peerDataFromMixer.J;
                }
                if (userDataCache.hashedVisitID) {
                    newUserData.hashedVisitID = userDataCache.hashedVisitID;
                }
                else if (typeof (peerDataFromMixer.e) === "string") {
                    userDataCache.hashedVisitID = peerDataFromMixer.e;
                    newUserData.hashedVisitID = peerDataFromMixer.e;
                }
                let serverSentNewUserData = false;
                let serverSentNewPosition = false;
                if (typeof (peerDataFromMixer.x) === "number") {
                    if (!userDataCache.position) {
                        userDataCache.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.Point3D();
                    }
                    userDataCache.position.x = peerDataFromMixer.x / 1000;
                    serverSentNewPosition = true;
                }
                if (typeof (peerDataFromMixer.y) === "number") {
                    if (!userDataCache.position) {
                        userDataCache.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.Point3D();
                    }
                    userDataCache.position.y = peerDataFromMixer.y / 1000;
                    serverSentNewPosition = true;
                }
                if (typeof (peerDataFromMixer.z) === "number") {
                    if (!userDataCache.position) {
                        userDataCache.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.Point3D();
                    }
                    userDataCache.position.z = peerDataFromMixer.z / 1000;
                    serverSentNewPosition = true;
                }
                if (serverSentNewPosition) {
                    newUserData.position = _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisUtilities.translatePoint3DFromMixerSpace(_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.ourHiFiAxisConfiguration, userDataCache.position);
                    serverSentNewUserData = true;
                }
                let serverSentNewOrientation = false;
                if (typeof (peerDataFromMixer.W) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.w = peerDataFromMixer.W / 1000;
                    serverSentNewOrientation = true;
                }
                if (typeof (peerDataFromMixer.X) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.x = peerDataFromMixer.X / 1000;
                    serverSentNewOrientation = true;
                }
                if (typeof (peerDataFromMixer.Y) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.y = peerDataFromMixer.Y / 1000;
                    serverSentNewOrientation = true;
                }
                if (typeof (peerDataFromMixer.Z) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.z = peerDataFromMixer.Z / 1000;
                    serverSentNewOrientation = true;
                }
                if (serverSentNewOrientation) {
                    newUserData.orientationQuat = _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisUtilities.translateOrientationQuat3DFromMixerSpace(_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.ourHiFiAxisConfiguration, userDataCache.orientationQuat);
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.v) === "number") {
                    userDataCache.volumeDecibels = peerDataFromMixer.v;
                    newUserData.volumeDecibels = peerDataFromMixer.v;
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.s) === "boolean") {
                    userDataCache.isStereo = peerDataFromMixer.s;
                    newUserData.isStereo = peerDataFromMixer.s;
                    serverSentNewUserData = true;
                }
                if (serverSentNewUserData) {
                    allNewUserData.push(newUserData);
                }
            }
            if (this.onUserDataUpdated && allNewUserData.length > 0) {
                this.onUserDataUpdated(allNewUserData);
            }
        }
        if (jsonData.instructions) {
            for (const instruction of jsonData.instructions) {
                if (!Array.isArray(instruction) || !instruction.length) {
                    continue;
                }
                let instructionName = instruction[0];
                let instructionArguments = instruction.slice(1);
                if (instructionName === "mute") {
                    let shouldBeMuted;
                    if (instructionArguments.length >= 1) {
                        if (typeof (instructionArguments[0]) === "boolean") {
                            shouldBeMuted = instructionArguments[0];
                        }
                    }
                    if (shouldBeMuted !== undefined) {
                        this._setMutedByAdmin(shouldBeMuted, MuteReason.ADMIN);
                    }
                }
            }
        }
    }
    connectToHiFiMixer({ webRTCSessionParams, customSTUNandTURNConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._currentHiFiConnectionState === _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Connected && this.mixerInfo["connected"]) {
                let msg = `Already connected! If a reconnect is needed, please hang up and try again.`;
                return Promise.resolve(msg);
            }
            if (!this.webRTCAddress) {
                let errMsg = `Couldn't connect: \`this.webRTCAddress\` is falsey!`;
                try {
                    yield this._disconnectFromHiFiMixer();
                }
                catch (errorClosing) {
                    errMsg += `\nAdditionally, there was an error trying to close the failed connection. Error:\n${errorClosing}`;
                }
                return Promise.reject(errMsg);
            }
            this._currentHiFiConnectionState = undefined;
            let mixerIsUnavailable = false;
            const tempUnavailableStateHandler = (event) => {
                if (event && event.state === _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingStates.UNAVAILABLE) {
                    mixerIsUnavailable = true;
                    this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                    this._raviSession.closeRAVISession();
                }
            };
            this._raviSignalingConnection.addStateChangeHandler(tempUnavailableStateHandler);
            try {
                yield this._raviSignalingConnection.openRAVISignalingConnection(this.webRTCAddress);
            }
            catch (errorOpeningSignalingConnection) {
                let errMsg = `Couldn't open signaling connection to \`${this.webRTCAddress.slice(0, this.webRTCAddress.indexOf("token="))}<token redacted>\`! Error:\n${errorOpeningSignalingConnection}`;
                try {
                    yield this._disconnectFromHiFiMixer();
                }
                catch (errorClosing) {
                    errMsg += `\nAdditionally, there was an error trying to close the failed connection. Error:\n${errorClosing}`;
                }
                this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                return Promise.reject(errMsg);
            }
            try {
                yield this._raviSession.openRAVISession({ signalingConnection: this._raviSignalingConnection, params: webRTCSessionParams, customStunAndTurn: customSTUNandTURNConfig });
            }
            catch (errorOpeningRAVISession) {
                let errMsg = `Couldn't open RAVI session associated with \`${this.webRTCAddress.slice(0, this.webRTCAddress.indexOf("token="))}<token redacted>\`! Error:\n${errorOpeningRAVISession}`;
                if (mixerIsUnavailable) {
                    errMsg = `High Fidelity server is at capacity; service is unavailable.`;
                }
                try {
                    yield this._disconnectFromHiFiMixer();
                }
                catch (errorClosing) {
                    errMsg += `\nAdditionally, there was an error trying to close the connection. Error:\n${errorClosing}`;
                }
                this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                return Promise.reject(errMsg);
            }
            let audionetInitResponse;
            try {
                audionetInitResponse = yield this.promiseToRunAudioInit();
            }
            catch (initError) {
                let errMsg = `\`audionet.init\` command failed! Error:\n${initError.error}`;
                try {
                    yield this._disconnectFromHiFiMixer();
                }
                catch (errorClosing) {
                    errMsg += `\nAdditionally, there was an error trying to close the failed connection. Error:\n${errorClosing}`;
                }
                this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                return Promise.reject(errMsg);
            }
            this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
            this.concurrency = 0;
            this._raviSession.getCommandController().addBinaryHandler((data) => { this.handleRAVISessionBinaryData(data); }, true);
            return Promise.resolve(audionetInitResponse);
        });
    }
    disconnectFromHiFiMixer() {
        return __awaiter(this, void 0, void 0, function* () {
            this._raviDiagnostics.noteExplicitApplicationClose();
            this._hifiDiagnostics.noteExplicitApplicationClose();
            return this._disconnectFromHiFiMixer();
        });
    }
    _disconnectFromHiFiMixer() {
        return __awaiter(this, void 0, void 0, function* () {
            function close(thingToClose, nameOfThingToClose, closedState) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (thingToClose) {
                        let state = thingToClose.getState();
                        if (!thingToClose || state === closedState) {
                            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`The RAVI ${nameOfThingToClose} was already closed.`);
                        }
                        else {
                            try {
                                if (thingToClose instanceof _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingConnection) {
                                    yield thingToClose.closeRAVISignalingConnection();
                                }
                                else if (thingToClose instanceof _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSession) {
                                    yield thingToClose.closeRAVISession();
                                }
                                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`The RAVI ${nameOfThingToClose} closed successfully from state ${state}.`);
                            }
                            catch (e) {
                                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`The RAVI ${nameOfThingToClose} didn't close successfully from state ${state}! Error:\n${e}`);
                            }
                        }
                    }
                    else {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`The RAVI ${nameOfThingToClose} was missing.`);
                    }
                    thingToClose = null;
                });
            }
            yield close(this._raviSignalingConnection, "Signaling Connection", _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingStates.CLOSED);
            yield close(this._raviSession, "Session", _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.CLOSED);
            this._resetMixerInfo();
            yield this._setMutedByAdmin(false, MuteReason.INTERNAL);
            return Promise.resolve(`Successfully disconnected.`);
        });
    }
    setRAVIInputAudio(inputAudioMediaStream, isStereo = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let retval = false;
            if (this._raviSession) {
                let streamController = this._raviSession.getStreamController();
                if (!streamController) {
                    _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set input audio on _raviSession.streamController: No \`streamController\`!`);
                    retval = false;
                }
                else {
                    streamController.setInputAudio(inputAudioMediaStream, isStereo);
                    _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set input audio on _raviSession.streamController!`);
                    retval = true;
                }
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set input audio on _raviSession.streamController: No \`_raviSession\`!`);
                retval = false;
            }
            if (retval) {
                if (this._inputAudioMediaStreamIsStereo != isStereo) {
                    if (this._raviSession.getState() === _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.CONNECTED) {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Stereo status has changed from ${this._inputAudioMediaStreamIsStereo} to ${isStereo}; attempting to re-initialize with the mixer`);
                        let audionetInitResponse;
                        try {
                            this._inputAudioMediaStreamIsStereo = isStereo;
                            audionetInitResponse = yield this.promiseToRunAudioInit();
                        }
                        catch (initError) {
                            let errMsg = `Attempt to call \`audionet.init\` for change in stereo status failed! Error:\n${initError.error}`;
                            return Promise.reject(errMsg);
                        }
                    }
                    else {
                        this._inputAudioMediaStreamIsStereo = isStereo;
                    }
                }
            }
            return retval;
        });
    }
    setInputAudioMuted(newMutedValue, tryToStopMicStream = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._setMuted(newMutedValue, tryToStopMicStream, MuteReason.CLIENT);
        });
    }
    _setMutedByAdmin(mutedByAdmin, muteReason) {
        return __awaiter(this, void 0, void 0, function* () {
            this._adminPreventsInputAudioUnmuting = mutedByAdmin;
            return yield this._setMuted(mutedByAdmin || this._lastSuccessfulInputAudioMutedValue, false, muteReason);
        });
    }
    _setMuted(newMutedValue, tryToStopMicStream, muteReason) {
        return __awaiter(this, void 0, void 0, function* () {
            let success = true;
            if (muteReason == MuteReason.CLIENT) {
                if (this._adminPreventsInputAudioUnmuting && !newMutedValue) {
                    _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: Muted by admin.`);
                    success = false;
                }
            }
            if (success) {
                success = yield this._trySetInputAudioMuted(newMutedValue, tryToStopMicStream);
            }
            if (success) {
                this._lastSuccessfulInputAudioMutedValue = newMutedValue;
            }
            if (this.onMuteChanged) {
                this.onMuteChanged(new MuteChangedEvent({
                    success: success,
                    targetInputAudioMutedValue: newMutedValue,
                    currentInputAudioMutedValue: this._lastSuccessfulInputAudioMutedValue,
                    adminPreventsInputAudioUnmuting: this._adminPreventsInputAudioUnmuting,
                    muteReason: muteReason
                }));
            }
            return success;
        });
    }
    _trySetInputAudioMuted(newMutedValue, tryToStopMicStream) {
        return __awaiter(this, void 0, void 0, function* () {
            let streamController = this._raviSession.getStreamController();
            if (this._raviSession && streamController) {
                let hasMicPermission = false;
                if (typeof (navigator) !== "undefined" && navigator.permissions && navigator.permissions.query) {
                    let result;
                    try {
                        result = yield navigator.permissions.query({ name: 'microphone' });
                    }
                    catch (_a) { }
                    if (result && result.state === "granted") {
                        hasMicPermission = true;
                    }
                }
                if (!tryToStopMicStream || !hasMicPermission || typeof self === 'undefined') {
                    let raviAudioStream = streamController._inputAudioStream;
                    if (raviAudioStream) {
                        raviAudioStream.getTracks().forEach((track) => {
                            track.enabled = !newMutedValue;
                        });
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set mute state to ${newMutedValue} on _raviSession.streamController._inputAudioStream`);
                        return true;
                    }
                    else {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: No \`_inputAudioStream\` on \`_raviSession.streamController\`.`);
                    }
                }
                else {
                    let raviAudioStream = streamController._inputAudioStream;
                    if (raviAudioStream && newMutedValue) {
                        raviAudioStream.getTracks().forEach((track) => {
                            this._cachedMediaTrackConstraints = track.getConstraints();
                            track.stop();
                        });
                        streamController.setInputAudio(null);
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set mute state to \`true\` by stopping all input media tracks!`);
                        return true;
                    }
                    else if (!raviAudioStream && !newMutedValue) {
                        let newMediaStream = yield navigator.mediaDevices.getUserMedia({ audio: this._cachedMediaTrackConstraints, video: false });
                        streamController.setInputAudio(newMediaStream);
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set mute state to \`false\` by getting new input media stream!`);
                        return true;
                    }
                    else if (raviAudioStream && !newMutedValue) {
                        raviAudioStream.getTracks().forEach((track) => {
                            track.enabled = true;
                        });
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set mute state to \`false\` by enabling all tracks on \`_raviSession.streamController._inputAudioStream\`!`);
                        return true;
                    }
                    else {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: No \`_inputAudioStream\` on \`_raviSession.streamController\`.`);
                    }
                }
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: No \`_raviSession\`, or \`_raviSession.getStreamController()\` returned null.`);
                return false;
            }
        });
    }
    getOutputAudioMediaStream() {
        if (!this._raviSession) {
            return null;
        }
        let streamController = this._raviSession.getStreamController();
        if (!streamController) {
            return null;
        }
        return streamController.getAudioStream();
    }
    _setCurrentHiFiConnectionState(state) {
        if (this._currentHiFiConnectionState !== state) {
            this._currentHiFiConnectionState = state;
            if (this.onConnectionStateChanged) {
                this.onConnectionStateChanged(this._currentHiFiConnectionState);
            }
            this._hifiDiagnostics.fire();
        }
    }
    getCurrentHiFiConnectionState() {
        return this._currentHiFiConnectionState;
    }
    onRAVISignalingStateChanged(event) {
        return __awaiter(this, void 0, void 0, function* () {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`New RAVI signaling state: \`${event.state}\``);
            switch (event.state) {
                case _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingStates.UNAVAILABLE:
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Unavailable);
                    try {
                        yield this._disconnectFromHiFiMixer();
                    }
                    catch (errorClosing) {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Error encountered while trying to close the connection. Error:\n${errorClosing}`);
                    }
                    break;
            }
        });
    }
    onRAVISessionStateChanged(event) {
        return __awaiter(this, void 0, void 0, function* () {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`New RAVI session state: \`${event.state}\``);
            this._raviDiagnostics.fire();
            switch (event.state) {
                case _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.CONNECTED:
                    this._mixerPeerKeyToStateCacheDict = {};
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Connected);
                    break;
                case _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.DISCONNECTED:
                    if (this._currentHiFiConnectionState === _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Unavailable) {
                        break;
                    }
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Disconnected);
                    try {
                        yield this._disconnectFromHiFiMixer();
                    }
                    catch (errorClosing) {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Error encountered while trying to close the connection. Error:\n${errorClosing}`);
                    }
                    break;
                case _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.FAILED:
                    if (this._currentHiFiConnectionState === _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Unavailable) {
                        break;
                    }
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Failed);
                    break;
                case _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.CLOSED:
                    if (this._currentHiFiConnectionState === _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Unavailable) {
                        break;
                    }
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Disconnected);
                    break;
            }
        });
    }
    startCollectingWebRTCStats(callback) {
        if (!this._raviSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`Couldn't start collecting WebRTC stats: No \`_raviSession\`!`);
            return;
        }
        if (this._statsObserverCallback) {
            this.stopCollectingWebRTCStats();
        }
        this._statsObserverCallback = callback;
        this._raviSession.addStatsObserver(this._statsObserverCallback);
    }
    stopCollectingWebRTCStats() {
        if (!this._raviSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`Couldn't stop collecting WebRTC stats: No \`_raviSession\`!`);
            return;
        }
        this._raviSession.removeStatsObserver(this._statsObserverCallback);
        this._statsObserverCallback = undefined;
    }
    _transmitHiFiAudioAPIDataToServer(currentHifiAudioAPIData, previousHifiAudioAPIData) {
        if (!this.mixerInfo["connected"] || !this._raviSession) {
            return {
                success: false,
                error: `Can't transmit data to mixer; not connected to mixer.`
            };
        }
        let dataForMixer = {};
        if (currentHifiAudioAPIData.position && (typeof (currentHifiAudioAPIData.position.x) === "number")
            && (typeof (currentHifiAudioAPIData.position.y) === "number")
            && (typeof (currentHifiAudioAPIData.position.z) === "number")) {
            let changedComponents = { x: false, y: false, z: false, changed: false };
            if (previousHifiAudioAPIData && previousHifiAudioAPIData.position) {
                if (currentHifiAudioAPIData.position.x !== previousHifiAudioAPIData.position.x) {
                    changedComponents.x = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.position.y !== previousHifiAudioAPIData.position.y) {
                    changedComponents.y = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.position.z !== previousHifiAudioAPIData.position.z) {
                    changedComponents.z = true;
                    changedComponents.changed = true;
                }
            }
            else {
                changedComponents.x = true;
                changedComponents.y = true;
                changedComponents.z = true;
                changedComponents.changed = true;
            }
            if (changedComponents.changed) {
                let translatedPosition = _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisUtilities.translatePoint3DToMixerSpace(_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.ourHiFiAxisConfiguration, currentHifiAudioAPIData.position);
                if (changedComponents.x) {
                    dataForMixer["x"] = Math.round(translatedPosition.x * 1000);
                }
                if (changedComponents.y) {
                    dataForMixer["y"] = Math.round(translatedPosition.y * 1000);
                }
                if (changedComponents.z) {
                    dataForMixer["z"] = Math.round(translatedPosition.z * 1000);
                }
            }
        }
        if (currentHifiAudioAPIData.orientationQuat && (typeof (currentHifiAudioAPIData.orientationQuat.w) === "number")
            && (typeof (currentHifiAudioAPIData.orientationQuat.x) === "number")
            && (typeof (currentHifiAudioAPIData.orientationQuat.y) === "number")
            && (typeof (currentHifiAudioAPIData.orientationQuat.z) === "number")) {
            let changedComponents = { w: false, x: false, y: false, z: false, changed: false };
            if (previousHifiAudioAPIData && previousHifiAudioAPIData.orientationQuat) {
                if (currentHifiAudioAPIData.orientationQuat.w !== previousHifiAudioAPIData.orientationQuat.w) {
                    changedComponents.w = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.orientationQuat.x !== previousHifiAudioAPIData.orientationQuat.x) {
                    changedComponents.x = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.orientationQuat.y !== previousHifiAudioAPIData.orientationQuat.y) {
                    changedComponents.y = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.orientationQuat.z !== previousHifiAudioAPIData.orientationQuat.z) {
                    changedComponents.z = true;
                    changedComponents.changed = true;
                }
            }
            else {
                changedComponents.w = true;
                changedComponents.x = true;
                changedComponents.y = true;
                changedComponents.z = true;
                changedComponents.changed = true;
            }
            if (changedComponents.changed) {
                let translatedOrientation = _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisUtilities.translateOrientationQuat3DToMixerSpace(_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.ourHiFiAxisConfiguration, currentHifiAudioAPIData.orientationQuat);
                if (changedComponents.w) {
                    dataForMixer["W"] = translatedOrientation.w * 1000;
                }
                if (changedComponents.x) {
                    dataForMixer["X"] = translatedOrientation.x * 1000;
                }
                if (changedComponents.y) {
                    dataForMixer["Y"] = translatedOrientation.y * 1000;
                }
                dataForMixer["Z"] = translatedOrientation.z * 1000;
            }
        }
        if (typeof (currentHifiAudioAPIData.volumeThreshold) === "number") {
            dataForMixer["T"] = currentHifiAudioAPIData.volumeThreshold;
        }
        if (typeof (currentHifiAudioAPIData.hiFiGain) === "number") {
            dataForMixer["g"] = Math.max(0, currentHifiAudioAPIData.hiFiGain);
        }
        if (typeof (currentHifiAudioAPIData.userAttenuation) === "number") {
            dataForMixer["a"] = currentHifiAudioAPIData.userAttenuation;
        }
        if (typeof (currentHifiAudioAPIData.userRolloff) === "number") {
            dataForMixer["r"] = Math.max(0, currentHifiAudioAPIData.userRolloff);
        }
        if (typeof (currentHifiAudioAPIData._otherUserGainQueue) == "object") {
            let changedUserGains = {};
            let idToGains = Object.entries(currentHifiAudioAPIData._otherUserGainQueue);
            let previousOtherUserGains = previousHifiAudioAPIData ? previousHifiAudioAPIData._otherUserGainQueue : undefined;
            for (const idToGain of idToGains) {
                let hashedVisitId = idToGain[0];
                let gain = idToGain[1];
                if (!(typeof (gain) == "number")) {
                    continue;
                }
                if (previousOtherUserGains && previousOtherUserGains[hashedVisitId] === gain) {
                    continue;
                }
                changedUserGains[hashedVisitId] = gain;
            }
            if (Object.entries(changedUserGains).length) {
                dataForMixer["V"] = changedUserGains;
            }
        }
        if (Object.keys(dataForMixer).length === 0) {
            return {
                success: true,
                stringifiedDataForMixer: JSON.stringify({})
            };
        }
        else {
            let commandController = this._raviSession.getCommandController();
            if (commandController) {
                let stringifiedDataForMixer = JSON.stringify(dataForMixer);
                commandController.sendInput(stringifiedDataForMixer);
                return {
                    success: true,
                    stringifiedDataForMixer: stringifiedDataForMixer
                };
            }
            else {
                return {
                    success: false,
                    error: `Can't transmit data to mixer; no \`commandController\`!.`
                };
            }
        }
    }
    _resetMixerInfo() {
        this.mixerInfo = {
            "connected": false,
        };
    }
}


/***/ }),

/***/ "./src/classes/HiFiUserDataSubscription.ts":
/*!*************************************************!*\
  !*** ./src/classes/HiFiUserDataSubscription.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AvailableUserDataSubscriptionComponents": () => (/* binding */ AvailableUserDataSubscriptionComponents),
/* harmony export */   "UserDataSubscription": () => (/* binding */ UserDataSubscription)
/* harmony export */ });
var AvailableUserDataSubscriptionComponents;
(function (AvailableUserDataSubscriptionComponents) {
    AvailableUserDataSubscriptionComponents["Position"] = "Position";
    AvailableUserDataSubscriptionComponents["OrientationEuler"] = "Orientation (Euler)";
    AvailableUserDataSubscriptionComponents["OrientationQuat"] = "Orientation (Quaternion)";
    AvailableUserDataSubscriptionComponents["VolumeDecibels"] = "Volume (Decibels)";
    AvailableUserDataSubscriptionComponents["IsStereo"] = "IsStereo";
})(AvailableUserDataSubscriptionComponents || (AvailableUserDataSubscriptionComponents = {}));
class UserDataSubscription {
    constructor({ providedUserID = null, components, callback }) {
        this.providedUserID = providedUserID;
        this.components = components;
        this.callback = callback;
    }
}


/***/ }),

/***/ "./src/constants/HiFiConstants.ts":
/*!****************************************!*\
  !*** ./src/constants/HiFiConstants.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiConstants": () => (/* binding */ HiFiConstants)
/* harmony export */ });
class HiFiConstants {
    constructor() { }
}
HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS = 10;
HiFiConstants.DEFAULT_TRANSMIT_RATE_LIMIT_TIMEOUT_MS = 50;
HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_ENDPOINT = "api.highfidelity.com";
HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_PORT = 443;
;


/***/ }),

/***/ "./src/diagnostics/diagnostics.ts":
/*!****************************************!*\
  !*** ./src/diagnostics/diagnostics.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Diagnostics": () => (/* binding */ Diagnostics)
/* harmony export */ });
/* harmony import */ var _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libravi/RaviSession */ "./src/libravi/RaviSession.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const isBrowser = typeof window !== 'undefined';
const noop = (_) => undefined;
const xStorage = isBrowser ? window.localStorage : { getItem: noop, setItem: noop, removeItem: noop };
const xAddEventListener = isBrowser ? window.addEventListener : noop;
const xRemoveEventListener = isBrowser ? window.removeEventListener : noop;
const xDocument = isBrowser ? window.document : { visibilityState: true, addEventListener: noop, removeEventListener: noop };
const xNavigator = isBrowser ? window.navigator : { onLine: true, userAgent: `NodeJS ${process.report.getReport().header.nodejsVersion}` };
let xfetch = isBrowser && window.fetch;
if (!isBrowser) {
    try {
        xfetch = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
    }
    catch (e) {
        ;
    }
}
const nonOperative = "non-operative";
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('remote-inbound-rtp', _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.get('remote-inbound-rtp').concat(['packetsLost', 'totalRoundTripTime']));
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('inbound-rtp', _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.get('inbound-rtp').concat(['packetsLost', 'packetsReceived', 'jitter']));
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('outbound-rtp', ['type', 'retransmittedPacketsSent', 'packetsSent']);
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('candidate-pair', ['writable', 'state', 'nominated', 'localCandidateId', 'remoteCandidateId']);
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('remote-candidate', ['id', 'address', 'ip', 'candidateType', 'protocol']);
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('local-candidate', ['id', 'address', 'ip', 'candidateType', 'protocol']);
let nStatsClients = 0;
let browserStats = {};
let remoteStats = {};
let reports;
const useDebugPrefixes = false;
class Diagnostics {
    constructor({ url = "https://webrtc-diag.highfidelity.com/api/v1/logs/post_logs", label, session, ravi, fireOn = [] }) {
        Object.assign(this, { url, label, session, ravi, fireOn });
        this.checkPersisted();
        this.reset();
        this.fireListener = () => this.fire();
        this.onlineListener = () => this.checkPersisted();
    }
    prime(identifier) {
        if (this.isPrimed())
            return;
        this.checkPersisted();
        this.identifier = identifier;
        this.grabRTCInternals();
        Diagnostics.startStats(this.session);
        this.fireOn.forEach(event => xDocument.addEventListener(event, this.fireListener));
    }
    fire() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isPrimed())
                return;
            const reportString = this.toString();
            if (!(yield this.report(reportString))) {
                this.persist(reportString);
            }
            this.reset();
        });
    }
    noteExplicitApplicationClose() {
        this.explicitApplicationClose = true;
    }
    reset() {
        Diagnostics.stopStats(this.session);
        this.identifier = nonOperative;
        this.explicitApplicationClose = false;
        this.webSocket = this.rtc = {};
        this.fireOn.forEach(event => xDocument.removeEventListener(event, this.fireListener));
        reports = {
            'outbound-rtp': {},
            'inbound-rtp': {},
            'remote-inbound-rtp': {}
        };
    }
    isPrimed() {
        return this.identifier !== nonOperative;
    }
    toString() {
        return `${new Date().toISOString()} ${this.identifier} ` +
            this.s('logReason', 'sessionEND') +
            this.connectionStats('browserStats') +
            this.connectionStats('mixerStats') +
            this.rtpStats() +
            this.rtcStates() +
            this.s('NUM_CONNECTED', this.session.concurrency, '\n') +
            this.s('APPSTATE', this.session.getCurrentHiFiConnectionState(), '\n') +
            this.s('RAVISTATE', this.ravi.getState()) +
            this.s('ONLINE', xNavigator.onLine ? 'yes' : 'no') +
            this.s('XPLICITCLOSED', this.explicitApplicationClose ? 'yes' : 'no') +
            this.visibilityInfo() +
            this.connectionInfo() +
            (useDebugPrefixes ? '\n' : '') +
            ` [${xNavigator.userAgent}]`;
    }
    s(name, value, debugPrefix = '') {
        let separator = isNaN(value) ? '_' : ':';
        return `${useDebugPrefixes ? debugPrefix : ''} ${this.label}${name}${separator}${value}`;
    }
    connectionInfo() {
        const info = xNavigator.connection || xNavigator.mozConnection || xNavigator.webkitConnection || {};
        return this.s('DEVICE', info.type, '\n') +
            this.s('RATING', info.effectiveType) +
            this.s('DL', info.downlink) +
            this.s('RTT', info.rtt);
    }
    visibilityInfo() {
        return this.s('VISIBLITY', xDocument.visibilityState);
    }
    grabRTCInternals() {
        let ravi = this.ravi, raviRTC = ravi._raviImplementation, signaling = raviRTC._signalingConnection._signalingImplementation;
        this.webSocket = signaling._webSocket;
        this.rtc = raviRTC._rtcConnection;
    }
    rtcStates() {
        let collector = {}, safelyGet = (property, source = this.rtc) => {
            try {
                collector[property] = source[property];
            }
            catch (e) {
                collector[property] = e.name;
            }
        };
        safelyGet('readyState', this.webSocket);
        ['connectionState', 'signalingState', 'iceConnctionState', 'iceGatheringState'].forEach(p => safelyGet(p));
        return this.s('WebSocket', collector.readyState, '\n') +
            this.s('RTC', collector.connectionState) +
            this.s('SIGNALING', collector.signalingState) +
            this.s('ICE', collector.iceConnectionState) +
            this.s('GATHERING', collector.iceGatheringState);
    }
    connectionStats(kind) {
        let report = kind === 'browserStats' ? browserStats : remoteStats;
        return this.s(kind + 'IP', report.ip || report.address, '\n') +
            this.s(kind + 'TYPE', report.candidateType) +
            this.s(kind + 'PROTOCOL', report.protocol);
    }
    rtpStats() {
        let s = '';
        Object.keys(reports).forEach(reportName => {
            let report = reports[reportName], first = true;
            Object.keys(report).forEach(propertyName => {
                s += this.s(`${reportName}_${propertyName}`, report[propertyName], first ? '\n' : '');
                first = false;
            });
        });
        return s;
    }
    report(reportString) {
        if (!xNavigator.onLine)
            return false;
        if (!xfetch)
            return false;
        return xfetch(this.url, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: reportString
        }).then((response) => response.ok, (x) => false);
    }
    persist(reportString) {
        let existing = xStorage.getItem(this.label) || "";
        if (existing)
            existing += "\n";
        xStorage.setItem(this.label, existing + reportString);
        xAddEventListener('online', this.onlineListener);
    }
    checkPersisted() {
        return __awaiter(this, void 0, void 0, function* () {
            xRemoveEventListener('online', this.onlineListener);
            let existing = xStorage.getItem(this.label);
            if (!existing)
                return;
            if (!(yield this.report(existing)))
                return;
            xStorage.removeItem(this.label);
        });
    }
    static startStats(session) {
        if (nStatsClients++ > 0)
            return;
        session.startCollectingWebRTCStats((next, previous) => {
            let selected = next.find((report) => report.writable || report.nominated), localReport = next.find((report) => report.id === selected.localCandidateId), remoteReport = next.find((report) => report.id === selected.remoteCandidateId);
            if (localReport)
                browserStats = localReport;
            if (remoteReport)
                remoteStats = remoteReport;
            function note(type, deltaProperties, absoluteProperties = []) {
                function findReport(list) {
                    return list.find((report) => {
                        return report.type == type;
                    });
                }
                let previousReport = findReport(previous), nextReport = findReport(next);
                deltaProperties.forEach(property => reports[type][property] =
                    nextReport && (nextReport[property] - (previousReport ? previousReport[property] : 0)));
                absoluteProperties.forEach(property => reports[type][property] =
                    nextReport && nextReport[property]);
            }
            note('outbound-rtp', ['retransmittedPacketsSent', 'packetsSent']);
            note('inbound-rtp', ['packetsLost', 'packetsReceived'], ['jitter']);
            note('remote-inbound-rtp', ['packetsLost'], ['roundTripTime', 'totalRoundTripTime', 'jitter']);
        });
    }
    static stopStats(session) {
        if (!nStatsClients)
            return;
        if (--nStatsClients > 0)
            return;
        session.stopCollectingWebRTCStats();
        browserStats = remoteStats = {};
    }
}


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiUtilities": () => (/* reexport safe */ _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities),
/* harmony export */   "hiFiAPIVersion": () => (/* binding */ apiVersion),
/* harmony export */   "apiVersion": () => (/* binding */ apiVersion),
/* harmony export */   "HiFiAudioAPIData": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.HiFiAudioAPIData),
/* harmony export */   "ReceivedHiFiAudioAPIData": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.ReceivedHiFiAudioAPIData),
/* harmony export */   "OrientationEuler3D": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationEuler3D),
/* harmony export */   "OrientationQuat3D": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationQuat3D),
/* harmony export */   "Point3D": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.Point3D),
/* harmony export */   "eulerToQuaternion": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.eulerToQuaternion),
/* harmony export */   "eulerFromQuaternion": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.eulerFromQuaternion),
/* harmony export */   "HiFiCommunicator": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiCommunicator),
/* harmony export */   "HiFiConnectionStates": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates),
/* harmony export */   "HiFiUserDataStreamingScopes": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiUserDataStreamingScopes),
/* harmony export */   "AvailableUserDataSubscriptionComponents": () => (/* reexport safe */ _classes_HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_3__.AvailableUserDataSubscriptionComponents),
/* harmony export */   "UserDataSubscription": () => (/* reexport safe */ _classes_HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_3__.UserDataSubscription),
/* harmony export */   "HiFiLogLevel": () => (/* reexport safe */ _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__.HiFiLogLevel),
/* harmony export */   "HiFiLogger": () => (/* reexport safe */ _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__.HiFiLogger),
/* harmony export */   "HiFiConstants": () => (/* reexport safe */ _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_5__.HiFiConstants),
/* harmony export */   "HiFiAxes": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxes),
/* harmony export */   "HiFiHandedness": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiHandedness),
/* harmony export */   "HiFiAxisConfiguration": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisConfiguration),
/* harmony export */   "getBestAudioConstraints": () => (/* binding */ getBestAudioConstraints),
/* harmony export */   "preciseInterval": () => (/* binding */ preciseInterval),
/* harmony export */   "Communicator": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiCommunicator),
/* harmony export */   "ConnectionStates": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates),
/* harmony export */   "UserDataStreamingScopes": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiUserDataStreamingScopes),
/* harmony export */   "ReceivedAudioAPIData": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.ReceivedHiFiAudioAPIData),
/* harmony export */   "AudioAPIData": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.HiFiAudioAPIData),
/* harmony export */   "Logger": () => (/* reexport safe */ _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__.HiFiLogger),
/* harmony export */   "LogLevel": () => (/* reexport safe */ _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__.HiFiLogLevel),
/* harmony export */   "Utilities": () => (/* reexport safe */ _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities),
/* harmony export */   "Constants": () => (/* reexport safe */ _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_5__.HiFiConstants),
/* harmony export */   "Axes": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxes),
/* harmony export */   "Handedness": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiHandedness),
/* harmony export */   "AxisConfiguration": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisConfiguration)
/* harmony export */ });
/* harmony import */ var _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities/HiFiUtilities */ "./src/utilities/HiFiUtilities.ts");
/* harmony import */ var _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");
/* harmony import */ var _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/HiFiCommunicator */ "./src/classes/HiFiCommunicator.ts");
/* harmony import */ var _classes_HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classes/HiFiUserDataSubscription */ "./src/classes/HiFiUserDataSubscription.ts");
/* harmony import */ var _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* harmony import */ var _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants/HiFiConstants */ "./src/constants/HiFiConstants.ts");
/* harmony import */ var _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./classes/HiFiAxisConfiguration */ "./src/classes/HiFiAxisConfiguration.ts");


let isBrowserContext = typeof self !== 'undefined';
if (isBrowserContext) {
    _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.checkBrowserCompatibility();
}
let apiVersion =  true ? "v1.2.2-2" : 0;








let getBestAudioConstraints = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.getBestAudioConstraints;

let preciseInterval = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.preciseInterval;









/***/ }),

/***/ "./src/libravi/RaviCommandController.ts":
/*!**********************************************!*\
  !*** ./src/libravi/RaviCommandController.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviCommandController": () => (/* binding */ RaviCommandController)
/* harmony export */ });
/* harmony import */ var _RaviUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");

const _BINARY_COMMAND_KEY = "_BINARY";
const _MOUSE_STATE_BUFFER_SIZE = 28;
var _KEY_CODE_TABLE;
(function (_KEY_CODE_TABLE) {
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ControlLeft"] = 0] = "ControlLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["AltLeft"] = 1] = "AltLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["OSLeft"] = 2] = "OSLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Space"] = 3] = "Space";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["OSRight"] = 4] = "OSRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["AltRight"] = 5] = "AltRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ControlRight"] = 6] = "ControlRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ShiftLeft"] = 7] = "ShiftLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ShiftRight"] = 8] = "ShiftRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Comma"] = 9] = "Comma";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Period"] = 10] = "Period";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Slash"] = 11] = "Slash";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["CapsLock"] = 12] = "CapsLock";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Enter"] = 13] = "Enter";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Semicolon"] = 14] = "Semicolon";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Quote"] = 15] = "Quote";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Tab"] = 16] = "Tab";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["BracketLeft"] = 17] = "BracketLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["BracketRight"] = 18] = "BracketRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Backslash"] = 19] = "Backslash";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Backquote"] = 20] = "Backquote";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Minus"] = 21] = "Minus";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Equal"] = 22] = "Equal";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit0"] = 23] = "Digit0";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit1"] = 24] = "Digit1";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit2"] = 25] = "Digit2";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit3"] = 26] = "Digit3";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit4"] = 27] = "Digit4";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit5"] = 28] = "Digit5";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit6"] = 29] = "Digit6";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit7"] = 30] = "Digit7";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit8"] = 31] = "Digit8";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit9"] = 32] = "Digit9";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Backspace"] = 33] = "Backspace";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Escape"] = 34] = "Escape";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowLeft"] = 35] = "ArrowLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowRight"] = 36] = "ArrowRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowDown"] = 37] = "ArrowDown";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowUp"] = 38] = "ArrowUp";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["PageDown"] = 39] = "PageDown";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["PageUp"] = 40] = "PageUp";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["End"] = 41] = "End";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Home"] = 42] = "Home";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Delete"] = 43] = "Delete";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Insert"] = 44] = "Insert";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad0"] = 45] = "Numpad0";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad1"] = 46] = "Numpad1";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad2"] = 47] = "Numpad2";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad3"] = 48] = "Numpad3";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad4"] = 49] = "Numpad4";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad5"] = 50] = "Numpad5";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad6"] = 51] = "Numpad6";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad7"] = 52] = "Numpad7";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad8"] = 53] = "Numpad8";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad9"] = 54] = "Numpad9";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadDecimal"] = 55] = "NumpadDecimal";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadEnter"] = 56] = "NumpadEnter";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadAdd"] = 57] = "NumpadAdd";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadSubtract"] = 58] = "NumpadSubtract";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumLock"] = 59] = "NumLock";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadEqual"] = 60] = "NumpadEqual";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadMultiply"] = 61] = "NumpadMultiply";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadDivide"] = 62] = "NumpadDivide";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyA"] = 63] = "KeyA";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyB"] = 64] = "KeyB";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyC"] = 65] = "KeyC";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyD"] = 66] = "KeyD";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyE"] = 67] = "KeyE";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyF"] = 68] = "KeyF";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyG"] = 69] = "KeyG";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyH"] = 70] = "KeyH";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyI"] = 71] = "KeyI";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyJ"] = 72] = "KeyJ";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyK"] = 73] = "KeyK";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyL"] = 74] = "KeyL";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyM"] = 75] = "KeyM";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyN"] = 76] = "KeyN";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyO"] = 77] = "KeyO";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyP"] = 78] = "KeyP";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyQ"] = 79] = "KeyQ";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyR"] = 80] = "KeyR";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyS"] = 81] = "KeyS";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyT"] = 82] = "KeyT";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyU"] = 83] = "KeyU";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyV"] = 84] = "KeyV";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyW"] = 85] = "KeyW";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyX"] = 86] = "KeyX";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyY"] = 87] = "KeyY";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyZ"] = 88] = "KeyZ";
})(_KEY_CODE_TABLE || (_KEY_CODE_TABLE = {}));
;
const _KEYBOARD_STATE_BUFFER_SIZE = 12;
class RaviCommandController {
    constructor() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviCommandController");
        this._commandQueueMap = new Map();
        this._numQueuedCommands = 0;
        this._commandQueueInterval = 1000;
        this._commandPumpTimer = null;
        this._inputTarget;
        this._keyboardTarget;
        this._mouseStateBuffer = new ArrayBuffer(_MOUSE_STATE_BUFFER_SIZE + 4);
        this._mouseStateUint8 = new Uint8Array(this._mouseStateBuffer);
        this._mouseStateUint8[0] = 0x4D;
        this._mouseStateFloat = new Float32Array(this._mouseStateBuffer, 4);
        this._mouseStateFloat[0] = -1.0;
        this._mouseStateFloat[1] = -1.0;
        this._mouseStateFloat[2] = -1.0;
        this._mouseStateFloat[3] = -1.0;
        this._keyboardStateBuffer = new ArrayBuffer(_KEYBOARD_STATE_BUFFER_SIZE + 1);
        this._keyboardState = new Uint8Array(this._keyboardStateBuffer);
        this._keyboardState[0] = 0x4B;
    }
    setCommandQueueInterval(queueInterval) {
        this._commandQueueInterval = queueInterval;
        if (this._commandPumpTimer) {
            this.stopMonitoringQueues();
            this.monitorQueues();
        }
    }
    queueCommand(command, param, handler) {
        var commandQueue = this._commandQueueMap.get(command);
        if (!commandQueue) {
            commandQueue = { toSend: [], listener: [] };
            this._commandQueueMap.set(command, commandQueue);
        }
        var handlerInstance = null;
        if (handler) {
            handlerInstance = new RaviCommandHandlerInstance(handler, false, true);
        }
        commandQueue.toSend.push(new RaviCommandInstance(command, param, handlerInstance));
        this._numQueuedCommands++;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Added command " + command, "RaviCommandController");
    }
    queueBinaryCommand(message) {
        let command = _BINARY_COMMAND_KEY;
        var commandQueue = this._commandQueueMap.get(command);
        if (!commandQueue) {
            commandQueue = { toSend: [], listener: [] };
            this._commandQueueMap.set(command, commandQueue);
        }
        commandQueue.toSend.push(new RaviCommandInstance(message, null, null));
        this._numQueuedCommands++;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Added binary command", "RaviCommandController");
    }
    addMessageHandler(expectedMessage, handler, isSticky) {
        var messageEntry = this._commandQueueMap.get(expectedMessage);
        if (!messageEntry) {
            messageEntry = { toSend: [], listener: [] };
            this._commandQueueMap.set(expectedMessage, messageEntry);
        }
        var handlerInstance = new RaviCommandHandlerInstance(handler, isSticky, false);
        messageEntry.listener.push(handlerInstance);
    }
    addBinaryHandler(handler, isSticky) {
        this.addMessageHandler(_BINARY_COMMAND_KEY, handler, isSticky);
    }
    sendInput(inputEvent) {
        if (this._inputDataChannel && this._inputDataChannel.readyState === 'open') {
            this._inputDataChannel.send(inputEvent);
        }
    }
    monitorQueues() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Begin monitoring for queued commands", "RaviCommandController");
        this._commandPumpTimer = setInterval(this._processSendingQueuedCommands.bind(this), this._commandQueueInterval);
    }
    stopMonitoringQueues() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Stop monitoring for queued commands", "RaviCommandController");
        clearInterval(this._commandPumpTimer);
        this._commandPumpTimer = null;
    }
    _processSendingQueuedCommands() {
        if (this._numQueuedCommands <= 0) {
            return;
        }
        this._commandQueueMap.forEach(function (value, key, map) {
            if (value.toSend.length) {
                var commandInstance = value.toSend.shift();
                if (commandInstance._handler) {
                    value.listener.push(commandInstance._handler);
                }
                if (this._sendCommandInstance(commandInstance)) {
                    this._numQueuedCommands--;
                }
                else {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Send failed. CommandDataChannel may have been disconnected. Will not retry.", "RaviCommandController");
                }
            }
        }.bind(this));
    }
    _serializeJsonCommandMessageToSend(command, payload) {
        return JSON.stringify({ "c": command, "p": payload });
    }
    _unserializeJsonCommandMessageFromReceived(message) {
        let commandMessage;
        try {
            commandMessage = JSON.parse(message);
        }
        catch (e) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err(`Couldn't parse command message! Error:\n${e}\n Full message contents:\n${message}`, "RaviCommandController");
            return;
        }
        if (commandMessage && commandMessage.c && commandMessage.p) {
            return { 'command': commandMessage.c, 'payload': commandMessage.p };
        }
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Message cannot be unserialized into a CommandMessage: " + message, "RaviCommandController");
        return null;
    }
    _sendCommandInstance(commandInstance) {
        try {
            let message = commandInstance._command;
            if (typeof message === "string") {
                message = this._serializeJsonCommandMessageToSend(commandInstance._command, commandInstance._param);
                _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Sending command " + message, "RaviCommandController");
            }
            else {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Sending binary command", "RaviCommandController");
            }
            this._commandDataChannel.send(message);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Received error while sending: " + err.message, "RaviCommandController");
            return false;
        }
    }
    _processListeningCommand(fromServerMessage) {
        let serverData = fromServerMessage.data;
        let commandMessage = null;
        if (serverData) {
            if (typeof serverData === 'string') {
                commandMessage = this._unserializeJsonCommandMessageFromReceived(serverData);
                this._continueProcessingListeningCommand(commandMessage);
            }
            else if (serverData instanceof ArrayBuffer) {
                commandMessage = { 'command': _BINARY_COMMAND_KEY, 'payload': new Uint8Array(serverData) };
                this._continueProcessingListeningCommand(commandMessage);
            }
            else if (serverData instanceof Blob) {
                serverData.arrayBuffer()
                    .then((processedArrayBuffer) => {
                    commandMessage = { 'command': _BINARY_COMMAND_KEY, 'payload': new Uint8Array(processedArrayBuffer) };
                    this._continueProcessingListeningCommand(commandMessage);
                });
            }
        }
    }
    _continueProcessingListeningCommand(commandMessage) {
        if (!commandMessage) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Received invalid command message, ignoring: " + JSON.stringify(commandMessage), "RaviCommandController");
            return;
        }
        var foundCommandInstance = this._commandQueueMap.get(commandMessage.command);
        if (foundCommandInstance) {
            var length = foundCommandInstance.listener.length;
            if (length > 0) {
                if (foundCommandInstance.listener[0] && foundCommandInstance.listener[0]._hasMatchingSentCommand) {
                    var commandInstance = foundCommandInstance.listener.shift();
                    if (commandInstance && commandInstance._handler) {
                        commandInstance._handler(commandMessage.payload);
                        return;
                    }
                    else {
                        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Undefined command handler: " + commandMessage, "RaviCommandController");
                    }
                }
                else {
                    var newListeners = [];
                    for (var i = 0; i < length; i++) {
                        var listener = foundCommandInstance.listener[i];
                        if (listener && listener._handler) {
                            listener._handler(commandMessage.payload);
                        }
                        else {
                            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Undefined message handler: " + commandMessage, "RaviCommandController");
                        }
                        if (listener && listener._isSticky) {
                            newListeners.push(listener);
                        }
                    }
                    foundCommandInstance.listener = newListeners;
                }
            }
        }
    }
    _setInputDataChannel(inputDataChannel) {
        this._inputDataChannel = inputDataChannel;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Received new input data channel with id " + this._inputDataChannel.id, "RaviCommandController");
        this._inputDataChannel.onopen = function () {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_inputDataChannel onopen, state is " + this._inputDataChannel.readyState, "RaviCommandController");
        }.bind(this);
        this._inputDataChannel.onclose = function () {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_inputDataChannel onclose, state is " + this._inputDataChannel.readyState, "RaviCommandController");
        }.bind(this);
        this._inputDataChannel.onmessage = function (message) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_inputDataChannel got message: " + (message.data), "RaviCommandController");
        }.bind(this);
    }
    _setCommandDataChannel(commandDataChannel) {
        this._commandDataChannel = commandDataChannel;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Received new data channel with id " + this._commandDataChannel.id, "RaviCommandController");
        this._commandDataChannel.onopen = function () {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_commandDataChannel ononpen, state is " + this._commandDataChannel.readyState, "RaviCommandController");
            this.monitorQueues();
        }.bind(this);
        this._commandDataChannel.onclose = function () {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_commandDataChannel onclose, state is " + this._commandDataChannel.readyState, "RaviCommandController");
            this.stopMonitoringQueues();
        }.bind(this);
        this._commandDataChannel.onmessage = function (message) {
            this._processListeningCommand(message);
        }.bind(this);
    }
    setInputTarget(inputTargetElement) {
        if (this._inputTarget) {
            this._inputTarget.onmousemove = null;
            this._inputTarget.onmouseenter = null;
            this._inputTarget.onmouseleave = null;
            this._inputTarget.onmousedown = null;
            this._inputTarget.onmouseup = null;
            this._inputTarget.onwheel = null;
        }
        this._inputTarget = inputTargetElement;
        if (this._inputTarget) {
            var that = this;
            this._inputTarget.onmousemove = function (event) { that._trackMouse(event); };
            this._inputTarget.onmouseenter = null;
            this._inputTarget.onmouseleave = null;
            this._inputTarget.onmousedown = function (event) { that._captureMouseDown(event); };
            this._inputTarget.onmouseup = function (event) { that._resetMouseDown(event); };
            this._inputTarget.onwheel = function (event) { that._wheelMouse(event); };
        }
    }
    setKeyboardTarget(inputTargetElement) {
        if (this._keyboardTarget) {
            this._keyboardTarget.onkeydown = null;
            this._keyboardTarget.onkeyup = null;
        }
        this._keyboardTarget = inputTargetElement;
        if (this._keyboardTarget) {
            var that = this;
            this._keyboardTarget.onkeydown = function (event) { that._onKeyboardDown(event); };
            this._keyboardTarget.onkeyup = function (event) { that._onKeyboardUp(event); };
        }
    }
    _captureMouseDown(e) {
        this._mouseStateFloat[0] = e.offsetX;
        this._mouseStateFloat[1] = e.offsetY;
        this._mouseStateFloat[2] = e.offsetX;
        this._mouseStateFloat[3] = e.offsetY;
        this._mouseStateUint8[1] = e.buttons;
        this._sendMouseState();
    }
    _resetMouseDown(e) {
        this._mouseStateFloat[0] = -1.0;
        this._mouseStateFloat[1] = -1.0;
        this._mouseStateFloat[2] = -1.0;
        this._mouseStateFloat[3] = -1.0;
        this._mouseStateUint8[1] = e.buttons;
        this._sendMouseState();
    }
    _trackMouse(e) {
        this._mouseStateFloat[0] = e.offsetX;
        this._mouseStateFloat[1] = e.offsetY;
        this._mouseStateFloat[4] = this._inputTarget.offsetWidth;
        this._mouseStateFloat[5] = this._inputTarget.offsetHeight;
        this._mouseStateUint8[1] = e.buttons;
        this._sendMouseState();
    }
    _wheelMouse(e) {
        this._mouseStateFloat[6] = e.deltaY;
        this._sendMouseState();
        this._mouseStateFloat[6] = 0;
    }
    _sendMouseState() {
        this.sendInput(this._mouseStateBuffer);
    }
    _keyByteNum(c) {
        return c >> 3;
    }
    _keyBitMask(c) {
        return (1 << (c % 8));
    }
    _onKeyboardDown(e) {
        let c = _KEY_CODE_TABLE[e.code];
        let keyByteNum = 1 + this._keyByteNum(c);
        let keyByteMask = this._keyBitMask(c);
        if ((this._keyboardState[keyByteNum] & keyByteMask) === 0) {
            this._keyboardState[keyByteNum] |= keyByteMask;
            this._sendKeyboardState();
        }
    }
    _onKeyboardUp(e) {
        let c = _KEY_CODE_TABLE[e.code];
        let keyByteNum = 1 + this._keyByteNum(c);
        let keyByteMask = this._keyBitMask(c);
        if ((this._keyboardState[keyByteNum] & keyByteMask) !== 0) {
            this._keyboardState[keyByteNum] ^= keyByteMask;
            this._sendKeyboardState();
        }
    }
    _sendKeyboardState() {
        this.sendInput(this._keyboardStateBuffer);
    }
}
class RaviCommandInstance {
    constructor(command, param, handler) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviCommandInstance");
        this._command = command;
        this._param = param;
        this._handler = handler;
    }
}
class RaviCommandHandlerInstance {
    constructor(handler, isSticky, hasMatchingSentCommand) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviCommandHandlerInstance");
        this._handler = handler;
        this._isSticky = isSticky;
        this._hasMatchingSentCommand = hasMatchingSentCommand;
    }
}


/***/ }),

/***/ "./src/libravi/RaviSession.ts":
/*!************************************!*\
  !*** ./src/libravi/RaviSession.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviSessionStates": () => (/* binding */ RaviSessionStates),
/* harmony export */   "RaviSession": () => (/* binding */ RaviSession),
/* harmony export */   "STATS_WATCHER_FILTER": () => (/* binding */ STATS_WATCHER_FILTER)
/* harmony export */ });
/* harmony import */ var _RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RaviSignalingConnection */ "./src/libravi/RaviSignalingConnection.ts");
/* harmony import */ var _RaviStreamController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RaviStreamController */ "./src/libravi/RaviStreamController.ts");
/* harmony import */ var _RaviUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");
/* harmony import */ var _RaviCommandController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RaviCommandController */ "./src/libravi/RaviCommandController.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




;
var RaviSessionStates;
(function (RaviSessionStates) {
    RaviSessionStates["NEW"] = "new";
    RaviSessionStates["CONNECTING"] = "checking";
    RaviSessionStates["CONNECTED"] = "connected";
    RaviSessionStates["COMPLETED"] = "completed";
    RaviSessionStates["DISCONNECTED"] = "disconnected";
    RaviSessionStates["FAILED"] = "failed";
    RaviSessionStates["CLOSED"] = "closed";
})(RaviSessionStates || (RaviSessionStates = {}));
;
class RaviSession {
    constructor() {
        this._stateChangeHandlers = new Set();
        this._uuid = _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.createUUID();
        this._commandController = new _RaviCommandController__WEBPACK_IMPORTED_MODULE_3__.RaviCommandController();
        this._streamController = new _RaviStreamController__WEBPACK_IMPORTED_MODULE_1__.RaviStreamController(this._commandController);
        this._state = RaviSessionStates.CLOSED;
        this._raviImplementation = new RaviWebRTCImplementation(this);
        const raviImpl = this._raviImplementation;
        this._streamController.setInputAudioChangeHandler(raviImpl._addAudioInputStream.bind(raviImpl));
        this._streamController.setInputVideoChangeHandler(raviImpl._addVideoInputStream.bind(raviImpl));
    }
    getState() {
        return this._state;
    }
    getUUID() {
        return this._uuid;
    }
    addStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.add(changeHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error adding a state change handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    removeStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.delete(changeHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error removing a state change handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    getCommandController() {
        return this._commandController;
    }
    getStreamController() {
        return this._streamController;
    }
    openRAVISession({ signalingConnection, timeout = 5000, params = null, customStunAndTurn = null }) {
        if (this._state === RaviSessionStates.CONNECTED || this._state === RaviSessionStates.COMPLETED) {
            return Promise.resolve("There is already an open RAVI session. To reconnect, first close the existing connection, and then attempt to open again.");
        }
        var raviSession = this;
        this._raviImplementation._assignSignalingConnection(signalingConnection);
        this._openingTimeout = setTimeout(() => {
            let errorMessage = "RaviSession.open timed out after " + timeout + " ms";
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log(errorMessage, "RaviSession");
            raviSession._fulfillPromises({ message: errorMessage }, RaviSessionStates.FAILED);
            raviSession.closeRAVISession();
        }, timeout);
        return new Promise((resolve, reject) => {
            raviSession._resolveOpen = resolve;
            raviSession._rejectOpen = reject;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Opening RAVI session", "RaviSession");
            this._state = RaviSessionStates.NEW;
            raviSession._raviImplementation._open(params, customStunAndTurn);
        });
    }
    closeRAVISession() {
        var raviSession = this;
        if (this._state === RaviSessionStates.CLOSED)
            return Promise.resolve("RAVI session is already closed.");
        this._streamController._stop();
        this._commandController.stopMonitoringQueues();
        return new Promise((resolve, reject) => {
            raviSession._resolveClose = resolve;
            raviSession._rejectClose = reject;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Closing RAVI session", "RaviSession");
            raviSession._raviImplementation._close();
        });
    }
    _fulfillPromises(event = {}, state) {
        let errorMessage = event.reason || event.message || state;
        switch (state) {
            case RaviSessionStates.CONNECTED:
            case RaviSessionStates.COMPLETED:
                if (this._openingTimeout) {
                    clearTimeout(this._openingTimeout);
                    this._openingTimeout = null;
                }
                if (this._resolveOpen)
                    this._resolveOpen();
                if (this._rejectClose)
                    this._rejectClose(errorMessage);
                break;
            case RaviSessionStates.DISCONNECTED:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("_fulfillPromises: Possible transitory state DISCONNECTED; leaving promises pending", "RaviSession");
                break;
            case RaviSessionStates.FAILED:
                if (this._openingTimeout) {
                    clearTimeout(this._openingTimeout);
                    this._openingTimeout = null;
                }
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._rejectClose)
                    this._rejectClose(errorMessage);
                let raviSession = this;
                const closeTimer = setTimeout(() => {
                    raviSession._raviImplementation._close();
                }, 0);
                break;
            case RaviSessionStates.CLOSED:
                if (this._openingTimeout) {
                    clearTimeout(this._openingTimeout);
                    this._openingTimeout = null;
                }
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._resolveClose)
                    this._resolveClose();
                break;
            default:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("_fulfillPromises: Skipping in-progress state " + state, "RaviSession");
        }
    }
    _doOntrack(event) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received new track: ", "RaviSession");
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log(event, "RaviSession");
        if (event && event.track && event.track.kind === "video") {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Adding remote video track to stream controller", "RaviSession");
            this._streamController._setVideoStream(event.streams[0]);
            this._streamController._onVideoStreamStateChanged("ready");
        }
        if (event && event.track && event.track.kind === "audio") {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Adding remote audio track to stream controller", "RaviSession");
            this._streamController._setAudioStream(event.streams[0]);
        }
    }
    _doOndatachannel(event) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received new channel: ", "RaviSession");
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log(event, "RaviSession");
        switch (event.channel.label) {
            case "ravi.input":
                this._commandController._setInputDataChannel(event.channel);
                break;
            case "ravi.command":
                this._commandController._setCommandDataChannel(event.channel);
                break;
            default:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received unknown data channel named " + event.channel.label, "RaviSession");
                break;
        }
    }
    _handleStateChange(event = {}, state) {
        event["state"] = state;
        this._fulfillPromises(event, state);
        if (state !== this._state) {
            this._state = state;
            event["state"] = state;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("_handleStateChange: " + _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.safelyPrintable(event), "RaviSession");
            this._stateChangeHandlers.forEach(function (handler) {
                if (handler) {
                    handler(event);
                }
            });
        }
    }
    addStatsObserver(observer) {
        return this._raviImplementation._addStatsObserver(observer);
    }
    removeStatsObserver(observer) {
        return this._raviImplementation._removeStatsObserver(observer);
    }
}
const STATS_WATCHER_FILTER = new Map([
    ["remote-inbound-rtp", ["id", "type", "timestamp", "roundTripTime", "jitter"]],
    ["inbound-rtp", ["id", "type", "timestamp", "jitterBufferDelay", "jitterBufferEmittedCount", "bytesReceived"]]
]);
class RaviWebRTCStatsWatcher {
    constructor(webRTCImplementation) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("constructor", "RaviStatsWatcher");
        this._raviImplementation = webRTCImplementation;
        this._observers = new Set();
        this._filter = STATS_WATCHER_FILTER;
        this._interval = 0;
        this._prevStats = [];
    }
    stop() {
        if (this._interval) {
            clearInterval(this._interval);
            this._interval = 0;
        }
    }
    addObserver(observer) {
        try {
            this._observers.add(observer);
            this._onObserverChange();
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error adding a stats observer: " +
                err.message, "RaviStatsWatcher");
            return false;
        }
        return false;
    }
    removeObserver(observer) {
        try {
            this._observers.delete(observer);
            this._onObserverChange();
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error removing a stats observer handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    _onObserverChange() {
        const INTERVAL = 1000;
        this._prevStats = [];
        if (this._observers.size > 0) {
            if (!this._interval) {
                setInterval((handler, timeout) => __awaiter(this, void 0, void 0, function* () {
                    const stats = yield this._raviImplementation._getStats();
                    let filteredStats = [];
                    if (stats) {
                        stats.forEach((report) => {
                            if (this._filter.has(report.type)) {
                                let selectedFields = this._filter.get(report.type);
                                let filteredReport = {};
                                selectedFields.forEach(key => {
                                    filteredReport[key] = report[key];
                                });
                                filteredStats.push(filteredReport);
                            }
                        });
                    }
                    if (filteredStats.length) {
                        this._observers.forEach((observer) => {
                            observer(filteredStats, this._prevStats);
                        });
                    }
                    this._prevStats = filteredStats;
                }), INTERVAL);
            }
        }
        else {
            if (this._interval) {
                clearInterval(this._interval);
                this._interval = 0;
            }
        }
    }
}
let crossPlatformRTCPeerConnection = null;
let crossPlatformRTCSessionDescription = null;
if (typeof self === 'undefined') {
    crossPlatformRTCPeerConnection = __webpack_require__(/*! wrtc */ "../.nvm/versions/node/v14.15.4/lib/node_modules/wrtc/lib/browser.js").RTCPeerConnection;
    crossPlatformRTCSessionDescription = __webpack_require__(/*! wrtc */ "../.nvm/versions/node/v14.15.4/lib/node_modules/wrtc/lib/browser.js").RTCSessionDescription;
}
else {
    crossPlatformRTCPeerConnection = RTCPeerConnection;
    crossPlatformRTCSessionDescription = RTCSessionDescription;
}
const DEFAULT_STUN_CONFIG = {
    'urls': ['stun:stun.l.google.com:19302']
};
const LEGACY_TURN_CONFIG = {
    'urls': ['turn:turn.highfidelity.com:3478'],
    'username': 'clouduser',
    'credential': 'chariot-travesty-hook'
};
let peerConnectionConfig = {
    'iceServers': [
        DEFAULT_STUN_CONFIG,
        LEGACY_TURN_CONFIG
    ]
};
class RaviWebRTCImplementation {
    constructor(raviSession) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("constructor", "RaviWebRTCImplementation");
        this._raviSession = raviSession;
        this._negotiator = this._setupConnection.bind(this);
        this._statsWatcher = new RaviWebRTCStatsWatcher(this);
        this._raviAudioSenders = [];
        this._raviVideoSenders = [];
    }
    _initRtcConnection() {
        const raviSession = this._raviSession;
        const sessionImplementation = this;
        this._rtcConnection = new crossPlatformRTCPeerConnection(peerConnectionConfig);
        const rtcConnection = this._rtcConnection;
        let senders = rtcConnection.getSenders();
        senders.forEach((sender) => {
            sender.replaceTrack(null);
        });
        this._raviAudioSenders = [];
        this._raviVideoSenders = [];
        rtcConnection.addEventListener('iceconnectionstatechange', function (event) {
            if (rtcConnection.iceConnectionState === "connected" || rtcConnection.iceConnectionState == "completed") {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Session has fully connected; removing short-circuit handler", "RaviWebRTCImplementation");
                sessionImplementation._signalingConnection.removeStateChangeHandler(sessionImplementation._shortCircuitHandler);
            }
            raviSession._handleStateChange(event, rtcConnection.iceConnectionState);
        });
        rtcConnection.addEventListener('datachannel', function (event) { raviSession._doOndatachannel(event); });
        rtcConnection.addEventListener('track', function (event) { raviSession._doOntrack(event); });
        rtcConnection.addEventListener('icecandidate', function (event) { sessionImplementation._doOnicecandidate(event); });
        rtcConnection.addEventListener('negotiationneeded', function (event) { sessionImplementation._doOnnegotiationneeded(event); });
        rtcConnection.addEventListener("signalingstatechange", function (event) { sessionImplementation._doOnsignalingstatechanged(event); });
    }
    _assignSignalingConnection(signalingConnection) {
        this._signalingConnection = signalingConnection;
    }
    _addAudioInputStream(stream) {
        const rtcConnection = this._rtcConnection;
        const sessionImplementation = this;
        var retval = false;
        if (stream) {
            this._audioInputStream = stream;
            if (!rtcConnection) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting audio input stream without available RTC connection; will store it until ready", "RaviWebRTCImplementation");
                return true;
            }
            const currentSenders = this._raviAudioSenders;
            const newAudioTracks = stream.getAudioTracks();
            const numNewTracks = newAudioTracks.length;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                if (i < numNewTracks) {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Replacing audio track #" + i + "  in rtcConnection", "RaviWebRTCImplementation");
                    currentSenders[i].replaceTrack(newAudioTracks[i]);
                }
                else {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting audio sender #" + i + " to null", "RaviWebRTCImplementation");
                    currentSenders[i].replaceTrack(null);
                }
            }
            for (i; i < numNewTracks; i++) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Adding local audio track #" + i + " to rtcConnection", "RaviWebRTCImplementation");
                currentSenders.push(rtcConnection.addTrack(newAudioTracks[i], stream));
            }
        }
        else {
            const currentSenders = this._raviAudioSenders;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting audio sender #" + i + " to null", "RaviWebRTCImplementation");
                currentSenders[i].replaceTrack(null);
            }
        }
        return retval;
    }
    _addVideoInputStream(stream) {
        const rtcConnection = this._rtcConnection;
        const that = this;
        var retval = false;
        if (stream) {
            this._videoInputStream = stream;
            if (!rtcConnection) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting video input stream without available RTC connection; will store it until ready", "RaviWebRTCImplementation");
                return true;
            }
            const currentSenders = this._raviVideoSenders;
            const newVideoTracks = stream.getVideoTracks();
            const numNewTracks = newVideoTracks.length;
            if (numNewTracks > 0) {
                if (currentSenders.length > 0) {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Replacing video track #0 in rtcConnection", "RaviWebRTCImplementation");
                    currentSenders[0].replaceTrack(newVideoTracks[0]);
                }
                else {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Adding video track #0 to rtcConnection", "RaviWebRTCImplementation");
                    currentSenders.push(rtcConnection.addTrack(newVideoTracks[0]));
                }
                retval = true;
            }
            else {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Assigned video stream doesn't contain vidoe track", "RaviWebRTCImplementation");
            }
        }
        else {
            const currentSenders = this._raviVideoSenders;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting video sender #" + i + " to null", "RaviWebRTCImplementation");
                currentSenders[i].replaceTrack(null);
            }
        }
        return retval;
    }
    _open(params, customStunAndTurn) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Attempting to open connection...", "RaviWebRTCImplementation");
        this._customStunAndTurn = customStunAndTurn;
        if (this._rtcConnection
            && (this._rtcConnection.connectionState == 'connecting'
                || this._rtcConnection.connectionState == 'connected')) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("We already have a connection in progress. Will not attempt a new one.", "RaviWebRTCImplementation");
            this._raviSession._handleStateChange({ "state": this._rtcConnection.connectionState }, this._rtcConnection.connectionState);
            return;
        }
        if (this._signalingConnection) {
            this._signalingConnection.addMessageHandler(this._negotiator);
            this._shortCircuitHandler = this._cancelOpeningProcessOnSignalingDisconnect.bind(this);
            this._signalingConnection.addStateChangeHandler(this._shortCircuitHandler);
            let message = {};
            if (params) {
                message = params;
                message["sessionID"] = this._raviSession.getUUID();
            }
            else {
                message = this._raviSession.getUUID();
            }
            this._signalingConnection.send(JSON.stringify({ 'request': message }));
        }
    }
    _cancelOpeningProcessOnSignalingDisconnect(event) {
        let state = event.state || "unknown";
        const raviSession = this._raviSession;
        switch (state) {
            case _RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_0__.RaviSignalingStates.CLOSED:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Signaling state closed before session was established; closing RaviSession", "RaviWebRTCImplementation");
                raviSession._handleStateChange(event, RaviSessionStates.CLOSED);
                this._close();
                break;
            case _RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_0__.RaviSignalingStates.ERROR:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Signaling state errored out before session was established; closing RaviSession", "RaviWebRTCImplementation");
                raviSession._handleStateChange(event, RaviSessionStates.FAILED);
                this._close();
                break;
            case _RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_0__.RaviSignalingStates.UNAVAILABLE:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Signaling state reached 'unavailable' before session was established; closing RaviSession", "RaviWebRTCImplementation");
                raviSession._handleStateChange(event, RaviSessionStates.FAILED);
                this._close();
                break;
            default:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Signaling state has changed during opening of RAVI session, but is an OK change. New state: " + state, "RaviWebRTCImplementation");
        }
    }
    _close() {
        this._statsWatcher.stop();
        const raviSession = this._raviSession;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("closing", "RaviWebRTCImplementation");
        if (this._rtcConnection) {
            this._rtcConnection.close();
        }
        this._signalingConnection.removeMessageHandler(this._negotiator);
        this._signalingConnection.removeStateChangeHandler(this._shortCircuitHandler);
        this._rtcConnection = null;
        raviSession._handleStateChange({}, RaviSessionStates.CLOSED);
    }
    _doOnicecandidate(event) {
        if (event.candidate && event.candidate != "") {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Sending local ICE candidate: " + JSON.stringify(event.candidate), "RaviWebRTCImplementation");
            this._signalingConnection.send(JSON.stringify({ 'ice': event.candidate, 'uuid': this._raviSession.getUUID() }));
        }
        else {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("End of local ICE candidates", "RaviSession");
        }
    }
    _doOnnegotiationneeded(event) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("need renegotiation please", "RaviWebRTCImplementation");
        const msg = {
            renegotiate: "please",
            uuid: this._raviSession.getUUID()
        };
        const desc = JSON.stringify(msg);
        if (this._signalingConnection && this._rtcConnection && this._rtcConnection.signalingState === "stable") {
            this._signalingConnection.send(desc);
        }
    }
    _doOnsignalingstatechanged(event) {
        if (this._rtcConnection) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("SignalingState changed: " + this._rtcConnection.signalingState, "RaviWebRTCImplementation");
        }
    }
    _forceBitrateUp(sdp) {
        const localAudioIsStereo = this._raviSession._streamController.isStereoInput();
        const bitrate = localAudioIsStereo ? 128000 : 64000;
        return sdp.replace(/a=fmtp:111 /g, 'a=fmtp:111 maxaveragebitrate=' + bitrate + ';');
    }
    _forceStereoDown(sdp) {
        return sdp.replace(/a=fmtp:111 /g, 'a=fmtp:111 maxaveragebitrate=128000;sprop-stereo=1;stereo=1;');
    }
    _setupConnection(event) {
        let fullMessage = "";
        let signal = "";
        const raviSession = this._raviSession;
        const signalingConnection = this._signalingConnection;
        const sessionImplementation = this;
        if (!raviSession || !signalingConnection) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Missing one of raviSession or signalingConnection! Can't set up connection.", "RaviWebRTCImplementation");
            return;
        }
        if (event && event.data) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log('Message from server: ' + event.data, "RaviWebRTCImplementation");
            fullMessage = JSON.parse(event.data);
        }
        else {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log('No message received by onMessage handler', "RaviWebRTCImplementation");
            return;
        }
        signal = fullMessage[raviSession.getUUID()];
        if (!signal)
            return;
        if (signal.sdp) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received sdp type=" + signal.type, "RaviWebRTCImplementation");
            if (sessionImplementation._customStunAndTurn) {
                const CUSTOM_TURN_CONFIG = {
                    'urls': sessionImplementation._customStunAndTurn.turnUrls,
                    'username': sessionImplementation._customStunAndTurn.turnUsername,
                    'credential': sessionImplementation._customStunAndTurn.turnCredential
                };
                const CUSTOM_STUN_CONFIG = {
                    'urls': sessionImplementation._customStunAndTurn.stunUrls
                };
                peerConnectionConfig = {
                    'iceServers': [
                        CUSTOM_STUN_CONFIG,
                        CUSTOM_TURN_CONFIG
                    ]
                };
            }
            else if (signal.turn && signal.turn.urls && signal.turn.username && signal.turn.credential) {
                const DYNAMIC_TURN_CONFIG = {
                    'urls': signal.turn.urls,
                    'username': signal.turn.username,
                    'credential': signal.turn.credential
                };
                peerConnectionConfig = {
                    'iceServers': [
                        DEFAULT_STUN_CONFIG,
                        DYNAMIC_TURN_CONFIG
                    ]
                };
            }
            if (!this._rtcConnection) {
                this._initRtcConnection();
                if (this._audioInputStream) {
                    this._addAudioInputStream(this._audioInputStream);
                }
                if (this._videoInputStream) {
                    this._addVideoInputStream(this._videoInputStream);
                }
            }
            let rtcConnection = this._rtcConnection;
            signal.sdp = sessionImplementation._forceBitrateUp(signal.sdp);
            const desc = new crossPlatformRTCSessionDescription(signal);
            rtcConnection.setRemoteDescription(desc)
                .then(function () {
                return rtcConnection.createAnswer();
            })
                .then(function (answer) {
                answer.sdp = sessionImplementation._forceStereoDown(answer.sdp);
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Answer:", "RaviWebRTCImplementation");
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log(answer, "RaviWebRTCImplementation");
                return rtcConnection.setLocalDescription(answer);
            })
                .then(function () {
                const msg = {
                    type: "answer",
                    sdp: rtcConnection.localDescription,
                    uuid: raviSession.getUUID()
                };
                const desc = JSON.stringify(msg);
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Sending answer to server", "RaviWebRTCImplementation");
                signalingConnection.send(desc);
            });
        }
        else if (signal.ice) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received remote ICE candidate: " + JSON.stringify(signal.ice), "RaviWebRTCImplementation");
            if (this._rtcConnection) {
                this._rtcConnection.addIceCandidate(signal.ice)
                    .then(function () {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Added remote candidate", "RaviWebRTCImplementation");
                })
                    .catch(function (e) {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error attempting to add remote ICE candidate: " + e.message, "RaviWebRTCImplementation");
                });
            }
            else {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Ignore ice candidate until we have an rtcConnection, ice='" + JSON.stringify(signal) + "'", "RaviWebRTCImplementation");
            }
        }
        else {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Unknown message " + JSON.stringify(signal), "RaviWebRTCImplementation");
        }
    }
    _addStatsObserver(observer) {
        return this._statsWatcher.addObserver(observer);
    }
    _removeStatsObserver(observer) {
        return this._statsWatcher.removeObserver(observer);
    }
    _getStats(selector = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._rtcConnection) {
                return this._rtcConnection.getStats(selector);
            }
            else {
                return [];
            }
        });
    }
}


/***/ }),

/***/ "./src/libravi/RaviSignalingConnection.ts":
/*!************************************************!*\
  !*** ./src/libravi/RaviSignalingConnection.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviSignalingStates": () => (/* binding */ RaviSignalingStates),
/* harmony export */   "RaviSignalingConnection": () => (/* binding */ RaviSignalingConnection)
/* harmony export */ });
/* harmony import */ var _RaviUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");

var RaviSignalingStates;
(function (RaviSignalingStates) {
    RaviSignalingStates["CONNECTING"] = "connecting";
    RaviSignalingStates["OPEN"] = "open";
    RaviSignalingStates["ERROR"] = "error";
    RaviSignalingStates["CLOSING"] = "closing";
    RaviSignalingStates["CLOSED"] = "closed";
    RaviSignalingStates["UNAVAILABLE"] = "unavailable";
})(RaviSignalingStates || (RaviSignalingStates = {}));
;
class RaviSignalingConnection {
    constructor() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Constructor", "RaviSignalingConnection");
        this._stateChangeHandlers = new Set();
        this._messageHandlers = new Set();
        this._state = RaviSignalingStates.CLOSED;
        this._signalingImplementation = new RaviSignalingWebSocketImplementation(this);
    }
    getState() {
        return this._state;
    }
    addStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.add(changeHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Error adding a state change handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    removeStateChangeHandler(changeHandler) {
        try {
            const retval = this._stateChangeHandlers.delete(changeHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Error removing a state change handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    addMessageHandler(messageHandler) {
        try {
            this._messageHandlers.add(messageHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Error adding a message handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    removeMessageHandler(messageHandler) {
        try {
            this._messageHandlers.delete(messageHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Error removing a state change handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    openRAVISignalingConnection(URL) {
        var signalingConnection = this;
        if (this._state === RaviSignalingStates.OPEN)
            return Promise.resolve("There is already an open WebSocket connection. To reconnect, first close the existing WebSocket and then attempt to open again.");
        return new Promise((resolve, reject) => {
            signalingConnection._resolveOpen = resolve;
            signalingConnection._rejectOpen = reject;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Opening signaling connection to " + URL, "RaviSignalingController");
            let event = { "state": RaviSignalingStates.CONNECTING };
            this._handleStateChange(event, RaviSignalingStates.CONNECTING);
            this._signalingImplementation._open(URL);
        });
    }
    send(message) {
        this._signalingImplementation._send(message);
    }
    closeRAVISignalingConnection() {
        var signalingConnection = this;
        if (this._state === RaviSignalingStates.CLOSED)
            return Promise.resolve("Signaling connection is already closed.");
        return new Promise((resolve, reject) => {
            signalingConnection._resolveClose = resolve;
            signalingConnection._rejectClose = reject;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Closing signaling connection", "RaviSignalingController");
            let event = { "state": RaviSignalingStates.CLOSING };
            this._handleStateChange(event, RaviSignalingStates.CLOSING);
            this._signalingImplementation._close();
        });
    }
    _handleStateChange(event = {}, state) {
        this._fulfillPromises(event, state);
        if (state !== this._state) {
            this._state = state;
            event["state"] = state;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_handleStateChange: " + _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.safelyPrintable(event), "RaviSignalingConnection");
            this._stateChangeHandlers.forEach(function (handler) {
                if (handler) {
                    handler(event);
                }
            });
        }
    }
    _fulfillPromises(event = {}, state) {
        let errorMessage = event.reason || event.message || state;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_fulfillPromises: Handling state " + state, "RaviSignalingConnection");
        switch (state) {
            case RaviSignalingStates.OPEN:
                if (this._resolveOpen)
                    this._resolveOpen();
                if (this._rejectClose)
                    this._rejectClose(errorMessage);
                break;
            case RaviSignalingStates.CLOSED:
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._resolveClose)
                    this._resolveClose();
                break;
            case RaviSignalingStates.ERROR:
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._rejectClose)
                    this._rejectClose(errorMessage);
                break;
            case RaviSignalingStates.UNAVAILABLE:
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._resolveClose)
                    this._resolveClose();
                break;
            default:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_fulfillPromises: Skipping in-progress state " + state, "RaviSignalingConnection");
        }
    }
    _handleMessage(message) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_doOnmessage: " + _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.safelyPrintable(message), "RaviSignalingConnection");
        if (message.data) {
            try {
                let messageData = JSON.parse(message.data);
                if (messageData.error && messageData.error === "service-unavailable") {
                    this._handleStateChange({}, RaviSignalingStates.UNAVAILABLE);
                }
            }
            catch (err) {
            }
        }
        this._messageHandlers.forEach(function (handler) {
            if (handler) {
                handler(message);
            }
        });
    }
}
let crossPlatformWebSocket = null;
if (typeof self === 'undefined') {
    crossPlatformWebSocket = __webpack_require__(/*! ws */ "./node_modules/ws/browser.js");
}
else {
    crossPlatformWebSocket = WebSocket;
}
class RaviSignalingWebSocketImplementation {
    constructor(raviSignalingConnection) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviSignalingWebSocketImplementation");
        this._raviSignalingConnection = raviSignalingConnection;
    }
    _open(socketAddress) {
        var signalingConnection = this._raviSignalingConnection;
        if (this._webSocket && this._webSocket.readyState === crossPlatformWebSocket.OPEN) {
            signalingConnection._handleStateChange({}, RaviSignalingStates.OPEN);
            return;
        }
        this._webSocket = new crossPlatformWebSocket(socketAddress);
        this._webSocket.addEventListener('open', function (event) { signalingConnection._handleStateChange(event, RaviSignalingStates.OPEN); });
        this._webSocket.addEventListener('error', function (event) { signalingConnection._handleStateChange(event, RaviSignalingStates.ERROR); });
        this._webSocket.addEventListener('close', function (event) {
            if (event && event.code && event.code > 4000) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("_handleStateChange: signaling error code " + event.code + ":  " + event.reason, "RaviSignalingConnection");
                signalingConnection._handleStateChange(event, RaviSignalingStates.ERROR);
            }
            else {
                signalingConnection._handleStateChange(event, RaviSignalingStates.CLOSED);
            }
        });
        this._webSocket.addEventListener('message', function (event) { signalingConnection._handleMessage(event); });
    }
    _send(message) {
        if (this._webSocket && this._webSocket.readyState === crossPlatformWebSocket.OPEN) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Sending message to server: " + message, "RaviSignalingWebSocketImplementation");
            this._webSocket.send(message);
        }
    }
    _close() {
        var signalingConnection = this._raviSignalingConnection;
        if (!this._webSocket || this._webSocket.readyState === crossPlatformWebSocket.CLOSED) {
            signalingConnection._handleStateChange({}, RaviSignalingStates.CLOSED);
            return;
        }
        this._webSocket.close();
        this._webSocket = null;
    }
}


/***/ }),

/***/ "./src/libravi/RaviStreamController.ts":
/*!*********************************************!*\
  !*** ./src/libravi/RaviStreamController.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviStreamController": () => (/* binding */ RaviStreamController)
/* harmony export */ });
/* harmony import */ var _RaviUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");

class RaviStreamController {
    constructor(raviCommandController) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviStreamController");
        this._commandController = raviCommandController;
        this._audioStream = null;
        this._videoStream = null;
        this._onVideoStreamStateChanged = function (state) { _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("onvideostreamstatechanged " + state, "RaviStreamController"); };
        this._onInputAudioChanged = null;
        this._onInputVideoChanged = null;
    }
    getVideoStream() {
        return this._videoStream;
    }
    _setVideoStream(videoStream) {
        this._videoStream = videoStream;
        if (this._videoContainer) {
            this._videoContainer.srcObject = this._videoStream;
        }
    }
    setVideoContainer(videoElement, onvideostreamstatechanged) {
        this._videoContainer = videoElement;
        if (this._videoStream) {
            this._videoContainer.srcObject = this._videoStream;
        }
        this.setVideoStateChangeHandler(onvideostreamstatechanged);
    }
    setVideoStateChangeHandler(onvideostreamstatechanged) {
        if (onvideostreamstatechanged) {
            this._onVideoStreamStateChanged = onvideostreamstatechanged;
        }
    }
    showVideoDashboard(enabled) {
        this._commandController.queueCommand("video.showDashboard", { "enabled": enabled }, null);
    }
    showVideoCursor(enabled) {
        this._commandController.queueCommand("video.showCursor", { "enabled": enabled }, null);
    }
    getAudioStream() {
        return this._audioStream;
    }
    _setAudioStream(audioStream) {
        this._audioStream = audioStream;
        if (this._audioContainer) {
            this._audioContainer.srcObject = this._audioStream;
        }
    }
    setAudioContainer(audioElement) {
        this._audioContainer = audioElement;
        if (this._audioStream) {
            this._audioContainer.srcObject = this._audioStream;
        }
    }
    setInputAudio(stream, isStereo = false) {
        this._inputAudioStream = stream;
        this._isStereo = isStereo;
        if (this._onInputAudioChanged)
            this._onInputAudioChanged(stream);
    }
    setInputAudioChangeHandler(oninputaudiochanged) {
        if (oninputaudiochanged) {
            this._onInputAudioChanged = oninputaudiochanged;
        }
    }
    setInputVideo(stream) {
        this._inputVideoStream = stream;
        if (this._onInputVideoChanged)
            this._onInputVideoChanged(stream);
    }
    setInputVideoChangeHandler(oninputvideochanged) {
        if (oninputvideochanged) {
            this._onInputVideoChanged = oninputvideochanged;
        }
    }
    isStereoInput() {
        return this._isStereo;
    }
    _stop() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("stopping streams", "RaviStreamController");
        if (this._videoContainer && this._videoContainer.srcObject) {
            let srcObject = this._videoContainer.srcObject;
            let tracks = srcObject.getTracks();
            tracks.forEach(track => track.stop());
            this._videoContainer.srcObject = null;
            this._onVideoStreamStateChanged("over");
        }
        if (this._audioStream) {
            this._audioStream.getTracks().forEach(track => track.stop());
            this._audioStream = null;
        }
    }
}


/***/ }),

/***/ "./src/libravi/RaviUtils.ts":
/*!**********************************!*\
  !*** ./src/libravi/RaviUtils.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviUtils": () => (/* binding */ RaviUtils)
/* harmony export */ });
var DEBUG = true;
class RaviUtils {
    static createUUID() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }
    static log(message, classname) {
        if (typeof classname !== 'undefined')
            message = classname + ": " + message;
        if (DEBUG) {
            console.log(message);
        }
        if (typeof document !== 'undefined' && DEBUG) {
            try {
                document.dispatchEvent(new CustomEvent('logger', { detail: message }));
            }
            catch (err) {
                console.log(message);
                console.log("Additionally, an error was encountered trying to log that.");
                console.log(err);
            }
        }
    }
    static err(message, classname) {
        if (typeof classname !== 'undefined')
            message = classname + ": " + message;
        console.log('%c %s', 'color: #FB0A1C', message);
        if (typeof document !== 'undefined') {
            document.dispatchEvent(new CustomEvent('errlogger', { detail: message }));
        }
    }
    static safelyPrintable(item) {
        try {
            return JSON.stringify(item);
        }
        catch (e) {
            return item;
        }
    }
    static getElementCSSSize(el) {
        if (!getComputedStyle) {
            return;
        }
        var cs = getComputedStyle(el);
        var w = parseInt(cs.getPropertyValue("width"), 10);
        var h = parseInt(cs.getPropertyValue("height"), 10);
        return { width: w, height: h };
    }
    static setDebug(debug) {
        DEBUG = debug;
    }
}


/***/ }),

/***/ "./src/utilities/HiFiLogger.ts":
/*!*************************************!*\
  !*** ./src/utilities/HiFiLogger.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiLogLevel": () => (/* binding */ HiFiLogLevel),
/* harmony export */   "HiFiLogger": () => (/* binding */ HiFiLogger)
/* harmony export */ });
var HiFiLogLevel;
(function (HiFiLogLevel) {
    HiFiLogLevel["None"] = "None";
    HiFiLogLevel["Error"] = "Error";
    HiFiLogLevel["Warn"] = "Warn";
    HiFiLogLevel["Debug"] = "Debug";
})(HiFiLogLevel || (HiFiLogLevel = {}));
class HiFiLogger {
    constructor(logLevel) {
        logLevel = logLevel ? logLevel : HiFiLogLevel.Debug;
    }
    static setHiFiLogLevel(newLogLevel) {
        HiFiLogger.logLevel = newLogLevel;
    }
    static log(message) {
        if (HiFiLogger.logLevel === HiFiLogLevel.Debug) {
            console.log(message);
            return true;
        }
        else {
            return false;
        }
    }
    static debug(message) {
        return this.log(message);
    }
    static warn(message) {
        if (HiFiLogger.logLevel === HiFiLogLevel.Debug || HiFiLogger.logLevel === HiFiLogLevel.Warn) {
            console.warn(message);
            return true;
        }
        else {
            return false;
        }
    }
    static error(message) {
        if (HiFiLogger.logLevel === HiFiLogLevel.Debug || HiFiLogger.logLevel === HiFiLogLevel.Warn || HiFiLogger.logLevel === HiFiLogLevel.Error) {
            console.error(message);
            return true;
        }
        else {
            return false;
        }
    }
}
HiFiLogger.logLevel = HiFiLogLevel.Error;


/***/ }),

/***/ "./src/utilities/HiFiUtilities.ts":
/*!****************************************!*\
  !*** ./src/utilities/HiFiUtilities.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiUtilities": () => (/* binding */ HiFiUtilities)
/* harmony export */ });
/* harmony import */ var _HiFiLogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* module decorator */ module = __webpack_require__.hmd(module);

function dynamicRequire(mod, requireString) {
    return mod.require(requireString);
}
let now;
if (typeof self === 'undefined') {
    try {
        now = dynamicRequire(module, 'perf_hooks').performance.now;
    }
    catch (_a) { }
}
class HiFiUtilities {
    constructor() { }
    static recursivelyDiffObjects(obj1, obj2) {
        if (!obj2 || Object.prototype.toString.call(obj2) !== '[object Object]') {
            return obj1;
        }
        let diffs = {};
        let key;
        let doArraysMatch = (arr1, arr2) => {
            if (arr1.length !== arr2.length) {
                return false;
            }
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i]) {
                    return false;
                }
            }
            return true;
        };
        let compare = (item1, item2, key) => {
            let type1 = Object.prototype.toString.call(item1);
            let type2 = Object.prototype.toString.call(item2);
            if (type2 === '[object Undefined]') {
                diffs[key] = null;
                return;
            }
            if (type1 !== type2) {
                diffs[key] = item2;
                return;
            }
            if (type1 === '[object Object]') {
                let objDiff = HiFiUtilities.recursivelyDiffObjects(item1, item2);
                if (Object.keys(objDiff).length > 0) {
                    diffs[key] = objDiff;
                }
                return;
            }
            if (type1 === '[object Array]') {
                if (!doArraysMatch(item1, item2)) {
                    diffs[key] = item2;
                }
                return;
            }
            if (type1 === '[object Function]') {
                if (item1.toString() !== item2.toString()) {
                    diffs[key] = item2;
                }
            }
            else {
                if (item1 !== item2) {
                    diffs[key] = item2;
                }
            }
        };
        for (key in obj1) {
            if (obj1.hasOwnProperty(key)) {
                compare(obj1[key], obj2[key], key);
            }
        }
        for (key in obj2) {
            if (obj2.hasOwnProperty(key)) {
                if (!obj1[key] && obj1[key] !== obj2[key]) {
                    diffs[key] = obj2[key];
                }
            }
        }
        return diffs;
    }
    ;
    static getBestAudioConstraints() {
        let audioConstraints = {};
        if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().echoCancellation) {
            audioConstraints.echoCancellation = false;
        }
        if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().noiseSuppression) {
            audioConstraints.noiseSuppression = false;
        }
        if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().autoGainControl) {
            audioConstraints.autoGainControl = false;
        }
        return audioConstraints;
    }
    static preciseInterval(callback, intervalMS) {
        if (!now) {
            _HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.warn(`\`preciseInterval()\` is a wrapper for \`setInterval()\` in the browser context!`);
            return setInterval(callback, intervalMS);
        }
        let nextTick = now();
        let clear = clearTimeout;
        let wrapper = () => {
            let thisTick = now();
            if (thisTick < nextTick) {
                clear = clearImmediate;
                return timeout = setImmediate(wrapper);
            }
            nextTick += intervalMS;
            clear = clearTimeout;
            timeout = setTimeout(wrapper, nextTick - thisTick - 2);
            callback();
        };
        let timeout = setTimeout(wrapper);
        return { clear: () => clear(timeout) };
    }
    static checkBrowserCompatibility() {
        let requiredFeatures = [
            "navigator",
            "navigator.mediaDevices.getUserMedia",
            "navigator.mediaDevices.getSupportedConstraints",
            "window.MediaStream",
            "window.RTCDataChannel",
            "window.RTCPeerConnection",
            "window.RTCSessionDescription"
        ];
        for (let i = 0; i < requiredFeatures.length; i++) {
            if (typeof (eval(requiredFeatures[i])) === "undefined") {
                _HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error("HiFi Audio API: The browser does not support: " + requiredFeatures[i]);
                if (requiredFeatures[i] === "navigator.mediaDevices.getUserMedia") {
                    _HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error("HiFi Audio API: Your browser may be preventing access to this feature if you are running in an insecure context, i.e. an `http` server.");
                }
                return false;
            }
        }
        return true;
    }
    static nonan(v, ifnan) {
        return (isNaN(v) ? ifnan : v);
    }
    static clamp(v, min, max) {
        return (v > max ? max : (v < min ? min : v));
    }
    static clampNonan(v, min, max, ifnan) {
        return (v > max ? max : (v < min ? min : HiFiUtilities.nonan(v, ifnan)));
    }
    static clampNormalized(v) {
        return (v > 1.0 ? 1.0 : (v < -1.0 ? -1.0 : v));
    }
}


/***/ }),

/***/ "./node_modules/ws/browser.js":
/*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
/***/ ((module) => {



module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/index.ts");
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi4vLm52bS92ZXJzaW9ucy9ub2RlL3YxNC4xNS40L2xpYi9ub2RlX21vZHVsZXMvd3J0Yy9saWIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9icm93c2VyLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvY2xhc3Nlcy9IaUZpQXVkaW9BUElEYXRhLnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy9jbGFzc2VzL0hpRmlBeGlzQ29uZmlndXJhdGlvbi50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvY2xhc3Nlcy9IaUZpQ29tbXVuaWNhdG9yLnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy9jbGFzc2VzL0hpRmlNaXhlclNlc3Npb24udHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2NsYXNzZXMvSGlGaVVzZXJEYXRhU3Vic2NyaXB0aW9uLnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy9jb25zdGFudHMvSGlGaUNvbnN0YW50cy50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvZGlhZ25vc3RpY3MvZGlhZ25vc3RpY3MudHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy9saWJyYXZpL1JhdmlDb21tYW5kQ29udHJvbGxlci50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvbGlicmF2aS9SYXZpU2Vzc2lvbi50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvbGlicmF2aS9SYXZpU2lnbmFsaW5nQ29ubmVjdGlvbi50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvbGlicmF2aS9SYXZpU3RyZWFtQ29udHJvbGxlci50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvbGlicmF2aS9SYXZpVXRpbHMudHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL3V0aWxpdGllcy9IaUZpTG9nZ2VyLnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy91dGlsaXRpZXMvSGlGaVV0aWxpdGllcy50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvd3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vd2VicGFjay9ydW50aW1lL2hhcm1vbnkgbW9kdWxlIGRlY29yYXRvciIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vd2Vi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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQix5Q0FBeUM7O0FBRTlEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCO0FBQ3RCLHNCQUFz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OztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7Ozs7Ozs7OztBQ3ZWYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9CYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTs7O0FBR0Esb0JBQW9CLHNCQUFzQixxQkFBcUIsY0FBYyxFQUFFOztBQUUvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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R0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFlBQVksR0FBRyxlQUFlLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxXQUFXLEdBQUcsZUFBZSxDQUFDLEVBQUMsQ0FBQztJQVFsSyxJQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMvQixJQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMvQixJQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMvQixJQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUUvQixJQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMvQixJQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMvQixJQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMvQixJQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUUvQixRQUFRLEtBQUssRUFBRTtRQUtmLEtBQUssdUJBQXVC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QUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUMxQixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7SUFJMUIsSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNsQyxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDNUIsSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBRTVCLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUM1QixJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ2xDLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUU1QixJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDNUIsSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQzVCLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFJbEMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2QsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ1osSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO0lBQ2IsTUFBTSxpQkFBaUIsR0FBRyxTQUFTLENBQUM7SUFDcEMsUUFBUSxLQUFLLEVBQUU7UUFDZixLQUFLLHVCQUF1QixDQUFDLFlBQVk7WUFBRTtnQkFDdkMsR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUUsbUZBQTZCLENBQUMsR0FBRyxD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LFFBQVEsR0FBRyxDQUFDLENBQUM7WUFDL0ksT0FBTyxHQUFHLEtBQUssQ0FBQztTQUNuQjtRQUVELElBQUksaUJBQWlCLENBQUMsU0FBUyxLQUFLLFFBQVEsQ0FBQyxTQUFTLElBQUksaUJBQWlCLENBQUMsUUFBUSxLQUFLLFFBQVEsQ0FBQyxTQUFTLEVBQUU7WUFDekcsbUVBQWdCLENBQUMsOENBQThDLGlCQUFpQixDQUFDLFNBQVMsc0JBQXNCLGlCQUFpQixDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7WUFDL0ksT0FBTyxHQUFHLEtBQUssQ0FBQztTQUNuQjtRQUNELElBQUksaUJBQWlCLENBQUMsUUFBUSxLQUFLLFFBQVEsQ0FBQyxTQUFTLElBQUksaUJBQWlCLENBQUMsU0FBUyxLQUFLLFFBQVEsQ0FBQyxTQUFTLEVBQUU7WUFDekcsbUVBQWdCLENBQUMsOENBQThDLGlCQUFpQixDQUFDLFNBQVMsc0JBQXNCLGlCQUFpQixDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7WUFDL0ksT0FBTyxHQUFHLEtBQUssQ0FBQztTQUNuQjtRQUVELElBQUksaUJBQWlCLENBQUMsU0FBUyxLQUFLLFFBQVEsQ0FBQyxTQUFTLElBQUksaUJBQWlCLENBQUMsUUFBUSxLQUFLLFFBQVEsQ0FBQyxTQUFTLEVBQUU7WUFDekcsbUVBQWdCLENBQUMsOENBQThDLGlCQUFpQixDQUFDLFNBQVMsc0JBQXNCLGlCQUFpQixDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7WUFDL0ksT0FBTyxHQUFHLEtBQUssQ0FBQztTQUNuQjtRQUNELElBQUksaUJBQWlCLENBQUMsUUFBUSxLQUFLLFFBQVEsQ0FBQyxTQUFTLElBQUksaUJBQWlCLENBQUMsU0FBUyxLQUFLLFFBQVEsQ0FBQyxTQUFTLEVBQUU7WUFDekcsbUVBQWdCLENBQUMsOENBQThDLGlCQUFpQixDQUFDLFNBQVMsc0JBQXNCLGlCQUFpQixDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7WUFDL0ksT0FBTyxHQUFHLEtBQUssQ0FBQztTQUNuQjtRQUlELElBQUksaUJBQWlCLENBQUMsY0FBYyxLQUFLLFFBQVEsQ0FBQyxTQUFTLElBQUksaUJBQWlCLENBQUMsZUFBZSxLQUFLLFFBQVEsQ0FBQyxTQUFTLEVBQUU7WUFDckgsbUVBQWdCLENBQUMsbURBQW1ELGlCQUFpQixDQUFDLGNBQWMsNkJBQTZCLGlCQUFpQixDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUM7WUFDdkssT0FBTyxHQUFHLEtBQUssQ0FBQztTQUNuQjtRQUNELElBQUksaUJBQWlCLENBQUMsZUFBZSxLQUFLLFFBQVEsQ0FBQyxTQUFTLElBQUksaUJBQWlCLENBQUMsY0FBYyxLQUFLLFFBQVEsQ0FBQyxTQUFTLEVBQUU7WUFDckgsbUVBQWdCLENBQUMsbURBQW1ELGlCQUFpQixDQUFDLGNBQWMsNkJBQTZCLGlCQUFpQixDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUM7WUFDdkssT0FBTyxHQUFHLEtBQUssQ0FBQztTQUNuQjtRQUVELElBQUksaUJBQWlCLENBQUMsY0FBYyxLQUFLLFFBQVEsQ0FBQyxTQUFTLElBQUksaUJBQWlCLENBQUMsZUFBZSxLQUFLLFFBQVEsQ0FBQyxTQUFTLEVBQUU7WUFDckgsbUVBQWdCLENBQUMsbURBQW1ELGlCQUFpQixDQUFDLGNBQWMsNkJBQTZCLGlCQUFpQixDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUM7WUFDdkssT0FBTyxHQUFHLEtBQUssQ0FBQztTQUNuQjtRQUNELElBQUksaUJBQWlCLENBQUMsZUFBZSxLQUFLLFFBQVEsQ0FBQyxTQUFTLElBQUksaUJBQWlCLENBQUMsY0FBYyxLQUFLLFFBQVEsQ0FBQyxTQUFTLEVBQUU7WUFDckgsbUVBQWdCLENBQUMsbURBQW1ELGlCQUFpQixDQUFDLGNBQWMsNkJBQTZCLGlCQUFpQixDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUM7WUFDdkssT0FBTyxHQUFHLEtBQUssQ0FBQztTQUNuQjtRQUVELElBQUksaUJBQWlCLENBQUMsY0FBYyxLQUFLLFFBQVEsQ0FBQyxTQUFTLElBQUksaUJBQWlCLENBQUMsZUFBZSxLQUFLLFFBQVEsQ0FBQyxTQUFTLEVB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SyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdFLENBQUM7SUFFRCxNQUFNLENBQUMsZUFBZSxDQUFDLENBQVM7UUFFNUIsT0FBTyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25ELENBQUM7Q0FDSjs7Ozs7Ozs7Ozs7QUM3T1k7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O1VDUEE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N4QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx3Q0FBd0MseUNBQXlDO1dBQ2pGO1dBQ0E7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7V0FDQSxFOzs7OztXQ1ZBLHdGOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHNEQUFzRCxrQkFBa0I7V0FDeEU7V0FDQSwrQ0FBK0MsY0FBYztXQUM3RCxFOzs7O1VDTkE7VUFDQTtVQUNBO1VBQ0EiLCJmaWxlIjoiSGlnaEZpZGVsaXR5QXVkaW8tbGF0ZXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLk1lZGlhU3RyZWFtID0gd2luZG93Lk1lZGlhU3RyZWFtO1xuZXhwb3J0cy5NZWRpYVN0cmVhbVRyYWNrID0gd2luZG93Lk1lZGlhU3RyZWFtVHJhY2s7XG5leHBvcnRzLlJUQ0RhdGFDaGFubmVsID0gd2luZG93LlJUQ0RhdGFDaGFubmVsO1xuZXhwb3J0cy5SVENEYXRhQ2hhbm5lbEV2ZW50ID0gd2luZG93LlJUQ0RhdGFDaGFubmVsRXZlbnQ7XG5leHBvcnRzLlJUQ0R0bHNUcmFuc3BvcnQgPSB3aW5kb3cuUlRDRHRsc1RyYW5zcG9ydDtcbmV4cG9ydHMuUlRDSWNlQ2FuZGlkYXRlID0gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZTtcbmV4cG9ydHMuUlRDSWNlVHJhbnNwb3J0ID0gd2luZG93LlJUQ0ljZVRyYW5zcG9ydDtcbmV4cG9ydHMuUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb247XG5leHBvcnRzLlJUQ1BlZXJDb25uZWN0aW9uSWNlRXZlbnQgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb25JY2VFdmVudDtcbmV4cG9ydHMuUlRDUnRwUmVjZWl2ZXIgPSB3aW5kb3cuUlRDUnRwUmVjZWl2ZXI7XG5leHBvcnRzLlJUQ1J0cFNlbmRlciA9IHdpbmRvdy5SVENSdHBTZW5kZXI7XG5leHBvcnRzLlJUQ1J0cFRyYW5zY2VpdmVyID0gd2luZG93LlJUQ1J0cFRyYW5zY2VpdmVyO1xuZXhwb3J0cy5SVENTY3RwVHJhbnNwb3J0ID0gd2luZG93LlJUQ1NjdHBUcmFuc3BvcnQ7XG5leHBvcnRzLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb247XG5leHBvcnRzLmdldFVzZXJNZWRpYSA9IHdpbmRvdy5nZXRVc2VyTWVkaWE7XG5leHBvcnRzLm1lZGlhRGV2aWNlcyA9IG5hdmlnYXRvci5tZWRpYURldmljZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gcmVmOiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIHRoZSBvbmx5IHJlbGlhYmxlIG1lYW5zIHRvIGdldCB0aGUgZ2xvYmFsIG9iamVjdCBpc1xuXHQvLyBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcblx0Ly8gSG93ZXZlciwgdGhpcyBjYXVzZXMgQ1NQIHZpb2xhdGlvbnMgaW4gQ2hyb21lIGFwcHMuXG5cdGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHNlbGY7IH1cblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH1cblx0aWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBnbG9iYWw7IH1cblx0dGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnKTtcbn1cblxudmFyIGdsb2JhbCA9IGdldEdsb2JhbCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBnbG9iYWwuZmV0Y2g7XG5cbi8vIE5lZWRlZCBmb3IgVHlwZVNjcmlwdCBhbmQgV2VicGFjay5cbmlmIChnbG9iYWwuZmV0Y2gpIHtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZ2xvYmFsLmZldGNoLmJpbmQoZ2xvYmFsKTtcbn1cblxuZXhwb3J0cy5IZWFkZXJzID0gZ2xvYmFsLkhlYWRlcnM7XG5leHBvcnRzLlJlcXVlc3QgPSBnbG9iYWwuUmVxdWVzdDtcbmV4cG9ydHMuUmVzcG9uc2UgPSBnbG9iYWwuUmVzcG9uc2U7IiwiLy8gVG9wIGxldmVsIGZpbGUgaXMganVzdCBhIG1peGluIG9mIHN1Ym1vZHVsZXMgJiBjb25zdGFudHNcbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEZWZsYXRlLCBkZWZsYXRlLCBkZWZsYXRlUmF3LCBnemlwIH0gPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG5cbmNvbnN0IHsgSW5mbGF0ZSwgaW5mbGF0ZSwgaW5mbGF0ZVJhdywgdW5nemlwIH0gPSByZXF1aXJlKCcuL2xpYi9pbmZsYXRlJyk7XG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbm1vZHVsZS5leHBvcnRzLmd6aXAgPSBnemlwO1xubW9kdWxlLmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3O1xubW9kdWxlLmV4cG9ydHMudW5nemlwID0gdW5nemlwO1xubW9kdWxlLmV4cG9ydHMuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmNvbnN0IHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG5jb25zdCB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xuY29uc3Qgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG5jb25zdCBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbmNvbnN0IFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG5cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9OT19GTFVTSCwgWl9TWU5DX0ZMVVNILCBaX0ZVTExfRkxVU0gsIFpfRklOSVNILFxuICBaX09LLCBaX1NUUkVBTV9FTkQsXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgWl9ERUZBVUxUX1NUUkFURUdZLFxuICBaX0RFRkxBVEVEXG59ID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGBoZWFkZXJgIChPYmplY3QpIC0gY3VzdG9tIGhlYWRlciBmb3IgZ3ppcFxuICogICAtIGB0ZXh0YCAoQm9vbGVhbikgLSB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0XG4gKiAgIC0gYHRpbWVgIChOdW1iZXIpIC0gbW9kaWZpY2F0aW9uIHRpbWUsIHVuaXggdGltZXN0YW1wXG4gKiAgIC0gYG9zYCAoTnVtYmVyKSAtIG9wZXJhdGlvbiBzeXN0ZW0gY29kZVxuICogICAtIGBleHRyYWAgKEFycmF5KSAtIGFycmF5IG9mIGJ5dGVzIHdpdGggZXh0cmEgZGF0YSAobWF4IDY1NTM2KVxuICogICAtIGBuYW1lYCAoU3RyaW5nKSAtIGZpbGUgbmFtZSAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgY29tbWVudGAgKFN0cmluZykgLSBjb21tZW50IChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBoY3JjYCAoQm9vbGVhbikgLSB0cnVlIGlmIGhlYWRlciBjcmMgc2hvdWxkIGJlIGFkZGVkXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBuZXcgVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiBjb25zdCBkZWZsYXRlID0gbmV3IHBha28uRGVmbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogZGVmbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogZGVmbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoZGVmbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGRlZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGRlZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gRGVmbGF0ZShvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgICBtZXRob2Q6IFpfREVGTEFURUQsXG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICBtZW1MZXZlbDogOCxcbiAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGxldCBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgbGV0IHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC5sZXZlbCxcbiAgICBvcHQubWV0aG9kLFxuICAgIG9wdC53aW5kb3dCaXRzLFxuICAgIG9wdC5tZW1MZXZlbCxcbiAgICBvcHQuc3RyYXRlZ3lcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVyKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIGxldCBkaWN0O1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBmbHVzaF9tb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBmbHVzaF9tb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdFxuICogaGF2ZSBgZmx1c2hfbW9kZWAgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nXG4gKiBidWZmZXJzIGFuZCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dLlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZsdXNoX21vZGUpIHtcbiAgY29uc3Qgc3RybSA9IHRoaXMuc3RybTtcbiAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgbGV0IHN0YXR1cywgX2ZsdXNoX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKGZsdXNoX21vZGUgPT09IH5+Zmx1c2hfbW9kZSkgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlO1xuICBlbHNlIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZSA9PT0gdHJ1ZSA/IFpfRklOSVNIIDogWl9OT19GTFVTSDtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBhdmFpbF9vdXQgPiA2IHRvIGF2b2lkIHJlcGVhdGluZyBtYXJrZXJzXG4gICAgaWYgKChfZmx1c2hfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIIHx8IF9mbHVzaF9tb2RlID09PSBaX0ZVTExfRkxVU0gpICYmIHN0cm0uYXZhaWxfb3V0IDw9IDYpIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcblxuICAgIC8vIEVuZGVkID0+IGZsdXNoIGFuZCBmaW5pc2hcbiAgICBpZiAoc3RhdHVzID09PSBaX1NUUkVBTV9FTkQpIHtcbiAgICAgIGlmIChzdHJtLm5leHRfb3V0ID4gMCkge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gc3RhdHVzID09PSBaX09LO1xuICAgIH1cblxuICAgIC8vIEZsdXNoIGlmIG91dCBidWZmZXIgZnVsbFxuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggaWYgcmVxdWVzdGVkIGFuZCBoYXMgZGF0YVxuICAgIGlmIChfZmx1c2hfbW9kZSA+IDAgJiYgc3RybS5uZXh0X291dCA+IDApIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5KTogb3V0cHV0IGRhdGEuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBkZWZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBvbmNlIGFmdGVyIHlvdSB0ZWxsIGRlZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGRlZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChkZWZsYXRvci5lcnIpIHsgdGhyb3cgZGVmbGF0b3IubXNnIHx8IG1zZ1tkZWZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGRlZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXlcbiAqIC0gZGF0YSAoVWludDhBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCBvZlxuICogZGVmbGF0ZSBvbmUuXG4gKiovXG5mdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVSYXcgPSBkZWZsYXRlUmF3O1xubW9kdWxlLmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG5tb2R1bGUuZXhwb3J0cy5jb25zdGFudHMgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuY29uc3QgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgnLi96bGliL2luZmxhdGUnKTtcbmNvbnN0IHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG5jb25zdCBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbmNvbnN0IG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xuY29uc3QgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcbmNvbnN0IEdaaGVhZGVyICAgICA9IHJlcXVpcmUoJy4vemxpYi9nemhlYWRlcicpO1xuXG5jb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0gsIFpfRklOSVNILFxuICBaX09LLCBaX1NUUkVBTV9FTkQsIFpfTkVFRF9ESUNULCBaX1NUUkVBTV9FUlJPUiwgWl9EQVRBX0VSUk9SLCBaX01FTV9FUlJPUlxufSA9IHJlcXVpcmUoJy4vemxpYi9jb25zdGFudHMnKTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogY29uc3QgY2h1bmsxID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqIGNvbnN0IGNodW5rMiA9IG5ldyBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIGNvbnN0IGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDEwMjQgKiA2NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgY29uc3Qgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgbGV0IHN0YXR1cyAgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcblxuICAvLyBTZXR1cCBkaWN0aW9uYXJ5XG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH1cbiAgICBpZiAob3B0LnJhdykgeyAvL0luIHJhdyBtb2RlIHdlIG5lZWQgdG8gc2V0IHRoZSBkaWN0aW9uYXJ5IGVhcmx5XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBmbHVzaF9tb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5QnVmZmVyKTogaW5wdXQgZGF0YVxuICogLSBmbHVzaF9tb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFXG4gKiAgIGZsdXNoIG1vZGVzLiBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCxcbiAqICAgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gSWYgZW5kIG9mIHN0cmVhbSBkZXRlY3RlZCxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dIHdpbGwgYmUgY2FsbGVkLlxuICpcbiAqIGBmbHVzaF9tb2RlYCBpcyBub3QgbmVlZGVkIGZvciBub3JtYWwgb3BlcmF0aW9uLCBiZWNhdXNlIGVuZCBvZiBzdHJlYW1cbiAqIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkuIFlvdSBtYXkgdHJ5IHRvIHVzZSBpdCBmb3IgYWR2YW5jZWQgdGhpbmdzLCBidXRcbiAqIHRoaXMgZnVuY3Rpb25hbGl0eSB3YXMgbm90IHRlc3RlZC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmbHVzaF9tb2RlKSB7XG4gIGNvbnN0IHN0cm0gPSB0aGlzLnN0cm07XG4gIGNvbnN0IGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIGNvbnN0IGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgbGV0IHN0YXR1cywgX2ZsdXNoX21vZGUsIGxhc3RfYXZhaWxfb3V0O1xuXG4gIGlmICh0aGlzLmVuZGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGZsdXNoX21vZGUgPT09IH5+Zmx1c2hfbW9kZSkgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlO1xuICBlbHNlIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZSA9PT0gdHJ1ZSA/IFpfRklOSVNIIDogWl9OT19GTFVTSDtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGZvciAoOzspIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpO1xuXG4gICAgICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBaX0RBVEFfRVJST1IpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBjb2RlIHdpdGggbW9yZSB2ZXJib3NlXG4gICAgICAgIHN0YXR1cyA9IFpfTkVFRF9ESUNUO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNraXAgc255YyBtYXJrZXJzIGlmIG1vcmUgZGF0YSBmb2xsb3dzIGFuZCBub3QgcmF3IG1vZGVcbiAgICB3aGlsZSAoc3RybS5hdmFpbF9pbiA+IDAgJiZcbiAgICAgICAgICAgc3RhdHVzID09PSBaX1NUUkVBTV9FTkQgJiZcbiAgICAgICAgICAgc3RybS5zdGF0ZS53cmFwID4gMCAmJlxuICAgICAgICAgICBkYXRhW3N0cm0ubmV4dF9pbl0gIT09IDApXG4gICAge1xuICAgICAgemxpYl9pbmZsYXRlLmluZmxhdGVSZXNldChzdHJtKTtcbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSBaX1NUUkVBTV9FUlJPUjpcbiAgICAgIGNhc2UgWl9EQVRBX0VSUk9SOlxuICAgICAgY2FzZSBaX05FRURfRElDVDpcbiAgICAgIGNhc2UgWl9NRU1fRVJST1I6XG4gICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBSZW1lbWJlciByZWFsIGBhdmFpbF9vdXRgIHZhbHVlLCBiZWNhdXNlIHdlIG1heSBwYXRjaCBvdXQgYnVmZmVyIGNvbnRlbnRcbiAgICAvLyB0byBhbGlnbiB1dGY4IHN0cmluZ3MgYm91bmRhcmllcy5cbiAgICBsYXN0X2F2YWlsX291dCA9IHN0cm0uYXZhaWxfb3V0O1xuXG4gICAgaWYgKHN0cm0ubmV4dF9vdXQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IFpfU1RSRUFNX0VORCkge1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICBsZXQgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICBsZXQgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4O1xuICAgICAgICAgIGxldCB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTtcblxuICAgICAgICAgIC8vIG1vdmUgdGFpbCAmIHJlYWxpZ24gY291bnRlcnNcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHN0cm0ub3V0cHV0LnNldChzdHJtLm91dHB1dC5zdWJhcnJheShuZXh0X291dF91dGY4LCBuZXh0X291dF91dGY4ICsgdGFpbCksIDApO1xuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5sZW5ndGggPT09IHN0cm0ubmV4dF9vdXQgPyBzdHJtLm91dHB1dCA6IHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE11c3QgcmVwZWF0IGl0ZXJhdGlvbiBpZiBvdXQgYnVmZmVyIGlzIGZ1bGxcbiAgICBpZiAoc3RhdHVzID09PSBaX09LICYmIGxhc3RfYXZhaWxfb3V0ID09PSAwKSBjb250aW51ZTtcblxuICAgIC8vIEZpbmFsaXplIGlmIGVuZCBvZiBzdHJlYW0gcmVhY2hlZC5cbiAgICBpZiAoc3RhdHVzID09PSBaX1NUUkVBTV9FTkQpIHtcbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBlYWNoIGNodW5rIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogaW5mbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgZWl0aGVyIGFmdGVyIHlvdSB0ZWxsIGluZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXkpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpO1xuICogY29uc3QgaW5wdXQgPSBwYWtvLmRlZmxhdGUobmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSkpO1xuICogbGV0IG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKVxuICogICBjb25zb2xlLmxvZyhlcnIpO1xuICogfVxuICogYGBgXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1zZ1tpbmZsYXRvci5lcnJdO1xuXG4gIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBpbmZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheSk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheSk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG5tb2R1bGUuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5tb2R1bGUuZXhwb3J0cy51bmd6aXAgPSBpbmZsYXRlO1xubW9kdWxlLmV4cG9ydHMuY29uc3RhbnRzID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmNvbnN0IF9oYXMgPSAob2JqLCBrZXkpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgY29uc3Qgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgICBpZiAoIXNvdXJjZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG5vbi1vYmplY3QnKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG5tb2R1bGUuZXhwb3J0cy5mbGF0dGVuQ2h1bmtzID0gKGNodW5rcykgPT4ge1xuICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgbGV0IGxlbiA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7XG4gIH1cblxuICAvLyBqb2luIGNodW5rc1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuXG4gIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxldCBjaHVuayA9IGNodW5rc1tpXTtcbiAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgIHBvcyArPSBjaHVuay5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIFN0cmluZyBlbmNvZGUvZGVjb2RlIGhlbHBlcnNcbid1c2Ugc3RyaWN0JztcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG5sZXQgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7IH1cblxuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbmNvbnN0IF91dGY4bGVuID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvciAobGV0IHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5tb2R1bGUuZXhwb3J0cy5zdHJpbmcyYnVmID0gKHN0cikgPT4ge1xuICBsZXQgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGJ1Zl9sZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpID0gMCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIEhlbHBlclxuY29uc3QgYnVmMmJpbnN0cmluZyA9IChidWYsIGxlbikgPT4ge1xuICAvLyBPbiBDaHJvbWUsIHRoZSBhcmd1bWVudHMgaW4gYSBmdW5jdGlvbiBjYWxsIHRoYXQgYXJlIGFsbG93ZWQgaXMgYDY1NTM0YC5cbiAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGlzIHNtYWxsZXIgdGhhbiB0aGF0LCB3ZSBjYW4gdXNlIHRoaXMgb3B0aW1pemF0aW9uLFxuICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCB0YWtlIGEgc2xvd2VyIHBhdGguXG4gIGlmIChsZW4gPCA2NTUzNCkge1xuICAgIGlmIChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmLmxlbmd0aCA9PT0gbGVuID8gYnVmIDogYnVmLnN1YmFycmF5KDAsIGxlbikpO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZXN1bHQgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbm1vZHVsZS5leHBvcnRzLmJ1ZjJzdHJpbmcgPSAoYnVmLCBtYXgpID0+IHtcbiAgbGV0IGksIG91dDtcbiAgY29uc3QgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG5cbiAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgY29uc3QgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBsZXQgYyA9IGJ1ZltpKytdO1xuICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgIGxldCBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH1cblxuICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgIGNfbGVuLS07XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7XG59O1xuXG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG5tb2R1bGUuZXhwb3J0cy51dGY4Ym9yZGVyID0gKGJ1ZiwgbWF4KSA9PiB7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgbGV0IHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IGFkbGVyMzIgPSAoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpID0+IHtcbiAgbGV0IHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbiAgWl9OT19GTFVTSDogICAgICAgICAwLFxuICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsXG4gIFpfU1lOQ19GTFVTSDogICAgICAgMixcbiAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLFxuICBaX0ZJTklTSDogICAgICAgICAgIDQsXG4gIFpfQkxPQ0s6ICAgICAgICAgICAgNSxcbiAgWl9UUkVFUzogICAgICAgICAgICA2LFxuXG4gIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gICovXG4gIFpfT0s6ICAgICAgICAgICAgICAgMCxcbiAgWl9TVFJFQU1fRU5EOiAgICAgICAxLFxuICBaX05FRURfRElDVDogICAgICAgIDIsXG4gIFpfRVJSTk86ICAgICAgICAgICAtMSxcbiAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLFxuICBaX0RBVEFfRVJST1I6ICAgICAgLTMsXG4gIFpfTUVNX0VSUk9SOiAgICAgICAtNCxcbiAgWl9CVUZfRVJST1I6ICAgICAgIC01LFxuICAvL1pfVkVSU0lPTl9FUlJPUjogLTYsXG5cbiAgLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4gIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCxcbiAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046ICAgICAgIDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSxcblxuXG4gIFpfRklMVEVSRUQ6ICAgICAgICAgICAgICAgMSxcbiAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLFxuICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsXG4gIFpfRklYRUQ6ICAgICAgICAgICAgICAgICAgNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLFxuXG4gIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbiAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLFxuICBaX1RFWFQ6ICAgICAgICAgICAgICAgICAgIDEsXG4gIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpXG4gIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMixcblxuICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbiAgWl9ERUZMQVRFRDogICAgICAgICAgICAgICA4XG4gIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5jb25zdCBtYWtlVGFibGUgPSAoKSA9PiB7XG4gIGxldCBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufTtcblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbmNvbnN0IGNyY1RhYmxlID0gbmV3IFVpbnQzMkFycmF5KG1ha2VUYWJsZSgpKTtcblxuXG5jb25zdCBjcmMzMiA9IChjcmMsIGJ1ZiwgbGVuLCBwb3MpID0+IHtcbiAgY29uc3QgdCA9IGNyY1RhYmxlO1xuICBjb25zdCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAobGV0IGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgeyBfdHJfaW5pdCwgX3RyX3N0b3JlZF9ibG9jaywgX3RyX2ZsdXNoX2Jsb2NrLCBfdHJfdGFsbHksIF90cl9hbGlnbiB9ID0gcmVxdWlyZSgnLi90cmVlcycpO1xuY29uc3QgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuY29uc3QgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbmNvbnN0IG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0gsIFpfUEFSVElBTF9GTFVTSCwgWl9GVUxMX0ZMVVNILCBaX0ZJTklTSCwgWl9CTE9DSyxcbiAgWl9PSywgWl9TVFJFQU1fRU5ELCBaX1NUUkVBTV9FUlJPUiwgWl9EQVRBX0VSUk9SLCBaX0JVRl9FUlJPUixcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICBaX0ZJTFRFUkVELCBaX0hVRkZNQU5fT05MWSwgWl9STEUsIFpfRklYRUQsIFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgWl9VTktOT1dOLFxuICBaX0RFRkxBVEVEXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5jb25zdCBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xuY29uc3QgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbmNvbnN0IERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbmNvbnN0IExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuY29uc3QgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuY29uc3QgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuY29uc3QgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5jb25zdCBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbmNvbnN0IEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuY29uc3QgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxuY29uc3QgTUlOX01BVENIID0gMztcbmNvbnN0IE1BWF9NQVRDSCA9IDI1ODtcbmNvbnN0IE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbmNvbnN0IFBSRVNFVF9ESUNUID0gMHgyMDtcblxuY29uc3QgSU5JVF9TVEFURSA9IDQyO1xuY29uc3QgRVhUUkFfU1RBVEUgPSA2OTtcbmNvbnN0IE5BTUVfU1RBVEUgPSA3MztcbmNvbnN0IENPTU1FTlRfU1RBVEUgPSA5MTtcbmNvbnN0IEhDUkNfU1RBVEUgPSAxMDM7XG5jb25zdCBCVVNZX1NUQVRFID0gMTEzO1xuY29uc3QgRklOSVNIX1NUQVRFID0gNjY2O1xuXG5jb25zdCBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xuY29uc3QgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbmNvbnN0IEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbmNvbnN0IEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG5jb25zdCBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuY29uc3QgZXJyID0gKHN0cm0sIGVycm9yQ29kZSkgPT4ge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufTtcblxuY29uc3QgcmFuayA9IChmKSA9PiB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59O1xuXG5jb25zdCB6ZXJvID0gKGJ1ZikgPT4ge1xuICBsZXQgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9XG59O1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cbmxldCBIQVNIX1pMSUIgPSAocywgcHJldiwgZGF0YSkgPT4gKChwcmV2IDw8IHMuaGFzaF9zaGlmdCkgXiBkYXRhKSAmIHMuaGFzaF9tYXNrO1xuLy8gVGhpcyBoYXNoIGNhdXNlcyBsZXNzIGNvbGxpc2lvbnMsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9pc3N1ZXMvMTM1XG4vLyBCdXQgYnJlYWtzIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vL2xldCBIQVNIX0ZBU1QgPSAocywgcHJldiwgZGF0YSkgPT4gKChwcmV2IDw8IDgpICsgKHByZXYgPj4gOCkgKyAoZGF0YSA8PCA0KSkgJiBzLmhhc2hfbWFzaztcbmxldCBIQVNIID0gSEFTSF9aTElCO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5jb25zdCBmbHVzaF9wZW5kaW5nID0gKHN0cm0pID0+IHtcbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgbGV0IGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICBzdHJtLm91dHB1dC5zZXQocy5wZW5kaW5nX2J1Zi5zdWJhcnJheShzLnBlbmRpbmdfb3V0LCBzLnBlbmRpbmdfb3V0ICsgbGVuKSwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufTtcblxuXG5jb25zdCBmbHVzaF9ibG9ja19vbmx5ID0gKHMsIGxhc3QpID0+IHtcbiAgX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59O1xuXG5cbmNvbnN0IHB1dF9ieXRlID0gKHMsIGIpID0+IHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmNvbnN0IHB1dFNob3J0TVNCID0gKHMsIGIpID0+IHtcblxuICAvLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuY29uc3QgcmVhZF9idWYgPSAoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkgPT4ge1xuXG4gIGxldCBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICBidWYuc2V0KHN0cm0uaW5wdXQuc3ViYXJyYXkoc3RybS5uZXh0X2luLCBzdHJtLm5leHRfaW4gKyBsZW4pLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmNvbnN0IGxvbmdlc3RfbWF0Y2ggPSAocywgY3VyX21hdGNoKSA9PiB7XG5cbiAgbGV0IGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgbGV0IHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICBsZXQgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIGxldCBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgbGV0IG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgY29uc3QgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICBjb25zdCBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgY29uc3Qgd21hc2sgPSBzLndfbWFzaztcbiAgY29uc3QgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgY29uc3Qgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgbGV0IHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICBsZXQgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuY29uc3QgZmlsbF93aW5kb3cgPSAocykgPT4ge1xuXG4gIGNvbnN0IF93X3NpemUgPSBzLndfc2l6ZTtcbiAgbGV0IHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgcy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KF93X3NpemUsIF93X3NpemUgKyBfd19zaXplKSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbc3RyICsgMV0pO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKTtcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIGNvbnN0IGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICBsZXQgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmNvbnN0IGRlZmxhdGVfc3RvcmVkID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICBsZXQgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIGNvbnN0IG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5jb25zdCBkZWZsYXRlX2Zhc3QgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICBsZXQgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSk7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5jb25zdCBkZWZsYXRlX3Nsb3cgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGxldCBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5jb25zdCBkZWZsYXRlX3JsZSA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIGxldCBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgbGV0IHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgY29uc3QgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuY29uc3QgZGVmbGF0ZV9odWZmID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG5mdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG5cbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbmNvbnN0IGNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuY29uc3QgbG1faW5pdCA9IChzKSA9PiB7XG5cbiAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTtcblxuICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn07XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgVWludDE2QXJyYXkoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyBVaW50MTZBcnJheSgoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgVWludDE2QXJyYXkoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IFVpbnQxNkFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgVWludDE2QXJyYXkoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyBVaW50MTZBcnJheSgyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuY29uc3QgZGVmbGF0ZVJlc2V0S2VlcCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICBfdHJfaW5pdChzKTtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVSZXNldCA9IChzdHJtKSA9PiB7XG5cbiAgY29uc3QgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuY29uc3QgZGVmbGF0ZVNldEhlYWRlciA9IChzdHJtLCBoZWFkKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufTtcblxuXG5jb25zdCBkZWZsYXRlSW5pdDIgPSAoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSA9PiB7XG5cbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgbGV0IHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgY29uc3QgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IFVpbnQ4QXJyYXkocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IFVpbnQxNkFycmF5KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IFVpbnQxNkFycmF5KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyBVaW50OEFycmF5KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn07XG5cbmNvbnN0IGRlZmxhdGVJbml0ID0gKHN0cm0sIGxldmVsKSA9PiB7XG5cbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufTtcblxuXG5jb25zdCBkZWZsYXRlID0gKHN0cm0sIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIGNvbnN0IG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICBsZXQgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICBsZXQgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgbGV0IGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn07XG5cblxuY29uc3QgZGVmbGF0ZUVuZCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBjb25zdCBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuY29uc3QgZGVmbGF0ZVNldERpY3Rpb25hcnkgPSAoc3RybSwgZGljdGlvbmFyeSkgPT4ge1xuXG4gIGxldCBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcbiAgY29uc3Qgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIGxldCB0bXBEaWN0ID0gbmV3IFVpbnQ4QXJyYXkocy53X3NpemUpO1xuICAgIHRtcERpY3Quc2V0KGRpY3Rpb25hcnkuc3ViYXJyYXkoZGljdExlbmd0aCAtIHMud19zaXplLCBkaWN0TGVuZ3RoKSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGNvbnN0IGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgY29uc3QgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgY29uc3QgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgbGV0IHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbGV0IG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSk7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG5jb25zdCBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgbGV0IF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgbGV0IGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICBsZXQgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgbGV0IGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgbGV0IGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgbGV0IGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgbGV0IHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICBsZXQgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICBsZXQgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIGxldCBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICBsZXQgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIGxldCBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgbGV0IGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgbGV0IGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICBsZXQgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgbGV0IGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICBsZXQgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgbGV0IGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIGxldCBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgbGV0IGZyb21fc291cmNlO1xuXG5cbiAgbGV0IGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5jb25zdCBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG5jb25zdCBjcmMzMiAgICAgICAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xuY29uc3QgaW5mbGF0ZV9mYXN0ICA9IHJlcXVpcmUoJy4vaW5mZmFzdCcpO1xuY29uc3QgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxuY29uc3QgQ09ERVMgPSAwO1xuY29uc3QgTEVOUyA9IDE7XG5jb25zdCBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfRklOSVNILCBaX0JMT0NLLCBaX1RSRUVTLFxuICBaX09LLCBaX1NUUkVBTV9FTkQsIFpfTkVFRF9ESUNULCBaX1NUUkVBTV9FUlJPUiwgWl9EQVRBX0VSUk9SLCBaX01FTV9FUlJPUiwgWl9CVUZfRVJST1IsXG4gIFpfREVGTEFURURcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmNvbnN0ICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbmNvbnN0ICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xuY29uc3QgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqL1xuY29uc3QgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xuY29uc3QgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbmNvbnN0ICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi9cbmNvbnN0ICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xuY29uc3QgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xuY29uc3QgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovXG5jb25zdCAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xuY29uc3QgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xuY29uc3QgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5jb25zdCAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbmNvbnN0ICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbmNvbnN0ICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbmNvbnN0ICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbmNvbnN0ICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG5jb25zdCAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuY29uc3QgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbmNvbnN0ICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG5jb25zdCAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG5jb25zdCAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xuY29uc3QgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xuY29uc3QgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xuY29uc3QgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG5jb25zdCAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xuY29uc3QgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xuY29uc3QgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG5jb25zdCAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0ICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0ICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbmNvbnN0IEVOT1VHSF9MRU5TID0gODUyO1xuY29uc3QgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy9jb25zdCBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbmNvbnN0IE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG5jb25zdCBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuY29uc3QgenN3YXAzMiA9IChxKSA9PiB7XG5cbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59O1xuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyBVaW50MTZBcnJheSgzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyBVaW50MTZBcnJheSgyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgSW50MzJBcnJheShFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5cbmNvbnN0IGluZmxhdGVSZXNldEtlZXAgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgSW50MzJBcnJheShFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufTtcblxuXG5jb25zdCBpbmZsYXRlUmVzZXQgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufTtcblxuXG5jb25zdCBpbmZsYXRlUmVzZXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHtcbiAgbGV0IHdyYXA7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufTtcblxuXG5jb25zdCBpbmZsYXRlSW5pdDIgPSAoc3RybSwgd2luZG93Qml0cykgPT4ge1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgY29uc3Qgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIGNvbnN0IHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUluaXQgPSAoc3RybSkgPT4ge1xuXG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn07XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xubGV0IHZpcmdpbiA9IHRydWU7XG5cbmxldCBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cblxuY29uc3QgZml4ZWR0YWJsZXMgPSAoc3RhdGUpID0+IHtcblxuICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqL1xuICBpZiAodmlyZ2luKSB7XG4gICAgbGVuZml4ID0gbmV3IEludDMyQXJyYXkoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IEludDMyQXJyYXkoMzIpO1xuXG4gICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi9cbiAgICBsZXQgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59O1xuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5jb25zdCB1cGRhdGV3aW5kb3cgPSAoc3RybSwgc3JjLCBlbmQsIGNvcHkpID0+IHtcblxuICBsZXQgZGlzdDtcbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IFVpbnQ4QXJyYXkoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgc3RhdGUud2luZG93LnNldChzcmMuc3ViYXJyYXkoZW5kIC0gc3RhdGUud3NpemUsIGVuZCksIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICBzdGF0ZS53aW5kb3cuc2V0KHNyYy5zdWJhcnJheShlbmQgLSBjb3B5LCBlbmQgLSBjb3B5ICsgZGlzdCksIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIGNvcHksIGVuZCksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5cbmNvbnN0IGluZmxhdGUgPSAoc3RybSwgZmx1c2gpID0+IHtcblxuICBsZXQgc3RhdGU7XG4gIGxldCBpbnB1dCwgb3V0cHV0OyAgICAgICAgICAvLyBpbnB1dC9vdXRwdXQgYnVmZmVyc1xuICBsZXQgbmV4dDsgICAgICAgICAgICAgICAgICAgLyogbmV4dCBpbnB1dCBJTkRFWCAqL1xuICBsZXQgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi9cbiAgbGV0IGhhdmUsIGxlZnQ7ICAgICAgICAgICAgIC8qIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIGxldCBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBiaXQgYnVmZmVyICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi9cbiAgbGV0IF9pbiwgX291dDsgICAgICAgICAgICAgIC8qIHNhdmUgc3RhcnRpbmcgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgbGV0IGNvcHk7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBzdG9yZWQgb3IgbWF0Y2ggYnl0ZXMgdG8gY29weSAqL1xuICBsZXQgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovXG4gIGxldCBmcm9tX3NvdXJjZTtcbiAgbGV0IGhlcmUgPSAwOyAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgZGVjb2RpbmcgdGFibGUgZW50cnkgKi9cbiAgbGV0IGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkIFwiaGVyZVwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIC8vbGV0IGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIHBhcmVudCB0YWJsZSBlbnRyeSAqL1xuICBsZXQgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgXCJsYXN0XCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgbGV0IGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCB0byBjb3B5IGZvciByZXBlYXRzLCBiaXRzIHRvIGRyb3AgKi9cbiAgbGV0IHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovXG4gIGNvbnN0IGhidWYgPSBuZXcgVWludDhBcnJheSg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgbGV0IG9wdHM7XG5cbiAgbGV0IG47IC8vIHRlbXBvcmFyeSB2YXJpYWJsZSBmb3IgTkVFRF9CSVRTXG5cbiAgY29uc3Qgb3JkZXIgPSAvKiBwZXJtdXRhdGlvbiBvZiBjb2RlIGxlbmd0aHMgKi9cbiAgICBuZXcgVWludDhBcnJheShbIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXSk7XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuXG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAhISEgcGFrbyBwYXRjaC4gRm9yY2UgdXNlIGBvcHRpb25zLndpbmRvd0JpdHNgIGlmIHBhc3NlZC5cbiAgICAgICAgLy8gUmVxdWlyZWQgdG8gYWx3YXlzIHVzZSBtYXggd2luZG93IHNpemUgYnkgZGVmYXVsdC5cbiAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgICAgIC8vc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEU7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRkxBR1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7XG4gICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRJTUU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgICAvLz09PVxuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgT1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYTEVOOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYVFJBOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVudCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBVaW50OEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLnNldChcbiAgICAgICAgICAgICAgICBpbnB1dC5zdWJhcnJheShcbiAgICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICAgICAgbmV4dCArIGNvcHlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPTU1FTlQ6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUNUSUQ6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElDVDpcbiAgICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICBvdXRwdXQuc2V0KGlucHV0LnN1YmFycmF5KG5leHQsIG5leHQgKyBjb3B5KSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgICAgLy8tLS1cblxuICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNUOlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTUFUQ0g6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5O1xuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMSVQ6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBsZWZ0LS07XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDSEVDSzpcbiAgICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAvLyBVc2UgJ3wnIGluc3RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgICAgY2FzZSBTWU5DOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5mX2xlYXZlIDwtIGhlcmUgaXMgcmVhbCBwbGFjZSBmb3IgXCJnb3RvIGluZl9sZWF2ZVwiLCBlbXVsYXRlZCB2aWEgXCJicmVhayBpbmZfbGVhdmVcIlxuXG4gIC8qXG4gICAgIFJldHVybiBmcm9tIGluZmxhdGUoKSwgdXBkYXRpbmcgdGhlIHRvdGFsIGNvdW50cyBhbmQgdGhlIGNoZWNrIHZhbHVlLlxuICAgICBJZiB0aGVyZSB3YXMgbm8gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBpbmZsYXRlKCkgY2FsbCwgcmV0dXJuIGEgYnVmZmVyXG4gICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLlxuICAgICBOb3RlOiBhIG1lbW9yeSBlcnJvciBmcm9tIGluZmxhdGUoKSBpcyBub24tcmVjb3ZlcmFibGUuXG4gICAqL1xuXG4gIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAvLy0tLVxuXG4gIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7XG4gICAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIH1cbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7XG4gIH1cbiAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVFbmQgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgbGV0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LO1xufTtcblxuXG5jb25zdCBpbmZsYXRlR2V0SGVhZGVyID0gKHN0cm0sIGhlYWQpID0+IHtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVTZXREaWN0aW9uYXJ5ID0gKHN0cm0sIGRpY3Rpb25hcnkpID0+IHtcbiAgY29uc3QgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIGxldCBzdGF0ZTtcbiAgbGV0IGRpY3RpZDtcbiAgbGV0IHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IE1BWEJJVFMgPSAxNTtcbmNvbnN0IEVOT1VHSF9MRU5TID0gODUyO1xuY29uc3QgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy9jb25zdCBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxuY29uc3QgQ09ERVMgPSAwO1xuY29uc3QgTEVOUyA9IDE7XG5jb25zdCBESVNUUyA9IDI7XG5cbmNvbnN0IGxiYXNlID0gbmV3IFVpbnQxNkFycmF5KFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl0pO1xuXG5jb25zdCBsZXh0ID0gbmV3IFVpbnQ4QXJyYXkoWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl0pO1xuXG5jb25zdCBkYmFzZSA9IG5ldyBVaW50MTZBcnJheShbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl0pO1xuXG5jb25zdCBkZXh0ID0gbmV3IFVpbnQ4QXJyYXkoWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl0pO1xuXG5jb25zdCBpbmZsYXRlX3RhYmxlID0gKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpID0+XG57XG4gIGNvbnN0IGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIGxldCBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIGxldCBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICBsZXQgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgbGV0IHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgbGV0IGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgbGV0IGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICBsZXQgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIGxldCB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIGxldCBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICBsZXQgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgbGV0IGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICBsZXQgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgbGV0IG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIGxldCBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICBsZXQgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICBsZXQgYmFzZV9pbmRleCA9IDA7XG4vLyAgbGV0IHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICBsZXQgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgY29uc3QgY291bnQgPSBuZXcgVWludDE2QXJyYXkoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgY29uc3Qgb2ZmcyA9IG5ldyBVaW50MTZBcnJheShNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICBsZXQgZXh0cmEgPSBudWxsO1xuICBsZXQgZXh0cmFfaW5kZXggPSAwO1xuXG4gIGxldCBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGluZmxhdGVfdGFibGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8qIGVzbGludC1kaXNhYmxlIHNwYWNlLXVuYXJ5LW9wcyAqL1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL2NvbnN0IFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy9jb25zdCBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vY29uc3QgWl9STEUgICAgICAgICAgICAgICA9IDM7XG5jb25zdCBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy9jb25zdCBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuY29uc3QgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbmNvbnN0IFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL2NvbnN0IFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxuY29uc3QgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyBsZXQgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbmNvbnN0IFNUT1JFRF9CTE9DSyA9IDA7XG5jb25zdCBTVEFUSUNfVFJFRVMgPSAxO1xuY29uc3QgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbmNvbnN0IE1JTl9NQVRDSCAgICA9IDM7XG5jb25zdCBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbmNvbnN0IExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG5jb25zdCBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbmNvbnN0IExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxuY29uc3QgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbmNvbnN0IEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG5jb25zdCBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxuY29uc3QgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbmNvbnN0IEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxuY29uc3QgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbmNvbnN0IFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbmNvbnN0IFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuY29uc3QgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5jb25zdCBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXSk7XG5cbmNvbnN0IGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdKTtcblxuY29uc3QgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XSk7XG5cbmNvbnN0IGJsX29yZGVyID1cbiAgbmV3IFVpbnQ4QXJyYXkoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbmNvbnN0IERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc3RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxuY29uc3Qgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbmNvbnN0IHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG5jb25zdCBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbmNvbnN0IF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbmNvbnN0IGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxuY29uc3QgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbmxldCBzdGF0aWNfbF9kZXNjO1xubGV0IHN0YXRpY19kX2Rlc2M7XG5sZXQgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuY29uc3QgZF9jb2RlID0gKGRpc3QpID0+IHtcblxuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmNvbnN0IHB1dF9zaG9ydCA9IChzLCB3KSA9PiB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmNvbnN0IHNlbmRfYml0cyA9IChzLCB2YWx1ZSwgbGVuZ3RoKSA9PiB7XG5cbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufTtcblxuXG5jb25zdCBzZW5kX2NvZGUgPSAocywgYywgdHJlZSkgPT4ge1xuXG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmNvbnN0IGJpX3JldmVyc2UgPSAoY29kZSwgbGVuKSA9PiB7XG5cbiAgbGV0IHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5jb25zdCBiaV9mbHVzaCA9IChzKSA9PiB7XG5cbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmNvbnN0IGdlbl9iaXRsZW4gPSAocywgZGVzYykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgY29uc3QgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgY29uc3QgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgY29uc3Qgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIGNvbnN0IGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgY29uc3QgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgY29uc3QgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgY29uc3QgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgbGV0IGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIGxldCBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICBsZXQgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgbGV0IGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgbGV0IG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuY29uc3QgZ2VuX2NvZGVzID0gKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudCkgPT5cbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgY29uc3QgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIGxldCBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICBsZXQgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBsZXQgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuY29uc3QgdHJfc3RhdGljX2luaXQgPSAoKSA9PiB7XG5cbiAgbGV0IG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICBsZXQgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICBsZXQgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgbGV0IGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICBjb25zdCBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5jb25zdCBpbml0X2Jsb2NrID0gKHMpID0+IHtcblxuICBsZXQgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmNvbnN0IGJpX3dpbmR1cCA9IChzKSA9Plxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5jb25zdCBjb3B5X2Jsb2NrID0gKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpID0+XG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICBzLnBlbmRpbmdfYnVmLnNldChzLndpbmRvdy5zdWJhcnJheShidWYsIGJ1ZiArIGxlbiksIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuY29uc3Qgc21hbGxlciA9ICh0cmVlLCBuLCBtLCBkZXB0aCkgPT4ge1xuXG4gIGNvbnN0IF9uMiA9IG4gKiAyO1xuICBjb25zdCBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmNvbnN0IHBxZG93bmhlYXAgPSAocywgdHJlZSwgaykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgY29uc3QgdiA9IHMuaGVhcFtrXTtcbiAgbGV0IGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufTtcblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyBjb25zdCBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmNvbnN0IGNvbXByZXNzX2Jsb2NrID0gKHMsIGx0cmVlLCBkdHJlZSkgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICBsZXQgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIGxldCBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIGxldCBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICBsZXQgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgbGV0IGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuY29uc3QgYnVpbGRfdHJlZSA9IChzLCBkZXNjKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICBjb25zdCB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIGNvbnN0IHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIGNvbnN0IGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgY29uc3QgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgbGV0IG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIGxldCBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgbGV0IG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5jb25zdCBzY2FuX3RyZWUgPSAocywgdHJlZSwgbWF4X2NvZGUpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgbGV0IGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIGxldCBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICBsZXQgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICBsZXQgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIGxldCBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuY29uc3Qgc2VuZF90cmVlID0gKHMsIHRyZWUsIG1heF9jb2RlKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIGxldCBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICBsZXQgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgbGV0IG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIGxldCBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIGxldCBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgbGV0IG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuY29uc3QgYnVpbGRfYmxfdHJlZSA9IChzKSA9PiB7XG5cbiAgbGV0IG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuY29uc3Qgc2VuZF9hbGxfdHJlZXMgPSAocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICBsZXQgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5jb25zdCBkZXRlY3RfZGF0YV90eXBlID0gKHMpID0+IHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICBsZXQgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIGxldCBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59O1xuXG5cbmxldCBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5jb25zdCBfdHJfaW5pdCA9IChzKSA9Plxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmNvbnN0IF90cl9zdG9yZWRfYmxvY2sgPSAocywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSA9PlxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuY29uc3QgX3RyX2FsaWduID0gKHMpID0+IHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmNvbnN0IF90cl9mbHVzaF9ibG9jayA9IChzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpID0+XG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBsZXQgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICBsZXQgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuY29uc3QgX3RyX3RhbGx5ID0gKHMsIGRpc3QsIGxjKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vbGV0IG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufTtcblxubW9kdWxlLmV4cG9ydHMuX3RyX2luaXQgID0gX3RyX2luaXQ7XG5tb2R1bGUuZXhwb3J0cy5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jaztcbm1vZHVsZS5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5tb2R1bGUuZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7XG5tb2R1bGUuZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIiwiLyoqXG4gKiBUaGlzIE1vZHVsZSBjb250YWlucyBjbGFzc2VzIHJlbGV2YW50IHRvIGRhdGEgYWJvdXQgYSB1c2VyIGluIHRoZSB2aXJ0dWFsIDNEIGVudmlyb25tZW50LlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cblxuaW1wb3J0IHsgSGlGaVV0aWxpdGllcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvSGlGaVV0aWxpdGllc1wiO1xuXG5cbi8qKlxuICogSW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcyBkZWZpbmUgYSBwb3NpdGlvbiBpbiAzRCBzcGFjZS4gVGhlIHBvc2l0aW9uIG9mIGEgdXNlciBhZmZlY3RzIHRoZSB3YXkgdGhlIG1peGVkIHNwYXRpYWxcbiAqIGF1ZGlvIGlzIGhlYXJkIGJ5IHRoZSB1c2VyLlxuICovXG5leHBvcnQgY2xhc3MgUG9pbnQzRCB7XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgK3ggaXMgdG8gdGhlIHJpZ2h0IGFuZCAteCBpcyB0byB0aGUgbGVmdC4gVW5pdHMgZm9yIHRoaXMgbWVtYmVyIHZhcmlhYmxlIGFyZSAqKm1ldGVycyoqLlxuICAgICAqL1xuICAgIHg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCAreSBpcyBpbnRvIHRoZSBzY3JlZW4gYW5kIC15IGlzIG91dCBvZiB0aGUgc2NyZWVuIHRvd2FyZHMgdGhlIHVzZXIuIFVuaXRzIGZvciB0aGlzIG1lbWJlciB2YXJpYWJsZSBhcmUgKiptZXRlcnMqKi5cbiAgICAgKi9cbiAgICB5OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgK3ogaXMgdXAgYW5kIC16IGlzIGRvd24uIFVuaXRzIGZvciB0aGlzIG1lbWJlciB2YXJpYWJsZSBhcmUgKiptZXRlcnMqKi5cbiAgICAgKi9cbiAgICB6OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYFBvaW50M0RgIG9iamVjdC4gQWxsIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLiBVbnNldCBwYXJhbWV0ZXJzIHdpbGwgYmUgc2V0IHRvIGAwYC4gUmVtZW1iZXIsIGFsbCB1bml0cyBmb3IgbWVtYmVyIHZhcmlhYmxlcyBhcmUgYG1ldGVyc2AuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyB4ID0gMCwgeSA9IDAsIHogPSAwIH06IHsgeD86IG51bWJlciwgeT86IG51bWJlciwgej86IG51bWJlciB9ID0ge30pIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICB9XG59XG5cbi8qKlxuICogSW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcyBkZWZpbmUgYW4gb3JpZW50YXRpb24gaW4gM0Qgc3BhY2UgaW4gUXVhdGVybmlvbiBmb3JtYXQuIEEgdXNlcidzIG9yaWVudGF0aW9uIGluIDNEIHNwYWNlXG4gKiBhZmZlY3RzIHRoZSB3YXkgdGhlIG1peGVkIHNwYXRpYWwgYXVkaW8gaXMgaGVhcmQgYnkgdGhlIHVzZXIuIEFkZGl0aW9uYWxseSwgb3JpZW50YXRpb24gYWZmZWN0cyB0aGUgd2F5XG4gKiBhIHVzZXIncyBhdWRpbyBpbnB1dCBwcm9wYWdhdGVzIHRocm91Z2ggYSBzcGFjZTogc3BlYWtlcnMgZmFjaW5nIGRpcmVjdGx5IHRvd2FyZHMgYSBsaXN0ZW5lciB3aWxsIHNvdW5kIGxvdWRlciB0aGFuXG4gKiBzcGVha2VycyBmYWNpbmcgYXdheSBmcm9tIGEgbGlzdGVuZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBPcmllbnRhdGlvblF1YXQzRCB7XG4gICAgdzogbnVtYmVyO1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgejogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGBPcmllbnRhdGlvblF1YXQzRGAgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgdyA9IDEsIHggPSAwLCB5ID0gMCwgeiA9IDAgfTogeyB3PzogbnVtYmVyLCB4PzogbnVtYmVyLCB5PzogbnVtYmVyLCB6PzogbnVtYmVyIH0gPSB7fSkge1xuICAgICAgICB0aGlzLncgPSBIaUZpVXRpbGl0aWVzLmNsYW1wTm9uYW4odywgLTEsIDEsIDEpO1xuICAgICAgICB0aGlzLnggPSBIaUZpVXRpbGl0aWVzLmNsYW1wTm9uYW4oeCwgLTEsIDEsIDApO1xuICAgICAgICB0aGlzLnkgPSBIaUZpVXRpbGl0aWVzLmNsYW1wTm9uYW4oeSwgLTEsIDEsIDApO1xuICAgICAgICB0aGlzLnogPSBIaUZpVXRpbGl0aWVzLmNsYW1wTm9uYW4oeiwgLTEsIDEsIDApO1xuICAgIH1cbn1cblxuXG4vLyBoZWxwZXIgZnVuY3Rpb24gdGhhdCBrZWVwcyBhbiBhbmdsZSBleHByZXNzZWQgaW4gZGVncmVlcyBpbiB0aGUgcmFuZ2UgXS0zNjAsIDM2MFtcbmZ1bmN0aW9uIHNhbml0aXplQW5nbGVEZWdyZWVzKHY6IG51bWJlcik6IG51bWJlciB7XG4gICAgLy8gaW4gdGhlIGNhc2UgdiBpcyBJbmZpbml0eSBvciBOYW4sICBsZXQncyBzcGVjaWFsIGNhc2VcbiAgICBpZiAoaXNOYU4odikgfHwgdiA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmICh2ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIC0wO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGJyaW5nIHRoZSB2YWx1ZSBpbiB0aGUgcmFuZ2UgXS0zNjAsIDM2MFtcbiAgICAgICAgLy8gaWYgdiBpcyA8IDAgdGhlbiBpdCB3aWxsIGN5Y2xlIGluIF0tMzYwLCAwXVxuICAgICAgICAvLyBpZiB2IGlzID4gMCB0aGVuIGl0IHdpbGwgY3ljbGUgaW4gWzAsIDM2MFtcbiAgICAgICAgcmV0dXJuIHYgJSAzNjA7XG4gICAgfVxufVxuXG4vKipcbiAqIEluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MgZGVmaW5lIGFuIG9yaWVudGF0aW9uIGluIDNEIHNwYWNlIHJlcHJlc2VudGVkIGJ5IGV1bGVyIGFuZ2xlcy5cbiAqIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIHF1YXRlcm5pb24gcmVwcmVzZW50YXRpb24gZm9yIG9yaWVudGF0aW9uIHdoZW4gdXBkYXRpbmcgdGhlIGNsaWVudFxuICogb3Igd2hlbiByZWNlaXZpbmcgdGhlIHVwZGF0ZXMgYWJvdXQgdGhlIG90aGVyIGNsaWVudHMgaW4gdGhlIHNwYWNlLlxuICovXG5leHBvcnQgY2xhc3MgT3JpZW50YXRpb25FdWxlcjNEIHtcbiAgICAvKipcbiAgICAgKiBDb25zaWRlciBhbiBhaXJjcmFmdDogXCJQaXRjaFwiIGlzIGRlZmluZWQgYXMgXCJub3NlIHVwL2Rvd24gYWJvdXQgdGhlIGF4aXMgcnVubmluZyBmcm9tIHdpbmcgdG8gd2luZ1wiLlxuICAgICAqICoqTmVnYXRpdmUgcGl0Y2gqKiBtZWFucyB0aGF0IHRoZSBhaXJjcmFmdCBtb3ZlcyBpdHMgbm9zZSAqKmNsb3NlciB0byB0aGUgZ3JvdW5kKiouXG4gICAgICogKipQb3NpdGl2ZSBwaXRjaCoqIG1lYW5zIHRoYXQgdGhlIGFpcmNyYWZ0IG1vdmVzIGl0cyBub3NlICoqYXdheSBmcm9tIHRoZSBncm91bmQqKi5cbiAgICAgKiBVbml0cyBoZXJlIGFyZSBkZWdyZWVzLlxuICAgICAqL1xuICAgIHBpdGNoRGVncmVlczogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENvbnNpZGVyIGFuIGFpcmNyYWZ0OiBcIllhd1wiIGlzIGRlZmluZWQgYXMgXCJub3NlIGxlZnQvcmlnaHQgYWJvdXQgdGhlIGF4aXMgcnVubmluZyB1cCBhbmQgZG93blwiLlxuICAgICAqICoqTmVnYXRpdmUgeWF3KiogbWVhbnMgdGhhdCB0aGUgYWlyY3JhZnQgd2lsbCByb3RhdGUgKipjbG9ja3dpc2UqKiB3aGVuIHZpZXdpbmcgdGhlIGFpcmNyYWZ0IGZyb20gYWJvdmUuXG4gICAgICogKipQb3NpdGl2ZSB5YXcqKiBtZWFucyB0aGF0IHRoZSBhaXJjcmFmdCB3aWxsIHJvdGF0ZSAqKmNvdW50ZXItY2xvY2t3aXNlKiogd2hlbiB2aWV3aW5nIHRoZSBhaXJjcmFmdCBmcm9tIGFib3ZlLlxuICAgICAqIFVuaXRzIGhlcmUgYXJlIGRlZ3JlZXMuXG4gICAgICovXG4gICAgeWF3RGVncmVlczogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENvbnNpZGVyIGFuIGFpcmNyYWZ0OiBcIlJvbGxcIiBpcyBkZWZpbmVkIGFzIFwicm90YXRpb24gYWJvdXQgdGhlIGF4aXMgcnVubmluZyBmcm9tIG5vc2UgdG8gdGFpbFwiLlxuICAgICAqICoqUG9zaXRpdmUgcm9sbCoqIG1lYW5zIHRoYXQgdGhlIGFpcmNyYWZ0J3MgKipyaWdodCB3aW5nIHdpbGwgbW92ZSBjbG9zZXIgdG8gdGhlIGdyb3VuZCoqLlxuICAgICAqICoqTmVnYXRpdmUgcm9sbCoqIG1lYW5zIHRoYXQgdGhlIGFpcmNyYWZ0J3MgKipsZWZ0IHdpbmcgd2lsbCBtb3ZlIGNsb3NlciB0byB0aGUgZ3JvdW5kKiouXG4gICAgICogVW5pdHMgaGVyZSBhcmUgZGVncmVlcy5cbiAgICAgKi9cbiAgICByb2xsRGVncmVlczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGBPcmllbnRhdGlvbkV1bGVyM0RgIG9iamVjdC4gQWxsIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLiBVbnNldCBwYXJhbWV0ZXJzIHdpbGwgYmUgc2V0IHRvIGAwYC4gUmVtZW1iZXIsIGFsbCB1bml0cyBmb3IgbWVtYmVyIHZhcmlhYmxlcyBhcmUgYGRlZ3JlZXNgLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgcGl0Y2hEZWdyZWVzID0gMCwgeWF3RGVncmVlcyA9IDAsIHJvbGxEZWdyZWVzID0gMCB9OiB7IHBpdGNoRGVncmVlcz86IG51bWJlciwgeWF3RGVncmVlcz86IG51bWJlciwgcm9sbERlZ3JlZXM/OiBudW1iZXIgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMucGl0Y2hEZWdyZWVzID0gc2FuaXRpemVBbmdsZURlZ3JlZXMocGl0Y2hEZWdyZWVzKTtcbiAgICAgICAgdGhpcy55YXdEZWdyZWVzID0gc2FuaXRpemVBbmdsZURlZ3JlZXMoeWF3RGVncmVlcyk7XG4gICAgICAgIHRoaXMucm9sbERlZ3JlZXMgPSBzYW5pdGl6ZUFuZ2xlRGVncmVlcyhyb2xsRGVncmVlcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFzaWRlIGZyb20gdGhlIDMgYW5nbGVzIFlhdywgUGl0Y2gsIFJvbGwgZGVmaW5pbmcgYW4gb3JpZW50YXRpb24sIGV1bGVyIGFuZ2xlcyByZXF1aXJlcyBcbiAqIHRvIGRlZmluZSB0aGUgb3JkZXIgaW4gd2l0Y2ggdGhlIGluZGl2aWR1YWwgeWF3LCBwaXRjaCByb2xsIHJvdGF0aW9ucyBhcmUgY29tYmluZWQuXG4gKiBUaGVyZSBhcmUgNiBvcmRlcnMgcG9zc2libGUgaWRlbnRpZmllZCBieSB0aGUgSGlGaUV1bGVyT3JkZXIgZW51bS5cbiAqIFxuICogIEZvciBleGFtcGxlLCB0aGUgb3JkZXIgWWF3UGl0Y2hSb2xsIGlzIGRlc2NyaWJpbmcgdGhlIGZvbGxvd2luZyBzZXF1ZW5jZVxuICogIHN0YXJ0aW5nIGZyb20gdGhlIGJhc2UgM2QgZnJhbWUsXG4gKiAgMS8gWWF3LCByb3RhdGluZyBhcm91bmQgdGhlIHZlcnRpY2FsIGF4aXNcbiAqICAyLyBQaXRjaCwgcm90YXRpbmcgYXJvdW5kIHRoZSByaWdodCBheGlzIFxuICogIDMvIFJvbGwsIHJvdGF0aW5nIGFyb3VuZCB0aGUgZnJvbnQgYXhpc1xuICogIHRoZSByZXN1bHRpbmcgM2QgZnJhbWUgb3JpZW50YXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIGJhc2UgZnJhbWUuXG4gKi9cbmV4cG9ydCBlbnVtIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyIHtcbiAgICBQaXRjaFlhd1JvbGwgPSBcIlBpdGNoWWF3Um9sbFwiLFxuICAgIFlhd1BpdGNoUm9sbCA9IFwiWWF3UGl0Y2hSb2xsXCIsXG4gICAgUm9sbFBpdGNoWWF3ID0gXCJSb2xsUGl0Y2hZYXdcIixcbiAgICBSb2xsWWF3UGl0Y2ggPSBcIlJvbGxZYXdQaXRjaFwiLFxuICAgIFlhd1JvbGxQaXRjaCA9IFwiWWF3Um9sbFBpdGNoXCIsXG4gICAgUGl0Y2hSb2xsWWF3ID0gXCJQaXRjaFJvbGxZYXdcIixcbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBvcmllbnRhdGlvbiBxdWF0ZXJuaW9uIGZyb20gdGhlIHNwZWNpZmllZCBldWxlciBhbmdsZXMuXG4gKiBUaGUgcmVzdWx0aW5nIHF1YXRlcm5pb24gaXMgdGhlIHJvdGF0aW9uIHRyYW5zZm9ybWluZyBmcm9tIGNvbWJpbmluZyB0aGUgZXVsZXIgYW5nbGVzIHJvdGF0aW9ucyBpbiB0aGUgc3BlY2lmaWVkIG9yZGVyXG4gKiBcbiAqIEZvciBleGFtcGxlLCB0aGUgb3JkZXIgWWF3UGl0Y2hSb2xsIGlzIGNvbXB1dGVkIGFzIGZvbGxvdzpcbiAqICBzdGFydGluZyBmcm9tIHRoZSBiYXNlIDNkIGZyYW1lLFxuICogIDEvIFlhdywgcm90YXRpbmcgYXJvdW5kIHRoZSB2ZXJ0aWNhbCBheGlzXG4gKiAgMi8gUGl0Y2gsIHJvdGF0aW5nIGFyb3VuZCB0aGUgcmlnaHQgYXhpcyBcbiAqICAzLyBSb2xsLCByb3RhdGluZyBhcm91bmQgdGhlIGZyb250IGF4aXNcbiAqICB0aGUgcmVzdWx0aW5nIDNkIGZyYW1lIG9yaWVudGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBiYXNlIGZyYW1lLlxuICogIFRoZSByZXN1bHRpbmcgcm90YXRpb24gaXMgZGVmaW5pbmcgdGhlICdyb3RhdGVkJyBzcGFjZSByZWxhdGl2ZSB0byB0aGUgJ2Jhc2UnIHNwYWNlLlxuICogIEEgdmVjdG9yIFZyIGluIFwicm90YXRlZCcgc3BhY2UgYW5kIGl0cyBlcXVpdmFsZW50IHZhbHVlIFZiIGluIHRoZSdiYXNlJyBzcGFjZSBpcyBjb21wdXRlZCBhcyBmb2xsb3c6XG4gKiAgVmIgPSBbUF1bWV1bUl0gVnJcbiAqIFxuICogQHBhcmFtIGV1bGVyIC0gVGhlIGV1bGVyIGFuZ2xlcy5cbiAqIEBwYXJhbSBvcmRlciAtIFRoZSBldWxlciBvcmRlciBjb252ZW50aW9uLlxuICogXG4gKiBAcmV0dXJuIFRoZSBlbmQgcmVzdWx0aW5nIHF1YXRlcm5pb24gZGVmaW5lZCBmcm9tIHRoZSBldWxlciBhbmdsZXMgY29tYmluYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV1bGVyVG9RdWF0ZXJuaW9uKGV1bGVyOiBPcmllbnRhdGlvbkV1bGVyM0QsIG9yZGVyOiBPcmllbnRhdGlvbkV1bGVyM0RPcmRlcik6IE9yaWVudGF0aW9uUXVhdDNEIHtcbiAgICAvLyBjb21wdXRlIHRoZSBpbmRpdmlkdWFsIGV1bGVyIGFuZ2xlIHJvdGF0aW9uIHF1YXRlcm5pb24gdGVybXMgc2luKGFuZ2xlLzIpIGFuZCBjb3MoYWFuZ2xlLzIpXG4gICAgY29uc3QgSEFMRl9ERUdfVE9fUkFEID0gMC41ICogTWF0aC5QSSAvIDE4MC4wO1xuICAgIGxldCBjb3MgPSB7IFA6IE1hdGguY29zKGV1bGVyLnBpdGNoRGVncmVlcyAqIEhBTEZfREVHX1RPX1JBRCksIFk6IE1hdGguY29zKGV1bGVyLnlhd0RlZ3JlZXMgKiBIQUxGX0RFR19UT19SQUQpLCBSOiBNYXRoLmNvcyhldWxlci5yb2xsRGVncmVlcyAqIEhBTEZfREVHX1RPX1JBRCl9O1xuICAgIGxldCBzaW4gPSB7IFA6IE1hdGguc2luKGV1bGVyLnBpdGNoRGVncmVlcyAqIEhBTEZfREVHX1RPX1JBRCksIFk6IE1hdGguc2luKGV1bGVyLnlhd0RlZ3JlZXMgKiBIQUxGX0RFR19UT19SQUQpLCBSOiBNYXRoLnNpbihldWxlci5yb2xsRGVncmVlcyAqIEhBTEZfREVHX1RPX1JBRCl9O1xuXG4gICAgLy8gdGhlIGNvbXB1dGVkIHF1YXRlcm5pb24gY29tcG9uZW50cyBmb3IgdGhlIDYgb3JkZXJzIGFyZSBiYXNlZCBvbiB0aGUgc2FtZSBwYXR0ZXJuXG4gICAgLy8gcS54ID0gYXggKy8tIGJ4IFxuICAgIC8vIHEueSA9IGF5ICsvLSBieSBcbiAgICAvLyBxLnogPSBheiArLy0gYnogXG4gICAgLy8gcS53ID0gYXcgKy8tIGJ3IFxuXG4gICAgbGV0IGF4ID0gc2luLlAgKiBjb3MuWSAqIGNvcy5SO1xuICAgIGxldCBheSA9IGNvcy5QICogc2luLlkgKiBjb3MuUjtcbiAgICBsZXQgYXogPSBjb3MuUCAqIGNvcy5ZICogc2luLlI7XG4gICAgbGV0IGF3ID0gY29zLlAgKiBjb3MuWSAqIGNvcy5SO1xuXG4gICAgbGV0IGJ4ID0gY29zLlAgKiBzaW4uWSAqIHNpbi5SO1xuICAgIGxldCBieSA9IHNpbi5QICogY29zLlkgKiBzaW4uUjtcbiAgICBsZXQgYnogPSBzaW4uUCAqIHNpbi5ZICogY29zLlI7XG4gICAgbGV0IGJ3ID0gc2luLlAgKiBzaW4uWSAqIHNpbi5SO1xuXG4gICAgc3dpdGNoIChvcmRlcikge1xuICAgIC8vIGZyb20gJ2Jhc2UnIHNwYWNlIHJvdGF0ZSBQaXRjaCwgdGhlbiBZYXcgdGhlbiBSb2xsXG4gICAgLy8gUmVzdWx0aW5nIHJvdGF0aW9uIGlzIGRlZmluaW5nIHRoZSAncm90YXRlZCcgc3BhY2UgcmVsYXRpdmUgdG8gdGhlICdiYXNlJyBzcGFjZS5cbiAgICAvLyBBIHZlY3RvciBWciBpbiBcInJvdGF0ZWQnIHNwYWNlIGFuZCBpdHMgZXF1aXZhbGVudCB2YWx1ZSBWYiBpbiB0aGUnYmFzZScgc3BhY2UgaXMgY29tcHV0ZWQgYXMgZm9sbG93OlxuICAgIC8vIFZiID0gW1BdW1ldW1JdIFZyXG4gICAgY2FzZSBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5QaXRjaFlhd1JvbGw6IHtcbiAgICAgICAgcmV0dXJuIG5ldyBPcmllbnRhdGlvblF1YXQzRCh7XG4gICAgICAgICAgICAgICAgeDogYXggKyBieCxcbiAgICAgICAgICAgICAgICB5OiBheSAtIGJ5LFxuICAgICAgICAgICAgICAgIHo6IGF6ICsgYnosXG4gICAgICAgICAgICAgICAgdzogYXcgLSBidyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgLy8gRnJvbSAnYmFzZScgc3BhY2Ugcm90YXRlIFlhdywgdGhlbiBQaXRjaCB0aGVuIFJvbGwuLi5cbiAgICBjYXNlIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLllhd1BpdGNoUm9sbDoge1xuICAgICAgICByZXR1cm4gbmV3IE9yaWVudGF0aW9uUXVhdDNEKHtcbiAgICAgICAgICAgICAgICB4OiBheCArIGJ4LFxuICAgICAgICAgICAgICAgIHk6IGF5IC0gYnksXG4gICAgICAgICAgICAgICAgejogYXogLSBieixcbiAgICAgICAgICAgICAgICB3OiBhdyArIGJ3LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gYnJlYWs7XG4gXG4gICAgLy8gRnJvbSAnYmFzZScgc3BhY2Ugcm90YXRlIFJvbGwsIHRoZW4gUGl0Y2ggdGhlbiBZYXcuLi5cbiAgICBjYXNlIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLlJvbGxQaXRjaFlhdzoge1xuICAgICAgICByZXR1cm4gbmV3IE9yaWVudGF0aW9uUXVhdDNEKHtcbiAgICAgICAgICAgICAgICB4OiBheCAtIGJ4LFxuICAgICAgICAgICAgICAgIHk6IGF5ICsgYnksXG4gICAgICAgICAgICAgICAgejogYXogKyBieixcbiAgICAgICAgICAgICAgICB3OiBhdyAtIGJ3LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gYnJlYWs7XG4gXG4gICAgLy8gRnJvbSAnYmFzZScgc3BhY2Ugcm90YXRlIFJvbGwsIHRoZW4gWWF3IHRoZW4gUGl0Y2guLi5cbiAgICBjYXNlIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLlJvbGxZYXdQaXRjaDoge1xuICAgICAgICByZXR1cm4gbmV3IE9yaWVudGF0aW9uUXVhdDNEKHtcbiAgICAgICAgICAgICAgICB4OiBheCAtIGJ4LFxuICAgICAgICAgICAgICAgIHk6IGF5ICsgYnksXG4gICAgICAgICAgICAgICAgejogYXogLSBieixcbiAgICAgICAgICAgICAgICB3OiBhdyArIGJ3LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gYnJlYWs7XG4gIFxuICAgIC8vIEZyb20gJ2Jhc2UnIHNwYWNlIHJvdGF0ZSBZYXcsIHRoZW4gUm9sbCB0aGVuIFBpdGNoLi4uXG4gICAgY2FzZSBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5ZYXdSb2xsUGl0Y2g6IHtcbiAgICAgICAgcmV0dXJuIG5ldyBPcmllbnRhdGlvblF1YXQzRCh7XG4gICAgICAgICAgICAgICAgeDogYXggKyBieCxcbiAgICAgICAgICAgICAgICB5OiBheSArIGJ5LFxuICAgICAgICAgICAgICAgIHo6IGF6IC0gYnosXG4gICAgICAgICAgICAgICAgdzogYXcgLSBidyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGJyZWFrO1xuICBcbiAgICAvLyBGcm9tICdiYXNlJyBzcGFjZSByb3RhdGUgUGl0Y2gsIHRoZW4gUm9sbCB0aGVuIFlhdy4uLlxuICAgIGNhc2UgT3JpZW50YXRpb25FdWxlcjNET3JkZXIuUGl0Y2hSb2xsWWF3OiB7XG4gICAgICAgIHJldHVybiBuZXcgT3JpZW50YXRpb25RdWF0M0Qoe1xuICAgICAgICAgICAgICAgIHg6IGF4IC0gYngsXG4gICAgICAgICAgICAgICAgeTogYXkgLSBieSxcbiAgICAgICAgICAgICAgICB6OiBheiArIGJ6LFxuICAgICAgICAgICAgICAgIHc6IGF3ICsgYncsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBicmVhaztcbiAgICB9ICAgIFxufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIG9yaWVudGF0aW9uIGV1bGVyIGRlY29tcG9zaXRpb24gZnJvbSB0aGUgc3BlY2lmaWVkIHF1YXRlcm5pb24uXG4gKiBUaGUgcmVzdWx0aW5nIGV1bGVyIGlzIHRoZSByb3RhdGlvbiB0cmFuc2Zvcm1pbmcgZnJvbSBjb21iaW5pbmcgdGhlIGV1bGVyIGFuZ2xlcyByb3RhdGlvbnMgaW4gdGhlIHNwZWNpZmllZCBvcmRlclxuICogXG4gKiBGb3IgZXhhbXBsZSwgdGhlIG9yZGVyIFlhd1BpdGNoUm9sbCBpcyBjb21wdXRlZCBhcyBmb2xsb3c6XG4gKiAgc3RhcnRpbmcgZnJvbSB0aGUgYmFzZSAzZCBmcmFtZSxcbiAqICAxLyBZYXcsIHJvdGF0aW5nIGFyb3VuZCB0aGUgdmVydGljYWwgYXhpc1xuICogIDIvIFBpdGNoLCByb3RhdGluZyBhcm91bmQgdGhlIHJpZ2h0IGF4aXMgXG4gKiAgMy8gUm9sbCwgcm90YXRpbmcgYXJvdW5kIHRoZSBmcm9udCBheGlzXG4gKiAgdGhlIHJlc3VsdGluZyAzZCBmcmFtZSBvcmllbnRhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgYmFzZSBmcmFtZS5cbiAqICBUaGUgcmVzdWx0aW5nIHJvdGF0aW9uIGlzIGRlZmluaW5nIHRoZSAncm90YXRlZCcgc3BhY2UgcmVsYXRpdmUgdG8gdGhlICdiYXNlJyBzcGFjZS5cbiAqICBBIHZlY3RvciBWciBpbiBcInJvdGF0ZWQnIHNwYWNlIGFuZCBpdHMgZXF1aXZhbGVudCB2YWx1ZSBWYiBpbiB0aGUnYmFzZScgc3BhY2UgaXMgY29tcHV0ZWQgYXMgZm9sbG93OlxuICogIFZiID0gW1BdW1ldW1JdIFZyXG4gKiBcbiAqIEBwYXJhbSBxdWF0IC0gVGhlIG9yaWVudGF0aW9uIHF1YXRlcm5pb24uXG4gKiBAcGFyYW0gb3JkZXIgLSBUaGUgZXVsZXIgb3JkZXIgY29udmVudGlvbi5cbiAqIFxuICogQHJldHVybiBUaGUgZW5kIHJlc3VsdGluZyBxdWF0ZXJuaW9uIGRlZmluZWQgZnJvbSB0aGUgZXVsZXIgYW5nbGVzIGNvbWJpbmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldWxlckZyb21RdWF0ZXJuaW9uKHF1YXQ6IE9yaWVudGF0aW9uUXVhdDNELCBvcmRlcjogT3JpZW50YXRpb25FdWxlcjNET3JkZXIpOiBPcmllbnRhdGlvbkV1bGVyM0Qge1xuICAgIC8vIFdlIG5lZWQgdG8gY29udmVydCB0aGUgcXVhdGVybmlvbiB0byB0aGUgZXF1aXZhbGVudCBtYXQzeDNcbiAgICBsZXQgcXgyID0gcXVhdC54ICogcXVhdC54O1xuICAgIGxldCBxeTIgPSBxdWF0LnkgKiBxdWF0Lnk7XG4gICAgbGV0IHF6MiA9IHF1YXQueiAqIHF1YXQuejtcbiAgICAvLyBsZXQgcXcyID0gcXVhdC53ICogcXVhdC53OyB3ZSBjb3VsZCBjaG9vc2UgdG8gdXNlIGl0IGluc3RlYWQgb2YgdGhlIDEgLSAyKiB0ZXJtLi4uXG4gICAgbGV0IHF3eCA9IHF1YXQudyAqIHF1YXQueDtcbiAgICBsZXQgcXd5ID0gcXVhdC53ICogcXVhdC55O1xuICAgIGxldCBxd3ogPSBxdWF0LncgKiBxdWF0Lno7XG4gICAgbGV0IHF4eSA9IHF1YXQueCAqIHF1YXQueTtcbiAgICBsZXQgcXl6ID0gcXVhdC55ICogcXVhdC56O1xuICAgIGxldCBxeHogPSBxdWF0LnogKiBxdWF0Lng7XG4gICAgLy8gUk9UIE1hdDMzID0gIHsgIDEgLSAycXkyIC0gMnF6MiAgfCAgMihxeHkgLSBxd3opICAgIHwgIDIocXh6ICsgcXd5KSAgfVxuICAgIC8vICAgICAgICAgICAgICB7ICAyKHF4eSArIHF3eikgICAgIHwgIDEgLSAycXgyIC0gMnF6MiB8ICAyKHF5eiAtIHF3eCkgIH1cbiAgICAvLyAgICAgICAgICAgICAgeyAgMihxeHogLSBxd3kpICAgICB8ICAyKHF5eiArIHF3eCkgICAgfCAgMSAtIDJxeDIgLSAycXkyICB9XG4gICAgbGV0IHIwMCA9IDEuMCAtIDIuMCAqIChxeTIgKyBxejIpO1xuICAgIGxldCByMTAgPSAyLjAgKiAocXh5ICsgcXd6KTtcbiAgICBsZXQgcjIwID0gMi4wICogKHF4eiAtIHF3eSk7XG5cbiAgICBsZXQgcjAxID0gMi4wICogKHF4eSAtIHF3eik7XG4gICAgbGV0IHIxMSA9IDEuMCAtIDIuMCAqIChxeDIgKyBxejIpOyBcbiAgICBsZXQgcjIxID0gMi4wICogKHF5eiArIHF3eCk7XG4gICBcbiAgICBsZXQgcjAyID0gMi4wICogKHF4eiArIHF3eSk7XG4gICAgbGV0IHIxMiA9IDIuMCAqIChxeXogLSBxd3gpO1xuICAgIGxldCByMjIgPSAxLjAgLSAyLjAgKiAocXgyICsgcXkyKTsgXG5cbiAgICAvLyB0aGVuIGRlcGVuZGluZyBvbiB0aGUgZXVsZXIgcm90YXRpb24gb3JkZXIgZGVjb21wb3NpdGlvbiwgd2UgZXh0cmFjdCB0aGUgYW5nbGVzIFxuICAgIC8vIGZyb20gdGhlIGJhc2UgdmVjdG9yIGNvbXBvbmVudHNcbiAgICBsZXQgcGl0Y2ggPSAwO1xuICAgIGxldCB5YXcgPSAwO1xuICAgIGxldCByb2xsID0gMDtcbiAgICBjb25zdCBPTkVfTUlOVVNfRVBTSUxPTiA9IDAuOTk5OTk5OTtcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5QaXRjaFlhd1JvbGw6IHtcbiAgICAgICAgeWF3ID0gTWF0aC5hc2luKCBIaUZpVXRpbGl0aWVzLmNsYW1wTm9ybWFsaXplZChyMDIpICk7XG4gICAgICAgIGlmICggTWF0aC5hYnMoIHIwMiApIDwgT05FX01JTlVTX0VQU0lMT04gKSB7XG4gICAgICAgICAgICBwaXRjaCA9IE1hdGguYXRhbjIoIC1yMTIsIHIyMik7XG4gICAgICAgICAgICByb2xsID0gTWF0aC5hdGFuMiggLXIwMSwgcjAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpdGNoID0gTWF0aC5hdGFuMihyMjEsIHIxMSk7XG4gICAgICAgIH0gICAgICAgXG4gICAgfSBicmVhaztcbiAgICBjYXNlIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLllhd1BpdGNoUm9sbDoge1xuICAgICAgICBwaXRjaCA9IE1hdGguYXNpbiggSGlGaVV0aWxpdGllcy5jbGFtcE5vcm1hbGl6ZWQoLXIxMikgKTtcbiAgICAgICAgaWYgKCBNYXRoLmFicyggcjEyICkgPCBPTkVfTUlOVVNfRVBTSUxPTiApIHtcbiAgICAgICAgICAgIHlhdyA9IE1hdGguYXRhbjIocjAyLCByMjIpO1xuICAgICAgICAgICAgcm9sbCA9IE1hdGguYXRhbjIocjEwLCByMTEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWF3ID0gTWF0aC5hdGFuMigtcjIwLCByMDApO1xuICAgICAgICB9IFxuICAgIH0gYnJlYWs7XG4gICAgY2FzZSBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5Sb2xsUGl0Y2hZYXc6IHtcbiAgICAgICAgcGl0Y2ggPSBNYXRoLmFzaW4oIEhpRmlVdGlsaXRpZXMuY2xhbXBOb3JtYWxpemVkKHIyMSkgKTtcbiAgICAgICAgaWYgKCBNYXRoLmFicyggcjIxICkgPCBPTkVfTUlOVVNfRVBTSUxPTiApIHtcbiAgICAgICAgICAgIHlhdyA9IE1hdGguYXRhbjIoLXIyMCwgcjIyKTtcbiAgICAgICAgICAgIHJvbGwgPSBNYXRoLmF0YW4yKC1yMDEsIHIxMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb2xsID0gTWF0aC5hdGFuMihyMTAsIHIwMCk7XG4gICAgICAgIH1cbiAgICB9IGJyZWFrO1xuICAgIGNhc2UgT3JpZW50YXRpb25FdWxlcjNET3JkZXIuUm9sbFlhd1BpdGNoOiB7XG4gICAgICAgIHlhdyA9IE1hdGguYXNpbiggSGlGaVV0aWxpdGllcy5jbGFtcE5vcm1hbGl6ZWQoLXIyMCkgKTtcbiAgICAgICAgaWYgKCBNYXRoLmFicyggcjIwICkgPCBPTkVfTUlOVVNfRVBTSUxPTiApIHtcbiAgICAgICAgICAgIHBpdGNoID0gTWF0aC5hdGFuMiggcjIxLCByMjIpO1xuICAgICAgICAgICAgcm9sbCA9IE1hdGguYXRhbjIoIHIxMCwgcjAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvbGwgPSBNYXRoLmF0YW4yKCAtcjAxLCByMTEpO1xuICAgICAgICB9ICBcbiAgICB9IGJyZWFrO1xuICAgIGNhc2UgT3JpZW50YXRpb25FdWxlcjNET3JkZXIuWWF3Um9sbFBpdGNoOiB7XG4gICAgICAgIHJvbGwgPSBNYXRoLmFzaW4oIEhpRmlVdGlsaXRpZXMuY2xhbXBOb3JtYWxpemVkKHIxMCkgKTtcbiAgICAgICAgaWYgKCBNYXRoLmFicyggcjEwICkgPCBPTkVfTUlOVVNfRVBTSUxPTiApIHtcbiAgICAgICAgICAgIHBpdGNoID0gTWF0aC5hdGFuMiggLXIxMiwgcjExKTtcbiAgICAgICAgICAgIHlhdyA9IE1hdGguYXRhbjIoIC1yMjAsIHIwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5YXcgPSBNYXRoLmF0YW4yKCByMDIsIHIyMik7XG4gICAgICAgIH1cbiAgICB9IGJyZWFrO1xuICAgIGNhc2UgT3JpZW50YXRpb25FdWxlcjNET3JkZXIuUGl0Y2hSb2xsWWF3OiB7XG4gICAgICAgIHJvbGwgPSBNYXRoLmFzaW4oIEhpRmlVdGlsaXRpZXMuY2xhbXBOb3JtYWxpemVkKC1yMDEpICk7XG4gICAgICAgIGlmICggTWF0aC5hYnMoIHIwMSApIDwgT05FX01JTlVTX0VQU0lMT04gKSB7XG4gICAgICAgICAgICBwaXRjaCA9IE1hdGguYXRhbjIoIHIyMSwgcjExKTtcbiAgICAgICAgICAgIHlhdyA9IE1hdGguYXRhbjIoIHIwMiwgcjAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlhdyA9IE1hdGguYXRhbjIoIC1yMTIsIHIyMik7XG4gICAgICAgIH1cbiAgICB9IGJyZWFrO1xuICAgIH0gICAgXG4gICAgY29uc3QgUkFEX1RPX0RFRyA9IDE4MC4wIC8gTWF0aC5QSTtcbiAgICByZXR1cm4gbmV3IE9yaWVudGF0aW9uRXVsZXIzRCh7IHBpdGNoRGVncmVlczogUkFEX1RPX0RFRyAqIHBpdGNoLCB5YXdEZWdyZWVzOiBSQURfVE9fREVHICogeWF3LCByb2xsRGVncmVlczogUkFEX1RPX0RFRyAqIHJvbGwgfSk7XG59XG5cbi8qKlxuICogSW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcyBkZWZpbmUgYSBtYXAgYmV0d2VlbiBoYXNoZWQgdmlzaXQgSURzIGFuZCB0aGUgZ2FpbnMgb2Ygb3RoZXIgdXNlcnMuXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGluIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLnNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb259IHRvIGNoYW5nZSB0aGUgZ2FpbnMgb2Ygb3RoZXIgdXNlcnMgYXMgcGVyY2VpdmVkIGJ5IHRoZSBjdXJyZW50IGNvbm5lY3Rpb24sIHByb3ZpZGluZyBhIG1vcmUgY29tZm9ydGFibGUgbGlzdGVuaW5nIGV4cGVyaWVuY2UgZm9yIHRoZSBjbGllbnQuIElmIHlvdSBuZWVkIHRvIHBlcmZvcm0gbW9kZXJhdGlvbiBhY3Rpb25zIG9uIHRoZSBzZXJ2ZXIgc2lkZSwgdXNlIHRoZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmhpZ2hmaWRlbGl0eS5jb20vcmVzdC9sYXRlc3QvaW5kZXguaHRtbHxBZG1pbmlzdHJhdGl2ZSBSRVNUIEFQSX0uXG4gKlxuICogSW50ZXJuYWxseSwgdGhpcyBjbGFzcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb3RoZXIgdXNlciBnYWluIGNoYW5nZXMgbmVlZCB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCB0eXBlIE90aGVyVXNlckdhaW5NYXAgPSB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9O1xuXG4vKipcbiAqIEluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MgY29udGFpbiBhbGwgb2YgdGhlIGRhdGEgdGhhdCBpcyBwb3NzaWJsZSB0byAqKnNlbmQgdG8gQU5EIHJlY2VpdmUgZnJvbSoqIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBTZXJ2ZXIuXG4gKiBBbGwgbWVtYmVyIGRhdGEgaW5zaWRlIHRoaXMgYGNsYXNzYCBjYW4gYmUgc2VudCB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgU2VydmVyLiBTZWUgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAqIFxuICogU2VlIHtAbGluayBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGF9IGZvciBkYXRhIHRoYXQgY2FuJ3QgYmUgc2VudCB0byB0aGUgU2VydmVyLCBidXQgcmF0aGVyIGNhbiBvbmx5IGJlIHJlY2VpdmVkIGZyb20gdGhlIFNlcnZlciAoaS5lLiBgdm9sdW1lRGVjaWJlbHNgKS5cbiAqIFxuICogTWVtYmVyIGRhdGEgb2YgdGhpcyBjbGFzcyB0aGF0IGlzIHNlbnQgdG8gdGhlIFNlcnZlciB3aWxsIGFmZmVjdCB0aGUgZmluYWwgbWl4ZWQgc3BhdGlhbCBhdWRpbyBmb3IgYWxsIGxpc3RlbmVycyBpbiB0aGUgc2VydmVyJ3MgdmlydHVhbCBzcGFjZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEhpRmlBdWRpb0FQSURhdGEge1xuICAgIC8qKlxuICAgICAqIElmIHlvdSBkb24ndCBzdXBwbHkgYSBgcG9zaXRpb25gIHdoZW4gY29uc3RydWN0aW5nIGluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MsIGBwb3NpdGlvbmAgd2lsbCBiZSBgbnVsbGAuXG4gICAgICogXG4gICAgICog4pyUIFRoZSBjbGllbnQgc2VuZHMgYHBvc2l0aW9uYCBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2hlbiBgX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKClgIGlzIGNhbGxlZC5cbiAgICAgKiBcbiAgICAgKiDinJQgVGhlIHNlcnZlciBzZW5kcyBgcG9zaXRpb25gIGRhdGEgdG8gYWxsIGNsaWVudHMgY29ubmVjdGVkIHRvIGEgc2VydmVyIGR1cmluZyBcInBlZXIgdXBkYXRlc1wiLlxuICAgICAqL1xuICAgIHBvc2l0aW9uOiBQb2ludDNEO1xuICAgIC8qKlxuICAgICAqIElmIHlvdSBkb24ndCBzdXBwbHkgYW4gYG9yaWVudGF0aW9uUXVhdGAgd2hlbiBjb25zdHJ1Y3RpbmcgaW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcywgYG9yaWVudGF0aW9uUXVhdGAgd2lsbCBiZSBgbnVsbGAuXG4gICAgICogXG4gICAgICog4pyUIFRoZSBjbGllbnQgc2VuZHMgYG9yaWVudGF0aW9uUXVhdGAgZGF0YSB0byB0aGUgc2VydmVyIHdoZW4gYF90cmFuc21pdEhpRmlBdWRpb0FQSURhdGFUb1NlcnZlcigpYCBpcyBjYWxsZWQuXG4gICAgICogXG4gICAgICog4pyUIFRoZSBzZXJ2ZXIgc2VuZHMgYG9yaWVudGF0aW9uUXVhdGAgZGF0YSB0byBhbGwgY2xpZW50cyBjb25uZWN0ZWQgdG8gYSBzZXJ2ZXIgZHVyaW5nIFwicGVlciB1cGRhdGVzXCIuXG4gICAgICovXG4gICAgb3JpZW50YXRpb25RdWF0OiBPcmllbnRhdGlvblF1YXQzRDtcbiAgICAvKipcbiAgICAgKiBGb3IgY29udmVuaWVuY2UsIGEgRXVsZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9yaWVudGF0aW9uIGlzIHN1cHBvcnRlZC5cbiAgICAgKiBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHdheSB0byBzcGVjaWZ5IHRoZSBgb3JpZW50YXRpb25RdWF0YCBmaWVsZCBpbiB0aGUgYEhpRmlBdWRpb0FQSURhdGFgIHRoYXQgaXMgc2VudCB0byBvciByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogXG4gICAgICogIOKclCBXaGVuIHVzaW5nIGV1bGVyIHJlcHJlc2VudGF0aW9uIHRvIHVwZGF0ZSB0aGUgY2xpZW50IG9yaWVudGF0aW9uLCB0aGUgZXF1aXZhbGVudCBRdWF0ZXJuaW9uIGlzIGV2YWx1YXRlZCBpbiBgX3VwZGF0ZVVzZXJEYXRhKClgXG4gICAgICogXG4gICAgICogIOKclCBXaGVuIHJlcXVlc3Rpbmcgb3JpZW50YXRpb24gRXVsZXIgZnJvbSBzZXJ2ZXIgdXBkYXRlcywgdGhlIEV1bGVyIHJlcHJlc2VudGF0aW9uIGlzIGV2YWx1YXRlZCBpbiBgX2hhbmRsZVVzZXJEYXRhVXBkYXRlcygpYFxuICAgICAqL1xuICAgIG9yaWVudGF0aW9uRXVsZXI6IE9yaWVudGF0aW9uRXVsZXIzRDtcbiAgICAvKipcbiAgICAgKiBBIHZvbHVtZSBsZXZlbCBiZWxvdyB0aGlzIHZhbHVlIGlzIGNvbnNpZGVyZWQgYmFja2dyb3VuZCBub2lzZSBhbmQgd2lsbCBiZSBzbW9vdGhseSBnYXRlZCBvZmYuXG4gICAgICogVGhlIGZsb2F0aW5nIHBvaW50IHZhbHVlIGlzIHNwZWNpZmllZCBpbiBkQkZTIChkZWNpYmVscyByZWxhdGl2ZSB0byBmdWxsIHNjYWxlKSB3aXRoIHZhbHVlcyBiZXR3ZWVuIC05NiBkQiAoaW5kaWNhdGluZyBubyBnYXRpbmcpXG4gICAgICogYW5kIDAgZEIgKGVmZmVjdGl2ZWx5IG11dGluZyB0aGUgaW5wdXQgZnJvbSB0aGlzIHVzZXIpLiBJdCBpcyBpbiB0aGUgc2FtZSBkZWNpYmVsIHVuaXRzIGFzIHRoZSBWb2x1bWVEZWNpYmVscyBjb21wb25lbnQgb2YgVXNlckRhdGFTdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgdm9sdW1lVGhyZXNob2xkOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBhZmZlY3RzIGhvdyBsb3VkIFVzZXIgQSB3aWxsIHNvdW5kIHRvIFVzZXIgQiBhdCBhIGdpdmVuIGRpc3RhbmNlIGluIDNEIHNwYWNlLlxuICAgICAqIFRoaXMgdmFsdWUgYWxzbyBhZmZlY3RzIHRoZSBkaXN0YW5jZSBhdCB3aGljaCBVc2VyIEEgY2FuIGJlIGhlYXJkIGluIDNEIHNwYWNlLlxuICAgICAqIEhpZ2hlciB2YWx1ZXMgZm9yIFVzZXIgQSBtZWFucyB0aGF0IFVzZXIgQSB3aWxsIHNvdW5kIGxvdWRlciB0byBvdGhlciB1c2VycyBhcm91bmQgVXNlciBBLCBhbmQgaXQgYWxzbyBtZWFucyB0aGF0IFVzZXIgQSB3aWxsIGJlIGF1ZGlibGUgZnJvbSBhIGdyZWF0ZXIgZGlzdGFuY2UuXG4gICAgICogSWYgeW91IGRvbid0IHN1cHBseSBhbiBgaGlGaUdhaW5gIHdoZW4gY29uc3RydWN0aW5nIGluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MsIGBoaUZpR2FpbmAgd2lsbCBiZSBgbnVsbGAuXG4gICAgICogXG4gICAgICog4pyUIFRoZSBjbGllbnQgc2VuZHMgYGhpRmlHYWluYCBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2hlbiBgX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKClgIGlzIGNhbGxlZC5cbiAgICAgKiBcbiAgICAgKiDinYwgVGhlIHNlcnZlciBkb2VzIG5vdCBzZW5kIGBoaUZpR2FpbmAgZGF0YSB0byBhbGwgY2xpZW50cyBhcyBwYXJ0IG9mIFwicGVlciB1cGRhdGVzXCIuXG4gICAgICovXG4gICAgaGlGaUdhaW46IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGlzIHZhbHVlIGFmZmVjdHMgaG93IGZhciBhIHVzZXIncyBzb3VuZCB3aWxsIHRyYXZlbCBpbiAzRCBzcGFjZSwgd2l0aG91dCBhZmZlY3RpbmcgdGhlIHVzZXIncyBsb3VkbmVzcy5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGVyZSBpcyBhIGdsb2JhbCBhdHRlbnVhdGlvbiB2YWx1ZSAoc2V0IGZvciBhIGdpdmVuIHNwYWNlKSB0aGF0IGFwcGxpZXMgdG8gYWxsIHVzZXJzIGluIGEgc3BhY2UuIFRoaXMgZGVmYXVsdCBzcGFjZVxuICAgICAqIGF0dGVudWF0aW9uIGlzIHVzdWFsbHkgMC41LCB3aGljaCByZXByZXNlbnRzIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uIG9mIGEgcmVhbC13b3JsZCBmYWxsLW9mZiBpbiBzb3VuZCBvdmVyIGRpc3RhbmNlLlxuICAgICAqIExvd2VyIG51bWJlcnMgcmVwcmVzZW50IGxlc3MgYXR0ZW51YXRpb24gKGkuZS4gc291bmQgdHJhdmVscyBmYXJ0aGVyKTsgaGlnaGVyIG51bWJlcnMgcmVwcmVzZW50IG1vcmUgYXR0ZW51YXRpb24gKGkuZS4gc291bmQgZHJvcHNcbiAgICAgKiBvZmYgbW9yZSBxdWlja2x5KS5cbiAgICAgKiBcbiAgICAgKiBXaGVuIHNldHRpbmcgdGhpcyB2YWx1ZSBmb3IgYW4gaW5kaXZpZHVhbCB1c2VyLCB0aGUgZm9sbG93aW5nIGhvbGRzOlxuICAgICAqICAgLSBQb3NpdGl2ZSBudW1iZXJzIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGFuZCB0aGV5IHJlcHJlc2VudCBhIGxvZ2FyaXRobWljIGF0dGVudWF0aW9uLiBUaGlzIHJhbmdlIGlzIHJlY29tbWVuZGVkLCBhcyBpdCBpc1xuICAgICAqIG1vcmUgbmF0dXJhbCBzb3VuZGluZy4gIFNtYWxsZXIgbnVtYmVycyByZXByZXNlbnQgbGVzcyBhdHRlbnVhdGlvbiwgc28gYSBudW1iZXIgc3VjaCBhcyAwLjIgY2FuIGJlIHVzZWQgdG8gbWFrZSBhIHBhcnRpY3VsYXIgXG4gICAgICogdXNlcidzIGF1ZGlvIHRyYXZlbCBmYXJ0aGVyIHRoYW4gb3RoZXIgdXNlcnMnLCBmb3IgaW5zdGFuY2UgaW4gXCJhbXBsaWZpZWRcIiBjb25jZXJ0IHR5cGUgc2V0dGluZ3MuIFNpbWlsYXJseSwgYW4gZXh0cmVtZWx5IFxuICAgICAqIHNtYWxsIG5vbi16ZXJvIG51bWJlciAoZS5nLiAwLjAwMDAxKSBjYW4gYmUgdXNlZCB0byBlZmZlY3RpdmVseSB0dXJuIG9mZiBhdHRlbnVhdGlvbiBmb3IgYSBnaXZlbiB1c2VyIHdpdGhpbiBhIHJlYXNvbmFibHkgXG4gICAgICogc2l6ZWQgc3BhY2UsIHJlc3VsdGluZyBpbiBhIFwiYnJvYWRjYXN0IG1vZGVcIiB3aGVyZSB0aGUgdXNlciBjYW4gYmUgaGVhcmQgdGhyb3VnaG91dCBtb3N0IG9mIHRoZSBzcGFjZSByZWdhcmRsZXNzIG9mIHRoZWlyIGxvY2F0aW9uXG4gICAgICogcmVsYXRpdmUgdG8gb3RoZXIgdXNlcnMuIChOb3RlOiBUaGUgYWN0dWFsIHZhbHVlIFwiMFwiIGlzIHVzZWQgaW50ZXJuYWxseSB0byByZXByZXNlbnQgdGhlIGRlZmF1bHQ7IGZvciBzZXR0aW5nIG1pbmltYWwgYXR0ZW51YXRpb24sIFxuICAgICAqIHNtYWxsIG5vbi16ZXJvIG51bWJlcnMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC4gU2VlIGFsc28gXCJ1c2VyUm9sbG9mZlwiIGJlbG93LilcbiAgICAgKiAgIC0gTmVnYXRpdmUgYXR0ZW51YXRpb24gbnVtYmVycyBhcmUgdXNlZCB0byByZXByZXNlbnQgbGluZWFyIGF0dGVudWF0aW9uLCBhbmQgYXJlIGEgc29tZXdoYXQgYXJ0aWZpY2lhbCwgbm9uLXJlYWwtd29ybGQgY29uY2VwdC4gSG93ZXZlcixcbiAgICAgKiB0aGlzIHNldHRpbmcgY2FuIGJlIHVzZWQgYXMgYSBibHVudCB0b29sIHRvIGVhc2lseSB0ZXN0IGF0dGVudWF0aW9uLCBhbmQgdHVuZSBpdCBhZ2dyZXNzaXZlbHkgaW4gZXh0cmVtZSBjaXJjdW1zdGFuY2VzLiBXaGVuIHVzaW5nIGxpbmVhciBcbiAgICAgKiBhdHRlbnVhdGlvbiwgdGhlIHNldHRpbmcgaXMgdGhlIGRpc3RhbmNlIGluIG1ldGVycyBhdCB3aGljaCB0aGUgYXVkaW8gYmVjb21lcyB0b3RhbGx5IGluYXVkaWJsZS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBkb24ndCBzdXBwbHkgYW4gYHVzZXJBdHRlbnVhdGlvbmAgd2hlbiBjb25zdHJ1Y3RpbmcgaW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcywgYHVzZXJBdHRlbnVhdGlvbmAgd2lsbCBiZSBgbnVsbGAgYW5kIHRoZVxuICAgICAqIGRlZmF1bHQgd2lsbCBiZSB1c2VkLlxuICAgICAqIFxuICAgICAqIOKclCBUaGUgY2xpZW50IHNlbmRzIGB1c2VyQXR0ZW51YXRpb25gIGRhdGEgdG8gdGhlIHNlcnZlciB3aGVuIGBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIoKWAgaXMgY2FsbGVkLlxuICAgICAqIFxuICAgICAqIOKdjCBUaGUgc2VydmVyIG5ldmVyIHNlbmRzIGB1c2VyQXR0ZW51YXRpb25gIGRhdGEuXG4gICAgICovXG4gICAgdXNlckF0dGVudWF0aW9uOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHVzZXJSb2xsb2ZmIFRoaXMgdmFsdWUgcmVwcmVzZW50cyB0aGUgcHJvZ3Jlc3NpdmUgaGlnaCBmcmVxdWVuY3kgcm9sbC1vZmYgaW4gbWV0ZXJzLCBhIG1lYXN1cmUgb2YgaG93IHRoZSBoaWdoZXIgZnJlcXVlbmNpZXMgXG4gICAgICogaW4gYSB1c2VyJ3Mgc291bmQgYXJlIGRhbXBlbmVkIGFzIHRoZSB1c2VyIGdldHMgZnVydGhlciBhd2F5LiBCeSBkZWZhdWx0LCB0aGVyZSBpcyBhIGdsb2JhbCByb2xsLW9mZiB2YWx1ZSAoc2V0IGZvciBhIGdpdmVuIHNwYWNlKSwgY3VycmVudGx5IDE2IFxuICAgICAqIG1ldGVycywgd2hpY2ggYXBwbGllcyB0byBhbGwgdXNlcnMgaW4gYSBzcGFjZS4gVGhpcyB2YWx1ZSByZXByZXNlbnRzIHRoZSBkaXN0YW5jZSBmb3IgYSAxa0h6IHJvbGxvZmYuIFZhbHVlcyBpbiB0aGUgcmFuZ2Ugb2YgXG4gICAgICogMTIgdG8gMzIgbWV0ZXJzIHByb3ZpZGUgYSBtb3JlIFwiZW5jbG9zZWRcIiBzb3VuZCwgaW4gd2hpY2ggaGlnaCBmcmVxdWVuY2llcyB0ZW5kIHRvIGJlIGRhbXBlbmVkIG92ZXIgZGlzdGFuY2UgYXMgdGhleSBhcmUgXG4gICAgICogaW4gdGhlIHJlYWwgd29ybGQuIEdlbmVyYWxseSBjaGFuZ2VzIHRvIHJvbGwtb2ZmIHZhbHVlcyBzaG91bGQgYmUgbWFkZSBmb3IgdGhlIGVudGlyZSBzcGFjZSByYXRoZXIgdGhhbiBmb3IgaW5kaXZpZHVhbCB1c2VycywgYnV0XG4gICAgICogZXh0cmVtZWx5IGhpZ2ggdmFsdWVzIChlLmcuIDk5OTk5KSBzaG91bGQgYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIFwiYnJvYWRjYXN0IG1vZGVcIi1zdHlsZSB1c2VyQXR0ZW51YXRpb24gc2V0dGluZ3MgdG8gY2F1c2UgdGhlXG4gICAgICogYnJvYWRjYXN0ZWQgdm9pY2UgdG8gc291bmQgY3Jpc3AgYW5kIFwidXAgY2xvc2VcIiBldmVuIGF0IHZlcnkgbGFyZ2UgZGlzdGFuY2VzLlxuICAgICAqXG4gICAgICogSWYgeW91IGRvbid0IHN1cHBseSBhbiBgdXNlclJvbGxvZmZgIHdoZW4gY29uc3RydWN0aW5nIGluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MsIGB1c2VyUm9sbG9mZmAgd2lsbCBiZSBgbnVsbGAuXG4gICAgICogXG4gICAgICog4pyUIFRoZSBjbGllbnQgc2VuZHMgYHVzZXJSb2xsb2ZmYCBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2hlbiBgX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKClgIGlzIGNhbGxlZC5cbiAgICAgKiBcbiAgICAgKiDinYwgVGhlIHNlcnZlciBuZXZlciBzZW5kcyBgdXNlclJvbGxvZmZgIGRhdGEuXG4gICAgICovXG4gICAgdXNlclJvbGxvZmY6IG51bWJlcjtcblxuICAgIC8qXG4gICAgICogVGhpcyBpcyBhbiBpbnRlcm5hbCBjbGFzcyBhbmQgaXQgaXMgbm90IHJlY29tbWVuZGVkIGZvciBub3JtYWwgdXNhZ2Ugb2YgdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIFNlZSBpbnN0ZWFkIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLnNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb259LCB3aGljaCBhbGxvd3MgeW91IHRvIHNldCB0aGUgZGVzaXJlZCBnYWlucyBmb3Igb25lIG9yIG1vcmUgdXNlcnMgYXMgcGVyY2VpdmVkIGJ5IHRoaXMgY2xpZW50IG9ubHkuIElmIHlvdSBuZWVkIHRvIHBlcmZvcm0gbW9kZXJhdGlvbiBhY3Rpb25zIG9uIHRoZSBzZXJ2ZXIgc2lkZSwgdXNlIHRoZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmhpZ2hmaWRlbGl0eS5jb20vcmVzdC9sYXRlc3QvaW5kZXguaHRtbHxBZG1pbmlzdHJhdGl2ZSBSRVNUIEFQSX0uXG4gICAgICpcbiAgICAgKiBJbnRlcm5hbGx5LCB0aGlzIHZhcmlhYmxlIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBvdGhlciB1c2VyIGdhaW4gY2hhbmdlcyBuZWVkIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci4gVGhlIGtleXMgYXJlIGhhc2hlZCB2aXNpdCBJRHMsIGFuZCB0aGUgdmFsdWVzIGFyZSBnYWlucy5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX290aGVyVXNlckdhaW5RdWV1ZTogT3RoZXJVc2VyR2Fpbk1hcDtcbiAgICBcbiAgICBjb25zdHJ1Y3Rvcih7IHBvc2l0aW9uID0gbnVsbCwgb3JpZW50YXRpb25RdWF0ID0gbnVsbCwgb3JpZW50YXRpb25FdWxlciA9IG51bGwsIHZvbHVtZVRocmVzaG9sZCA9IG51bGwsIGhpRmlHYWluID0gbnVsbCwgdXNlckF0dGVudWF0aW9uID0gbnVsbCwgdXNlclJvbGxvZmYgPSBudWxsIH06IHsgcG9zaXRpb24/OiBQb2ludDNELCBvcmllbnRhdGlvblF1YXQ/OiBPcmllbnRhdGlvblF1YXQzRCwgb3JpZW50YXRpb25FdWxlcj86IE9yaWVudGF0aW9uRXVsZXIzRCwgdm9sdW1lVGhyZXNob2xkPzogbnVtYmVyLCBoaUZpR2Fpbj86IG51bWJlciwgdXNlckF0dGVudWF0aW9uPzogbnVtYmVyLCB1c2VyUm9sbG9mZj86IG51bWJlciB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uUXVhdCA9IG9yaWVudGF0aW9uUXVhdDtcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbkV1bGVyID0gb3JpZW50YXRpb25FdWxlcjtcbiAgICAgICAgdGhpcy52b2x1bWVUaHJlc2hvbGQgPSB2b2x1bWVUaHJlc2hvbGQ7XG4gICAgICAgIHRoaXMuaGlGaUdhaW4gPSBoaUZpR2FpbjtcbiAgICAgICAgdGhpcy51c2VyQXR0ZW51YXRpb24gPSB1c2VyQXR0ZW51YXRpb247XG4gICAgICAgIHRoaXMudXNlclJvbGxvZmYgPSB1c2VyUm9sbG9mZjtcbiAgICAgICAgdGhpcy5fb3RoZXJVc2VyR2FpblF1ZXVlID0ge307XG4gICAgfVxufVxuXG4vKipcbiAqIEluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MgY29udGFpbiBhbGwgb2YgdGhlIGRhdGEgdGhhdCBpcyBwb3NzaWJsZSB0byAqKnJlY2VpdmUgZnJvbSoqIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBTZXJ2ZXIuXG4gKiBTZWUgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAqIFxuICogU2VlIHtAbGluayBIaUZpQXVkaW9BUElEYXRhfSBmb3IgZGF0YSB0aGF0IGNhbiBib3RoIGJlIHNlbnQgdG8gYW5kIHJlY2VpdmVkIGZyb20gdGhlIFNlcnZlciAoaS5lLiBgcG9zaXRpb25gKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSBleHRlbmRzIEhpRmlBdWRpb0FQSURhdGEge1xuICAgIC8qKlxuICAgICAqIFRoaXMgVXNlciBJRCBpcyBhbiBhcmJpdHJhcnkgc3RyaW5nIHByb3ZpZGVkIGJ5IGFuIGFwcGxpY2F0aW9uIGRldmVsb3BlciB3aGljaCBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSB0aGUgdXNlciBhc3NvY2lhdGVkIHdpdGggYSBjbGllbnQuXG4gICAgICogV2UgcmVjb21tZW5kIHRoYXQgdGhpcyBgcHJvdmlkZWRVc2VySURgIGlzIHVuaXF1ZSBhY3Jvc3MgYWxsIHVzZXJzLCBidXQgdGhlIEhpZ2ggRmlkZWxpdHkgQVBJIHdpbGwgbm90IGVuZm9yY2UgdW5pcXVlbmVzcyBhY3Jvc3MgY2xpZW50cyBmb3IgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBwcm92aWRlZFVzZXJJRDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoaXMgc3RyaW5nIGlzIGEgaGFzaGVkIHZlcnNpb24gb2YgdGhlIHJhbmRvbSBVVUlEIHRoYXQgaXMgZ2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICogXG4gICAgICogQSBjb25uZWN0aW5nIGNsaWVudCBzZW5kcyB0aGlzIHZhbHVlIGFzIHRoZSBgc2Vzc2lvbmAga2V5IGluc2lkZSB0aGUgYXJndW1lbnQgdG8gdGhlIGBhdWRpb25ldC5pbml0YCBjb21tYW5kLlxuICAgICAqIFxuICAgICAqIEl0IGlzIHVzZWQgdG8gaWRlbnRpZnkgYSBnaXZlbiBjbGllbnQgYWNyb3NzIGEgY2xvdWQgb2YgbWl4ZXJzIGFuZCBpcyBndWFyYW50ZWVkIChcImd1YXJhbnRlZWRcIiBnaXZlbiB0aGUgY29udGV4dCBvZiByYW5kb20gVVVJRFMpIHRvIGJlIHVuaXF1ZS5cbiAgICAgKiBBcHBsaWNhdGlvbiBkZXZlbG9wZXJzIHNob3VsZCBub3QgbmVlZCB0byBpbnRlcmFjdCB3aXRoIG9yIG1ha2UgdXNlIG9mIHRoaXMgdmFsdWUsIHVubGVzcyB0aGV5IHdhbnQgdG8gdXNlIGl0IGludGVybmFsbHkgZm9yIHRyYWNraW5nIG9yIG90aGVyIHB1cnBvc2VzLlxuICAgICAqIFxuICAgICAqIFRoaXMgdmFsdWUgY2Fubm90IGJlIHNldCBieSB0aGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyLlxuICAgICAqL1xuICAgIGhhc2hlZFZpc2l0SUQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCB2b2x1bWUgb2YgdGhlIHVzZXIgaW4gZGVjaWJlbHMuXG4gICAgICogXG4gICAgICog4p2MIFRoZSBjbGllbnQgbmV2ZXIgc2VuZHMgYHZvbHVtZURlY2liZWxzYCBkYXRhIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogXG4gICAgICog4pyUIFRoZSBzZXJ2ZXIgc2VuZHMgYHZvbHVtZURlY2liZWxzYCBkYXRhIHRvIGFsbCBjbGllbnRzIGNvbm5lY3RlZCB0byBhIHNlcnZlciBkdXJpbmcgXCJwZWVyIHVwZGF0ZXNcIi5cbiAgICAgKi9cbiAgICB2b2x1bWVEZWNpYmVsczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHBlZXIgaXMgcHJvdmlkaW5nIHN0ZXJlbyBhdWRpby5cbiAgICAgKlxuICAgICAqIFRoZSBzZXJ2ZXIgc2VuZHMgYGlzU3RlcmVvYCBkYXRhIHRvIGFsbCBjbGllbnRzIGNvbm5lY3RlZCB0byBhIHNlcnZlciBkdXJpbmcgXCJwZWVyIHVwZGF0ZXNcIi5cbiAgICAgKi9cbiAgICBpc1N0ZXJlbzogYm9vbGVhbjtcbiAgICBcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXM6IHsgcHJvdmlkZWRVc2VySUQ/OiBzdHJpbmcsIGhhc2hlZFZpc2l0SUQ/OiBzdHJpbmcsIHZvbHVtZURlY2liZWxzPzogbnVtYmVyLCBwb3NpdGlvbj86IFBvaW50M0QsIG9yaWVudGF0aW9uUXVhdD86IE9yaWVudGF0aW9uUXVhdDNELCBpc1N0ZXJlbz86IGJvb2xlYW4gfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgICAgIHRoaXMucHJvdmlkZWRVc2VySUQgPSBwYXJhbXMucHJvdmlkZWRVc2VySUQ7XG4gICAgICAgIHRoaXMuaGFzaGVkVmlzaXRJRCA9IHBhcmFtcy5oYXNoZWRWaXNpdElEO1xuICAgICAgICB0aGlzLnZvbHVtZURlY2liZWxzID0gcGFyYW1zLnZvbHVtZURlY2liZWxzO1xuICAgICAgICB0aGlzLmlzU3RlcmVvID0gcGFyYW1zLmlzU3RlcmVvO1xuICAgIH1cbn1cbiIsIi8qKlxuICogVGhpcyBtb2R1bGUgcGVydGFpbnMgdG8gM0QgQXhpcyBjb25maWd1YXRpb24uIE1vZGlmeSB5b3VyIDNEIGF4aXMgY29uZmlndXJhdGlvbiB3aGVuIGNvbnN0cnVjdGluZyBhIG5ldyBbW0hpRmlDb21tdW5pY2F0b3JdXSBvYmplY3QuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG5pbXBvcnQgeyBIaUZpTG9nZ2VyIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9IaUZpTG9nZ2VyXCI7XG5pbXBvcnQgeyBPcmllbnRhdGlvblF1YXQzRCwgUG9pbnQzRCwgT3JpZW50YXRpb25FdWxlcjNET3JkZXIsIE9yaWVudGF0aW9uRXVsZXIzRCB9IGZyb20gXCIuL0hpRmlBdWRpb0FQSURhdGFcIjtcblxuZXhwb3J0IGVudW0gSGlGaUF4ZXMge1xuICAgIFBvc2l0aXZlWCA9IFwiUG9zaXRpdmUgWFwiLFxuICAgIE5lZ2F0aXZlWCA9IFwiTmVnYXRpdmUgWFwiLFxuICAgIFBvc2l0aXZlWSA9IFwiUG9zaXRpdmUgWVwiLFxuICAgIE5lZ2F0aXZlWSA9IFwiTmVnYXRpdmUgWVwiLFxuICAgIFBvc2l0aXZlWiA9IFwiUG9zaXRpdmUgWlwiLFxuICAgIE5lZ2F0aXZlWiA9IFwiTmVnYXRpdmUgWlwiXG59XG5cbmV4cG9ydCBlbnVtIEhpRmlIYW5kZWRuZXNzIHtcbiAgICBSaWdodEhhbmQgPSBcIlJpZ2h0IEhhbmRcIixcbiAgICBMZWZ0SGFuZCA9IFwiTGVmdCBIYW5kXCJcbn1cblxuLyoqXG4gKiBUaGUgYXhpcyBjb25maWd1cmF0aW9uIGRlc2NyaWJlcyB0aGUgM2QgZnJhbWUgb2YgcmVmZXJlbmNlIGluIHdoaWNoIGFyZSBleHByZXNzZWQgdGhlIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiB0aGUgSGlmaUNvbW11bmljYXRvciBwZWVycy5cbiAqIEFsbCBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gc2VuZCBvciByZWNlaXZlZCBmcm9tIHRoZSBhcGkgY2FsbHMgYXJlIGV4cGVjdGVkIHRvIGJlIGV4cHJlc3NlZCB1c2luZyB0aGF0IHNwYWNlIGNvbnZlbnRpb24uXG4gKiBPbiB0aGUgd2lyZSBhbmQgaW4gdGhlIG1peGVyLCB0aGUgSGlGaSBTcGF0aWFsIEF1ZGlvIHN5c3RlbSBpcyB1c2luZyBhIHNpbmdsZSB1bmlmaWVkIGNvbnZlbnRpb24gY2FsbGVkICdNaXhlclNwYWNlJyB3aGljaCBpcyB0aGUgc2FtZSBhcyB0aGUgXG4gKiBkZWZhdWx0IHZhbHVlLCBzZWUge0BsaW5rIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbn0uXG4gKiBcbiAqIFdoZW4gY29udmVydGluZyB0aGUgb3JpZW50YXRpb25FdWxlciwgdG8gb3IgZnJvbSB0aGUgcXVhdGVybmlvbiByZXByZXNlbnRhdGlvbiwgdGhlIExpYnJhcnkgcmVsaWVzIG9uIHRoZSBIaUZpQ29tbXVuaWNhdG9yJ3MgYXhpc0NvbmZpZ3VyYXRpb25cbiAqIHRvIGFwcGx5IHRoZSBleHBlY3RlZCBjb252ZW50aW9uIGFuZCBjb3JyZWN0IGNvbnZlcnNpb24uXG4gKiBUaGUgJ2V1bGVyT3JkZXInIGZpZWxkIG9mIHRoZSBheGlzIGNvbmZpZ3VyYXRpb24gaXMgdXNlZCBmb3IgdGhpcyBjb252ZXJzaW9uLlxuICogXG4gKiDimqAgV0FSTklORyDimqAgXG4gKiBUaGUgYXhpcyBjb25maWd1cmF0aW9uIGZpZWxkcyAocmlnaHRBeGlzLCBsZWZ0QXhpcywgaW50b1NjcmVlbkF4aXMsIG91dE9mU2NyZWVuQXhpcywgdXBBeGlzLCBkb3duQXhpcywgaGFuZGVkbmVzcykgYXJlIG5vdCBpbiB1c2UgeWV0XG4gKiBPbmx5IHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzIGZpZWxkcyB3aWxsIHJlc3VsdCBpbiB0aGUgZXhwZWN0ZWQgYmVoYXZpb3IuXG4gKiBUaGUgZXVsZXJPcmRlciBmaWVsZCBpcyB3b3JraW5nIGNvcnJlY2x0eSBhbmQgY2FuIGJlIGNvbmZpZ3VyZWQgYXQgdGhlIGNyZWF0aW9uIG9mIHRoZSBIaUZpQ29tbXVuaWNhdG9yXG4gKi9cbmV4cG9ydCBjbGFzcyBIaUZpQXhpc0NvbmZpZ3VyYXRpb24ge1xuICAgIHJpZ2h0QXhpczogSGlGaUF4ZXM7XG4gICAgbGVmdEF4aXM6IEhpRmlBeGVzO1xuXG4gICAgaW50b1NjcmVlbkF4aXM6IEhpRmlBeGVzO1xuICAgIG91dE9mU2NyZWVuQXhpczogSGlGaUF4ZXM7XG5cbiAgICB1cEF4aXM6IEhpRmlBeGVzO1xuICAgIGRvd25BeGlzOiBIaUZpQXhlcztcblxuICAgIGhhbmRlZG5lc3M6IEhpRmlIYW5kZWRuZXNzO1xuXG4gICAgZXVsZXJPcmRlcjogT3JpZW50YXRpb25FdWxlcjNET3JkZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcih7cmlnaHRBeGlzLCBsZWZ0QXhpcywgaW50b1NjcmVlbkF4aXMsIG91dE9mU2NyZWVuQXhpcywgdXBBeGlzLCBkb3duQXhpcywgaGFuZGVkbmVzcywgZXVsZXJPcmRlcn06IHtyaWdodEF4aXM6IEhpRmlBeGVzLCBsZWZ0QXhpczogSGlGaUF4ZXMsIGludG9TY3JlZW5BeGlzOiBIaUZpQXhlcywgb3V0T2ZTY3JlZW5BeGlzOiBIaUZpQXhlcywgdXBBeGlzOiBIaUZpQXhlcywgZG93bkF4aXM6IEhpRmlBeGVzLCBoYW5kZWRuZXNzOiBIaUZpSGFuZGVkbmVzcywgZXVsZXJPcmRlcjogT3JpZW50YXRpb25FdWxlcjNET3JkZXIgfSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgcmlnaHRBeGlzLCBsZWZ0QXhpcywgaW50b1NjcmVlbkF4aXMsIG91dE9mU2NyZWVuQXhpcywgdXBBeGlzLCBkb3duQXhpcywgaGFuZGVkbmVzcywgZXVsZXJPcmRlciB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29udGFpbnMgdGhlIGFwcGxpY2F0aW9uJ3MgM0QgYXhpcyBjb25maWd1cmF0aW9uLiBCeSBkZWZhdWx0OlxuICogLSBgK3hgIGlzIHRvIHRoZSByaWdodCBhbmQgYC14YCBpcyB0byB0aGUgbGVmdFxuICogLSBgK3lgIGlzIHVwIGFuZCBgLXlgIGlzIGRvd25cbiAqIC0gYCt6YCBpcyBiYWNrIGFuZCBgLXpgIGlzIGZyb250XG4gKiAtIFRoZSBjb29yZGluYXRlIHN5c3RlbSBpcyByaWdodC1oYW5kZWQuXG4gKiAtIEV1bGVyIG9yZGVyIGlzIGBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5ZYXdQaXRjaFJvbGxgXG4gKi9cbmV4cG9ydCBsZXQgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uID0gbmV3IEhpRmlBeGlzQ29uZmlndXJhdGlvbih7XG4gICAgcmlnaHRBeGlzOiBIaUZpQXhlcy5Qb3NpdGl2ZVgsXG4gICAgbGVmdEF4aXM6IEhpRmlBeGVzLk5lZ2F0aXZlWCxcbiAgICBpbnRvU2NyZWVuQXhpczogSGlGaUF4ZXMuUG9zaXRpdmVZLFxuICAgIG91dE9mU2NyZWVuQXhpczogSGlGaUF4ZXMuTmVnYXRpdmVZLFxuICAgIHVwQXhpczogSGlGaUF4ZXMuUG9zaXRpdmVaLFxuICAgIGRvd25BeGlzOiBIaUZpQXhlcy5OZWdhdGl2ZVosXG4gICAgaGFuZGVkbmVzczogSGlGaUhhbmRlZG5lc3MuUmlnaHRIYW5kLFxuICAgIGV1bGVyT3JkZXI6IE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLllhd1BpdGNoUm9sbCxcbn0pO1xuXG5leHBvcnQgY2xhc3MgSGlGaUF4aXNVdGlsaXRpZXMge1xuICAgIHN0YXRpYyB2ZXJpZnkoYXhpc0NvbmZpZ3VyYXRpb246IEhpRmlBeGlzQ29uZmlndXJhdGlvbikge1xuICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG5cbiAgICAgICAgLy8gU1RBUlQgbGVmdC9yaWdodCBheGlzIGVycm9yIGNoZWNraW5nXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVYKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5SaWdodCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzfSwgYW5kIExlZnQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWCkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuUmlnaHQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpc30sIGFuZCBMZWZ0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWSkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuUmlnaHQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpc30sIGFuZCBMZWZ0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVkpIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblJpZ2h0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXN9LCBhbmQgTGVmdCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVopIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblJpZ2h0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXN9LCBhbmQgTGVmdCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGF4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVaKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5SaWdodCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzfSwgYW5kIExlZnQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFTkQgbGVmdC9yaWdodCBheGlzIGVycm9yIGNoZWNraW5nXG5cbiAgICAgICAgLy8gU1RBUlQgaW50by1zY3JlZW4vb3V0LW9mLXNjcmVlbiBheGlzIGVycm9yIGNoZWNraW5nXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVYKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5JbnRvU2NyZWVuIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpc30sIGFuZCBPdXRPZlNjcmVlbiBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVggJiYgYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWCkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuSW50b1NjcmVlbiBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXN9LCBhbmQgT3V0T2ZTY3JlZW4gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWSkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuSW50b1NjcmVlbiBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXN9LCBhbmQgT3V0T2ZTY3JlZW4gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVZICYmIGF4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVkpIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcbkludG9TY3JlZW4gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzfSwgYW5kIE91dE9mU2NyZWVuIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgYXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVopIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcbkludG9TY3JlZW4gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzfSwgYW5kIE91dE9mU2NyZWVuIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVaKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5JbnRvU2NyZWVuIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpc30sIGFuZCBPdXRPZlNjcmVlbiBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFTkQgaW50by1zY3JlZW4vb3V0LW9mLXNjcmVlbiBheGlzIGVycm9yIGNoZWNraW5nXG5cbiAgICAgICAgLy8gU1RBUlQgdXAvZG93biBheGlzIGVycm9yIGNoZWNraW5nXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi51cEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVYKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5VcCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzfSwgYW5kIERvd24gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBheGlzQ29uZmlndXJhdGlvbi51cEF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWCkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuVXAgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnVwQXhpc30sIGFuZCBEb3duIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWSkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuVXAgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnVwQXhpc30sIGFuZCBEb3duIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVkpIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblVwIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi51cEF4aXN9LCBhbmQgRG93biBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLnVwQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGF4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVopIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblVwIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi51cEF4aXN9LCBhbmQgRG93biBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGF4aXNDb25maWd1cmF0aW9uLnVwQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVaKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5VcCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzfSwgYW5kIERvd24gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFTkQgdXAvZG93biBheGlzIGVycm9yIGNoZWNraW5nXG5cbiAgICAgICAgaWYgKCEoYXhpc0NvbmZpZ3VyYXRpb24uaGFuZGVkbmVzcyA9PT0gSGlGaUhhbmRlZG5lc3MuUmlnaHRIYW5kIHx8IGF4aXNDb25maWd1cmF0aW9uLmhhbmRlZG5lc3MgPT09IEhpRmlIYW5kZWRuZXNzLkxlZnRIYW5kKSkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuSGFuZGVkbmVzcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmhhbmRlZG5lc3N9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIOKaoCBXQVJOSU5HIOKaoCBUaGUgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIElTIHdyb25nLlxuICAgICAqIFRPRE86IGltcGxlbWVudCB0aGUgZnVuY3Rpb24sIGp1c3QgYSBOTyBPUCBhdCB0aGUgbW9tZW50LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBheGlzQ29uZmlndXJhdGlvbiBcbiAgICAgKiBAcGFyYW0gaW5wdXRQb2ludDNEIFxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2xhdGVQb2ludDNEVG9NaXhlclNwYWNlKGF4aXNDb25maWd1cmF0aW9uOiBIaUZpQXhpc0NvbmZpZ3VyYXRpb24sIGlucHV0UG9pbnQzRDogUG9pbnQzRCk6IFBvaW50M0Qge1xuICAgICAgICBsZXQgcmV0dmFsID0gbmV3IFBvaW50M0QoKTtcbiAgICAgICAgLypcbiAgICAgICAgbGV0IGlucHV0WElzTnVtYmVyID0gdHlwZW9mIChpbnB1dFBvaW50M0QueCkgPT09IFwibnVtYmVyXCI7XG4gICAgICAgIGxldCBpbnB1dFlJc051bWJlciA9IHR5cGVvZiAoaW5wdXRQb2ludDNELnkpID09PSBcIm51bWJlclwiO1xuICAgICAgICBsZXQgaW5wdXRaSXNOdW1iZXIgPSB0eXBlb2YgKGlucHV0UG9pbnQzRC56KSA9PT0gXCJudW1iZXJcIjtcblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVggJiYgaW5wdXRYSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHZhbC54ID0gaW5wdXRQb2ludDNELng7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBpbnB1dFhJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnggPSAtaW5wdXRQb2ludDNELng7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBpbnB1dFlJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnggPSBpbnB1dFBvaW50M0QueTtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBpbnB1dFlJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnggPSAtaW5wdXRQb2ludDNELnk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVggJiYgaW5wdXRaSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHZhbC54ID0gaW5wdXRQb2ludDNELno7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBpbnB1dFpJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnggPSAtaW5wdXRQb2ludDNELno7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgaW5wdXRYSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHZhbC55ID0gaW5wdXRQb2ludDNELng7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBpbnB1dFhJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnkgPSAtaW5wdXRQb2ludDNELng7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBpbnB1dFlJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnkgPSBpbnB1dFBvaW50M0QueTtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBpbnB1dFlJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnkgPSAtaW5wdXRQb2ludDNELnk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgaW5wdXRaSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHZhbC55ID0gaW5wdXRQb2ludDNELno7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBpbnB1dFpJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnkgPSAtaW5wdXRQb2ludDNELno7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgaW5wdXRYSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHZhbC56ID0gaW5wdXRQb2ludDNELng7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBpbnB1dFhJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnogPSAtaW5wdXRQb2ludDNELng7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBpbnB1dFlJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnogPSBpbnB1dFBvaW50M0QueTtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBpbnB1dFlJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnogPSAtaW5wdXRQb2ludDNELnk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgaW5wdXRaSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHZhbC56ID0gaW5wdXRQb2ludDNELno7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBpbnB1dFpJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnogPSAtaW5wdXRQb2ludDNELno7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dmFsID0gaW5wdXRQb2ludDNEO1xuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOKaoCBXQVJOSU5HIOKaoCBUaGUgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIElTIHdyb25nLlxuICAgICAqIFRPRE86IGltcGxlbWVudCB0aGUgZnVuY3Rpb24sIGp1c3QgYSBOTyBPUCBhdCB0aGUgbW9tZW50LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBheGlzQ29uZmlndXJhdGlvbiBcbiAgICAgKiBAcGFyYW0gaW5wdXRPcmllbnRhdGlvblF1YXQzRCBcbiAgICAgKi9cbiAgICBzdGF0aWMgdHJhbnNsYXRlUG9pbnQzREZyb21NaXhlclNwYWNlKGF4aXNDb25maWd1cmF0aW9uOiBIaUZpQXhpc0NvbmZpZ3VyYXRpb24sIG1peGVyUG9pbnQzRDogUG9pbnQzRCk6IFBvaW50M0Qge1xuICAgICAgICBsZXQgcmV0dmFsID0gbmV3IFBvaW50M0QoKTtcbiAgICAgICAgcmV0dmFsID0gbWl4ZXJQb2ludDNEO1xuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOKaoCBXQVJOSU5HIOKaoCBUaGUgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIElTIHdyb25nLlxuICAgICAqIFRPRE86IGltcGxlbWVudCB0aGUgZnVuY3Rpb24sIGp1c3QgYSBOTyBPUCBhdCB0aGUgbW9tZW50LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBheGlzQ29uZmlndXJhdGlvbiBcbiAgICAgKiBAcGFyYW0gaW5wdXRPcmllbnRhdGlvblF1YXQzRCBcbiAgICAgKi9cbiAgICBzdGF0aWMgdHJhbnNsYXRlT3JpZW50YXRpb25RdWF0M0RUb01peGVyU3BhY2UoYXhpc0NvbmZpZ3VyYXRpb246IEhpRmlBeGlzQ29uZmlndXJhdGlvbiwgaW5wdXRPcmllbnRhdGlvblF1YXQzRDogT3JpZW50YXRpb25RdWF0M0QpOiBPcmllbnRhdGlvblF1YXQzRCB7XG4gICAgICAgIGxldCByZXR2YWwgPSBuZXcgT3JpZW50YXRpb25RdWF0M0QoKTtcbiAgICAgICAgcmV0dmFsID0gaW5wdXRPcmllbnRhdGlvblF1YXQzRDtcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDimqAgV0FSTklORyDimqAgVGhlIGNvZGUgaW4gdGhpcyBmdW5jdGlvbiBJUyB3cm9uZy5cbiAgICAgKiBUT0RPOiBpbXBsZW1lbnQgdGhlIGZ1bmN0aW9uLCBqdXN0IGEgTk8gT1AgYXQgdGhlIG1vbWVudC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gYXhpc0NvbmZpZ3VyYXRpb24gXG4gICAgICogQHBhcmFtIGlucHV0T3JpZW50YXRpb25RdWF0M0QgXG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zbGF0ZU9yaWVudGF0aW9uUXVhdDNERnJvbU1peGVyU3BhY2UoYXhpc0NvbmZpZ3VyYXRpb246IEhpRmlBeGlzQ29uZmlndXJhdGlvbiwgbWl4ZXJPcmllbnRhdGlvblF1YXQzRDogT3JpZW50YXRpb25RdWF0M0QpOiBPcmllbnRhdGlvblF1YXQzRCB7XG4gICAgICAgIGxldCByZXR2YWwgPSBuZXcgT3JpZW50YXRpb25RdWF0M0QoKTtcbiAgICAgICAgcmV0dmFsID0gbWl4ZXJPcmllbnRhdGlvblF1YXQzRDtcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9XG59XG4iLCIvKipcbiAqIE1ldGhvZHMgb24gdGhlIFtbSGlGaUNvbW11bmljYXRvcl1dIGNsYXNzIGFsbG93IGRldmVsb3BlcnMgdG8gcGVyZm9ybSBhY3Rpb25zIHN1Y2ggYXM6XG4gKiAtIGBjb25uZWN0VG9IaUZpQXVkaW9BUElTZXJ2ZXIoKWA6IENvbm5lY3QgdG8gYW5kIGRpc2Nvbm5lY3QgZnJvbSB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBTZXJ2ZXJcbiAqIC0gYHVwZGF0ZVVzZXJEYXRhQW5kVHJhbnNtaXQoKWA6IFVwZGF0ZSB0aGUgdXNlcidzIGRhdGEgKHBvc2l0aW9uLCBvcmllbnRhdGlvbiwgZXRjKSBvbiB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBTZXJ2ZXJcbiAqIC0gYHNldElucHV0QXVkaW9NZWRpYVN0cmVhbSgpYDogU2V0IGEgbmV3IGlucHV0IGF1ZGlvIG1lZGlhIHN0cmVhbSAoZm9yIGV4YW1wbGUsIHdoZW4gdGhlIHVzZXIncyBhdWRpbyBpbnB1dCBkZXZpY2UgY2hhbmdlcylcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5cbmRlY2xhcmUgdmFyIEhJRklfQVBJX1ZFUlNJT046IHN0cmluZztcblxuaW1wb3J0IHsgSGlGaUNvbnN0YW50cyB9IGZyb20gXCIuLi9jb25zdGFudHMvSGlGaUNvbnN0YW50c1wiO1xuaW1wb3J0IHsgV2ViUlRDU2Vzc2lvblBhcmFtcywgQ3VzdG9tU1RVTmFuZFRVUk5Db25maWcgfSBmcm9tIFwiLi4vbGlicmF2aS9SYXZpU2Vzc2lvblwiO1xuaW1wb3J0IHsgSGlGaUxvZ2dlciB9IGZyb20gXCIuLi91dGlsaXRpZXMvSGlGaUxvZ2dlclwiO1xuaW1wb3J0IHsgSGlGaVV0aWxpdGllcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvSGlGaVV0aWxpdGllc1wiO1xuaW1wb3J0IHsgSGlGaUF1ZGlvQVBJRGF0YSwgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhLCBQb2ludDNELCBPcmllbnRhdGlvblF1YXQzRCwgT3JpZW50YXRpb25FdWxlcjNELCBPcmllbnRhdGlvbkV1bGVyM0RPcmRlciwgZXVsZXJUb1F1YXRlcm5pb24sIGV1bGVyRnJvbVF1YXRlcm5pb24sIE90aGVyVXNlckdhaW5NYXAgfSBmcm9tIFwiLi9IaUZpQXVkaW9BUElEYXRhXCI7XG5pbXBvcnQgeyBIaUZpQXhpc0NvbmZpZ3VyYXRpb24sIEhpRmlBeGlzVXRpbGl0aWVzLCBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi9IaUZpQXhpc0NvbmZpZ3VyYXRpb25cIjtcbmltcG9ydCB7IEhpRmlNaXhlclNlc3Npb24sIFNldE90aGVyVXNlckdhaW5Gb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlLCBTZXRPdGhlclVzZXJHYWluc0ZvclRoaXNDb25uZWN0aW9uUmVzcG9uc2UsIE9uTXV0ZUNoYW5nZWRDYWxsYmFjayB9IGZyb20gXCIuL0hpRmlNaXhlclNlc3Npb25cIjtcbmltcG9ydCB7IEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cywgVXNlckRhdGFTdWJzY3JpcHRpb24gfSBmcm9tIFwiLi9IaUZpVXNlckRhdGFTdWJzY3JpcHRpb25cIjtcblxuLyoqXG4gKiBXaGVuIHRoZSBzdGF0ZSBvZiB0aGUgY29ubmVjdGlvbiB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBTZXJ2ZXIgY2hhbmdlcywgdGhlIG5ldyBzdGF0ZSB3aWxsIGJlIG9uZSBvZiB0aGVzZSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBlbnVtIEhpRmlDb25uZWN0aW9uU3RhdGVzIHtcbiAgICBDb25uZWN0ZWQgPSBcIkNvbm5lY3RlZFwiLFxuICAgIERpc2Nvbm5lY3RlZCA9IFwiRGlzY29ubmVjdGVkXCIsXG4gICAgRmFpbGVkID0gXCJGYWlsZWRcIixcbiAgICAvKipcbiAgICAgKiBUaGUgYEhpRmlDb25uZWN0aW9uU3RhdGVgIHdpbGwgYmUgYFwiVW5hdmFpbGFibGVcImAgd2hlbiB0aGUgQVBJIFNlcnZlciBpcyBhdCBjYXBhY2l0eS5cbiAgICAgKi9cbiAgICBVbmF2YWlsYWJsZSA9IFwiVW5hdmFpbGFibGVcIlxufTtcblxuLyoqXG4gKiBcbiAqL1xuZXhwb3J0IGVudW0gSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzIHtcbiAgICAvKipcbiAgICAgKiBQYXNzaW5nIHRoaXMgdmFsdWUgdG8gdGhlIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yfSBjb25zdHJ1Y3RvciBtZWFucyB0aGF0IHRoZSBTZXJ2ZXIgd2lsbCBub3Qgc2VuZCBhbnlcbiAgICAgKiBVc2VyIERhdGEgdXBkYXRlcyB0byB0aGUgY2xpZW50LCBtZWFuaW5nIFVzZXIgRGF0YSBTdWJzY3JpcHRpb25zIHdpbGwgbm90IGZ1bmN0aW9uLiBUaGlzIFN0cmVhbWluZyBTY29wZVxuICAgICAqIHNhdmVzIGJhbmR3aWR0aCBhbmQsIG1hcmdpbmFsbHksIHByb2Nlc3NpbmcgdGltZS5cbiAgICAgKi9cbiAgICBOb25lID0gXCJub25lXCIsXG4gICAgLyoqXG4gICAgICogUGFzc2luZyB0aGlzIHZhbHVlIHRvIHRoZSB7QGxpbmsgSGlGaUNvbW11bmljYXRvcn0gY29uc3RydWN0b3IgbWVhbnMgdGhhdCB0aGUgU2VydmVyIHdpbGwgb25seSBzZW5kXG4gICAgICogX3BlZXIgZGF0YV8gdG8gdGhlIENsaWVudDsgdGhlIFNlcnZlciB3aWxsIG5vdCBzZW5kIFVzZXIgRGF0YSBwZXJ0YWluaW5nIHRvIHRoZSBjb25uZWN0aW5nIENsaWVudCB3aGVuXG4gICAgICogdGhpcyBEYXRhIFN0cmVhbWluZyBTY29wZSBpcyBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBQZWVycyA9IFwicGVlcnNcIixcbiAgICAvKipcbiAgICAgKiBcImFsbFwiIGlzIHRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gdGhlIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yfSBjb25zdHJ1Y3RvciBpcyBjYWxsZWQuIEFsbCBVc2VyIERhdGFcbiAgICAgKiB3aWxsIGJlIHN0cmVhbWVkIGZyb20gdGhlIFNlcnZlciB0byB0aGUgQ2xpZW50LlxuICAgICAqL1xuICAgIEFsbCA9IFwiYWxsXCJcbn07XG5cbi8qKlxuICogVGhpcyBjbGFzcyBleHBvc2VzIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdXNlZnVsIGZvciBjb21tdW5pY2F0aW5nIGZyb20gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIENsaWVudCB0b1xuICogdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIFNlcnZlci4gXG4gKi9cbmV4cG9ydCBjbGFzcyBIaUZpQ29tbXVuaWNhdG9yIHtcbiAgICAvLyBQcmV2ZW50cyB1c2VycyBvZiBvdXIgY2xpZW50LXNpZGUgQVBJIGZyb20gc2xhbW1pbmcgdGhlaXIgbWl4ZXIgd2l0aCByZXF1ZXN0cy5cbiAgICAvLyBPZiBjb3Vyc2UsIGJlY2F1c2UgdGhpcyByYXRlIGxpbWl0IGlzIGNsaWVudHNpZGUsIGl0IGNvdWxkIGJlIHdvcmtlZCBhcm91bmQuXG4gICAgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVM6IG51bWJlcjtcbiAgICBwcml2YXRlIF90aW1lcnM6IGFueSA9IHtcbiAgICAgICAgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0OiBudWxsLFxuICAgICAgICB3YW50ZWRUb1RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YTogdHJ1ZVxuICAgIH07XG5cbiAgICAvLyBUaGlzIGlzIHVzdWFsbHkgdGhlIGBNZWRpYVN0cmVhbWAgYXNzb2NpYXRlZCB3aXRoIGEgdXNlcidzIGF1ZGlvIGlucHV0IGRldmljZSxcbiAgICAvLyBidXQgaXQgY291bGQgYmUgYW55IGBNZWRpYVN0cmVhbWAuXG4gICAgcHJpdmF0ZSBfaW5wdXRBdWRpb01lZGlhU3RyZWFtOiBNZWRpYVN0cmVhbTtcblxuICAgIC8vIFRoZXNlIG5leHQgdHdvIG1lbWJlciB2YXJpYWJsZXMgYXJlIHVzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCB0byBzZW5kIHRvIHRoZSBtaXhlci5cbiAgICAvLyBUaGUgY2xpZW50IG9ubHkgc2VuZHMgZGF0YSB0aGF0IHRoZSBtaXhlciBkb2Vzbid0IGFscmVhZHkga25vdyBhYm91dC5cbiAgICBwcml2YXRlIF9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YTogSGlGaUF1ZGlvQVBJRGF0YTtcbiAgICBwcml2YXRlIF9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhOiBIaUZpQXVkaW9BUElEYXRhO1xuXG4gICAgLy8gTGlicmFyeSB1c2VycyBjYW4gbWFrZSB1c2Ugb2YgXCJVc2VyIERhdGEgU3Vic2NyaXB0aW9uc1wiIHRvIGNhdXNlIHNvbWV0aGluZyB0byBoYXBwZW5cbiAgICAvLyB3aGVuIHRoZSBzZXJ2ZXIgcmVwb3J0cyB0aGF0IGEgdXNlcidzIGRhdGEgLSBzdWNoIGFzIHBvc2l0aW9uLCBvcmllbnRhdGlvbiwgYW5kIHZvbHVtZSAtIGhhcyBiZWVuIG1vZGlmaWVkLlxuICAgIHByaXZhdGUgX3VzZXJEYXRhU3Vic2NyaXB0aW9uczogQXJyYXk8VXNlckRhdGFTdWJzY3JpcHRpb24+O1xuXG4gICAgLyoqXG4gICAgICogU2VlIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLl9vblVzZXJzRGlzY29ubmVjdGVkfS5cbiAgICAgKi9cbiAgICBvblVzZXJzRGlzY29ubmVjdGVkOiBGdW5jdGlvbjtcblxuICAgIC8vIFRoaXMgY29udGFpbnMgZGF0YSBkZWFsaW5nIHdpdGggdGhlIG1peGVyIHNlc3Npb24sIHN1Y2ggYXMgdGhlIFJBVkkgc2Vzc2lvbiwgV2ViUlRDIGFkZHJlc3MsIGV0Yy5cbiAgICBwcml2YXRlIF9taXhlclNlc3Npb246IEhpRmlNaXhlclNlc3Npb247XG5cbiAgICBwcml2YXRlIF93ZWJSVENTZXNzaW9uUGFyYW1zPzogV2ViUlRDU2Vzc2lvblBhcmFtcztcbiAgICBwcml2YXRlIF9jdXN0b21TVFVOYW5kVFVSTkNvbmZpZz86IEN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBIaUZpQ29tbXVuaWNhdG9yIG9iamVjdC4gT25jZSB5b3UgaGF2ZSBjcmVhdGVkIGEgSGlGaUNvbW11bmljYXRvciwgeW91IGNhbiB1c2UgdGhlXG4gICAgICoge0BsaW5rIHNldElucHV0QXVkaW9NZWRpYVN0cmVhbX0gbWV0aG9kIHRvIGFzc2lnbiBhbiBpbnB1dCBhdWRpbyBzdHJlYW0gdG8gdGhlIGNvbm5lY3Rpb24sIGFuZFxuICAgICAqIG9uY2UgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQsIHVzZSB0aGUge0BsaW5rIGdldE91dHB1dEF1ZGlvTWVkaWFTdHJlYW19IG1ldGhvZCB0b1xuICAgICAqIHJldHJpZXZlIHRoZSBvdXRwdXQgYXVkaW8gZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBfX25hbWVkUGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBpbml0aWFsSGlGaUF1ZGlvQVBJRGF0YSAtIFRoZSBpbml0aWFsIHBvc2l0aW9uLCBvcmllbnRhdGlvbiwgZXRjIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0ZSB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgU2VydmVyIGNoYW5nZXMuIFNlZSB7QGxpbmsgSGlGaUNvbm5lY3Rpb25TdGF0ZXN9LlxuICAgICAqIEBwYXJhbSBvblVzZXJzRGlzY29ubmVjdGVkIC0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSBwZWVyIGRpc2Nvbm5lY3RzIGZyb20gdGhlIFNwYWNlLlxuICAgICAqIEBwYXJhbSB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNUyAtIFVzZXIgRGF0YSB1cGRhdGVzIHdpbGwgbm90IGJlIHNlbnQgdG8gdGhlIHNlcnZlciBhbnkgbW9yZSBmcmVxdWVudGx5IHRoYW4gdGhpcyBudW1iZXIgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBwYXJhbSB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlIC0gQ2Fubm90IGJlIHNldCBsYXRlci4gU2VlIHtAbGluayBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXN9LlxuICAgICAqIEBwYXJhbSBoaUZpQXhpc0NvbmZpZ3VyYXRpb24gLSBDYW5ub3QgYmUgc2V0IGxhdGVyLiBUaGUgM0QgYXhpcyBjb25maWd1cmF0aW9uLiBTZWUge0BsaW5rIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbn0gZm9yIGRlZmF1bHRzLlxuICAgICAqIEBwYXJhbSB3ZWJydGNTZXNzaW9uUGFyYW1zIC0gQ2Fubm90IGJlIHNldCBsYXRlci4gRXh0cmEgcGFyYW1ldGVycyB1c2VkIGZvciBjb25maWd1cmluZyB0aGUgdW5kZXJseWluZyBXZWJSVEMgY29ubmVjdGlvbiB0byB0aGUgQVBJIHNlcnZlcnMuXG4gICAgICogVGhlc2Ugc2V0dGluZ3MgYXJlIG5vdCBmcmVxdWVudGx5IHVzZWQ7IHRoZXkgYXJlIHByaW1hcmlseSBmb3Igc3BlY2lmaWMgaml0dGVyIGJ1ZmZlciBjb25maWd1cmF0aW9ucy5cbiAgICAgKiBAcGFyYW0gY3VzdG9tU1RVTmFuZFRVUk5Db25maWcgLSBDYW5ub3QgYmUgc2V0IGxhdGVyLiBUaGlzIG9iamVjdCBjYW4gYmUgdXNlZCBpZiBzcGVjaWZpYyBTVFVOIGFuZCBUVVJOIHNlcnZlciBpbmZvcm1hdGlvbiBuZWVkcyB0byBiZVxuICAgICAqIHByb3ZpZGVkIGZvciBuZWdvdGlhdGluZyB0aGUgdW5kZXJseWluZyBXZWJSVEMgY29ubmVjdGlvbi4gQnkgZGVmYXVsdCwgSGlnaCBGaWRlbGl0eSdzIFRVUk4gc2VydmVyIHdpbGwgYmUgdXNlZCwgd2hpY2ggc2hvdWxkIHN1ZmZpY2VcbiAgICAgKiBmb3IgbW9zdCBvcGVyYXRpb25zLiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIHRlc3Rpbmcgb3IgZm9yIHVzaW5nIGEgY29tbWVyY2lhbCBUVVJOIHNlcnZlciBwcm92aWRlciBmb3IgZGVhbGluZyB3aXRoIHBhcnRpY3VsYXJseSBjaGFsbGVuZ2luZyBjbGllbnQgbmV0d29ya3MvZmlyZXdhbGxzLlxuICAgICAqIFNlZSB7QGxpbmsgQ3VzdG9tU1RVTmFuZFRVUk5Db25maWd9IGZvciB0aGUgZm9ybWF0IG9mIHRoaXMgb2JqZWN0IChub3RlIHRoYXQgX2FsbF8gdmFsdWVzIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBzZXR0aW5nIHRoaXMpLlxuICAgICAqIEBwYXJhbSBvbk11dGVDaGFuZ2VkIC0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIG11dGUgc3RhdGUgb2YgdGhlIGNsaWVudCBoYXMgY2hhbmdlZCwgZm9yIGV4YW1wbGUgd2hlbiBtdXRlZCBieSBhbiBhZG1pbi4gU2VlIHtAbGluayBPbk11dGVDaGFuZ2VkQ2FsbGJhY2t9IGZvciB0aGUgaW5mb3JtYXRpb24gdGhpcyBmdW5jdGlvbiB3aWxsIHJlY2VpdmUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBpbml0aWFsSGlGaUF1ZGlvQVBJRGF0YSA9IG5ldyBIaUZpQXVkaW9BUElEYXRhKCksXG4gICAgICAgIG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCxcbiAgICAgICAgb25Vc2Vyc0Rpc2Nvbm5lY3RlZCxcbiAgICAgICAgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVMgPSBIaUZpQ29uc3RhbnRzLkRFRkFVTFRfVFJBTlNNSVRfUkFURV9MSU1JVF9USU1FT1VUX01TLFxuICAgICAgICB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlID0gSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzLkFsbCxcbiAgICAgICAgaGlGaUF4aXNDb25maWd1cmF0aW9uLFxuICAgICAgICB3ZWJydGNTZXNzaW9uUGFyYW1zLFxuICAgICAgICBjdXN0b21TVFVOYW5kVFVSTkNvbmZpZyxcbiAgICAgICAgb25NdXRlQ2hhbmdlZFxuICAgIH06IHtcbiAgICAgICAgaW5pdGlhbEhpRmlBdWRpb0FQSURhdGE/OiBIaUZpQXVkaW9BUElEYXRhLFxuICAgICAgICBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQ/OiBGdW5jdGlvbixcbiAgICAgICAgb25Vc2Vyc0Rpc2Nvbm5lY3RlZD86IEZ1bmN0aW9uLFxuICAgICAgICB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNUz86IG51bWJlcixcbiAgICAgICAgdXNlckRhdGFTdHJlYW1pbmdTY29wZT86IEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3BlcyxcbiAgICAgICAgaGlGaUF4aXNDb25maWd1cmF0aW9uPzogSGlGaUF4aXNDb25maWd1cmF0aW9uLFxuICAgICAgICB3ZWJydGNTZXNzaW9uUGFyYW1zPzogV2ViUlRDU2Vzc2lvblBhcmFtcyxcbiAgICAgICAgY3VzdG9tU1RVTmFuZFRVUk5Db25maWc/OiBDdXN0b21TVFVOYW5kVFVSTkNvbmZpZyxcbiAgICAgICAgb25NdXRlQ2hhbmdlZD86IE9uTXV0ZUNoYW5nZWRDYWxsYmFjayxcbiAgICB9ID0ge30pIHtcbiAgICAgICAgLy8gSWYgdXNlciBwYXNzZWQgaW4gdGhlaXIgb3duIHN0dW4vdHVybiBjb25maWcsIG1ha2Ugc3VyZSBpdCBtYXRjaGVzIG91ciBpbnRlcmZhY2UgKGlzaCkuXG4gICAgICAgIC8vIChJIGRvIHNvIHdpc2ggdGhhdCBUeXBlU2NyaXB0IGNvdWxkIGp1c3QgZG8gdGhpcyBmb3IgdXMgYmFzZWQgb24gdGhlIGludGVyZmFjZSBkZWZpbml0aW9uLCBidXQgaXQgc2VlbXMgdGhhdCBpdCBjYW4gbm90LilcbiAgICAgICAgaWYgKGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoIWN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLmhhc093blByb3BlcnR5KFwic3R1blVybHNcIikgfHwgIUFycmF5LmlzQXJyYXkoY3VzdG9tU1RVTmFuZFRVUk5Db25maWcuc3R1blVybHMpIHx8IGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLnN0dW5VcmxzLmxlbmd0aCA9PSAwICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgY3VzdG9tU1RVTmFuZFRVUk5Db25maWcuc3R1blVybHNcXGAgbXVzdCBiZSBzcGVjaWZpZWQgYW5kIG11c3QgYmUgYSBsaXN0IGNvbnRhaW5pbmcgYXQgbGVhc3Qgb25lIFNUVU4gc2VydmVyLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXN0b21TVFVOYW5kVFVSTkNvbmZpZy5oYXNPd25Qcm9wZXJ0eShcInR1cm5VcmxzXCIpIHx8ICFBcnJheS5pc0FycmF5KGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLnR1cm5VcmxzKSB8fCBjdXN0b21TVFVOYW5kVFVSTkNvbmZpZy50dXJuVXJscy5sZW5ndGggPT0gMCApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLnR1cm5VcmxzXFxgIG11c3QgYmUgc3BlY2lmaWVkIGFuZCBtdXN0IGJlIGEgbGlzdCBjb250YWluaW5nIGF0IGxlYXN0IG9uZSBUVVJOIHNlcnZlci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3VzdG9tU1RVTmFuZFRVUk5Db25maWcuaGFzT3duUHJvcGVydHkoXCJ0dXJuVXNlcm5hbWVcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLnR1cm5Vc2VybmFtZVxcYCBtdXN0IGJlIHNwZWNpZmllZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3VzdG9tU1RVTmFuZFRVUk5Db25maWcuaGFzT3duUHJvcGVydHkoXCJ0dXJuQ3JlZGVudGlhbFwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgY3VzdG9tU1RVTmFuZFRVUk5Db25maWcudHVybkNyZWRlbnRpYWxcXGAgbXVzdCBiZSBzcGVjaWZpZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VzdG9tU1RVTmFuZFRVUk5Db25maWcgPSBjdXN0b21TVFVOYW5kVFVSTkNvbmZpZztcblxuICAgICAgICAvLyBNYWtlIG1pbmltdW0gMTBtc1xuICAgICAgICBpZiAodHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVMgPCBIaUZpQ29uc3RhbnRzLk1JTl9UUkFOU01JVF9SQVRFX0xJTUlUX1RJTUVPVVRfTVMpIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgXFxgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVNcXGAgbXVzdCBiZSA+PSAke0hpRmlDb25zdGFudHMuTUlOX1RSQU5TTUlUX1JBVEVfTElNSVRfVElNRU9VVF9NU31tcyEgU2V0dGluZyB0byAke0hpRmlDb25zdGFudHMuTUlOX1RSQU5TTUlUX1JBVEVfTElNSVRfVElNRU9VVF9NU31tcy4uLmApO1xuICAgICAgICAgICAgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVMgPSBIaUZpQ29uc3RhbnRzLk1JTl9UUkFOU01JVF9SQVRFX0xJTUlUX1RJTUVPVVRfTVM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNUyA9IHRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dE1TO1xuXG4gICAgICAgIGlmIChvblVzZXJzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uVXNlcnNEaXNjb25uZWN0ZWQgPSBvblVzZXJzRGlzY29ubmVjdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWl4ZXJTZXNzaW9uID0gbmV3IEhpRmlNaXhlclNlc3Npb24oe1xuICAgICAgICAgICAgXCJ1c2VyRGF0YVN0cmVhbWluZ1Njb3BlXCI6IHVzZXJEYXRhU3RyZWFtaW5nU2NvcGUsXG4gICAgICAgICAgICBcIm9uVXNlckRhdGFVcGRhdGVkXCI6IChkYXRhOiBBcnJheTxSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE+KSA9PiB7IHRoaXMuX2hhbmRsZVVzZXJEYXRhVXBkYXRlcyhkYXRhKTsgfSxcbiAgICAgICAgICAgIFwib25Vc2Vyc0Rpc2Nvbm5lY3RlZFwiOiAoZGF0YTogQXJyYXk8UmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhPikgPT4geyB0aGlzLl9vblVzZXJzRGlzY29ubmVjdGVkKGRhdGEpOyB9LFxuICAgICAgICAgICAgXCJvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcIjogb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkLFxuICAgICAgICAgICAgXCJvbk11dGVDaGFuZ2VkXCI6IG9uTXV0ZUNoYW5nZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5faW5wdXRBdWRpb01lZGlhU3RyZWFtID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhID0gbmV3IEhpRmlBdWRpb0FQSURhdGEoKTtcblxuICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhID0gbmV3IEhpRmlBdWRpb0FQSURhdGEoKTtcblxuICAgICAgICB0aGlzLl91c2VyRGF0YVN1YnNjcmlwdGlvbnMgPSBbXTtcblxuICAgICAgICBpZiAod2VicnRjU2Vzc2lvblBhcmFtcyAmJiB3ZWJydGNTZXNzaW9uUGFyYW1zLmF1ZGlvTWluSml0dGVyQnVmZmVyRHVyYXRpb24gJiYgKHdlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NaW5KaXR0ZXJCdWZmZXJEdXJhdGlvbiA8IDAuMCB8fCB3ZWJydGNTZXNzaW9uUGFyYW1zLmF1ZGlvTWluSml0dGVyQnVmZmVyRHVyYXRpb24gPiAxMC4wKSkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBUaGUgdmFsdWUgb2YgXFxgd2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01pbkppdHRlckJ1ZmZlckR1cmF0aW9uXFxgICgke3dlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NaW5KaXR0ZXJCdWZmZXJEdXJhdGlvbn0pIHdpbGwgYmUgY2xhbXBlZCB0byAoMC4wLCAxMC4wKS5gKTtcbiAgICAgICAgICAgIHdlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NaW5KaXR0ZXJCdWZmZXJEdXJhdGlvbiA9IEhpRmlVdGlsaXRpZXMuY2xhbXAod2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01pbkppdHRlckJ1ZmZlckR1cmF0aW9uLCAwLjAsIDEwLjApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWJydGNTZXNzaW9uUGFyYW1zICYmIHdlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NYXhKaXR0ZXJCdWZmZXJEdXJhdGlvbiAmJiAod2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01heEppdHRlckJ1ZmZlckR1cmF0aW9uIDwgMC4wIHx8IHdlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NYXhKaXR0ZXJCdWZmZXJEdXJhdGlvbiA+IDEwLjApKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYFRoZSB2YWx1ZSBvZiBcXGB3ZWJydGNTZXNzaW9uUGFyYW1zLmF1ZGlvTWF4Sml0dGVyQnVmZmVyRHVyYXRpb25cXGAgKCR7d2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01heEppdHRlckJ1ZmZlckR1cmF0aW9ufSkgd2lsbCBiZSBjbGFtcGVkIHRvICgwLjAsIDEwLjApLmApO1xuICAgICAgICAgICAgd2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01heEppdHRlckJ1ZmZlckR1cmF0aW9uID0gSGlGaVV0aWxpdGllcy5jbGFtcCh3ZWJydGNTZXNzaW9uUGFyYW1zLmF1ZGlvTWF4Sml0dGVyQnVmZmVyRHVyYXRpb24sIDAuMCwgMTAuMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2ViUlRDU2Vzc2lvblBhcmFtcyA9IHdlYnJ0Y1Nlc3Npb25QYXJhbXM7XG5cbiAgICAgICAgaWYgKGhpRmlBeGlzQ29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKEhpRmlBeGlzVXRpbGl0aWVzLnZlcmlmeShoaUZpQXhpc0NvbmZpZ3VyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpcyA9IGhpRmlBeGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXM7XG4gICAgICAgICAgICAgICAgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzID0gaGlGaUF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzO1xuICAgICAgICAgICAgICAgIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyA9IGhpRmlBeGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcztcbiAgICAgICAgICAgICAgICBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzID0gaGlGaUF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcztcbiAgICAgICAgICAgICAgICBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID0gaGlGaUF4aXNDb25maWd1cmF0aW9uLnVwQXhpcztcbiAgICAgICAgICAgICAgICBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgPSBoaUZpQXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXM7XG4gICAgICAgICAgICAgICAgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLmhhbmRlZG5lc3MgPSBoaUZpQXhpc0NvbmZpZ3VyYXRpb24uaGFuZGVkbmVzcztcbiAgICAgICAgICAgICAgICBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24uZXVsZXJPcmRlciA9IGhpRmlBeGlzQ29uZmlndXJhdGlvbi5ldWxlck9yZGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBUaGVyZSBpcyBhbiBlcnJvciB3aXRoIHRoZSBwYXNzZWQgXFxgSGlGaUF4aXNDb25maWd1cmF0aW9uXFxgLCBzbyB0aGUgbmV3IGF4aXMgY29uZmlndXJhdGlvbiB3YXMgbm90IHNldC4gVGhlcmUgYXJlIG1vcmUgZXJyb3IgZGV0YWlscyBpbiB0aGUgbG9ncyBhYm92ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGN1cnJlbnQgQXVkaW8gQVBJIERhdGEgd2l0aCB0aGUgZ2l2ZW4gZGF0YSwgYnV0IHVzZSB0aGUgJ3VwZGF0ZVVzZXJEYXRhKCknIGNhbGwgZm9yIHNhbml0eS5cbiAgICAgICAgdGhpcy5fdXBkYXRlVXNlckRhdGEoaW5pdGlhbEhpRmlBdWRpb0FQSURhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBzZXJ2ZXIgYW5kIHRyYW5zbWl0cyB0aGUgaW5pdGlhbCB1c2VyIGRhdGEgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gaGlmaUF1dGhKV1QgIFRoaXMgSlNPTiBXZWIgVG9rZW4gKEpXVCkgaXMgdXNlZCBieSBjYWxsZXJzIHRvIGFzc29jaWF0ZSBhIHVzZXIgd2l0aCBhIHNwZWNpZmljIEhpZ2ggRmlkZWxpdHkgU3BhdGlhbCBBdWRpbyBBUEkgU2VydmVyLlxuICAgICAqIEpXVHMgYXJlIGFuIGluZHVzdHJ5LXN0YW5kYXJkIG1ldGhvZCBmb3Igc2VjdXJlbHkgcmVwcmVzZW50aW5nIGNsYWltcyBiZXR3ZWVuIHR3byBhcHBsaWNhdGlvbnMuXG4gICAgICogXG4gICAgICogKipJbXBvcnRhbnQgaW5mb3JtYXRpb24gYWJvdXQgSldUczoqKlxuICAgICAqIC0gKipEbyBub3QgZXhwb3NlIEpXVHMgdG8gdXNlcnMhKiogQW55b25lIHdpdGggYWNjZXNzIHRvIG9uZSBvZiB5b3VyIEpXVHMgd2lsbCBiZSBhYmxlIHRvIGNvbm5lY3QgdG8geW91ciBIaWdoIEZpZGVsaXR5IFNwYXRpYWwgQXVkaW8gQVBJIFNlcnZlci5cbiAgICAgKiAtIEluIHlvdXIgYXBwbGljYXRpb24ncyBwcm9kdWN0aW9uIGVudmlyb25tZW50LCBlYWNoIGNsaWVudCBydW5uaW5nIHlvdXIgYXBwIGNvZGUgc2hvdWxkIGNvbm5lY3QgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgU3BhdGlhbCBBdWRpbyBTZXJ2ZXIgd2l0aCBhIHVuaXF1ZSBKV1QuXG4gICAgICogSW4gdGhlIGNhc2Ugb2YgYSBXZWIgYXBwbGljYXRpb24sIHlvdXIgYXBwbGljYXRpb24gc2VydmVyIGNvZGUgc2hvdWxkIGdlbmVyYXRlIGEgSldUIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciByZXF1ZXN0aW5nIHlvdXIgV2ViIGFwcGxpY2F0aW9uLlxuICAgICAqIFxuICAgICAqIFRvIGdlbmVyYXRlIGEgSldUIGZvciB1c2Ugd2l0aCB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEk6XG4gICAgICogMS4gSGVhZCB0byB7QGxpbmsgaHR0cHM6Ly9qd3QuaW8vfSB0byBmaW5kIHRoZSBhcHByb3ByaWF0ZSBsaWJyYXJ5IGZvciB5b3VyIGxhbmdhdWdlLlxuICAgICAqICAgICBhLiBGb3IgTm9kZUpTIGFwcGxpY2F0aW9ucyBhbmQgV2ViIGFwcGxpY2F0aW9ucyBjb21waWxpZWQgZnJvbSBOb2RlSlMgY29kZSwgd2UgcmVjb21tZW5kIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9qb3NlfGpvc2V9LlxuICAgICAqIDIuIFVzaW5nIHRoZSB7QGxpbmsgaHR0cHM6Ly9hY2NvdW50LmhpZ2hmaWRlbGl0eS5jb20vZGV2L2FjY291bnR8SGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgRGV2ZWxvcGVyIENvbnNvbGV9LFxuICAgICAqIG9idGFpbiB5b3VyIEFwcCBJRCwgU3BhY2UgSUQsIGFuZCBBcHAgU2VjcmV0LlxuICAgICAqIDMuIENyZWF0ZSB5b3VyIHVzZXIncyBKV1QgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGxpYnJhcnksIHBhc3NpbmcgeW91ciBBcHAgSUQsIFNwYWNlIElELCBhbmQgQXBwIFNlY3JldC4gSGVyZSBpcyBhbiBleGFtcGxlIG9mIHdoYXQgdGhhdCBtaWdodCBsb29rIGxpa2UsIHVzaW5nIE5vZGVKUyBhbmQgYGpvc2VgOlxuICAgICAqICAgICBgYGBcbiAgICAgKiBoaUZpU2FtcGxlSldUID0gYXdhaXQgbmV3IFNpZ25KV1Qoe1xuICAgICAqICAgICBcImFwcF9pZFwiOiBBUFBfSUQsXG4gICAgICogICAgIFwic3BhY2VfaWRcIjogU1BBQ0VfSURcbiAgICAgKiB9KVxuICAgICAqIC5zZXRQcm90ZWN0ZWRIZWFkZXIoeyBhbGc6ICdIUzI1NicsIHR5cDogJ0pXVCcgfSlcbiAgICAgKiAuc2lnbihjcnlwdG8uY3JlYXRlU2VjcmV0S2V5KEJ1ZmZlci5mcm9tKEFQUF9TRUNSRVQsIFwidXRmOFwiKSkpO1xuICAgICAqICAgICBgYGBcbiAgICAgKiBQbGVhc2UgcmVmZXJlbmNlIG91ciB7QGxpbmsgaHR0cHM6Ly93d3cuaGlnaGZpZGVsaXR5LmNvbS9hcGkvZ3VpZGVzL21pc2MvZ2V0QUpXVHxcIkdldCBhIEpXVFwiIGd1aWRlfSBmb3IgYWRkaXRpb25hbCBjb250ZXh0LlxuICAgICAqIDQuIFBhc3MgdGhlIGNyZWF0ZWQgSldUIHRvIGBjb25uZWN0VG9IaUZpQXVkaW9BUElTZXJ2ZXIoKWAuXG4gICAgICogXG4gICAgICogQXMgb2YgMjAyMS0wMS0yMSwgd2UndmUgYWRkZWQgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIHdoaWNoLCBpbiB0aGUgYnJvd3NlciBjb250ZXh0LCBzZWFyY2hlcyBmb3IgYSBgdG9rZW5gIFVSTCBxdWVyeSBwYXJhbWV0ZXIgYW5kLCBpZiBhIEpXVFxuICAgICAqIGlzbid0IHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb24sIHVzZXMgdGhlIHZhbHVlIG9mIHRoYXQgYHRva2VuYCBVUkwgcXVlcnkgcGFyYW1ldGVyIGFzIHRoZSBKV1QuXG4gICAgICogV2Ugc2hvdWxkIHJlbW92ZSB0aGF0IGxhdGVyLCBiZWNhdXNlIHdlIGFsbW9zdCBjZXJ0YWlubHkgZG9uJ3Qgd2FudCB0aGlzIHRvIHN0YXkgaW4gdGhlIEFQSSBjb2RlLCBidXQgaXQncyBfdmVyeV8gY29udmVuaWVudCBmb3Igc2FtcGxlIGFwcHMgZm9yIHJpZ2h0IG5vdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaWduYWxpbmdIb3N0VVJMIEFuIFVSTCB0aGF0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSB2YWxpZCBXZWJSVEMgc2lnbmFsaW5nIGFkZHJlc3MgYXQgSGlnaCBGaWRlbGl0eS4gVGhlIHBhc3NlZCBgc2lnbmFsaW5nSG9zdFVSTGAgcGFyYW1ldGVyIHNob3VsZCBub3QgY29udGFpbiB0aGUgcHJvdG9jb2xcbiAgICAgKiBvciBwb3J0IC0gZS5nLiBgc2VydmVyLmhpZ2hmaWRlbGl0eS5jb21gIC0gYW5kIGl0IHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBzaWduYWxpbmcgYWRkcmVzcyBvZiB0aGUgZm9ybTogYHdzczovLyR7c2lnbmFsaW5nSG9zdFVSTH06JHtzaWduYWxpbmdQb3J0fS8/dG9rZW49YFxuICAgICAqIElmIHRoZSBkZXZlbG9wZXIgZG9lcyBub3QgcGFzcyBhIGBzaWduYWxpbmdIb3N0VVJMYCBwYXJhbWV0ZXIsIGEgZGVmYXVsdCBVUkwgd2lsbCBiZSB1c2VkIGluc3RlYWQuIFNlZToge0BsaW5rIERFRkFVTFRfUFJPRF9ISUdIX0ZJREVMSVRZX0VORFBPSU5UfVxuICAgICAqIFJlYWRpbmcgdGhpcyBwYXJhbWV0ZXIgZnJvbSB0aGUgVVJMIChpZiBuZWVkZWQpIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgZGV2ZWxvcGVyIGFzIHBhcnQgb2YgdGhlIGFwcGxpY2F0aW9uIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2lnbmFsaW5nUG9ydCBUaGUgcG9ydCB0byB1c2UgZm9yIG1ha2luZyBXZWJTb2NrZXQgY29ubmVjdGlvbnMgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgc2VydmVycy5cbiAgICAgKiBJZiB0aGUgZGV2ZWxvcGVyIGRvZXMgbm90IHBhc3MgYSBgc2lnbmFsaW5nUG9ydGAgcGFyYW1ldGVyLCB0aGUgZGVmYXVsdCAoNDQzKSB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gU2VlOiB7QGxpbmsgREVGQVVMVF9QUk9EX0hJR0hfRklERUxJVFlfUE9SVH1cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBJZiB0aGlzIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGUgUHJvbWlzZSB3aWxsIHJlc29sdmUgd2l0aCBgeyBzdWNjZXNzOiB0cnVlLCBhdWRpb25ldEluaXRSZXNwb25zZTogPFRoZSByZXNwb25zZSB0byBgYXVkaW9uZXQuaW5pdGAgZnJvbSB0aGUgc2VydmVyIGluIE9iamVjdCBmb3JtYXQ+fWAuXG4gICAgICogSWYgdW5zdWNjZXNzZnVsLCB0aGUgUHJvbWlzZSB3aWxsIHJlamVjdCB3aXRoIGB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogPGFuIGVycm9yIG1lc3NhZ2U+IH1gLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3RUb0hpRmlBdWRpb0FQSVNlcnZlcihoaWZpQXV0aEpXVDogc3RyaW5nLCBzaWduYWxpbmdIb3N0VVJMPzogc3RyaW5nLCBzaWduYWxpbmdQb3J0PzogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgaWYgKCF0aGlzLl9taXhlclNlc3Npb24pIHtcbiAgICAgICAgICAgIGxldCBlcnJNc2cgPSBgXFxgdGhpcy5fbWl4ZXJTZXNzaW9uXFxgIGlzIGZhbHNleTsgdHJ5IGNyZWF0aW5nIGEgbmV3IEhpRmlDb21tdW5pY2F0b3IgYW5kIHN0YXJ0aW5nIG92ZXIuYDtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyck1zZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWl4ZXJTZXNzaW9uLmdldEN1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlKCkgPT09IEhpRmlDb25uZWN0aW9uU3RhdGVzLkNvbm5lY3RlZCkge1xuICAgICAgICAgICAgbGV0IG1zZyA9IGBTZXNzaW9uIGlzIGFscmVhZHkgY29ubmVjdGVkISBJZiB5b3UgbmVlZCB0byByZXNldCB0aGUgY29ubmVjdGlvbiwgcGxlYXNlIGRpc2Nvbm5lY3QgZnVsbHkgdXNpbmcgXFxgZGlzY29ubmVjdEZyb21IaUZpQXVkaW9BUElTZXJ2ZXIoKVxcYCBhbmQgY2FsbCB0aGlzIG1ldGhvZCBhZ2Fpbi5gO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtaXhlckNvbm5lY3Rpb25SZXNwb25zZTtcbiAgICAgICAgbGV0IHNpZ25hbGluZ0hvc3RVUkxTYWZlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChzaWduYWxpbmdIb3N0VVJMKTtcbiAgICAgICAgICAgIHNpZ25hbGluZ0hvc3RVUkxTYWZlID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICAgICAgaWYgKHNpZ25hbGluZ1BvcnQgPT0gbnVsbCAmJiB1cmwucG9ydCAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIC8vIHNvbWV0aW1lcyB0aGUgc2lnbmFsaW5nUG9ydCBpcyBzcGVjaWZpZWQgaW4gdGhlIHNpZ25hbEhvc3RVUkwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgICAgIC8vIHdlIGV4dHJhY3QgdGhlIHBvcnQgbnVtYmVyIHJhdGhlciB0aGFuIGZhbGxiYWNrIHRvIGRlZmF1bHRcbiAgICAgICAgICAgICAgICBzaWduYWxpbmdQb3J0ID0gTnVtYmVyKHVybC5wb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBJZiBzaWduYWxpbmdIb3N0VVJMIGlzIG5vdCBkZWZpbmVkLCB3ZSBhc3NpZ24gdGhlIGRlZmF1bHQgVVJMXG4gICAgICAgICAgICBzaWduYWxpbmdIb3N0VVJMU2FmZSA9IHNpZ25hbGluZ0hvc3RVUkwgPyBzaWduYWxpbmdIb3N0VVJMIDogSGlGaUNvbnN0YW50cy5ERUZBVUxUX1BST0RfSElHSF9GSURFTElUWV9FTkRQT0lOVDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpZ25hbGluZ1BvcnQgPSBzaWduYWxpbmdQb3J0ID8gc2lnbmFsaW5nUG9ydCA6IEhpRmlDb25zdGFudHMuREVGQVVMVF9QUk9EX0hJR0hfRklERUxJVFlfUE9SVDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHdlYlJUQ1NpZ25hbGluZ0FkZHJlc3MgPSBgd3NzOi8vJHtzaWduYWxpbmdIb3N0VVJMU2FmZX06JHtzaWduYWxpbmdQb3J0fS8/dG9rZW49YDtcbiAgICAgICAgICAgIHRoaXMuX21peGVyU2Vzc2lvbi53ZWJSVENBZGRyZXNzID0gYCR7d2ViUlRDU2lnbmFsaW5nQWRkcmVzc30ke2hpZmlBdXRoSldUfWA7XG5cbiAgICAgICAgICAgIEhpRmlMb2dnZXIubG9nKGBVc2luZyBXZWJSVEMgU2lnbmFsaW5nIEFkZHJlc3M6XFxuJHt3ZWJSVENTaWduYWxpbmdBZGRyZXNzfTx0b2tlbiByZWRhY3RlZD5gKTtcblxuICAgICAgICAgICAgbWl4ZXJDb25uZWN0aW9uUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9taXhlclNlc3Npb24uY29ubmVjdFRvSGlGaU1peGVyKHsgd2ViUlRDU2Vzc2lvblBhcmFtczogdGhpcy5fd2ViUlRDU2Vzc2lvblBhcmFtcywgY3VzdG9tU1RVTmFuZFRVUk5Db25maWc6IHRoaXMuX2N1c3RvbVNUVU5hbmRUVVJOQ29uZmlnIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvckNvbm5lY3RpbmdUb01peGVyKSB7XG4gICAgICAgICAgICBsZXQgZXJyTXNnID0gYEVycm9yIHdoZW4gY29ubmVjdGluZyB0byBtaXhlciFcXG4ke2Vycm9yQ29ubmVjdGluZ1RvTWl4ZXJ9YDtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyck1zZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90cmFuc21pdEhpRmlBdWRpb0FQSURhdGFUb1NlcnZlcih0cnVlKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgYXVkaW9uZXRJbml0UmVzcG9uc2U6IG1peGVyQ29ubmVjdGlvblJlc3BvbnNlLmF1ZGlvbmV0SW5pdFJlc3BvbnNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIGdhaW4gb2YgYW5vdGhlciB1c2VyIGZvciB0aGlzIGNvbW11bmljYXRvcidzIGN1cnJlbnQgY29ubmVjdGlvbiBvbmx5LiBUaGlzIGlzIGEgc2luZ2xlIHVzZXIgdmVyc2lvbiBvZiB7QGxpbmsgSGlGaUNvbW11bmljYXRvci5zZXRPdGhlclVzZXJHYWluc0ZvclRoaXNDb25uZWN0aW9ufS5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgYSBtb3JlIGNvbWZvcnRhYmxlIGxpc3RlbmluZyBleHBlcmllbmNlIGZvciB0aGUgY2xpZW50LiBJZiB5b3UgbmVlZCB0byBwZXJmb3JtIG1vZGVyYXRpb24gYWN0aW9ucyB3aGljaCBhcHBseSBzZXJ2ZXIgc2lkZSwgdXNlIHRoZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmhpZ2hmaWRlbGl0eS5jb20vcmVzdC9sYXRlc3QvaW5kZXguaHRtbHxBZG1pbmlzdHJhdGl2ZSBSRVNUIEFQSX0uXG4gICAgICogXG4gICAgICogVG8gdXNlIHRoaXMgY29tbWFuZCwgdGhlIGNvbW11bmljYXRvciBtdXN0IGN1cnJlbnRseSBiZSBjb25uZWN0ZWQgdG8gYSBzcGFjZS4gWW91IGNhbiBjb25uZWN0IHRvIGEgc3BhY2UgdXNpbmcge0BsaW5rIGNvbm5lY3RUb0hpRmlBdWRpb0FQSVNlcnZlcn0uXG4gICAgICogXG4gICAgICogQHBhcmFtIGhhc2hlZFZpc2l0SWQgIFRoZSBoYXNoZWQgdmlzaXQgSUQgb2YgdGhlIHVzZXIgd2hvc2UgZ2FpbiB3aWxsIGJlIGFkanVzdGVkLlxuICAgICAqIFVzZSB7QGxpbmsgYWRkVXNlckRhdGFTdWJzY3JpcHRpb259IGFuZCB7QGxpbmsgSGlGaUNvbW11bmljYXRvci5vblVzZXJzRGlzY29ubmVjdGVkfSB0byBrZWVwIHRyYWNrIG9mIHRoZSBoYXNoZWQgdmlzaXQgSURzIG9mIGN1cnJlbnRseSBjb25uZWN0ZWQgdXNlcnMuXG4gICAgICogXG4gICAgICogV2hlbiB5b3Ugc3Vic2NyaWJlIHRvIHVzZXIgZGF0YSwgeW91IHdpbGwgZ2V0IGEgbGlzdCBvZiB7QGxpbmsgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhfSBvYmplY3RzLCB3aGljaCBlYWNoIGNvbnRhaW4sIGF0IG1pbmltdW0sIHtAbGluayBSZWNlaXZlZEhpZmlBdWRpb0FQSURhdGEuaGFzaGVkVmlzaXRJRH1zIGFuZCB7QGxpbmsgUmVjZWl2ZWRIaWZpQXVkaW9BUElEYXRhLnByb3ZpZGVkVXNlcklEfXMgZm9yIGVhY2ggdXNlciBpbiB0aGUgc3BhY2UuIEJ5IGluc3BlY3RpbmcgZWFjaCBvZiB0aGVzZSBvYmplY3RzLCB5b3UgY2FuIGFzc29jaWF0ZSBhIHVzZXIgd2l0aCB0aGVpciBoYXNoZWQgdmlzaXQgSUQsIGlmIHlvdSBrbm93IHRoZWlyIHByb3ZpZGVkIHVzZXIgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ2FpbiAgVGhlIHJlbGF0aXZlIGdhaW4gdG8gYXBwbHkgdG8gdGhlIG90aGVyIHVzZXIuIEJ5IGRlZmF1bHQsIHRoaXMgaXMgYDEuMGAuIFRoZSBnYWluIGNhbiBiZSBhbnkgdmFsdWUgZ3JlYXRlciBvciBlcXVhbCB0byBgMC4wYC5cbiAgICAgKiBGb3IgZXhhbXBsZTogYSBnYWluIG9mIGAyLjBgIHdpbGwgZG91YmxlIHRoZSBsb3VkbmVzcyBvZiB0aGUgdXNlciwgd2hpbGUgYSBnYWluIG9mIGAwLjVgIHdpbGwgaGFsdmUgdGhlIHVzZXIncyBsb3VkbmVzcy4gQSBnYWluIG9mIGAwLjBgIHdpbGwgZWZmZWN0aXZlbHkgbXV0ZSB0aGUgdXNlci5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBJZiB0aGlzIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGUgUHJvbWlzZSB3aWxsIHJlc29sdmUgd2l0aCB7QGxpbmsgU2V0T3RoZXJVc2VyR2FpbkZvclRoaXNDb25uZWN0aW9uUmVzcG9uc2V9IHdpdGggYHN1Y2Nlc3NgIGVxdWFsIHRvIGB0cnVlYC5cbiAgICAgKiBJZiB1bnN1Y2Nlc3NmdWwsIHRoZSBQcm9taXNlIHdpbGwgcmVqZWN0IHdpdGgge0BsaW5rIFNldE90aGVyVXNlckdhaW5Gb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlfSB3aXRoIGBzdWNjZXNzYCBlcXVhbCB0byBgZmFsc2VgIGFuZCBgZXJyb3JgIHNldCB0byBhbiBlcnJvciBtZXNzYWdlIGRlc2NyaWJpbmcgd2hhdCB3ZW50IHdyb25nLlxuICAgICAqL1xuICAgIGFzeW5jIHNldE90aGVyVXNlckdhaW5Gb3JUaGlzQ29ubmVjdGlvbih2aXNpdElkSGFzaDogc3RyaW5nLCBnYWluOiBudW1iZXIpOiBQcm9taXNlPFNldE90aGVyVXNlckdhaW5Gb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlPiB7XG4gICAgICAgIGxldCBvdGhlclVzZXJHYWluTWFwOiBPdGhlclVzZXJHYWluTWFwID0ge307XG4gICAgICAgIG90aGVyVXNlckdhaW5NYXBbdmlzaXRJZEhhc2hdID0gZ2FpbjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvbihvdGhlclVzZXJHYWluTWFwKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIGdhaW4gb2Ygb25lIG9yIG1vcmUgdXNlcnMgZm9yIHRoaXMgY29tbXVuaWNhdG9yJ3MgY3VycmVudCBjb25uZWN0aW9uIG9ubHkuXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGEgbW9yZSBjb21mb3J0YWJsZSBsaXN0ZW5pbmcgZXhwZXJpZW5jZSBmb3IgdGhlIGNsaWVudC4gSWYgeW91IG5lZWQgdG8gcGVyZm9ybSBtb2RlcmF0aW9uIGFjdGlvbnMgb24gdGhlIHNlcnZlciBzaWRlLCB1c2UgdGhlIHtAbGluayBodHRwczovL2RvY3MuaGlnaGZpZGVsaXR5LmNvbS9yZXN0L2xhdGVzdC9pbmRleC5odG1sfEFkbWluaXN0cmF0aXZlIFJFU1QgQVBJfS5cbiAgICAgKiBcbiAgICAgKiBUbyB1c2UgdGhpcyBjb21tYW5kLCB0aGUgY29tbXVuaWNhdG9yIG11c3QgY3VycmVudGx5IGJlIGNvbm5lY3RlZCB0byBhIHNwYWNlLiBZb3UgY2FuIGNvbm5lY3QgdG8gYSBzcGFjZSB1c2luZyB7QGxpbmsgY29ubmVjdFRvSGlGaUF1ZGlvQVBJU2VydmVyfS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gb3RoZXJVc2VyR2Fpbk1hcCAgVGhlIG1hcCBiZXR3ZWVuIGhhc2hlZCB2aXNpdCBJRHMgYW5kIHRoZSBkZXNpcmVkIGFkanVzdGVkIGdhaW5zIG9mIHVzZXJzIGZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIHRoaXMgY2xpZW50LCBmb3IgdGhpcyBjb25uZWN0aW9uIG9ubHkuXG4gICAgICogXG4gICAgICogVXNlIHtAbGluayBhZGRVc2VyRGF0YVN1YnNjcmlwdGlvbn0gYW5kIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLm9uVXNlcnNEaXNjb25uZWN0ZWR9IHRvIGtlZXAgdHJhY2sgb2YgdGhlIGhhc2hlZCB2aXNpdCBJRHMgb2YgY3VycmVudGx5IGNvbm5lY3RlZCB1c2Vycy5cbiAgICAgKiBcbiAgICAgKiBXaGVuIHlvdSBzdWJzY3JpYmUgdG8gdXNlciBkYXRhLCB5b3Ugd2lsbCBnZXQgYSBsaXN0IG9mIHtAbGluayBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGF9IG9iamVjdHMsIHdoaWNoIGVhY2ggY29udGFpbiwgYXQgbWluaW11bSwge0BsaW5rIFJlY2VpdmVkSGlmaUF1ZGlvQVBJRGF0YS5oYXNoZWRWaXNpdElEfXMgYW5kIHtAbGluayBSZWNlaXZlZEhpZmlBdWRpb0FQSURhdGEucHJvdmlkZWRVc2VySUR9cyBmb3IgZWFjaCB1c2VyIGluIHRoZSBzcGFjZS4gQnkgaW5zcGVjdGluZyBlYWNoIG9mIHRoZXNlIG9iamVjdHMsIHlvdSBjYW4gYXNzb2NpYXRlIGEgdXNlciB3aXRoIHRoZWlyIGhhc2hlZCB2aXNpdCBJRCwgaWYgeW91IGtub3cgdGhlaXIgcHJvdmlkZWQgdXNlciBJRC5cbiAgICAgKiBcbiAgICAgKiBUaGUgcmVsYXRpdmUgZ2FpbiB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIG90aGVyIHVzZXIgd2l0aCB0aGUgbWF0Y2hpbmcgaGFzaGVkIHZpc2l0IElELiBCeSBkZWZhdWx0LCB0aGlzIGlzIGAxLjBgLiBUaGUgZ2FpbiBjYW4gYmUgYW55IHZhbHVlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gYDAuMGAuXG4gICAgICogRm9yIGV4YW1wbGU6IGEgZ2FpbiBvZiBgMi4wYCB3aWxsIGRvdWJsZSB0aGUgbG91ZG5lc3Mgb2YgdGhlIHVzZXIsIHdoaWxlIGEgZ2FpbiBvZiBgMC41YCB3aWxsIGhhbHZlIHRoZSB1c2VyJ3MgbG91ZG5lc3MuIEEgZ2FpbiBvZiBgMC4wYCB3aWxsIGVmZmVjdGl2ZWx5IG11dGUgdGhlIHVzZXIuXG4gICAgICogXG4gICAgICogQHJldHVybnMgSWYgdGhpcyBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bCwgdGhlIFByb21pc2Ugd2lsbCByZXNvbHZlIHdpdGgge0BsaW5rIFNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb25SZXNwb25zZX0gd2l0aCBgc3VjY2Vzc2AgZXF1YWwgdG8gYHRydWVgLlxuICAgICAqIElmIHVuc3VjY2Vzc2Z1bCwgdGhlIFByb21pc2Ugd2lsbCByZWplY3Qgd2l0aCB7QGxpbmsgU2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlfSB3aXRoIGBzdWNjZXNzYCBlcXVhbCB0byBgZmFsc2VgIGFuZCBgZXJyb3JgIHNldCB0byBhbiBlcnJvciBtZXNzYWdlIGRlc2NyaWJpbmcgd2hhdCB3ZW50IHdyb25nLlxuICAgICAqL1xuICAgIGFzeW5jIHNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb24ob3RoZXJVc2VyR2Fpbk1hcDogT3RoZXJVc2VyR2Fpbk1hcCk6IFByb21pc2U8U2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlPiB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEuX290aGVyVXNlckdhaW5RdWV1ZSwgb3RoZXJVc2VyR2Fpbk1hcCk7XG5cbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgc3VjY2VzczogcmVzdWx0LnN1Y2Nlc3MsXG4gICAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIGZyb20gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJLiBBZnRlciB0aGlzIGNhbGwsIHVzZXIgZGF0YSB3aWxsIG5vIGxvbmdlciBiZSB0cmFuc21pdHRlZCB0byBIaWdoIEZpZGVsaXR5LCB0aGUgYXVkaW9cbiAgICAgKiBpbnB1dCBzdHJlYW0gd2lsbCBub3QgYmUgdHJhbnNtaXR0ZWQgdG8gSGlnaCBGaWRlbGl0eSwgYW5kIHRoZSB1c2VyIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gaGVhciB0aGUgYXVkaW8gc3RyZWFtIGZyb20gSGlnaCBGaWRlbGl0eS5cbiAgICAgKi9cbiAgICBhc3luYyBkaXNjb25uZWN0RnJvbUhpRmlBdWRpb0FQSVNlcnZlcigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBpZiAoIXRoaXMuX21peGVyU2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShgTm8gbWl4ZXIgc2Vzc2lvbiBmcm9tIHdoaWNoIHdlIGNhbiBkaXNjb25uZWN0IWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5wdXRBdWRpb01lZGlhU3RyZWFtID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9uVXNlcnNEaXNjb25uZWN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3VzZXJEYXRhU3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YSA9IG5ldyBIaUZpQXVkaW9BUElEYXRhKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21peGVyU2Vzc2lvbi5kaXNjb25uZWN0RnJvbUhpRmlNaXhlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBmaW5hbCBtaXhlZCBhdWRpbyBgTWVkaWFTdHJlYW1gIGNvbWluZyBmcm9tIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIFNlcnZlci5cbiAgICAgKi9cbiAgICBnZXRPdXRwdXRBdWRpb01lZGlhU3RyZWFtKCk6IE1lZGlhU3RyZWFtIHtcbiAgICAgICAgaWYgKHRoaXMuX21peGVyU2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21peGVyU2Vzc2lvbi5nZXRPdXRwdXRBdWRpb01lZGlhU3RyZWFtKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBjb25uZWN0aW9uIHRvIEhpZ2ggRmlkZWxpdHksIGFzIG9uZSBvZiB0aGUgSGlGaUNvbm5lY3Rpb25TdGF0ZXMuXG4gICAgICogVGhpcyB3aWxsIHJldHVybiBudWxsIGlmIHRoZSBjdXJyZW50IHN0YXRlIGlzIG5vdCBhdmFpbGFibGUgKGUuZy4gaWYgdGhlIEhpRmlDb21tdW5pY2F0b3JcbiAgICAgKiBpcyBzdGlsbCBpbiB0aGUgcHJvY2VzcyBvZiBpbml0aWFsaXppbmcgaXRzIHVuZGVybHlpbmcgSGlGaU1peGVyU2Vzc2lvbikuXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdGlvblN0YXRlKCk6IEhpRmlDb25uZWN0aW9uU3RhdGVzIHtcbiAgICAgICAgaWYgKHRoaXMuX21peGVyU2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21peGVyU2Vzc2lvbi5nZXRDdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBmdW5jdGlvbiB0byBzZXQgdGhlIGBNZWRpYVN0cmVhbWAgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyLiBUaGlzIGBNZWRpYVN0cmVhbWAgd2lsbCBiZSBzZW50IHVwIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIFNlcnZlcnMgYW5kXG4gICAgICogbWl4ZWQgd2l0aCBvdGhlciB1c2VycycgYXVkaW8gc3RyZWFtcy4gVGhlIHJlc3VsdGFudCBtaXhlZCBzdHJlYW0gd2lsbCBiZSBzZW50IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cy5cbiAgICAgKlxuICAgICAqICoqQmUgbWluZGZ1bCoqIG9mIHN1cHBseWluZyB0aGlzIHN0cmVhbSB1cG9uIGluaXRpYWwgY29ubmVjdGlvbiB3aGVuIHlvdSBhbnRpY2lwYXRlIHRoYXQgdGhlIHVzZXIgaXMgdXNpbmcgQmx1ZXRvb3RoIGF1ZGlvXG4gICAgICogaW5wdXQgYW5kIEJsdWV0b290aCBhdWRpbyBvdXRwdXQgc2ltdWx0YW5lb3VzbHkuIE1hbnkgQmx1ZXRvb3RoIGF1ZGlvIGRldmljZXMgZG8gbm90IHN1cHBvcnQgc3RlcmVvIChzcGF0aWFsaXplZCkgYXVkaW9cbiAgICAgKiBvdXRwdXQgYW5kIG1pY3JvcGhvbmUgYXVkaW8gaW5wdXQgc2ltdWx0YW5lb3VzbHksIGluY2x1ZGluZyB0aGUgcG9wdWxhciBjb21iaW5hdGlvbiBvZiBhbiBpUGhvbmUgYW5kIEFpclBvZHMuXG4gICAgICogWW91ciB1c2VycyBtYXkgaGF2ZSBhIGJldHRlciBleHBlcmllbmNlIGlmIHRoZXkgam9pbiB0aGUgU2VydmVyIGluIFwibGlzdGVuLW9ubHlcIiBtb2RlIC0gaS5lLiB3aXRob3V0IG1pY3JvcGhvbmUgaW5wdXQgLSBhbmQgdGhlblxuICAgICAqIGFyZSBhc2tlZCBmb3IgbWljcm9waG9uZSBwZXJtaXNzaW9uIGxhdGVyICh3aGljaCB3aWxsIGZvcmNlIHRoZWlyIEJsdWV0b290aCBvdXRwdXQgZGV2aWNlIGludG8gYSBsb3dlci1xdWFsaXR5LCB1bnNwYXRpYWxpemVkIG1vbm8gbW9kZSkuXG4gICAgICogXG4gICAgICogQHBhcmFtIG5ld0lucHV0QXVkaW9NZWRpYVN0cmVhbSAtIFRoZSBuZXcgYE1lZGlhU3RyZWFtYCB0byBzZW5kIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIFNlcnZlci4gSWYgdGhpc1xuICAgICAqIGlzIHNldCB0byBhbiBgdW5kZWZpbmVkYCB2YWx1ZSwgdGhlIGV4aXN0aW5nIGlucHV0IHN0cmVhbSAoaWYgb25lIGlzIHNldCkgd2lsbCBiZSBjbGVhcmVkLlxuICAgICAqIEBwYXJhbSBpc1N0ZXJlbyAtIGB0cnVlYCBpZiB0aGUgaW5wdXQgc3RyZWFtIHNob3VsZCBiZSB0cmVhdGVkIGFzIHN0ZXJlbywgYGZhbHNlYCBmb3IgbW9ubyAoZGVmYXVsdCkuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBuZXcgYE1lZGlhU3RyZWFtYCB3YXMgc3VjY2Vzc2Z1bGx5IHNldCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgYXN5bmMgc2V0SW5wdXRBdWRpb01lZGlhU3RyZWFtKG5ld0lucHV0QXVkaW9NZWRpYVN0cmVhbTogTWVkaWFTdHJlYW0sIGlzU3RlcmVvOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgcmV0dmFsID0gYXdhaXQgdGhpcy5fbWl4ZXJTZXNzaW9uLnNldFJBVklJbnB1dEF1ZGlvKG5ld0lucHV0QXVkaW9NZWRpYVN0cmVhbSwgaXNTdGVyZW8pO1xuICAgICAgICBpZiAocmV0dmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW0gPSBuZXdJbnB1dEF1ZGlvTWVkaWFTdHJlYW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYEVycm9yIHRyeWluZyB0byBzZXRSQVZJSW5wdXRBdWRpbyBvbiB0aGlzLl9taXhlclNlc3Npb25gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHNldCB3aGV0aGVyIGlucHV0IGF1ZGlvIHN0cmVhbSB3aWxsIGhhdmUgdGhlIGBlbmFibGVkYCBwcm9wZXJ0eSBvZiBlYWNoIG9mIGl0cyBgTWVkaWFTdHJlYW1UcmFja2BzIHNldCB0byBgZmFsc2VgXG4gICAgICogKGFuZCBhbiB1bm11dGVkIHN0cmVhbSAtLSB0aGUgZGVmYXVsdCAtLSB3aWxsIGhhdmUgdGhlIGBlbmFibGVkYCBwcm9wZXJ0eSBzZXQgdG8gYHRydWVgKS4gVGhpcyB3aWxsIHNpbGVuY2UgdGhlIGlucHV0LFxuICAgICAqIGJ1dCBoYXMgc3BlY2lmaWMgY29uc2VxdWVuY2VzOlxuICAgICAqICAgLSBJZiB5b3UgYXJlIHVzaW5nIHRoZSBzYW1lIGBNZWRpYVN0cmVhbWAgb2JqZWN0IGluIG90aGVyIHdheXMsIGl0IHdpbGwgYmUgYWZmZWN0ZWQgYnlcbiAgICAgKiBjYWxsaW5nIHRoaXMgbWV0aG9kLiBTbywgaWYgeW91IHdvdWxkIGxpa2UgdG8gbXV0ZS91bm11dGUgdGhlIGlucHV0IGF1ZGlvIHN0cmVhbSBzZXBhcmF0ZWx5IGZvciB0aGVcbiAgICAgKiBIaWdoIEZpZGVsaXR5IGF1ZGlvIHZzLiBzb21lIG90aGVyIHVzZSBvZiBpdCwgaXQgaXMgcmVjb21tZW5kZWQgdG8gY2xvbmUgdGhlIGF1ZGlvIHN0cmVhbSBzZXBhcmF0ZWx5XG4gICAgICogZm9yIGVhY2ggdXNlLlxuICAgICAqICAgLSBUaGUgZWZmZWN0IGlzIGltbWVkaWF0ZSBhbmQgY291bGQgcmVzdWx0IGluIGEgY2xpY2sgb3Igb3RoZXIgYXVkaW8gYXJ0aWZhY3QgaWYgdGhlcmUgaXMgc3RlYWR5IHNvdW5kIGF0XG4gICAgICogdGhlIG1vbWVudCB0aGUgaW5wdXQgaXMgbXV0ZWQuXG4gICAgICpcbiAgICAgKiBBbiBhbHRlcmF0aXZlIGlzIHRvIHNldCB0aGUgdXNlcidzIHtAbGluayB2b2x1bWVUaHJlc2hvbGR9IHRvIDAsIHdoaWNoIHNtb290aGx5IGdhdGVzIG9mZiB0aGUgdXNlcidzIGlucHV0LlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3RyZWFtIHdhcyBzdWNjZXNzZnVsbHkgbXV0ZWQvdW5tdXRlZCwgYGZhbHNlYCBpZiBpdCB3YXMgbm90LiAoVGhlIHVzZXIgc2hvdWxkXG4gICAgICogYXNzdW1lIHRoYXQgaWYgdGhpcyByZXR1cm5zIGBmYWxzZWAsIG5vIGNoYW5nZSB3YXMgbWFkZSB0byB0aGUgbXV0ZSAodHJhY2sgZW5hYmxlZCkgc3RhdGUgb2YgdGhlIHN0cmVhbS4pXG4gICAgICovXG4gICAgYXN5bmMgc2V0SW5wdXRBdWRpb011dGVkKGlzTXV0ZWQ6IGJvb2xlYW4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgaWYgKHRoaXMuX21peGVyU2Vzc2lvbikge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5kZWJ1ZyhgU2V0dGluZyBtdXRlIHN0YXRlIHRvIDogJHtpc011dGVkfWApO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX21peGVyU2Vzc2lvbi5zZXRJbnB1dEF1ZGlvTXV0ZWQoaXNNdXRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYENvdWxkbid0IHNldCBtdXRlIHN0YXRlOiBObyBcXGBfbWl4ZXJTZXNzaW9uXFxgLmApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgQSBidW5jaCBvZiBpbmZvIGFib3V0IHRoaXMgYEhpRmlDb21tdW5pY2F0b3JgIGluc3RhbnRpYXRpb24sIGluY2x1ZGluZyBTZXJ2ZXIgVmVyc2lvbi5cbiAgICAgKi9cbiAgICBnZXRDb21tdW5pY2F0b3JJbmZvKCk6IGFueSB7XG4gICAgICAgIGxldCByZXR2YWw6IGFueSA9IHtcbiAgICAgICAgICAgIFwiY2xpZW50SW5mb1wiOiB7XG4gICAgICAgICAgICAgICAgXCJpbnB1dEF1ZGlvU3RyZWFtU2V0XCI6ICEhdGhpcy5faW5wdXRBdWRpb01lZGlhU3RyZWFtLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBpc0Jyb3dzZXJDb250ZXh0ID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAoaXNCcm93c2VyQ29udGV4dCAmJiB0eXBlb2YgKEhJRklfQVBJX1ZFUlNJT04pID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR2YWwuY2xpZW50SW5mb1tcImFwaVZlcnNpb25cIl0gPSBISUZJX0FQSV9WRVJTSU9OO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21peGVyU2Vzc2lvbiAmJiB0aGlzLl9taXhlclNlc3Npb24ubWl4ZXJJbmZvKSB7XG4gICAgICAgICAgICByZXR2YWxbXCJzZXJ2ZXJJbmZvXCJdID0gdGhpcy5fbWl4ZXJTZXNzaW9uLm1peGVySW5mbztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgY29sbGVjdGluZyBkYXRhIGFib3V0IHRoZSBXZWJSVEMgY29ubmVjdGlvbiBiZXR3ZWVuIENsaWVudCBhbmQgU2VydmVyLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgZGF0YSBpbnNpZGUgdGhlIHJlcG9ydHMgcGVydGFpbnMgb25seSB0byBwYXlsb2FkIGRhdGEgaW50ZXJuYWwgdG8gdGhlIFdlYlJUQyBjb25uZWN0aW9uXG4gICAgICogYW5kIGRvZXMgbm90IGluY2x1ZGUgX3RvdGFsXyBkYXRhIHNlbnQgb3ZlciB0aGUgd2lyZSBvciByZWNlaXZlZCBvdmVyIHRoZSB3aXJlIGluIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9ucyB3aWxsIGJlIHByb3ZpZGVkIHR3byBBcnJheSBhcmd1bWVudHM6IGBzdGF0c2AgYW5kIGBwcmV2U3RhdHNgLlxuICAgICAqIEVhY2ggb2YgdGhvc2UgQXJyYXkgaXRlbXMgY29udGFpbnMgb25lIG9yIG1vcmUgT2JqZWN0cywgd2hpY2ggYXJlIHJlcG9ydHMgb2YgV2ViUlRDIHN0YXRzIGRhdGEsXG4gICAgICogaW5jbHVkaW5nIGRhdGEgc3VjaCBhcyBcImEgdGltZXN0YW1wXCIsIFwidGhlIG51bWJlciBvZiBieXRlcyByZWNlaXZlZCBzaW5jZSB0aGUgbGFzdCByZXBvcnRcIiBhbmQgXCJjdXJyZW50IGppdHRlciBidWZmZXIgZGVsYXlcIi5cbiAgICAgKi9cbiAgICBzdGFydENvbGxlY3RpbmdXZWJSVENTdGF0cyhjYWxsYmFjazogRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9taXhlclNlc3Npb24pIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYENvdWxkbid0IHN0YXJ0IGNvbGxlY3RpbmcgV2ViUlRDIFN0YXRzOiBObyBcXGBfbWl4ZXJTZXNzaW9uXFxgIWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWl4ZXJTZXNzaW9uLnN0YXJ0Q29sbGVjdGluZ1dlYlJUQ1N0YXRzKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGNvbGxlY3RpbmcgZGF0YSBhYm91dCB0aGUgV2ViUlRDIGNvbm5lY3Rpb24gYmV0d2VlbiBDbGllbnQgYW5kIFNlcnZlci5cbiAgICAgKi9cbiAgICBzdG9wQ29sbGVjdGluZ1dlYlJUQ1N0YXRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21peGVyU2Vzc2lvbikge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgQ291bGRuJ3Qgc3RvcCBjb2xsZWN0aW5nIFdlYlJUQyBTdGF0czogTm8gXFxgX21peGVyU2Vzc2lvblxcYCFgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21peGVyU2Vzc2lvbi5zdG9wQ29sbGVjdGluZ1dlYlJUQ1N0YXRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgY29weSBvZiB0aGUgVXNlciBEYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBjbGllbnQuIERvZXMgKipOT1QqKiB1cGRhdGVcbiAgICAgKiB0aGUgdXNlciBkYXRhIG9uIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBzZXJ2ZXIuIFRoZXJlIGFyZSBubyBnb29kIHJlYXNvbnMgZm9yIGEgY2xpZW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvblxuICAgICAqIGFuZCBfbm90XyB1cGRhdGUgdGhlIHNlcnZlciBVc2VyIERhdGEsIGFuZCB0aHVzIHRoaXMgZnVuY3Rpb24gaXMgYHByaXZhdGVgLlxuICAgICAqIFxuICAgICAqIFlvdSBjYW4gdXBkYXRlIHVzZXIgb3JpZW50YXRpb24gYnkgcGFzc2luZyBRdWF0ZXJuaW9uIG9yIEV1bGVyIG9yaWVudGF0aW9uIHJlcHJlc2VudGF0aW9ucyB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICogVGhlIHF1YXRlcm5pb24gcmVwcmVzZW50YXRpb24gaXMgcHJlZmVycmVkLlxuICAgICAqIElmIGJvdGggcmVwcmVzZW50YXRpb24gYXJlIHByb3ZpZGVkLCB0aGUgZXVsZXIgcmVwcmVzZW50YXRpb24gaXMgaWdub3JlZC5cbiAgICAgKiBJZiBvbmx5IHRoZSBldWxlciByZXByZXNlbnRhdGlvbiBpcyBwcm92aWRlZCwgaXQgaXMgdGhlbiBjb252ZXJ0ZWQgaW1tZWRpYXRlbHkgdG8gdGhlIGVxdWl2YWxlbnQgcXVhdGVybmlvbiByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBUaGUgZXVsZXJPcmRlciB1c2VkIGZvciB0aGUgY29udmVyc2lvbiBpcyB0aGUgcHJvdmlkZWQgYnkgdGhlICdvdXJBeGlzQ29uZmlndXJhdGlvbi5ldWxlck9yZGVyJy5cbiAgICAgKiBFdWxlciByZXByZXNlbnRhdGlvbiBpcyBub3QgdXNlZCBpbnRlcm5hbGx5IGFueW1vcmUgaW4gdGhlIEhpZmkgQVBJLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBfX25hbWVkUGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAtIFRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9yaWVudGF0aW9uUXVhdCAtIFRoZSBuZXcgb3JpZW50YXRpb25RdWF0IG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcmllbnRhdGlvbkV1bGVyIC0gVGhlIG5ldyBvcmllbnRhdGlvbkV1bGVyIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSB2b2x1bWVUaHJlc2hvbGQgLSBUaGUgbmV3IHZvbHVtZVRocmVzaG9sZCBvZiB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gaGlGaUdhaW4gLSBUaGlzIHZhbHVlIGFmZmVjdHMgaG93IGxvdWQgVXNlciBBIHdpbGwgc291bmQgdG8gVXNlciBCIGF0IGEgZ2l2ZW4gZGlzdGFuY2UgaW4gM0Qgc3BhY2UuXG4gICAgICogVGhpcyB2YWx1ZSBhbHNvIGFmZmVjdHMgdGhlIGRpc3RhbmNlIGF0IHdoaWNoIFVzZXIgQSBjYW4gYmUgaGVhcmQgaW4gM0Qgc3BhY2UuXG4gICAgICogSGlnaGVyIHZhbHVlcyBmb3IgVXNlciBBIG1lYW5zIHRoYXQgVXNlciBBIHdpbGwgc291bmQgbG91ZGVyIHRvIG90aGVyIHVzZXJzIGFyb3VuZCBVc2VyIEEsIGFuZCBpdCBhbHNvIG1lYW5zIHRoYXQgVXNlciBBIHdpbGwgYmUgYXVkaWJsZSBmcm9tIGEgZ3JlYXRlciBkaXN0YW5jZS5cbiAgICAgKiBUaGUgbmV3IGhpRmlHYWluIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSB1c2VyQXR0ZW51YXRpb24gLSBUaGlzIHZhbHVlIGFmZmVjdHMgaG93IGZhciBhIHVzZXIncyB2b2ljZSB3aWxsIHRyYXZlbCBpbiAzRCBzcGFjZS5cbiAgICAgKiBUaGUgbmV3IGF0dGVudWF0aW9uIHZhbHVlIGZvciB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gdXNlclJvbGxvZmYgLSBUaGlzIHZhbHVlIGFmZmVjdHMgdGhlIGZyZXF1ZW5jeSByb2xsb2ZmIGZvciBhIGdpdmVuIHVzZXIuXG4gICAgICogVGhlIG5ldyByb2xsb2ZmIHZhbHVlIGZvciB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBwcml2YXRlIF91cGRhdGVVc2VyRGF0YSh7IHBvc2l0aW9uLCBvcmllbnRhdGlvblF1YXQsIG9yaWVudGF0aW9uRXVsZXIsIHZvbHVtZVRocmVzaG9sZCwgaGlGaUdhaW4sIHVzZXJBdHRlbnVhdGlvbiwgdXNlclJvbGxvZmYgfTogeyBwb3NpdGlvbj86IFBvaW50M0QsIG9yaWVudGF0aW9uRXVsZXI/OiBPcmllbnRhdGlvbkV1bGVyM0QsIG9yaWVudGF0aW9uUXVhdD86IE9yaWVudGF0aW9uUXVhdDNELCB2b2x1bWVUaHJlc2hvbGQ/OiBudW1iZXIsIGhpRmlHYWluPzogbnVtYmVyLCB1c2VyQXR0ZW51YXRpb24/OiBudW1iZXIsIHVzZXJSb2xsb2ZmPzogbnVtYmVyIH0gPSB7fSk6IHZvaWQge1xuICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbiA9IG5ldyBQb2ludDNEKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnggPSBwb3NpdGlvbi54ID8/IHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLng7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi55ID0gcG9zaXRpb24ueSA/PyB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi55O1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24ueiA9IHBvc2l0aW9uLnogPz8gdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24uejtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcmllbnRhdGlvblF1YXQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0ID0gbmV3IE9yaWVudGF0aW9uUXVhdDNEKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC53ID0gb3JpZW50YXRpb25RdWF0LncgPz8gdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0Lnc7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueCA9IG9yaWVudGF0aW9uUXVhdC54ID8/IHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC54O1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnkgPSBvcmllbnRhdGlvblF1YXQueSA/PyB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC56ID0gb3JpZW50YXRpb25RdWF0LnogPz8gdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0Lno7XG4gICAgICAgIH0gXG4gICAgICAgIC8vIGlmIG9yaWVudGF0aW9uIGlzIHByb3ZpZGVkIGFzIGFuIGV1bGVyIGZvcm1hdCwgdGhlbiBkbyB0aGUgY29udmVyc2lvbiBpbW1lZGlhdGVseVxuICAgICAgICBlbHNlIGlmIChvcmllbnRhdGlvbkV1bGVyKSB7XG4gICAgICAgICAgICBsZXQgY2hlY2tlZEV1bGVyID0gbmV3IE9yaWVudGF0aW9uRXVsZXIzRChvcmllbnRhdGlvbkV1bGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdCA9IGV1bGVyVG9RdWF0ZXJuaW9uKGNoZWNrZWRFdWxlciwgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLmV1bGVyT3JkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiAodm9sdW1lVGhyZXNob2xkKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEudm9sdW1lVGhyZXNob2xkID0gdm9sdW1lVGhyZXNob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGhpRmlHYWluKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEuaGlGaUdhaW4gPSBNYXRoLm1heCgwLCBoaUZpR2Fpbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodXNlckF0dGVudWF0aW9uKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEudXNlckF0dGVudWF0aW9uID0gdXNlckF0dGVudWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHVzZXJSb2xsb2ZmKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEudXNlclJvbGxvZmYgPSBNYXRoLm1heCgwLCB1c2VyUm9sbG9mZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNsaWVudHNpZGUgcmF0ZSBsaW1pdCB0aW1lb3V0IHVzZWQgdG8gcHJldmVudCB1c2VyIGRhdGEgZnJvbSBiZWluZyBzZW50IHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBzZXJ2ZXIgdG9vIG9mdGVuLlxuICAgICAqL1xuICAgIHByaXZhdGUgX21heWJlQ2xlYXJSYXRlTGltaXRUaW1lb3V0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fdGltZXJzLnRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVycy50cmFuc21pdFJhdGVMaW1pdFRpbWVvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdGltZXJzLnRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2Uga2VlcCBhIGNsaWVudHNpZGUgY29weSBvZiB0aGUgZGF0YSB0aGF0IHdlIGxhc3QgdHJhbnNtaXR0ZWQgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIHNlcnZlci4gV2UgdXNlIHRoaXMgZGF0YSB0b1xuICAgICAqIGVuc3VyZSB0aGF0IHdlIG9ubHkgc2VuZCB0byB0aGUgc2VydmVyIHRoZSBtaW5pbXVtIHNldCBvZiBkYXRhIG5lY2Vzc2FyeSAtIGkuZS4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZGF0YSBjb250YWluZWQgb24gdGhlIHNlcnZlclxuICAgICAqIGFib3V0IHRoZSB1c2VyIGFuZCB0aGUgbmV3IGRhdGEgdGhhdCB0aGUgY2xpZW50IGhhcyBsb2NhbGx5LiBXZSB1c2UgdGhpcyBmdW5jdGlvbiBoZXJlIHRvIHVwZGF0ZSB0aGUgY2xpZW50c2lkZSBjb3B5IG9mIHRoZSBkYXRhXG4gICAgICogdGhhdCB3ZSBsYXN0IHRyYW5zbWl0dGVkLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBkYXRhSnVzdFRyYW5zbWl0dGVkIC0gVGhlIGRhdGEgdGhhdCB3ZSBqdXN0IHRyYW5zbWl0dGVkIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBzZXJ2ZXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfdXBkYXRlTGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YShkYXRhSnVzdFRyYW5zbWl0dGVkOiBIaUZpQXVkaW9BUElEYXRhKTogdm9pZCB7XG4gICAgICAgIGlmIChkYXRhSnVzdFRyYW5zbWl0dGVkLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uID0gbmV3IFBvaW50M0QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi54ID0gZGF0YUp1c3RUcmFuc21pdHRlZC5wb3NpdGlvbi54ID8/IHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24ueDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24ueSA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQucG9zaXRpb24ueSA/PyB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnogPSBkYXRhSnVzdFRyYW5zbWl0dGVkLnBvc2l0aW9uLnogPz8gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi56O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGFKdXN0VHJhbnNtaXR0ZWQub3JpZW50YXRpb25RdWF0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQgPSBuZXcgT3JpZW50YXRpb25RdWF0M0QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQudyA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQub3JpZW50YXRpb25RdWF0LncgPz8gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQudztcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnggPSBkYXRhSnVzdFRyYW5zbWl0dGVkLm9yaWVudGF0aW9uUXVhdC54ID8/IHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0Lng7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC55ID0gZGF0YUp1c3RUcmFuc21pdHRlZC5vcmllbnRhdGlvblF1YXQueSA/PyB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC55O1xuICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueiA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQub3JpZW50YXRpb25RdWF0LnogPz8gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQuejtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgKGRhdGFKdXN0VHJhbnNtaXR0ZWQudm9sdW1lVGhyZXNob2xkKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YVtcInZvbHVtZVRocmVzaG9sZFwiXSA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQudm9sdW1lVGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiAoZGF0YUp1c3RUcmFuc21pdHRlZC5oaUZpR2FpbikgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGFbXCJoaUZpR2FpblwiXSA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQuaGlGaUdhaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoZGF0YUp1c3RUcmFuc21pdHRlZC51c2VyQXR0ZW51YXRpb24pID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhW1widXNlckF0dGVudWF0aW9uXCJdID0gZGF0YUp1c3RUcmFuc21pdHRlZC51c2VyQXR0ZW51YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoZGF0YUp1c3RUcmFuc21pdHRlZC51c2VyUm9sbG9mZikgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGFbXCJ1c2VyUm9sbG9mZlwiXSA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQudXNlclJvbGxvZmY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoZGF0YUp1c3RUcmFuc21pdHRlZC5fb3RoZXJVc2VyR2FpblF1ZXVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZih0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWUpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5fb3RoZXJVc2VyR2FpblF1ZXVlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkVG9HYWluIG9mIE9iamVjdC5lbnRyaWVzKGRhdGFKdXN0VHJhbnNtaXR0ZWQuX290aGVyVXNlckdhaW5RdWV1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWVbaWRUb0dhaW5bMF1dID0gaWRUb0dhaW5bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIHRoZSBsb2NhbCB1c2VyIGRhdGEgcHJvcGVybHksIHRoZW4gc2VuZHMgdGhhdCB1c2VyIGRhdGEgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIHNlcnZlci4gVGhpcyB0cmFuc2ZlciBpcyByYXRlIGxpbWl0ZWQuXG4gICAgICogXG4gICAgICogVGhlcmUgaXMgbm8gcmVhc29uIGEgbGlicmFyeSB1c2VyIHdvdWxkIG5lZWQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHdpdGhvdXQgYWxzbyBzaW11bHRhbmVvdXNseSB1cGRhdGluZyBVc2VyIERhdGEsIHNvIHRoaXMgZnVuY3Rpb24gaXMgYHByaXZhdGVgLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBmb3JjZVRyYW5zbWl0IC0gYHRydWVgIGlmIHdlIHNob3VsZCBpZ25vcmUgdGhlIGNsaWVudHNpZGUgcmF0ZSBsaW1pdGVyIGFuZCBzZW5kIHRoZSBkYXRhIHJlZ2FyZGxlc3Mgb2YgaXRzIHN0YXR1czsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICogQHJldHVybnMgSWYgdGhpcyBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bCwgcmV0dXJucyBgeyBzdWNjZXNzOiB0cnVlLCByYXdEYXRhVHJhbnNtaXR0ZWQ6IDx0aGUgcmF3IGRhdGEgdGhhdCB3YXMgdHJhbnNtaXR0ZWQgdG8gdGhlIHNlcnZlcj59YC4gSWYgdW5zdWNjZXNzZnVsLCByZXR1cm5zXG4gICAgICogYHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiA8YW4gZXJyb3IgbWVzc2FnZT4gfWAuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIoZm9yY2VUcmFuc21pdD86IGJvb2xlYW4pOiBhbnkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhIGNhbGxlciBjYW4ndCB0cmFuc21pdCBkYXRhIGZvciBhbm90aGVyIGB0aGlzLnRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dE1TYCBtaWxsaXNlY29uZHMuXG4gICAgICAgIGlmICh0aGlzLl9taXhlclNlc3Npb24gJiYgKCF0aGlzLl90aW1lcnMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0IHx8IGZvcmNlVHJhbnNtaXQpKSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lcnMud2FudGVkVG9UcmFuc21pdEhpRmlBdWRpb0FQSURhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX21heWJlQ2xlYXJSYXRlTGltaXRUaW1lb3V0KCk7XG4gICAgICAgICAgICBpZiAoIWZvcmNlVHJhbnNtaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lcnMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21heWJlQ2xlYXJSYXRlTGltaXRUaW1lb3V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RpbWVycy53YW50ZWRUb1RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzLnRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dE1TKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGF0YSB0byB0cmFuc21pdCwgd2hpY2ggaXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbGFzdCBkYXRhIHdlIHRyYW5zbWl0dGVkXG4gICAgICAgICAgICAvLyBhbmQgdGhlIGN1cnJlbnQgZGF0YSB3ZSBoYXZlIHN0b3JlZC5cbiAgICAgICAgICAgLy8gbGV0IGRlbHRhID0gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5kaWZmKHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhKTtcbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCB0cmFuc2xhdGUgdGhlIG5ldyBgSGlGaUF1ZGlvQVBJRGF0YWAgb2JqZWN0IGZyb20gYWJvdmUgaW50byBzdHJpbmdpZmllZCBKU09OIGRhdGEgaW4gdGhlIHByb3BlciBmb3JtYXQsXG4gICAgICAgICAgICAvLyB0aGVuIHNlbmQgdGhhdCBkYXRhIHRvIHRoZSBtaXhlci5cbiAgICAgICAgICAgIC8vIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmF3IGRhdGEgdGhhdCBpdCBzZW50IHRvIHRoZSBtaXhlci5cbiAgICAgICAgICAgIGxldCB0cmFuc21pdFJldHZhbCA9IHRoaXMuX21peGVyU2Vzc2lvbi5fdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIodGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEsIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEpO1xuICAgICAgICAgICAgaWYgKHRyYW5zbWl0UmV0dmFsLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3cgd2UgaGF2ZSB0byB1cGRhdGUgb3VyIFwibGFzdCB0cmFuc21pdHRlZFwiIGBIaUZpQXVkaW9BUElEYXRhYCBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyB0byBjb250YWluIHRoZSBkYXRhIHRoYXQgd2UganVzdCB0cmFuc21pdHRlZC5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhKHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBpbiBzb21lIGNhc2VzLCBjbGVhbiB1cCBzb21lIG9mIHRoZSB0cmFuc21pdHRlZCBkYXRhIGhpc3RvcnlcbiAgICAgICAgICAgICAgICAvLyAocGFydGljdWxhcmx5LCBfb3RoZXJVc2VyR2FpblF1ZXVlKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFuVXBIaUZpQXVkaW9BUElEYXRhSGlzdG9yeSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmF3RGF0YVRyYW5zbWl0dGVkOiB0cmFuc21pdFJldHZhbC5zdHJpbmdpZmllZERhdGFGb3JNaXhlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdHJhbnNtaXRSZXR2YWwuZXJyb3JcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX21peGVyU2Vzc2lvbiAmJiB0aGlzLl90aW1lcnMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0ICYmICFmb3JjZVRyYW5zbWl0KSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lcnMud2FudGVkVG9UcmFuc21pdEhpRmlBdWRpb0FQSURhdGEgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgVHJhbnNmZXIgaXMgcmF0ZSBsaW1pdGVkLiBUcmFuc2ZlciB3aWxsIG9jY3VyIHNob3J0bHkgYXV0b21hdGljYWxseS5gXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9taXhlclNlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBObyBzZXJ2ZXIgY29ubmVjdGlvbiB5ZXQ7IGNhbid0IHRyYW5zbWl0IHVzZXIgZGF0YS5gXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsbHksIHdlIHRyeSB0byBsaW1pdCB0aGUgYW1vdW50IG9mIGRhdGEgd2UgdHJhbnNtaXQgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIHNlcnZlciwgYnkgcmVtZW1iZXJpbmcgd2hhdCB3ZVxuICAgICAqIHNlbnQuIFNlZSB7QGxpbmsgX3VwZGF0ZVVzZXJEYXRhfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdGhpcyBpcyBkb25lLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBleGlzdHMgdG8gaGFuZGxlIGFueSBzY2VuYXJpb3Mgb2YgcmVtZW1iZXJpbmcgdG9vIG11Y2ggc2VudCBkYXRhLiBJdCBpcyBjYWxsZWQganVzdCBhZnRlciBkYXRhIGlzIHN1Y2Nlc2Z1bGx5IHNlbnQsIHdoZW4gZGF0YSBpcyBrbm93biB0byBubyBsb25nZXIgYmUgbmVlZGVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2NsZWFuVXBIaUZpQXVkaW9BUElEYXRhSGlzdG9yeSgpOiB2b2lkIHtcbiAgICAgICAgLy8gQWx3YXlzIGNsZWFyIF9vdGhlclVzZXJHYWluUXVldWUgaW4gb3VyIGxvY2FsIGRhdGFcbiAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEuX290aGVyVXNlckdhaW5RdWV1ZSA9IHt9O1xuXG4gICAgICAgIGxldCBtYXhDYWNoZWRPdGhlclVzZXJHYWlucyA9IDEwMDA7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWUpLmxlbmd0aCA+IG1heENhY2hlZE90aGVyVXNlckdhaW5zKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWUgPSB7fTtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgU3RvcmVkIFxcYF9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWVcXGAgd2FzIHRvbyBsYXJnZSBhbmQgd2FzIGNsZWFyZWQgdG8gc2F2ZSBzcGFjZS5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGZ1bmN0aW9uIHRoYXQgY2FsbHMge0BsaW5rIF91cGRhdGVVc2VyRGF0YX0sIGZvbGxvd2VkIGJ5IHtAbGluayBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXJ9LlxuICAgICAqIERldmVsb3BlcnMgY2FuIGNhbGwgdGhpcyBmdW5jdGlvbiBhcyBvZnRlbiBhcyB0aGV5IHdhbnQuIFRoaXMgZnVuY3Rpb24gd2lsbCB1cGRhdGUgdGhlIGludGVybmFsIGRhdGEgc3RvcmUgb2YgdGhlIHVzZXInc1xuICAgICAqIHBvc2l0aW9uLCBvcmllbnRhdGlvbiwgZXRjLiBObyBtYXR0ZXIgaG93IG9mdGVuIGRldmVsb3BlcnMgY2FsbCB0aGlzIGZ1bmN0aW9uLCB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSB0cmFuc21pc3Npb24gaXMgcmF0ZS1saW1pdGVkXG4gICAgICogYW5kIHdpbGwgb25seSBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIgb25jZSBldmVyeSBgdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVNgIG1pbGxpc2Vjb25kcy4gV2hlbiB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSBpcyB0cmFuc21pdHRlZCxcbiAgICAgKiB0aGUgbW9zdCB1cC10by1kYXRlIGRhdGEgd2lsbCBiZSB0cmFuc21pdHRlZC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gbmV3VXNlckRhdGEgLSBUaGUgbmV3IHVzZXIgZGF0YSB0aGF0IHdlIHdhbnQgdG8gc2VuZCB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgc2VydmVyLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHJldHVybiB2YWx1ZSBvZiB7QGxpbmsgX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyfS5cbiAgICAgKi9cbiAgICB1cGRhdGVVc2VyRGF0YUFuZFRyYW5zbWl0KG5ld1VzZXJEYXRhOiBhbnkpOiBzdHJpbmcge1xuICAgICAgICB0aGlzLl91cGRhdGVVc2VyRGF0YShuZXdVc2VyRGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5nZXN0cyB1c2VyIGRhdGEgdXBkYXRlcyBmcm9tIHRoZSBzZXJ2ZXIgYW5kLCBpZiByZWxldmFudCwgY2FsbHMgdGhlIHJlbGV2YW50IGNhbGxiYWNrIGZ1bmN0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogVXNlciBEYXRhIFN1YnNjcmlwdGlvbnMuIFNlZSB7QGxpbmsgYWRkVXNlckRhdGFTdWJzY3JpcHRpb259LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBuZXdVc2VyRGF0YUZyb21TZXJ2ZXIgLSBDb250YWlucyBhbGwgb2YgdGhlIG5ldyB1c2VyIGRhdGEgbW9zdCByZWNlbnRseSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuIFxuICAgICAqL1xuICAgIHByaXZhdGUgX2hhbmRsZVVzZXJEYXRhVXBkYXRlcyhuZXdVc2VyRGF0YUZyb21TZXJ2ZXI6IEFycmF5PFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YT4pOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX3VzZXJEYXRhU3Vic2NyaXB0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHN1Ykl0ciA9IDA7IHN1Ykl0ciA8IHRoaXMuX3VzZXJEYXRhU3Vic2NyaXB0aW9ucy5sZW5ndGg7IHN1Ykl0cisrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuX3VzZXJEYXRhU3Vic2NyaXB0aW9uc1tzdWJJdHJdO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBib3RoZXIgY29udGludWluZyB0byBkbyBhbnl0aGluZyBpZiB0aGUgZGV2ZWxvcGVyIGRpZG4ndCBzcGVjaWZ5IGEgY2FsbGJhY2sgYXNzb2NpYXRlZFxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgY3VycmVudCBTdWJzY3JpcHRpb24gdGhhdCB3ZSBhcmUgcHJvY2Vzc2luZy5cbiAgICAgICAgICAgIGlmICghY3VycmVudFN1YnNjcmlwdGlvbi5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY3VycmVudFN1YnNjcmlwdGlvbkNhbGxiYWNrRGF0YTogQXJyYXk8UmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhPiA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBkYXRhSXRyID0gMDsgZGF0YUl0ciA8IG5ld1VzZXJEYXRhRnJvbVNlcnZlci5sZW5ndGg7IGRhdGFJdHIrKykge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50RGF0YUZyb21TZXJ2ZXIgPSBuZXdVc2VyRGF0YUZyb21TZXJ2ZXJbZGF0YUl0cl07XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN1YnNjcmlwdGlvbi5wcm92aWRlZFVzZXJJRCAmJiBjdXJyZW50RGF0YUZyb21TZXJ2ZXIucHJvdmlkZWRVc2VySUQgIT09IGN1cnJlbnRTdWJzY3JpcHRpb24ucHJvdmlkZWRVc2VySUQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IG5ld0NhbGxiYWNrRGF0YSA9IG5ldyBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnREYXRhRnJvbVNlcnZlci5wcm92aWRlZFVzZXJJRCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tEYXRhLnByb3ZpZGVkVXNlcklEID0gY3VycmVudERhdGFGcm9tU2VydmVyLnByb3ZpZGVkVXNlcklEO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnREYXRhRnJvbVNlcnZlci5oYXNoZWRWaXNpdElEKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBuZXdDYWxsYmFja0RhdGEuaGFzaGVkVmlzaXRJRCA9IGN1cnJlbnREYXRhRnJvbVNlcnZlci5oYXNoZWRWaXNpdElEO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBzaG91bGRQdXNoTmV3Q2FsbGJhY2tEYXRhID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb21wb25lbnRJdHIgPSAwOyBjb21wb25lbnRJdHIgPCBjdXJyZW50U3Vic2NyaXB0aW9uLmNvbXBvbmVudHMubGVuZ3RoOyBjb21wb25lbnRJdHIrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudENvbXBvbmVudCA9IGN1cnJlbnRTdWJzY3JpcHRpb24uY29tcG9uZW50c1tjb21wb25lbnRJdHJdO1xuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY3VycmVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHMuUG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREYXRhRnJvbVNlcnZlci5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxsYmFja0RhdGEucG9zaXRpb24gPSBjdXJyZW50RGF0YUZyb21TZXJ2ZXIucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFB1c2hOZXdDYWxsYmFja0RhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHMuT3JpZW50YXRpb25RdWF0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RGF0YUZyb21TZXJ2ZXIub3JpZW50YXRpb25RdWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrRGF0YS5vcmllbnRhdGlvblF1YXQgPSBjdXJyZW50RGF0YUZyb21TZXJ2ZXIub3JpZW50YXRpb25RdWF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQdXNoTmV3Q2FsbGJhY2tEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cy5PcmllbnRhdGlvbkV1bGVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSBldWxlciB2ZXJzaW9uIG9mIG9yaWVudGF0aW9uIGlmIHF1YXQgdmVyc2lvbiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudERhdGFGcm9tU2VydmVyLm9yaWVudGF0aW9uUXVhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxsYmFja0RhdGEub3JpZW50YXRpb25FdWxlciA9IGV1bGVyRnJvbVF1YXRlcm5pb24oY3VycmVudERhdGFGcm9tU2VydmVyLm9yaWVudGF0aW9uUXVhdCwgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLmV1bGVyT3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQdXNoTmV3Q2FsbGJhY2tEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXZhaWxhYmxlVXNlckRhdGFTdWJzY3JpcHRpb25Db21wb25lbnRzLlZvbHVtZURlY2liZWxzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnREYXRhRnJvbVNlcnZlci52b2x1bWVEZWNpYmVscykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tEYXRhLnZvbHVtZURlY2liZWxzID0gY3VycmVudERhdGFGcm9tU2VydmVyLnZvbHVtZURlY2liZWxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQdXNoTmV3Q2FsbGJhY2tEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXZhaWxhYmxlVXNlckRhdGFTdWJzY3JpcHRpb25Db21wb25lbnRzLklzU3RlcmVvOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnREYXRhRnJvbVNlcnZlci5pc1N0ZXJlbykgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrRGF0YS5pc1N0ZXJlbyA9IGN1cnJlbnREYXRhRnJvbVNlcnZlci5pc1N0ZXJlbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkUHVzaE5ld0NhbGxiYWNrRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFB1c2hOZXdDYWxsYmFja0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN1YnNjcmlwdGlvbkNhbGxiYWNrRGF0YS5wdXNoKG5ld0NhbGxiYWNrRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFN1YnNjcmlwdGlvbi5jYWxsYmFjayAmJiBjdXJyZW50U3Vic2NyaXB0aW9uQ2FsbGJhY2tEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3Vic2NyaXB0aW9uLmNhbGxiYWNrKGN1cnJlbnRTdWJzY3JpcHRpb25DYWxsYmFja0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBmdW5jdGlvbiBjYWxsZWQgYnkgb3VyIGluc3RhbnRpYXRpb24gb2YgYEhpRmlNaXhlclNlc3Npb25gIHRoYXQgY2FsbHMgdGhlIHVzZXItcHJvdmlkZWQgYG9uVXNlcnNEaXNjb25uZWN0ZWQoKWBcbiAgICAgKiBmdW5jdGlvbiBpZiBvbmUgZXhpc3RzLlxuICAgICAqIExpYnJhcnkgdXNlcnMgY2FuIHByb3ZpZGUgYW4gYG9uVXNlcnNEaXNjb25uZWN0ZWQoKWAgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBgSGlGaUNvbW11bmljYXRvcmAgb2JqZWN0LCBvciBieSBzZXR0aW5nXG4gICAgICogYEhpRmlDb21tdW5pY2F0b3Iub25Vc2Vyc0Rpc2Nvbm5lY3RlZGAgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAgICAgKiBAcGFyYW0gdXNlcnNEaXNjb25uZWN0ZWQgLSBBbiBBcnJheSBvZiB7QGxpbmsgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhfSByZWdhcmRpbmcgdGhlIHVzZXJzIHdobyBkaXNjb25uZWN0ZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfb25Vc2Vyc0Rpc2Nvbm5lY3RlZCh1c2Vyc0Rpc2Nvbm5lY3RlZDogQXJyYXk8UmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhPik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5vblVzZXJzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uVXNlcnNEaXNjb25uZWN0ZWQodXNlcnNEaXNjb25uZWN0ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBVc2VyIERhdGEgU3Vic2NyaXB0aW9uIHRvIHRoZSBsaXN0IG9mIGNsaWVudHNpZGUgU3Vic2NyaXB0aW9ucy4gVXNlciBEYXRhIFN1YnNjcmlwdGlvbnMgYXJlIHVzZWQgdG8gb2J0YWluXG4gICAgICogVXNlciBEYXRhIGFib3V0IG90aGVyIFVzZXJzLiBGb3IgZXhhbXBsZSwgaWYgeW91IHNldCB1cCBhIFVzZXIgRGF0YSBTdWJzY3JpcHRpb24gZm9yIHlvdXIgb3duIFVzZXIgRGF0YSwgeW91IGNhbiB1c2UgdGhhdCBzdWJzY3JpcHRpb24gXG4gICAgICogdG8gZW5zdXJlIHRoYXQgdGhlIGRhdGEgb24gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIFNlcnZlciBpcyB0aGUgc2FtZSBhcyB0aGUgZGF0YSB5b3UgYXJlIHNlbmRpbmdcbiAgICAgKiB0byBpdCBmcm9tIHRoZSBjbGllbnQuIFxuICAgICAqIFxuICAgICAqIFRvIGNoZWNrIGlmIGEgdXNlciBoYXMgZGlzY29ubmVjdGVkLCB1c2Uge0BsaW5rIEhpRmlDb21tdW5pY2F0b3Iub25Vc2Vyc0Rpc2Nvbm5lY3RlZH0uXG4gICAgICogXG4gICAgICogQHBhcmFtIG5ld1N1YnNjcmlwdGlvbiAtIFRoZSBuZXcgVXNlciBEYXRhIFN1YnNjcmlwdGlvbiBhc3NvY2lhdGVkIHdpdGggYSB1c2VyLiBcbiAgICAgKi9cbiAgICBhZGRVc2VyRGF0YVN1YnNjcmlwdGlvbihuZXdTdWJzY3JpcHRpb246IFVzZXJEYXRhU3Vic2NyaXB0aW9uKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5fbWl4ZXJTZXNzaW9uKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBObyBcXGBfbWl4ZXJTZXNzaW9uXFxgISBEYXRhIHN1YnNjcmlwdGlvbiBub3QgYWRkZWQuYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWl4ZXJTZXNzaW9uLnVzZXJEYXRhU3RyZWFtaW5nU2NvcGUgPT09IEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3Blcy5Ob25lKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBEdXJpbmcgXFxgSGlGaUNvbW11bmljYXRvclxcYCBjb25zdHJ1Y3Rpb24sIHRoZSBzZXJ2ZXIgd2FzIHNldCB1cCB0byAqKm5vdCoqIHNlbmQgdXNlciBkYXRhISBEYXRhIHN1YnNjcmlwdGlvbiBub3QgYWRkZWQuYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgQWRkaW5nIG5ldyBVc2VyIERhdGEgU3Vic2NyaXB0aW9uOlxcbiR7SlNPTi5zdHJpbmdpZnkobmV3U3Vic2NyaXB0aW9uKX1gKTtcbiAgICAgICAgdGhpcy5fdXNlckRhdGFTdWJzY3JpcHRpb25zLnB1c2gobmV3U3Vic2NyaXB0aW9uKTtcbiAgICB9XG59XG4iLCIvKipcbiAqIENvZGUgaW4gdGhpcyBtb2R1bGUgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBbW0hpRmlDb21tdW5pY2F0b3JdXSBvYmplY3QgdG8gbWFuYWdlIHRoZSBjb25uZWN0aW9uIGJldHdlZW4gY2xpZW50IGFuZCBzZXJ2ZXIuXG4gKiBEZXZlbG9wZXJzIGRvIG5vdCBuZWVkIHRvIGFuZCBzaG91bGQgbm90IGNvbnNpZGVyIHRoaXMgbW9kdWxlIHdoZW4gd3JpdGluZyB0aGVpciBhcHBsaWNhdGlvbnMuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG5pbXBvcnQgeyBIaUZpQXVkaW9BUElEYXRhLCBPcmllbnRhdGlvblF1YXQzRCwgUG9pbnQzRCwgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhLCBPdGhlclVzZXJHYWluTWFwIH0gZnJvbSBcIi4vSGlGaUF1ZGlvQVBJRGF0YVwiO1xuaW1wb3J0IHsgSGlGaUxvZ2dlciB9IGZyb20gXCIuLi91dGlsaXRpZXMvSGlGaUxvZ2dlclwiO1xuaW1wb3J0IHsgSGlGaUNvbm5lY3Rpb25TdGF0ZXMsIEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3BlcyB9IGZyb20gXCIuL0hpRmlDb21tdW5pY2F0b3JcIjtcblxuaW1wb3J0IHsgUmF2aVV0aWxzIH0gZnJvbSBcIi4uL2xpYnJhdmkvUmF2aVV0aWxzXCI7XG5pbXBvcnQgeyBSYXZpU2Vzc2lvbiwgUmF2aVNlc3Npb25TdGF0ZXMsIFdlYlJUQ1Nlc3Npb25QYXJhbXMsIEN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnIH0gZnJvbSBcIi4uL2xpYnJhdmkvUmF2aVNlc3Npb25cIjtcbmltcG9ydCB7IFJhdmlTaWduYWxpbmdDb25uZWN0aW9uLCBSYXZpU2lnbmFsaW5nU3RhdGVzIH0gZnJvbSBcIi4uL2xpYnJhdmkvUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25cIjtcbmltcG9ydCB7IEhpRmlBeGlzVXRpbGl0aWVzLCBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi9IaUZpQXhpc0NvbmZpZ3VyYXRpb25cIjtcbmltcG9ydCB7IERpYWdub3N0aWNzIH0gZnJvbSBcIi4uL2RpYWdub3N0aWNzL2RpYWdub3N0aWNzXCI7XG5jb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpO1xuXG5jb25zdCBJTklUX1RJTUVPVVRfTVMgPSA1MDAwO1xuY29uc3QgUEVSU09OQUxfVk9MVU1FX0FESlVTVF9USU1FT1VUX01TID0gNTAwMDtcblxuaW50ZXJmYWNlIEF1ZGlvbmV0U2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlIHtcbiAgICBzdWNjZXNzOiBib29sZWFuLFxuICAgIHJlYXNvbj86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb25SZXNwb25zZSB7XG4gICAgc3VjY2VzczogYm9vbGVhbixcbiAgICBlcnJvcj86IHN0cmluZyxcbiAgICBhdWRpb25ldFNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb25SZXNwb25zZT86IEF1ZGlvbmV0U2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlXG59XG5cbmV4cG9ydCB0eXBlIFNldE90aGVyVXNlckdhaW5Gb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlID0gU2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlO1xuXG4vKipcbiAqIFRoaXMgZW51bSBzdHJpbmcgcmVwcmVzZW50cyB0aGUgcmVhc29uIHRoZSBjbGllbnQncyBtdXRlIHN0YXRlIGhhcyB1cGRhdGVkLlxuICogU2VlIHtAbGluayBPbk11dGVDaGFuZ2VkQ2FsbGJhY2t9IGZvciBob3cgdGhpcyBpcyB1c2VkLlxuICpcbiAqIHtAbGluayBNdXRlUmVhc29uLkNMSUVOVH0gaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBjbGllbnQgaGFzIGF0dGVtcHRlZCB0byBjaGFuZ2UgdGhlIG11dGUgc3RhdGUgdXNpbmcge0BsaW5rIEhpRmlDb21tdW5pY2F0b3Iuc2V0SW5wdXRBdWRpb011dGVkfVxuICpcbiAqIHtAbGluayBNdXRlUmVhc29uLkFETUlOfSBpcyB1c2VkIHRvIGluZGljYXRlIHRoYXQgdGhlIHNlcnZlciBoYXMgY2hhbmdlZCB0aGUgY2xpZW50J3MgbXV0ZSBzdGF0ZS5cbiAqXG4gKiB7QGxpbmsgTXV0ZVJlYXNvbi5JTlRFUk5BTH0gaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBjbGllbnQncyBtdXRlIHN0YXRlIGhhcyBjaGFuZ2VkIGR1ZSB0byBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgdGhlIHNwYXRpYWwgYXVkaW8gQVBJLCBmb3IgZXhhbXBsZSB0byBrZWVwIHRoZSBzdGF0ZSBvZiB0aGUgY2xpZW50IGNvbnNpc3RlbnQgd2l0aCB0aGUgc2VydmVyLlxuKi9cbmV4cG9ydCBlbnVtIE11dGVSZWFzb24ge1xuICAgIENMSUVOVCA9IFwiY2xpZW50XCIsXG4gICAgQURNSU4gPSBcImFkbWluXCIsXG4gICAgSU5URVJOQUwgPSBcImludGVybmFsXCJcbn1cblxuLyoqXG4gKiBUaGlzIGV2ZW50IG9iamVjdCBkZXNjcmliZXMgaG93IGFuZCB3aHkgdGhlIG11dGUgc3RhdGUgb2YgdGhlIGNsaWVudCBoYXMgY2hhbmdlZC4gSXQgaXMgcGFzc2VkIGluIGFzIGEgcGFyYW1ldGVyIHRvIHtAbGluayBPbk11dGVDaGFuZ2VkQ2FsbGJhY2t9LlxuKi9cbmV4cG9ydCBjbGFzcyBNdXRlQ2hhbmdlZEV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGhlIG11dGUgc3RhdGUgd2FzIHNldCBzdWNjZXNzZnVsbHkuXG4gICAgICogVGhpcyBtYXkgYmUgYGZhbHNlYCBpZiB0aGUgY2xpZW50IGlzIHRyeWluZyB0byB1bm11dGUgdGhlbXNlbHZlcyB3aGVuIG11dGVkIGJ5IGFuIGFkbWluLCBvciBpZiB0aGVyZSB3YXMgYSBmYWlsdXJlIHNldHRpbmcgdGhlIG11dGUgc3RhdGUgb2YgdGhlIGlucHV0IGRldmljZS5cbiAgICAqL1xuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBtdXRlZCB2YWx1ZSB0aGF0IHdvdWxkIGhhdmUgYmVlbiBzZXQgaWYgdGhlIG11dGUgc3RhdGUgd2FzIHNldCBzdWNjZXNmdWxseS5cbiAgICAgKiBgdHJ1ZWAgbWVhbnMgbXV0ZWQsIGBmYWxzZWAgbWVhbnMgdW5tdXRlZC5cbiAgICAqL1xuICAgIHRhcmdldElucHV0QXVkaW9NdXRlZFZhbHVlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgY3VycmVudCBtdXRlZCB2YWx1ZSBhZnRlciBhdHRlbXB0aW5nIHRvIHNldCBtdXRlIHN0YXRlLlxuICAgICAqIGB0cnVlYCBtZWFucyBtdXRlZCwgYGZhbHNlYCBtZWFucyB1bm11dGVkLlxuICAgICovXG4gICAgY3VycmVudElucHV0QXVkaW9NdXRlZFZhbHVlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IHByZXZlbnRlZCBmcm9tIHVubXV0aW5nIHVzaW5nIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLnNldElucHV0QXVkaW9NdXRlZH0uXG4gICAgKi9cbiAgICBhZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgcmVhc29uIHRoZSBtdXRlIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICovXG4gICAgbXV0ZVJlYXNvbjogTXV0ZVJlYXNvbjtcblxuICAgIGNvbnN0cnVjdG9yKHsgc3VjY2VzcywgdGFyZ2V0SW5wdXRBdWRpb011dGVkVmFsdWUsIGN1cnJlbnRJbnB1dEF1ZGlvTXV0ZWRWYWx1ZSwgYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZywgbXV0ZVJlYXNvbiB9OiB7IHN1Y2Nlc3M6IGJvb2xlYW4sIHRhcmdldElucHV0QXVkaW9NdXRlZFZhbHVlOiBib29sZWFuLCBjdXJyZW50SW5wdXRBdWRpb011dGVkVmFsdWU6IGJvb2xlYW4sIGFkbWluUHJldmVudHNJbnB1dEF1ZGlvVW5tdXRpbmc6IGJvb2xlYW4sIG11dGVSZWFzb246IE11dGVSZWFzb24gfSkge1xuICAgICAgICB0aGlzLnN1Y2Nlc3MgPSBzdWNjZXNzO1xuICAgICAgICB0aGlzLnRhcmdldElucHV0QXVkaW9NdXRlZFZhbHVlID0gdGFyZ2V0SW5wdXRBdWRpb011dGVkVmFsdWU7XG4gICAgICAgIHRoaXMuY3VycmVudElucHV0QXVkaW9NdXRlZFZhbHVlID0gY3VycmVudElucHV0QXVkaW9NdXRlZFZhbHVlO1xuICAgICAgICB0aGlzLmFkbWluUHJldmVudHNJbnB1dEF1ZGlvVW5tdXRpbmcgPSBhZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nO1xuICAgICAgICB0aGlzLm11dGVSZWFzb24gPSBtdXRlUmVhc29uO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBbiBgb25NdXRlQ2hhbmdlZGAgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCB0aGlzIHNpZ25hdHVyZSBjYW4gYmUgcHJvdmlkZWQgdG8ge0BsaW5rIEhpRmlDb21tdW5pY2F0b3IuY29uc3RydWN0b3J9LiBUaGUgZnVuY3Rpb24geW91IHByb3ZpZGUgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIG11dGUgc3RhdGUgb2YgdGhlIGNsaWVudCBtYXkgaGF2ZSB1cGRhdGVkLlxuICpcbiAqIE9uZSBzaXR1YXRpb24gd2hlcmUgdGhpcyBpcyB1c2VmdWwgaXMgd2hlbiB0aGUgY2xpZW50J3MgbXV0ZSBzdGF0ZSBoYXMgYmVlbiBjaGFuZ2VkIGJ5IGFuIGFkbWluLCBpLmUuIHdoZW4ge0BsaW5rIE11dGVDaGFuZ2VkRXZlbnQubXV0ZVJlYXNvbn0gaXMge0BsaW5rIE11dGVSZWFzb24uQURNSU59LiBJZiB7QGxpbmsgTXV0ZUNoYW5nZWRFdmVudC5hZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nfSBpcyBgdHJ1ZWAsIHRoZW4gdGhlIGNsaWVudCBpcyBtdXRlZCwgYW5kIGlzIHByZXZlbnRlZCBmcm9tIHVubXV0aW5nIHdoZW4gdXNpbmcge0BsaW5rIEhpRmlDb21tdW5pY2F0b3Iuc2V0SW5wdXRBdWRpb011dGVkfS4gSWYge0BsaW5rIE11dGVDaGFuZ2VkRXZlbnQuYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZ30gaXMgYGZhbHNlYCwgdGhlbiB0aGUgY2xpZW50IGlzIG5vIGxvbmdlciBwcmV2ZW50ZWQgZnJvbSB1bm11dGluZywgYnV0IGlzIG5vdCBhdXRvbWF0aWNhbGx5IHVubXV0ZWQuIFRoZSBjbGllbnQgaXMgYWxsb3dlZCB0byBtdXRlIHRoZW1zZWxmIGF0IGFueSB0aW1lIHJlZ2FyZGxlc3Mgb2YgdGhlIGN1cnJlbnQgbXV0ZSBzdGF0ZS5cbiAqXG4gKiBJZiB7QGxpbmsgTXV0ZUNoYW5nZWRFdmVudC5tdXRlUmVhc29ufSBpcyBlcXVhbCB0byB7QGxpbmsgTXV0ZVJlYXNvbi5DTElFTlR9LCB0aGUgY2xpZW50IGF0dGVtcHRlZCB0byBzZXQgdGhlIG11dGUgc3RhdGUgdGhyb3VnaCB7QGxpbmsgSGlGaUNvbW11bmljYXRvci5zZXRJbnB1dEF1ZGlvTXV0ZWR9LlxuICpcbiAqIElmIHtAbGluayBNdXRlQ2hhbmdlZEV2ZW50Lm11dGVSZWFzb259IGlzIGVxdWFsIHRvIHtAbGluayBNdXRlUmVhc29uLklOVEVSTkFMfSwgdGhlIGNsaWVudCdzIG11dGUgc3RhdGUgaGFzIGNoYW5nZWQgZHVlIHRvIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiB0aGUgc3BhdGlhbCBhdWRpbyBBUEksIGZvciBleGFtcGxlIHRvIGtlZXAgdGhlIHN0YXRlIG9mIHRoZSBjbGllbnQgY29uc2lzdGVudCB3aXRoIHRoZSBzZXJ2ZXIuXG4gKlxuICogVGhpcyBjYWxsYmFjayBjYW4gYWxzbyBiZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGUgY2xpZW50IGlzIG11dGVkIGFuZCBkaXNwbGF5IHRoaXMgaW4gdGhlIGNsaWVudCBVSSwgYW5kIGNhbiBhbHNvIGJlIHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy4gVGhlIG11dGUgc3RhdGUgb2YgdGhlIGNsaWVudCBtYXkgbm90IGhhdmUgY2hhbmdlZCBhZnRlciB0aGlzIGNhbGxiYWNrLlxuKi9cbmV4cG9ydCB0eXBlIE9uTXV0ZUNoYW5nZWRDYWxsYmFjayA9IChtdXRlQ2hhbmdlZEV2ZW50OiBNdXRlQ2hhbmdlZEV2ZW50KSA9PiB2b2lkO1xuXG4vKipcbiAqIEluc3RhbnRpYXRpb25zIG9mIHRoaXMgY2xhc3MgY29udGFpbiBkYXRhIGFib3V0IGEgY29ubmVjdGlvbiBiZXR3ZWVuIGEgY2xpZW50IGFuZCBhIG1peGVyLlxuICogQ2xpZW50IGxpYnJhcnkgdXNlcnMgc2hvdWxkbid0IGhhdmUgdG8gY2FyZSBhdCBhbGwgYWJvdXQgdGhlIHZhcmlhYmxlcyBhbmQgbWV0aG9kcyBjb250YWluZWQgaW4gdGhpcyBjbGFzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEhpRmlNaXhlclNlc3Npb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBSQVZJIFNpZ25hbGluZyBDb25uZWN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE1peGVyIFNlc3Npb24uXG4gICAgICovXG4gICAgcHJpdmF0ZSBfcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb246IFJhdmlTaWduYWxpbmdDb25uZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIFRoZSBSQVZJIFNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgTWl4ZXIgU2Vzc2lvbi5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9yYXZpU2Vzc2lvbjogUmF2aVNlc3Npb247XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGN1cnJlbnQgSGlGaSBDb25uZWN0aW9uIFN0YXRlLCB3aGljaCBpcyBhbiBhYnN0cmFjdGlvbiBzZXBhcmF0ZSBmcm9tIHRoZSBSQVZJIFNlc3Npb24gU3RhdGUgYW5kIFJBVkkgU2lnbmFsaW5nIFN0YXRlLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2N1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlOiBIaUZpQ29ubmVjdGlvblN0YXRlcztcblxuICAgIC8qKlxuICAgICAqIFVzZWQgd2hlbiBtdXRpbmcgYW5kIHVubXV0aW5nIHRvIHNhdmUgdGhlIHN0YXRlIG9mIHRoZSB1c2VyJ3MgaW5wdXQgZGV2aWNlJ3MgYE1lZGlhVHJhY2tDb25zdHJhaW50c2AuXG4gICAgICogV2hlbiBhIHVzZXIgbXV0ZXMsIHdlIGV4cGxpY2l0bHkgY2FsbCBgc3RvcCgpYCBvbiBhbGwgYXVkaW8gdHJhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlcidzIGlucHV0IGRldmljZS5cbiAgICAgKiBXaGVuIGEgdXNlciB1bm11dGVzLCB3ZSBtdXN0IGNhbGwgYGdldFVzZXJNZWRpYSgpYCB0byByZS1vYnRhaW4gdGhvc2UgYXVkaW8gdHJhY2tzLiBXZSB3YW50IHRvIGNhbGwgYGdldFVzZXJNZWRpYSgpYFxuICAgICAqIHdpdGggdGhlIHNhbWUgY29uc3RyYWludHMgdXNlZCBieSB0aGUgYXBwbGljYXRpb24gd2hlbiBfaXRfIGZpcnN0IGNhbGxzIGBnZXRVc2VyTWVkaWEoKWAuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfY2FjaGVkTWVkaWFUcmFja0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHM7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIHJlY2VpdmUgcGVlciBkYXRhIGZyb20gdGhlIHNlcnZlciwgaXQncyBpbiBhIGZvcm1hdCBsaWtlIHRoaXM6XG4gICAgICoge1xuICAgICAqICAgICAzMTg6IHtjOiBcIiM1ZGYxZjVcIiwgZDogXCJIb3dhcmRcIiwgZTogXCI4NzNjNGQ0My1jY2Q5LTRjZTQtOWFjNy1kNWZhZGU0ZGVmOTI5YVwiLCBpOiBcIntmMGNlMjJiYi04YjY3LTQwNDQtYThjNS02NWFlZmJjZTQwNjB9XCIsIG86IDAsIOKApn1cbiAgICAgKiAgICAgMzQxOiB7ZTogXCI5YzVhZjQ0Yi03ZTNmLThmNjUtNTQyMS0zNzRiNDNiZWJjNGFcIiwgaTogXCJ7YmUzOGEyNTYtODUwYS00YzhkLWJkZGQtY2ZlODBhYWRkZmU5fVwiLCBvOiAwLCBwOiB0cnVlLCB2OiAtMTIwLCDigKZ9XG4gICAgICogfVxuICAgICAqIFRoZSBwZWVyIGRhdGEgZG9lcyBub3QgYWx3YXlzIGNvbnRhaW4gYWxsIHBvc3NpYmxlIGtleS92YWx1ZSBwYWlycyBhc3NvY2lhdGVkIHdpdGggZWFjaCBrZXkgaW4gdGhpcyBPYmplY3QuIEluIGZhY3QsIG1vc3Qgb2YgdGhlIHRpbWUsIGl0IGNvbnRhaW5zXG4gICAgICogb25seSBhIGZyYWN0aW9uIG9mIHRoZSBkYXRhLiBGb3IgZXhhbXBsZSwgd2UgbWlnaHQgcmVjZWl2ZSBgeyAzNDE6IHt2OiAtNDB9IH1gIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKiBXaGVuIHRoZSBIaUZpIEF1ZGlvIExpYnJhcnkgdXNlciBzZXRzIHVwIGEgVXNlciBEYXRhIFN1YnNjcmlwdGlvbiwgdGhleSBjYW4gb3B0aW9uYWxseSBhc3NvY2lhdGUgdGhlIFN1YnNjcmlwdGlvbiB3aXRoIGEgXCJQcm92aWRlZCBVc2VyIElEXCIuXG4gICAgICogU2luY2UgdGhlIHNlcnZlciBkb2Vzbid0IGFsd2F5cyBzZW5kIHRoZSBcIlByb3ZpZGVkIFVzZXIgSURcIiBpbiB0aGVzZSBwZWVyIHVwZGF0ZXMsIHdlIGhhdmUgdG8ga2VlcCB0cmFjayBvZiB0aGUgKHByZXN1bWFibHkgc3RhYmxlKSBrZXkgaW4gYGpzb25EYXRhLnBlZXJzYFxuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGF0IFwiUHJvdmlkZWQgVXNlciBJRFwiIGluIG9yZGVyIHRvIGZvcndhcmQgdGhhdCBcIlByb3ZpZGVkIFVzZXIgSURcIiB0byB0aGUgU3Vic2NyaXB0aW9uIGhhbmRsZXIgYW5kIHRodXMgdG8gdGhlIExpYnJhcnkgdXNlci5cbiAgICAgKiBcbiAgICAgKiBBbmQgc2luY2Ugd2UgYXJlIGNhY2hpbmcgdGhhdCBvbmUgdmFsdWUsIHdlIGFyZSBhbHNvIGNhY2hpbmcgdGhlIGZ1bGwgc3RhdGUgZm9yIGFsbCBrbm93biBwZWVycy5cbiAgICAgKiBUaGlzIGFsbG93cyB1cyB0byBvcHRpbWl6ZSB0aGUgcmVjZWl2ZWQgc3RyZWFtIG9mIGNoYW5nZWQgZGF0YSBmb3IgYSBnaXZlbiBwZWVyIGZyb20gdGhlIHNlcnZlciB0byBqdXN0IHRoZSBuZWNlc3NhcnkgYml0c1xuICAgICAqIGFuZCByZWNvbnN0cnVjdCB0aGUgY29tcGxldGUgaW5mb3JtYXRpb24gd2l0aCB0aGUga25vd2xlZGdlIG9mIHRoZSBjYWNoZWQgc3RhdGUgb2YgdGhhdGEgcGVlci5cbiAgICAgKiBPbmUgY2F2ZWF0LCB0aGUgcG9zaXRpb24gYW5kIG9yaWVuYXRpb25RdWF0IGZpZWxkcyBjYWNoZWQgZm9yIGEgcGVlciBhcmUgZXhwcmVzc2VkIGluIHRoZSAnTWl4ZXJTcGFjZScsIG5vdCB0cmFuc2Zvcm1lZCB5ZXQgaW4gdGhlICdDbGllbnRVc2VyU3BhY2UnLlxuICAgICAqIFxuICAgICAqIFRodXMsIHRoZSBMaWJyYXJ5IHVzZXIgc2hvdWxkIG5ldmVyIGhhdmUgdG8gY2FyZSBhYm91dCB0aGUgYF9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0YC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0OiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBXZSB3aWxsIHRyYWNrIHdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBzdHJlYW0gaXMgc3RlcmVvLCBzbyB0aGF0XG4gICAgICogd2UgY2FuIGFkdmlzZSB0aGUgc2VydmVyIHRvIG1peCBpdCBhcHByb3ByaWF0ZWx5XG4gICAgICovXG4gICAgcHJpdmF0ZSBfaW5wdXRBdWRpb01lZGlhU3RyZWFtSXNTdGVyZW86IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIF9hZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nOiBib29sZWFuO1xuICAgIHByaXZhdGUgX2xhc3RTdWNjZXNzZnVsSW5wdXRBdWRpb011dGVkVmFsdWU6IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIG9uTXV0ZUNoYW5nZWQ6IE9uTXV0ZUNoYW5nZWRDYWxsYmFjaztcblxuICAgIC8qKlxuICAgICAqIE9ubHkgdmFsaWQgZm9yIHVzZXJzIGNvdmVyZWQgYnkgYSB1c2VyIGRhdGEgc3Vic2NyaXB0aW9uLiBSZW1haW5zIGNvbnN0YW50IGF0IGRpc2Nvbm5lY3QgdW50aWwgdGhlIG5leHQgY29ubmVjdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29uY3VycmVuY3k6bnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBXZWJSVEMgU3RhdHMgT2JzZXJ2ZXIgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIF9zdGF0c09ic2VydmVyQ2FsbGJhY2s6IEZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU2VlIHtAbGluayBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXN9LlxuICAgICAqL1xuICAgIHVzZXJEYXRhU3RyZWFtaW5nU2NvcGU6IEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3BlcztcblxuICAgIC8qKlxuICAgICAqIFRoZSBXZWJSVEMgQWRkcmVzcyB0byB3aGljaCB3ZSB3YW50IHRvIGNvbm5lY3QgYXMgYSBwYXJ0IG9mIHRoaXMgU2Vzc2lvbi4gVGhpcyBXZWJSVEMgQWRkcmVzcyBpcyBvYnRhaW5lZCBmcm9tIHRoZSBNaXhlciBEaXNjb3ZlcnkgQWRkcmVzcyBkdXJpbmdcbiAgICAgKiB0aGUgYEhpRmlDb21tdW5pY2F0b3IuY29ubmVjdFRvSGlGaUF1ZGlvQVBJU2VydmVyKClgIGNhbGwuXG4gICAgICovXG4gICAgd2ViUlRDQWRkcmVzczogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gUGVlciBkYXRhIGlzIHJldHVybmVkIGZyb20gdGhlIFNlcnZlci5cbiAgICAgKi9cbiAgICBvblVzZXJEYXRhVXBkYXRlZDogRnVuY3Rpb247XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhIFBlZXIgZGlzY29ubmVjdHMgZnJvbSB0aGUgU2VydmVyLlxuICAgICAqL1xuICAgIG9uVXNlcnNEaXNjb25uZWN0ZWQ6IEZ1bmN0aW9uO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIFwiY29ubmVjdGlvbiBzdGF0ZVwiIGNoYW5nZXMuXG4gICAgICogUmlnaHQgbm93LCB0aGlzIGlzIGNhbGxlZCB3aGVuIHRoZSB0aGUgUkFWSSBzZXNzaW9uIHN0YXRlIGNoYW5nZXMgdG9cbiAgICAgKiBgUmF2aVNlc3Npb25TdGF0ZXMuQ09OTkVDVEVEYCwgYFJhdmlTZXNzaW9uU3RhdGVzLkRJU0NPTk5FQ1RFRGAsIGFuZCBgUmF2aVNlc3Npb25TdGF0ZXMuRkFJTEVEYC5cbiAgICAgKi9cbiAgICBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQ6IEZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1peGVyIHRvIHdoaWNoIHdlIGFyZSBjdXJyZW50bHkgY29ubmVjdGVkLlxuICAgICAqL1xuICAgIG1peGVySW5mbzogYW55O1xuXG4gICAgcHJpdmF0ZSBfcmF2aURpYWdub3N0aWNzOiBEaWFnbm9zdGljcztcbiAgICBwcml2YXRlIF9oaWZpRGlhZ25vc3RpY3M6IERpYWdub3N0aWNzO1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIF9fbmFtZWRQYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHVzZXJEYXRhU3RyZWFtaW5nU2NvcGUgLSBTZWUge0BsaW5rIEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3Blc30uXG4gICAgICogXG4gICAgICogSWYgc2V0IHRvIGBmYWxzZWAsIFVzZXIgRGF0YSBTdWJzY3JpcHRpb25zIHdpbGwgc2VydmUgbm8gcHVycG9zZS5cbiAgICAgKiBAcGFyYW0gb25Vc2VyRGF0YVVwZGF0ZWQgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBzZXJ2ZXIgc2VuZHMgdXNlciBkYXRhIHRvIHRoZSBjbGllbnQuIElycmVsZXZhbnQgaWYgYHVzZXJEYXRhU3RyZWFtaW5nU2NvcGVgIGlzIGBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXMuTm9uZWAuXG4gICAgICogQHBhcmFtIG9uVXNlcnNEaXNjb25uZWN0ZWQgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBzZXJ2ZXIgc2VuZHMgdXNlciBkYXRhIGFib3V0IHBlZXJzIHdobyBqdXN0IGRpc2Nvbm5lY3RlZCB0byB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgdXNlckRhdGFTdHJlYW1pbmdTY29wZSA9IEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3Blcy5BbGwsIG9uVXNlckRhdGFVcGRhdGVkLCBvblVzZXJzRGlzY29ubmVjdGVkLCBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIG9uTXV0ZUNoYW5nZWQgfTogeyB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlPzogSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzLCBvblVzZXJEYXRhVXBkYXRlZD86IEZ1bmN0aW9uLCBvblVzZXJzRGlzY29ubmVjdGVkPzogRnVuY3Rpb24sIG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZD86IEZ1bmN0aW9uLCBvbk11dGVDaGFuZ2VkPzogT25NdXRlQ2hhbmdlZENhbGxiYWNrIH0pIHtcbiAgICAgICAgdGhpcy53ZWJSVENBZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnVzZXJEYXRhU3RyZWFtaW5nU2NvcGUgPSB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlO1xuICAgICAgICB0aGlzLm9uVXNlckRhdGFVcGRhdGVkID0gb25Vc2VyRGF0YVVwZGF0ZWQ7XG4gICAgICAgIHRoaXMub25Vc2Vyc0Rpc2Nvbm5lY3RlZCA9IG9uVXNlcnNEaXNjb25uZWN0ZWQ7XG4gICAgICAgIHRoaXMuX21peGVyUGVlcktleVRvU3RhdGVDYWNoZURpY3QgPSB7fTtcbiAgICAgICAgdGhpcy5fbGFzdFN1Y2Nlc3NmdWxJbnB1dEF1ZGlvTXV0ZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uTXV0ZUNoYW5nZWQgPSBvbk11dGVDaGFuZ2VkO1xuXG4gICAgICAgIFJhdmlVdGlscy5zZXREZWJ1ZyhmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24gPSBuZXcgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24oKTtcbiAgICAgICAgdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24uYWRkU3RhdGVDaGFuZ2VIYW5kbGVyKChldmVudDogYW55KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uUkFWSVNpZ25hbGluZ1N0YXRlQ2hhbmdlZChldmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3JhdmlTZXNzaW9uID0gbmV3IFJhdmlTZXNzaW9uKCk7XG4gICAgICAgIHRoaXMuX3JhdmlTZXNzaW9uLmFkZFN0YXRlQ2hhbmdlSGFuZGxlcigoZXZlbnQ6IGFueSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vblJBVklTZXNzaW9uU3RhdGVDaGFuZ2VkKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQgPSBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQ7XG5cbiAgICAgICAgdGhpcy5fcmVzZXRNaXhlckluZm8oKTtcbiAgICAgICAgdGhpcy5fcmF2aURpYWdub3N0aWNzID0gbmV3IERpYWdub3N0aWNzKHtsYWJlbDogJ3JhdmknLCBzZXNzaW9uOiB0aGlzLCByYXZpOiB0aGlzLl9yYXZpU2Vzc2lvbn0pO1xuICAgICAgICB0aGlzLl9oaWZpRGlhZ25vc3RpY3MgPSBuZXcgRGlhZ25vc3RpY3Moe2xhYmVsOiAnYXBwJywgc2Vzc2lvbjogdGhpcywgcmF2aTogdGhpcy5fcmF2aVNlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGlzIHRoZSBzdGFuZGFyZCB3YXkgdG8gdGVsbCwgYnV0IGJyb3dzZXIgaGF2ZSBidWdzIGluIHdoaWNoIHRoZXkgZG9uJ3QgZmlyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2Vjb25kIGlzIGVub3VnaCBmb3IgYWxsIGtub3duIGJyb3dzZXIgYnVncywgZXhjZXB0IGZvciBTYWZhcmkgZGVza3RvcCBjbG9zaW5nIGEgdmlzaWJsZSB0YWIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZU9uOiBbJ3Zpc2liaWxpdHljaGFuZ2UnLCAncGFnZWhpZGUnLCAnYmVmb3JldW5sb2FkJ119KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyB0aGUgY29tbWFuZCBgYXVkaW9uZXQuaW5pdGAgdG8gdGhlIG1peGVyLlxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIElmIHRoaXMgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWwsIHRoZSBQcm9taXNlIHdpbGwgcmVzb2x2ZSB3aXRoIGB7IHN1Y2Nlc3M6IHRydWUsIGF1ZGlvbmV0SW5pdFJlc3BvbnNlOiA8VGhlIHJlc3BvbnNlIHRvIGBhdWRpb25ldC5pbml0YCBmcm9tIHRoZSBzZXJ2ZXIgaW4gT2JqZWN0IGZvcm1hdD59YC5cbiAgICAgKiBJZiB1bnN1Y2Nlc3NmdWwsIHRoZSBQcm9taXNlIHdpbGwgcmVqZWN0IHdpdGggYHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiA8YW4gZXJyb3IgbWVzc2FnZT4gfWAuXG4gICAgICovXG4gICAgYXN5bmMgcHJvbWlzZVRvUnVuQXVkaW9Jbml0KCk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5pdERhdGEgPSB7XG4gICAgICAgICAgICAgICAgcHJpbWFyeTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWl4ZXIgd2lsbCBoYXNoIHRoaXMgcmFuZG9tbHktZ2VuZXJhdGVkIFVVSUQsIHRoZW4gZGlzc2VtaW5hdGUgaXQgdG8gYWxsIGNsaWVudHMgdmlhIGBwZWVyRGF0YS5lYC5cbiAgICAgICAgICAgICAgICB2aXNpdF9pZDogdGhpcy5fcmF2aVNlc3Npb24uZ2V0VVVJRCgpLFxuICAgICAgICAgICAgICAgIHNlc3Npb246IHRoaXMuX3JhdmlTZXNzaW9uLmdldFVVSUQoKSwgLy8gU3RpbGwgcmVxdWlyZWQgZm9yIG9sZCBtaXhlcnMuIFdpbGwgZXZlbnR1YWxseSBnbyBhd2F5LlxuICAgICAgICAgICAgICAgIHN0cmVhbWluZ19zY29wZTogdGhpcy51c2VyRGF0YVN0cmVhbWluZ1Njb3BlLFxuICAgICAgICAgICAgICAgIGlzX2lucHV0X3N0cmVhbV9zdGVyZW86IHRoaXMuX2lucHV0QXVkaW9NZWRpYVN0cmVhbUlzU3RlcmVvXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGNvbW1hbmRDb250cm9sbGVyID0gdGhpcy5fcmF2aVNlc3Npb24uZ2V0Q29tbWFuZENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIGlmICghY29tbWFuZENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBDb3VsZG4ndCBjb25uZWN0IHRvIG1peGVyOiBubyBcXGBjb21tYW5kQ29udHJvbGxlclxcYCFgXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpbml0VGltZW91dCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBlcnJNc2cgPSBgQ291bGRuJ3QgY29ubmVjdCB0byBtaXhlcjogQ2FsbCB0byBcXGBpbml0XFxgIHRpbWVkIG91dCFgXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGlzY29ubmVjdEZyb21IaUZpTWl4ZXIoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvckNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyTXNnICs9IGBcXG5BZGRpdGlvbmFsbHksIHRoZXJlIHdhcyBhbiBlcnJvciB0cnlpbmcgdG8gY2xvc2UgdGhlIGZhaWxlZCBjb25uZWN0aW9uLiBFcnJvcjpcXG4ke2Vycm9yQ2xvc2luZ31gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyck1zZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgSU5JVF9USU1FT1VUX01TKTtcblxuICAgICAgICAgICAgY29tbWFuZENvbnRyb2xsZXIucXVldWVDb21tYW5kKFwiYXVkaW9uZXQuaW5pdFwiLCBpbml0RGF0YSwgYXN5bmMgKHJlc3BvbnNlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaW5pdFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRSZXNwb25zZTogYW55O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWl4ZXJJbmZvW1wiY29ubmVjdGVkXCJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhlckluZm9bXCJidWlsZF9udW1iZXJcIl0gPSBwYXJzZWRSZXNwb25zZS5idWlsZF9udW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWl4ZXJJbmZvW1wiYnVpbGRfdHlwZVwiXSA9IHBhcnNlZFJlc3BvbnNlLmJ1aWxkX3R5cGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWl4ZXJJbmZvW1wiYnVpbGRfdmVyc2lvblwiXSA9IHBhcnNlZFJlc3BvbnNlLmJ1aWxkX3ZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWl4ZXJJbmZvW1widmlzaXRfaWRfaGFzaFwiXSA9IHBhcnNlZFJlc3BvbnNlLnZpc2l0X2lkX2hhc2g7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhdmlEaWFnbm9zdGljcy5wcmltZSh0aGlzLm1peGVySW5mby52aXNpdF9pZF9oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlmaURpYWdub3N0aWNzLnByaW1lKHRoaXMubWl4ZXJJbmZvLnZpc2l0X2lkX2hhc2gpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb25ldEluaXRSZXNwb25zZTogcGFyc2VkUmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYENvdWxkbid0IHBhcnNlIGluaXQgcmVzcG9uc2UhIFBhcnNlIGVycm9yOlxcbiR7ZX1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgbWl4ZXJgIGFuZCBgcGVlcmAgZGF0YSBpcyBzZW50IGZyb20gdGhlIE1peGVyIHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyB3aGVuIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgYGd6aXBwZWRgIGRhdGEgZnJvbSB0aGUgTWl4ZXIuXG4gICAgICovXG4gICAgaGFuZGxlUkFWSVNlc3Npb25CaW5hcnlEYXRhKGRhdGE6IGFueSkge1xuICAgICAgICBsZXQgdW5HWmlwcGVkRGF0YSA9IHBha28udW5nemlwKGRhdGEsIHsgdG86ICdzdHJpbmcnIH0pO1xuICAgICAgICBsZXQganNvbkRhdGEgPSBKU09OLnBhcnNlKHVuR1ppcHBlZERhdGEpO1xuXG4gICAgICAgIGlmIChqc29uRGF0YS5kZWxldGVkX3Zpc2l0X2lkcykge1xuICAgICAgICAgICAgbGV0IGFsbERlbGV0ZWRVc2VyRGF0YTogQXJyYXk8UmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhPiA9IFtdO1xuXG4gICAgICAgICAgICBsZXQgZGVsZXRlZFZpc2l0SURzID0ganNvbkRhdGEuZGVsZXRlZF92aXNpdF9pZHM7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlbGV0ZWRWaXNpdElEIG9mIGRlbGV0ZWRWaXNpdElEcykge1xuICAgICAgICAgICAgICAgIGxldCBoYXNoZWRWaXNpdElEID0gZGVsZXRlZFZpc2l0SUQ7XG5cbiAgICAgICAgICAgICAgICBsZXQgZGVsZXRlZFVzZXJEYXRhID0gbmV3IFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hlZFZpc2l0SUQ6IGhhc2hlZFZpc2l0SURcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxldCBtaXhlclBlZXJLZXlzID0gT2JqZWN0LmtleXModGhpcy5fbWl4ZXJQZWVyS2V5VG9TdGF0ZUNhY2hlRGljdCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtaXhlclBlZXJLZXkgb2YgbWl4ZXJQZWVyS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWl4ZXJQZWVyS2V5VG9TdGF0ZUNhY2hlRGljdFttaXhlclBlZXJLZXldLmhhc2hlZFZpc2l0SUQgPT09IGhhc2hlZFZpc2l0SUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0W21peGVyUGVlcktleV0ucHJvdmlkZWRVc2VySUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVkVXNlckRhdGEucHJvdmlkZWRVc2VySUQgPSB0aGlzLl9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0W21peGVyUGVlcktleV0ucHJvdmlkZWRVc2VySUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFsbERlbGV0ZWRVc2VyRGF0YS5wdXNoKGRlbGV0ZWRVc2VyRGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGUgZW50cnkgZnJvbSB0aGUgcGVlciBzdGF0ZSBjYWNoZVxuICAgICAgICAgICAgdGhpcy5jb25jdXJyZW5jeSAtPSBhbGxEZWxldGVkVXNlckRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMub25Vc2Vyc0Rpc2Nvbm5lY3RlZCAmJiBhbGxEZWxldGVkVXNlckRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Vc2Vyc0Rpc2Nvbm5lY3RlZChhbGxEZWxldGVkVXNlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGpzb25EYXRhLnBlZXJzKSB7XG4gICAgICAgICAgICBsZXQgYWxsTmV3VXNlckRhdGE6IEFycmF5PFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YT4gPSBbXTtcblxuICAgICAgICAgICAgbGV0IHBlZXJLZXlzID0gT2JqZWN0LmtleXMoanNvbkRhdGEucGVlcnMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaXRyID0gMDsgaXRyIDwgcGVlcktleXMubGVuZ3RoOyBpdHIrKykge1xuICAgICAgICAgICAgICAgIGxldCBwZWVyRGF0YUZyb21NaXhlciA9IGpzb25EYXRhLnBlZXJzW3BlZXJLZXlzW2l0cl1dO1xuXG4gICAgICAgICAgICAgICAgLy8gU2VlIHtAbGluayB0aGlzLl9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0fS5cbiAgICAgICAgICAgICAgICBsZXQgdXNlckRhdGFDYWNoZTogUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhO1xuICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIGEga25vd24gcGVlciwgd2Ugc2hvdWxkIGhhdmUgYW4gZW50cnkgZm9yIGl0IGluIHRoZSBjYWNoZSBkaWN0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21peGVyUGVlcktleVRvU3RhdGVDYWNoZURpY3RbcGVlcktleXNbaXRyXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZSA9IHRoaXMuX21peGVyUGVlcktleVRvU3RhdGVDYWNoZURpY3RbcGVlcktleXNbaXRyXV0gYXMgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgbGV0J3MgY3JlYXRlIGl0LlxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlID0gbmV3IFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0W3BlZXJLZXlzW2l0cl1dID0gdXNlckRhdGFDYWNoZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25jdXJyZW5jeSArPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgZW1wdHkgZGF0YSB0aGF0IHdpbGwgY29sbGVjdCB0aGUgY2hhbmdlcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICAgICAgLy8gYXMgd2UgY29sbGVjdCB0aGUgY2hhbmdlcyBmcm9tIHRoZSByZWNlaXZlZCBkYXRhLCB3ZSB3aWxsIGFsc28gdXBkYXRlIHRoZSB1c2VyRGF0YUNhY2hlIGFzc29jaWF0ZWQgd2l0aCB0aGF0IHBlZXIuXG4gICAgICAgICAgICAgICAgbGV0IG5ld1VzZXJEYXRhID0gbmV3IFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gYC5KYCBpcyB0aGUgJ3Byb3ZpZGVkVXNlcklEJ1xuICAgICAgICAgICAgICAgIGlmICh1c2VyRGF0YUNhY2hlLnByb3ZpZGVkVXNlcklEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgIGRlZmluZWQsIHNob3VsZCBiZSB0aGUgc2FtZSBpbml0aWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5wcm92aWRlZFVzZXJJRCA9IHVzZXJEYXRhQ2FjaGUucHJvdmlkZWRVc2VySUQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLkopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUucHJvdmlkZWRVc2VySUQgPSBwZWVyRGF0YUZyb21NaXhlci5KO1xuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5wcm92aWRlZFVzZXJJRCA9IHBlZXJEYXRhRnJvbU1peGVyLko7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYC5lYCBpcyB0aGUgYGhhc2hlZFZpc2l0SURgLCB3aGljaCBpcyBhIGhhc2hlZCB2ZXJzaW9uIG9mIHRoZSByYW5kb20gVVVJRCB0aGF0IGEgY29ubmVjdGluZyBjbGllbnRcbiAgICAgICAgICAgICAgICAvLyBzZW5kcyBhcyB0aGUgYHNlc3Npb25gIGtleSBpbnNpZGUgdGhlIGFyZ3VtZW50IHRvIHRoZSBgYXVkaW9uZXQuaW5pdGAgY29tbWFuZC5cbiAgICAgICAgICAgICAgICAvLyBJdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGEgZ2l2ZW4gY2xpZW50IGFjcm9zcyBhIGNsb3VkIG9mIG1peGVycy5cbiAgICAgICAgICAgICAgICBpZiAodXNlckRhdGFDYWNoZS5oYXNoZWRWaXNpdElEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgIGRlZmluZWQsIHNob3VsZCBiZSB0aGUgc2FtZSBpbml0aWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5oYXNoZWRWaXNpdElEID0gdXNlckRhdGFDYWNoZS5oYXNoZWRWaXNpdElEO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci5lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLmhhc2hlZFZpc2l0SUQgPSBwZWVyRGF0YUZyb21NaXhlci5lO1xuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5oYXNoZWRWaXNpdElEID0gcGVlckRhdGFGcm9tTWl4ZXIuZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgc2VydmVyU2VudE5ld1VzZXJEYXRhID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLipgXG4gICAgICAgICAgICAgICAgbGV0IHNlcnZlclNlbnROZXdQb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLngpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlckRhdGFDYWNoZS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5wb3NpdGlvbiA9IG5ldyBQb2ludDNEKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTWl4ZXIgc2VuZHMgcG9zaXRpb24gZGF0YSBpbiBtaWxsaW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLnBvc2l0aW9uLnggPSBwZWVyRGF0YUZyb21NaXhlci54IC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld1Bvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocGVlckRhdGFGcm9tTWl4ZXIueSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyRGF0YUNhY2hlLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLnBvc2l0aW9uID0gbmV3IFBvaW50M0QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBNaXhlciBzZW5kcyBwb3NpdGlvbiBkYXRhIGluIG1pbGxpbWV0ZXJzXG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUucG9zaXRpb24ueSA9IHBlZXJEYXRhRnJvbU1peGVyLnkgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3UG9zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci56KSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJEYXRhQ2FjaGUucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUucG9zaXRpb24gPSBuZXcgUG9pbnQzRCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE1peGVyIHNlbmRzIHBvc2l0aW9uIGRhdGEgaW4gbWlsbGltZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5wb3NpdGlvbi56ID0gcGVlckRhdGFGcm9tTWl4ZXIueiAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIHJlY2VpdmVkIGEgbmV3IHBvc2l0aW9uIGFuZCB1cGRhdGVkIHRoZSBjYWNoZSBlbnRyeS5cbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGFkZCB0aGUgbmV3IHBvc2l0aW9uIHZhbHVlIGluIHRoZSBuZXdVc2VyRGF0YVxuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJTZW50TmV3UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgcG9zaXRpb24gdmFsdWUgZm9yIHRoZSBuZXdVc2VyRGF0YSBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCB0aGUgcmVjZWl2ZWQgcG9zaXRpb24gKGlmIGFueSkgdG8gdGhlIHVzZXIgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgbmV3VXNlckRhdGEucG9zaXRpb24gPSBIaUZpQXhpc1V0aWxpdGllcy50cmFuc2xhdGVQb2ludDNERnJvbU1peGVyU3BhY2Uob3VySGlGaUF4aXNDb25maWd1cmF0aW9uLCB1c2VyRGF0YUNhY2hlLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld1VzZXJEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uLipgXG4gICAgICAgICAgICAgICAgbGV0IHNlcnZlclNlbnROZXdPcmllbnRhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLlcpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUub3JpZW50YXRpb25RdWF0ID0gbmV3IE9yaWVudGF0aW9uUXVhdDNEKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQudyA9IHBlZXJEYXRhRnJvbU1peGVyLlcgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3T3JpZW50YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci5YKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJEYXRhQ2FjaGUub3JpZW50YXRpb25RdWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLm9yaWVudGF0aW9uUXVhdCA9IG5ldyBPcmllbnRhdGlvblF1YXQzRCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUub3JpZW50YXRpb25RdWF0LnggPSBwZWVyRGF0YUZyb21NaXhlci5YIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld09yaWVudGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocGVlckRhdGFGcm9tTWl4ZXIuWSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyRGF0YUNhY2hlLm9yaWVudGF0aW9uUXVhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQgPSBuZXcgT3JpZW50YXRpb25RdWF0M0QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLm9yaWVudGF0aW9uUXVhdC55ID0gcGVlckRhdGFGcm9tTWl4ZXIuWSAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdPcmllbnRhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLlopID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUub3JpZW50YXRpb25RdWF0ID0gbmV3IE9yaWVudGF0aW9uUXVhdDNEKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQueiA9IHBlZXJEYXRhRnJvbU1peGVyLlogLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3T3JpZW50YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSByZWNlaXZlZCBhIG5ldyBvcmllbnRhdGlvbiBhbmQgdXBkYXRlZCB0aGUgY2FjaGUgZW50cnkuXG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBhZGQgdGhlIG5ldyBvcmllbnRhdGlvbiB2YWx1ZSBpbiB0aGUgbmV3VXNlckRhdGFcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyU2VudE5ld09yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IG9yaWVudGF0aW9uIHZhbHVlIGZvciB0aGUgbmV3VXNlckRhdGEgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIHJlY2VpdmVkIG9yaWVudGF0aW9uIChpZiBhbnkpIHRvIHRoZSB1c2VyIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLm9yaWVudGF0aW9uUXVhdCA9IEhpRmlBeGlzVXRpbGl0aWVzLnRyYW5zbGF0ZU9yaWVudGF0aW9uUXVhdDNERnJvbU1peGVyU3BhY2Uob3VySGlGaUF4aXNDb25maWd1cmF0aW9uLCB1c2VyRGF0YUNhY2hlLm9yaWVudGF0aW9uUXVhdCk7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdVc2VyRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YS52b2x1bWVEZWNpYmVsc2BcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci52KSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLnZvbHVtZURlY2liZWxzID0gcGVlckRhdGFGcm9tTWl4ZXIudjtcbiAgICAgICAgICAgICAgICAgICAgbmV3VXNlckRhdGEudm9sdW1lRGVjaWJlbHMgPSBwZWVyRGF0YUZyb21NaXhlci52O1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3VXNlckRhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEuaXNTdGVyZW9gXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocGVlckRhdGFGcm9tTWl4ZXIucykgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUuaXNTdGVyZW8gPSBwZWVyRGF0YUZyb21NaXhlci5zO1xuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5pc1N0ZXJlbyA9IHBlZXJEYXRhRnJvbU1peGVyLnM7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdVc2VyRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdGhlIG5ld1VzZXJEYXRhIEFORCB0aGUgdXNlckRhdGFDYWNoZSBoYXZlIGJlZW4gdXBkYXRlZCB3aXRoIHRoZSBuZXcgdmFsdWVzXG4gICAgICAgICAgICAgICAgLy8gcHJvcGFnYXRlIG5ld1VzZXJEYXRhIHRvIHVzZXIgc3BhY2VcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyU2VudE5ld1VzZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbE5ld1VzZXJEYXRhLnB1c2gobmV3VXNlckRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub25Vc2VyRGF0YVVwZGF0ZWQgJiYgYWxsTmV3VXNlckRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Vc2VyRGF0YVVwZGF0ZWQoYWxsTmV3VXNlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoanNvbkRhdGEuaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGpzb25EYXRhLmluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0cnVjdGlvbikgfHwgIWluc3RydWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgaW5zdHJ1Y3Rpb25OYW1lID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAgICAgICAgICAgICAgbGV0IGluc3RydWN0aW9uQXJndW1lbnRzID0gaW5zdHJ1Y3Rpb24uc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uTmFtZSA9PT0gXCJtdXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZEJlTXV0ZWQ6IGJvb2xlYW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbkFyZ3VtZW50cy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihpbnN0cnVjdGlvbkFyZ3VtZW50c1swXSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQmVNdXRlZCA9IGluc3RydWN0aW9uQXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRCZU11dGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldE11dGVkQnlBZG1pbihzaG91bGRCZU11dGVkLCBNdXRlUmVhc29uLkFETUlOKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gdGhlIE1peGVyIGdpdmVuIGB0aGlzLndlYlJUQ0FkZHJlc3NgLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBfX25hbWVkUGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB3ZWJSVENTZXNzaW9uUGFyYW1zIC0gUGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIFJBVkkgc2Vzc2lvbiB3aGVuIG9wZW5pbmcgdGhhdCBzZXNzaW9uLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlamVjdHMgd2l0aCBhbiBlcnJvciBtZXNzYWdlIHN0cmluZyB1cG9uIGZhaWx1cmUsIG9yIHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIGZyb20gYGF1ZGlvbmV0LmluaXRgIGFzIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3RUb0hpRmlNaXhlcih7IHdlYlJUQ1Nlc3Npb25QYXJhbXMsIGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnIH06IHsgd2ViUlRDU2Vzc2lvblBhcmFtcz86IFdlYlJUQ1Nlc3Npb25QYXJhbXMsIGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnPzogQ3VzdG9tU1RVTmFuZFRVUk5Db25maWcgfSk6IFByb21pc2U8YW55PiB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlID09PSBIaUZpQ29ubmVjdGlvblN0YXRlcy5Db25uZWN0ZWQgJiYgdGhpcy5taXhlckluZm9bXCJjb25uZWN0ZWRcIl0pIHtcbiAgICAgICAgICAgIGxldCBtc2cgPSBgQWxyZWFkeSBjb25uZWN0ZWQhIElmIGEgcmVjb25uZWN0IGlzIG5lZWRlZCwgcGxlYXNlIGhhbmcgdXAgYW5kIHRyeSBhZ2Fpbi5gO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLndlYlJUQ0FkZHJlc3MpIHtcbiAgICAgICAgICAgIGxldCBlcnJNc2cgPSBgQ291bGRuJ3QgY29ubmVjdDogXFxgdGhpcy53ZWJSVENBZGRyZXNzXFxgIGlzIGZhbHNleSFgO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kaXNjb25uZWN0RnJvbUhpRmlNaXhlcigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3JDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgZXJyTXNnICs9IGBcXG5BZGRpdGlvbmFsbHksIHRoZXJlIHdhcyBhbiBlcnJvciB0cnlpbmcgdG8gY2xvc2UgdGhlIGZhaWxlZCBjb25uZWN0aW9uLiBFcnJvcjpcXG4ke2Vycm9yQ2xvc2luZ31gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVyck1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBsZXQgbWl4ZXJJc1VuYXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHRlbXBVbmF2YWlsYWJsZVN0YXRlSGFuZGxlciA9IChldmVudDogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuc3RhdGUgPT09IFJhdmlTaWduYWxpbmdTdGF0ZXMuVU5BVkFJTEFCTEUpIHtcbiAgICAgICAgICAgICAgICBtaXhlcklzVW5hdmFpbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uLnJlbW92ZVN0YXRlQ2hhbmdlSGFuZGxlcih0ZW1wVW5hdmFpbGFibGVTdGF0ZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhdmlTZXNzaW9uLmNsb3NlUkFWSVNlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbi5hZGRTdGF0ZUNoYW5nZUhhbmRsZXIodGVtcFVuYXZhaWxhYmxlU3RhdGVIYW5kbGVyKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24ub3BlblJBVklTaWduYWxpbmdDb25uZWN0aW9uKHRoaXMud2ViUlRDQWRkcmVzcylcbiAgICAgICAgfSBjYXRjaCAoZXJyb3JPcGVuaW5nU2lnbmFsaW5nQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgbGV0IGVyck1zZyA9IGBDb3VsZG4ndCBvcGVuIHNpZ25hbGluZyBjb25uZWN0aW9uIHRvIFxcYCR7dGhpcy53ZWJSVENBZGRyZXNzLnNsaWNlKDAsIHRoaXMud2ViUlRDQWRkcmVzcy5pbmRleE9mKFwidG9rZW49XCIpKX08dG9rZW4gcmVkYWN0ZWQ+XFxgISBFcnJvcjpcXG4ke2Vycm9yT3BlbmluZ1NpZ25hbGluZ0Nvbm5lY3Rpb259YDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGlzY29ubmVjdEZyb21IaUZpTWl4ZXIoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yQ2xvc2luZykge1xuICAgICAgICAgICAgICAgIGVyck1zZyArPSBgXFxuQWRkaXRpb25hbGx5LCB0aGVyZSB3YXMgYW4gZXJyb3IgdHJ5aW5nIHRvIGNsb3NlIHRoZSBmYWlsZWQgY29ubmVjdGlvbi4gRXJyb3I6XFxuJHtlcnJvckNsb3Npbmd9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uLnJlbW92ZVN0YXRlQ2hhbmdlSGFuZGxlcih0ZW1wVW5hdmFpbGFibGVTdGF0ZUhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVyck1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmF2aVNlc3Npb24ub3BlblJBVklTZXNzaW9uKHsgc2lnbmFsaW5nQ29ubmVjdGlvbjogdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24sIHBhcmFtczogd2ViUlRDU2Vzc2lvblBhcmFtcywgY3VzdG9tU3R1bkFuZFR1cm46IGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvck9wZW5pbmdSQVZJU2Vzc2lvbikge1xuICAgICAgICAgICAgbGV0IGVyck1zZyA9IGBDb3VsZG4ndCBvcGVuIFJBVkkgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggXFxgJHt0aGlzLndlYlJUQ0FkZHJlc3Muc2xpY2UoMCwgdGhpcy53ZWJSVENBZGRyZXNzLmluZGV4T2YoXCJ0b2tlbj1cIikpfTx0b2tlbiByZWRhY3RlZD5cXGAhIEVycm9yOlxcbiR7ZXJyb3JPcGVuaW5nUkFWSVNlc3Npb259YDtcbiAgICAgICAgICAgIGlmIChtaXhlcklzVW5hdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICBlcnJNc2cgPSBgSGlnaCBGaWRlbGl0eSBzZXJ2ZXIgaXMgYXQgY2FwYWNpdHk7IHNlcnZpY2UgaXMgdW5hdmFpbGFibGUuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGlzY29ubmVjdEZyb21IaUZpTWl4ZXIoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yQ2xvc2luZykge1xuICAgICAgICAgICAgICAgIGVyck1zZyArPSBgXFxuQWRkaXRpb25hbGx5LCB0aGVyZSB3YXMgYW4gZXJyb3IgdHJ5aW5nIHRvIGNsb3NlIHRoZSBjb25uZWN0aW9uLiBFcnJvcjpcXG4ke2Vycm9yQ2xvc2luZ31gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24ucmVtb3ZlU3RhdGVDaGFuZ2VIYW5kbGVyKHRlbXBVbmF2YWlsYWJsZVN0YXRlSGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyTXNnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhdWRpb25ldEluaXRSZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF1ZGlvbmV0SW5pdFJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9taXNlVG9SdW5BdWRpb0luaXQoKTtcbiAgICAgICAgfSBjYXRjaCAoaW5pdEVycm9yKSB7XG4gICAgICAgICAgICBsZXQgZXJyTXNnID0gYFxcYGF1ZGlvbmV0LmluaXRcXGAgY29tbWFuZCBmYWlsZWQhIEVycm9yOlxcbiR7aW5pdEVycm9yLmVycm9yfWA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2Rpc2Nvbm5lY3RGcm9tSGlGaU1peGVyKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvckNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICBlcnJNc2cgKz0gYFxcbkFkZGl0aW9uYWxseSwgdGhlcmUgd2FzIGFuIGVycm9yIHRyeWluZyB0byBjbG9zZSB0aGUgZmFpbGVkIGNvbm5lY3Rpb24uIEVycm9yOlxcbiR7ZXJyb3JDbG9zaW5nfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbi5yZW1vdmVTdGF0ZUNoYW5nZUhhbmRsZXIodGVtcFVuYXZhaWxhYmxlU3RhdGVIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJNc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24ucmVtb3ZlU3RhdGVDaGFuZ2VIYW5kbGVyKHRlbXBVbmF2YWlsYWJsZVN0YXRlSGFuZGxlcik7XG5cbiAgICAgICAgdGhpcy5jb25jdXJyZW5jeSA9IDA7XG4gICAgICAgIHRoaXMuX3JhdmlTZXNzaW9uLmdldENvbW1hbmRDb250cm9sbGVyKCkuYWRkQmluYXJ5SGFuZGxlcigoZGF0YTogYW55KSA9PiB7IHRoaXMuaGFuZGxlUkFWSVNlc3Npb25CaW5hcnlEYXRhKGRhdGEpIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYXVkaW9uZXRJbml0UmVzcG9uc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIGZyb20gdGhlIE1peGVyLiBDbG9zZXMgdGhlIFJBVkkgU2lnbmFsaW5nIENvbm5lY3Rpb24gYW5kIHRoZSBSQVZJIFNlc3Npb24uXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgX2Fsd2F5c18gUmVzb2x2ZXMgd2l0aCBhIFwic3VjY2Vzc1wiIHN0YXR1cyBzdHJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgZGlzY29ubmVjdEZyb21IaUZpTWl4ZXIoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdGhpcy5fcmF2aURpYWdub3N0aWNzLm5vdGVFeHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2UoKTtcbiAgICAgICAgdGhpcy5faGlmaURpYWdub3N0aWNzLm5vdGVFeHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2Nvbm5lY3RGcm9tSGlGaU1peGVyKCk7XG4gICAgfVxuICAgIGFzeW5jIF9kaXNjb25uZWN0RnJvbUhpRmlNaXhlcigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBjbG9zZSh0aGluZ1RvQ2xvc2U6IChSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiB8IFJhdmlTZXNzaW9uKSwgbmFtZU9mVGhpbmdUb0Nsb3NlOiBzdHJpbmcsIGNsb3NlZFN0YXRlOiBzdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGluZ1RvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGluZ1RvQ2xvc2UuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaW5nVG9DbG9zZSB8fCBzdGF0ZSA9PT0gY2xvc2VkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFRoZSBSQVZJICR7bmFtZU9mVGhpbmdUb0Nsb3NlfSB3YXMgYWxyZWFkeSBjbG9zZWQuYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGluZ1RvQ2xvc2UgaW5zdGFuY2VvZiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaW5nVG9DbG9zZS5jbG9zZVJBVklTaWduYWxpbmdDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaW5nVG9DbG9zZSBpbnN0YW5jZW9mIFJhdmlTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpbmdUb0Nsb3NlLmNsb3NlUkFWSVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIubG9nKGBUaGUgUkFWSSAke25hbWVPZlRoaW5nVG9DbG9zZX0gY2xvc2VkIHN1Y2Nlc3NmdWxseSBmcm9tIHN0YXRlICR7c3RhdGV9LmApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYFRoZSBSQVZJICR7bmFtZU9mVGhpbmdUb0Nsb3NlfSBkaWRuJ3QgY2xvc2Ugc3VjY2Vzc2Z1bGx5IGZyb20gc3RhdGUgJHtzdGF0ZX0hIEVycm9yOlxcbiR7ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBUaGUgUkFWSSAke25hbWVPZlRoaW5nVG9DbG9zZX0gd2FzIG1pc3NpbmcuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaW5nVG9DbG9zZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBjbG9zZSh0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiwgXCJTaWduYWxpbmcgQ29ubmVjdGlvblwiLCBSYXZpU2lnbmFsaW5nU3RhdGVzLkNMT1NFRCk7XG4gICAgICAgIGF3YWl0IGNsb3NlKHRoaXMuX3JhdmlTZXNzaW9uLCBcIlNlc3Npb25cIiwgUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VEKTtcblxuICAgICAgICB0aGlzLl9yZXNldE1peGVySW5mbygpO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuX3NldE11dGVkQnlBZG1pbihmYWxzZSwgTXV0ZVJlYXNvbi5JTlRFUk5BTCk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShgU3VjY2Vzc2Z1bGx5IGRpc2Nvbm5lY3RlZC5gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhdWRpbyBgTWVkaWFTdHJlYW1gIHRoYXQgaXMgc2VudCB0byBSQVZJIHRvIGJlIG1peGVkLlxuICAgICAqIEBwYXJhbSBpbnB1dEF1ZGlvTWVkaWFTdHJlYW0gVGhlIGBNZWRpYVN0cmVhbWAgdGhhdCBpcyBzZW50IHRvIFJBVkkgdG8gYmUgbWl4ZWQuXG4gICAgICogQHBhcmFtIGlzU3RlcmVvIC0gYHRydWVgIGlmIHRoZSBpbnB1dCBzdHJlYW0gc2hvdWxkIGJlIHRyZWF0ZWQgYXMgc3RlcmVvLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbmV3IHN0cmVhbSB3YXMgc3VjY2Vzc2Z1bGx5IHNldDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgYXN5bmMgc2V0UkFWSUlucHV0QXVkaW8oaW5wdXRBdWRpb01lZGlhU3RyZWFtOiBNZWRpYVN0cmVhbSwgaXNTdGVyZW86IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXG4gICAgICAgIGxldCByZXR2YWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX3JhdmlTZXNzaW9uKSB7XG4gICAgICAgICAgICBsZXQgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuX3JhdmlTZXNzaW9uLmdldFN0cmVhbUNvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIGlmICghc3RyZWFtQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IGlucHV0IGF1ZGlvIG9uIF9yYXZpU2Vzc2lvbi5zdHJlYW1Db250cm9sbGVyOiBObyBcXGBzdHJlYW1Db250cm9sbGVyXFxgIWApO1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnNldElucHV0QXVkaW8oaW5wdXRBdWRpb01lZGlhU3RyZWFtLCBpc1N0ZXJlbyk7XG4gICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFN1Y2Nlc3NmdWxseSBzZXQgaW5wdXQgYXVkaW8gb24gX3JhdmlTZXNzaW9uLnN0cmVhbUNvbnRyb2xsZXIhYCk7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IGlucHV0IGF1ZGlvIG9uIF9yYXZpU2Vzc2lvbi5zdHJlYW1Db250cm9sbGVyOiBObyBcXGBfcmF2aVNlc3Npb25cXGAhYCk7XG4gICAgICAgICAgICByZXR2YWwgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXR2YWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW1Jc1N0ZXJlbyAhPSBpc1N0ZXJlbykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yYXZpU2Vzc2lvbi5nZXRTdGF0ZSgpID09PSBSYXZpU2Vzc2lvblN0YXRlcy5DT05ORUNURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RlcmVvIHN0YXR1cyBoYXMgY2hhbmdlZDsgbWF5IG5lZWQgdG8gY2FsbCBhdWRpb25ldC5pbml0IGFnYWluLlxuICAgICAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYFN0ZXJlbyBzdGF0dXMgaGFzIGNoYW5nZWQgZnJvbSAke3RoaXMuX2lucHV0QXVkaW9NZWRpYVN0cmVhbUlzU3RlcmVvfSB0byAke2lzU3RlcmVvfTsgYXR0ZW1wdGluZyB0byByZS1pbml0aWFsaXplIHdpdGggdGhlIG1peGVyYCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhdWRpb25ldEluaXRSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0QXVkaW9NZWRpYVN0cmVhbUlzU3RlcmVvID0gaXNTdGVyZW87XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb25ldEluaXRSZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvbWlzZVRvUnVuQXVkaW9Jbml0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGluaXRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBnb2VzIHdyb25nLCBkbyB3ZSBhY3R1YWxseSBjYXJlIGFsbCB0aGF0IG11Y2g/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBqdXN0IG1lYW5zIHRoYXQgdGhlIG1peGVyIHdpbGwgY29udGludWUgdG8gdHJlYXQgdGhlIG5ldyBzdHJlYW0gYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoYXRldmVyIHNldHRpbmcgaXQgd2FzIGJlZm9yZS4gRm9yIG5vdywganVzdCByZXR1cm4gdGhlIGVycm9yIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IHRoZSB1c2VyIHRyeSBhZ2FpbiBpZiB0aGV5IHdhbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyTXNnID0gYEF0dGVtcHQgdG8gY2FsbCBcXGBhdWRpb25ldC5pbml0XFxgIGZvciBjaGFuZ2UgaW4gc3RlcmVvIHN0YXR1cyBmYWlsZWQhIEVycm9yOlxcbiR7aW5pdEVycm9yLmVycm9yfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgYWxyZWFkeSBjb25uZWN0ZWQsIGl0J2xsIGp1c3QgcGljayB1cCB0aGUgcmlnaHQgc3RlcmVvIHZhbHVlIHdoZW4gd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBpdCB0aGUgZmlyc3QgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXRBdWRpb01lZGlhU3RyZWFtSXNTdGVyZW8gPSBpc1N0ZXJlbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbnB1dCBhdWRpbyBzdHJlYW0gdG8gXCJtdXRlZFwiIGJ5IF9laXRoZXJfOlxuICAgICAqIDEuIENhbGxpbmcgYHN0b3AoKWAgb24gYWxsIG9mIHRoZSBgTWVkaWFTdHJlYW1UcmFja2BzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlcidzIGlucHV0IGF1ZGlvIHN0cmVhbSBPUlxuICAgICAqIDIuIFNldHRpbmcgYHRyYWNrLmVuYWJsZWQgPSBmYWxzZXx0cnVlYCBvbiBhbGwgb2YgdGhlIHRyYWNrcyBvbiB0aGUgdXNlcidzIGlucHV0IGF1ZGlvIHN0cmVhbSAodGhlIGRlZmF1bHQgYmVoYXZpb3IpXG4gICAgICogXG4gICAgICogTWV0aG9kIDEgd2lsbCB3b3JrIGlmIGFuZCBvbmx5IGlmOlxuICAgICAqIDEuIFRoZSBkZXZlbG9wZXIgaGFzIHNldCB0aGUgYHRyeVRvU3RvcE1pY1N0cmVhbWAgYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvbiB0byBgdHJ1ZWAgQU5EXG4gICAgICogMi4gVGhlIGFwcGxpY2F0aW9uIGNvZGUgaXMgcnVubmluZyBpbiB0aGUgYnJvd3NlciBjb250ZXh0IChub3QgdGhlIE5vZGVKUyBjb250ZXh0KSBBTkRcbiAgICAgKiAzLiBUaGUgdXNlcidzIGJyb3dzZXIgZ2l2ZXMgdGhlIHVzZXIgdGhlIGFiaWxpdHkgdG8gcGVybWFuZW50bHkgYWxsb3cgYSB3ZWJzaXRlIHRvIGFjY2VzcyB0aGUgdXNlcidzIG1pY3JvcGhvbmVcbiAgICAgKiAgICBhbmQgcHJvdmlkZXMgdGhlIGBuYXZpZ2F0b3IucGVybWlzc2lvbnNgIGFuZCBgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5YCBvYmplY3RzL21ldGhvZHMuXG4gICAgICogICAgKFJlZmVyIHRvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QZXJtaXNzaW9ucyAtIGFzIG9mIE1hcmNoIDIwMjEsIHRoaXNcbiAgICAgKiAgICBsaXN0IGRvZXMgbm90IGluY2x1ZGUgU2FmYXJpIG9uIGRlc2t0b3Agb3IgaU9TLilcbiAgICAgKiBcbiAgICAgKiBSZWFzb25zIHRvIHVzZSBNZXRob2QgMTpcbiAgICAgKiAtIEJsdWV0b290aCBBdWRpbyBJL08gZGV2aWNlcyB3aWxsIHN3aXRjaCBtb2RlcyBiZXR3ZWVuIG1vbm8gb3V0IGFuZCBzdGVyZW8gb3V0IHdoZW4gdGhlIHVzZXIgaXMgbXV0ZWQsXG4gICAgICogd2hpY2ggeWllbGRzIHNpZ25pZmljYW50bHkgaW1wcm92ZWQgYXVkaW8gb3V0cHV0IHF1YWxpdHkgYW5kIHByb3BlciBhdWRpbyBzcGF0aWFsaXphdGlvbi5cbiAgICAgKiAtIFdoZW4gdGhlIHVzZXIgaXMgbXV0ZWQsIHRoZSBicm93c2VyIHdpbGwgcmVwb3J0IHRoYXQgdGhlaXIgbWljcm9waG9uZSBpcyBub3QgaW4gdXNlLCB3aGljaCBjYW4gaW1wcm92ZVxuICAgICAqIHVzZXIgdHJ1c3QgaW4gdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqIFxuICAgICAqIFJlYXNvbnMgX25vdF8gdG8gdXNlIE1ldGhvZCAxOlxuICAgICAqIC0gQmVjYXVzZSBNZXRob2QgMSByZXF1aXJlcyByZS1vYnRhaW5pbmcgYW4gYXVkaW8gaW5wdXQgc3RyZWFtIHZpYSBgZ2V0VXNlck1lZGlhKClgLCB0aGVyZSBpcyBhIHNtYWxsIGRlbGF5XG4gICAgICogYmV0d2VlbiB0aGUgbW9tZW50IHRoZSB1c2VyIHVuLW11dGVzIGFuZCB3aGVuIHRoZSB1c2VyIGlzIGFibGUgdG8gYmUgaGVhcmQgYnkgb3RoZXIgdXNlcnMgaW4gdGhlIFNwYWNlLlxuICAgICAqIC0gSWYgYSB1c2VyIGlzIHVzaW5nIGEgQmx1ZXRvb3RoIEF1ZGlvIEkvTyBkZXZpY2UsIHRoZXJlIGlzIGEgZGVsYXkgYmV0d2VlbiB0aGUgbW9tZW50IHRoZSB1c2VyIHVuLW11dGVzXG4gICAgICogYW5kIHdoZW4gYSB1c2VyIGNhbiBoZWFyIG90aGVyIHVzZXJzIGluIGEgU3BhY2UgZHVlIHRvIHRoZSBmYWN0IHRoYXQgdGhlIEJsdWV0b290aCBhdWRpbyBkZXZpY2UgbXVzdFxuICAgICAqIHN3aXRjaCBJL08gcHJvZmlsZXMuXG4gICAgICogLSBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdGhlIGBuYXZpZ2F0b3IucGVybWlzc2lvbnNgIEFQSVxuICAgICAqIFxuICAgICAqIEBwYXJhbSBuZXdNdXRlZFZhbHVlIElmIGB0cnVlYCwgdGhlIGlucHV0IGF1ZGlvIHN0cmVhbSB3aWxsIGJlIG11dGVkLiBJZiBgZmFsc2VgLCB0aGUgaW5wdXQgc3RyZWFtIHdpbGwgYmUgdW5tdXRlZC5cbiAgICAgKiBAcGFyYW0gdHJ5VG9TdG9wTWljU3RyZWFtIElmIGBmYWxzZWAsIHRoaXMgZnVuY3Rpb24gd2lsbCB1c2UgTWV0aG9kIDIgZGVzY3JpYmVkIGFib3ZlIHRvIG11dGUgb3IgdW5tdXRlIHRoZSBpbnB1dCBhdWRpbyBzdHJlYW0uIElmIGB0cnVlYCwgdGhpcyBmdW5jdGlvbiB3aWxsIHVzZSBNZXRob2QgMS5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHN0cmVhbSB3YXMgc3VjY2Vzc2Z1bGx5IG11dGVkL3VubXV0ZWQsIGBmYWxzZWAgaWYgaXQgd2FzIG5vdC5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRJbnB1dEF1ZGlvTXV0ZWQobmV3TXV0ZWRWYWx1ZTogYm9vbGVhbiwgdHJ5VG9TdG9wTWljU3RyZWFtOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NldE11dGVkKG5ld011dGVkVmFsdWUsIHRyeVRvU3RvcE1pY1N0cmVhbSwgTXV0ZVJlYXNvbi5DTElFTlQpO1xuICAgIH1cblxuICAgIGFzeW5jIF9zZXRNdXRlZEJ5QWRtaW4obXV0ZWRCeUFkbWluOiBib29sZWFuLCBtdXRlUmVhc29uOiBNdXRlUmVhc29uKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIC8vIEZvciBub3c6XG4gICAgICAgIC8vIC0gQWRtaW4gbXV0aW5nIHNob3VsZCBtdXRlIHRoZSBjbGllbnQsIGFuZCBwcmV2ZW50IHRoZSBjbGllbnQgZnJvbSB1bm11dGluZ1xuICAgICAgICAvLyAtIEFkbWluIHVubXV0aW5nIHNob3VsZCBub3QgdW5tdXRlIHRoZSBjbGllbnQsIGJ1dCBzaW1wbHkgYWxsb3cgdGhlIGNsaWVudCB0byB1bm11dGVcbiAgICAgICAgLy8gLSBXaGVuIHRoZSBjb25uZWN0aW9uIGVuZHMsIHRoZSBjbGllbnQgaXMgYWxsb3dlZCB0byB1bm11dGUsIHdoaWNoIGZvciBub3cgaXMgZXF1aXZhbGVudCB0byBhbiBhZG1pbiB1bm11dGVcbiAgICAgICAgdGhpcy5fYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZyA9IG11dGVkQnlBZG1pbjtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NldE11dGVkKG11dGVkQnlBZG1pbiB8fCB0aGlzLl9sYXN0U3VjY2Vzc2Z1bElucHV0QXVkaW9NdXRlZFZhbHVlLCBmYWxzZSwgbXV0ZVJlYXNvbik7XG4gICAgfVxuXG4gICAgYXN5bmMgX3NldE11dGVkKG5ld011dGVkVmFsdWU6IGJvb2xlYW4sIHRyeVRvU3RvcE1pY1N0cmVhbTogYm9vbGVhbiwgbXV0ZVJlYXNvbjogTXV0ZVJlYXNvbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBsZXQgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIGlmIChtdXRlUmVhc29uID09IE11dGVSZWFzb24uQ0xJRU5UKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZyAmJiAhbmV3TXV0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IG11dGUgc3RhdGU6IE11dGVkIGJ5IGFkbWluLmApO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgc3VjY2VzcyA9IGF3YWl0IHRoaXMuX3RyeVNldElucHV0QXVkaW9NdXRlZChuZXdNdXRlZFZhbHVlLCB0cnlUb1N0b3BNaWNTdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0U3VjY2Vzc2Z1bElucHV0QXVkaW9NdXRlZFZhbHVlID0gbmV3TXV0ZWRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uTXV0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25NdXRlQ2hhbmdlZChuZXcgTXV0ZUNoYW5nZWRFdmVudCh7XG4gICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICB0YXJnZXRJbnB1dEF1ZGlvTXV0ZWRWYWx1ZTogbmV3TXV0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5wdXRBdWRpb011dGVkVmFsdWU6IHRoaXMuX2xhc3RTdWNjZXNzZnVsSW5wdXRBdWRpb011dGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZzogdGhpcy5fYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZyxcbiAgICAgICAgICAgICAgICBtdXRlUmVhc29uOiBtdXRlUmVhc29uXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfVxuXG4gICAgYXN5bmMgX3RyeVNldElucHV0QXVkaW9NdXRlZChuZXdNdXRlZFZhbHVlOiBib29sZWFuLCB0cnlUb1N0b3BNaWNTdHJlYW06IGJvb2xlYW4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgbGV0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRTdHJlYW1Db250cm9sbGVyKCk7XG4gICAgICAgIGlmICh0aGlzLl9yYXZpU2Vzc2lvbiAmJiBzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgICAgICAgICBsZXQgaGFzTWljUGVybWlzc2lvbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIChuYXZpZ2F0b3IpICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5wZXJtaXNzaW9ucyAmJiBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0OiBQZXJtaXNzaW9uU3RhdHVzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7IG5hbWU6ICdtaWNyb3Bob25lJyB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIHsgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnN0YXRlID09PSBcImdyYW50ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBoYXNNaWNQZXJtaXNzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdHJ5VG9TdG9wTWljU3RyZWFtIHx8ICFoYXNNaWNQZXJtaXNzaW9uIHx8IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIERldmVsb3BlciBoYXMgZXhwbGljaXRseSBvciBpbXBsaWNpdGx5IHNldCBgdHJ5VG9TdG9wTWljU3RyZWFtYCB0byBgZmFsc2VgIE9SXG4gICAgICAgICAgICAgICAgLy8gd2UncmUgaW4gdGhlIE5vZGVKUyBjb250ZXh0IE9SXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVzZXIgaGFzbid0IGdyYW50ZWQgb3IgY2FuJ3QgZ3JhbnQgcGVybWFuZW50IG1pYyBwZXJtaXNzaW9ucyB0byBvdXIgc2NyaXB0Li4uXG4gICAgICAgICAgICAgICAgLy8gT24gaU9TIFNhZmFyaSwgdGhlIHVzZXIgX2Nhbid0XyBncmFudCBwZXJtYW5lbnQgbWljIHBlcm1pc3Npb25zIHRvIG91ciBzY3JpcHQuXG4gICAgICAgICAgICAgICAgbGV0IHJhdmlBdWRpb1N0cmVhbSA9IHN0cmVhbUNvbnRyb2xsZXIuX2lucHV0QXVkaW9TdHJlYW07XG5cbiAgICAgICAgICAgICAgICBpZiAocmF2aUF1ZGlvU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhdmlBdWRpb1N0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9ICFuZXdNdXRlZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFN1Y2Nlc3NmdWxseSBzZXQgbXV0ZSBzdGF0ZSB0byAke25ld011dGVkVmFsdWV9IG9uIF9yYXZpU2Vzc2lvbi5zdHJlYW1Db250cm9sbGVyLl9pbnB1dEF1ZGlvU3RyZWFtYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IG11dGUgc3RhdGU6IE5vIFxcYF9pbnB1dEF1ZGlvU3RyZWFtXFxgIG9uIFxcYF9yYXZpU2Vzc2lvbi5zdHJlYW1Db250cm9sbGVyXFxgLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJyb3dzZXIgY29udGV4dCwgaWYgYW5kIG9ubHkgaWYgdGhlIHVzZXIgaGFzIGdyYW50ZWQgbWljIHBlcm1pc3Npb25zIHRvIG91ciBzY3JpcHQsXG4gICAgICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBjYWxsIGBzdG9wKClgIG9uIGFsbCBgTWVkaWFTdHJlYW1UcmFja2BzIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyB1c2VyJ3MgYXVkaW8gaW5wdXQgZGV2aWNlIHN0cmVhbS4gVGhpcyBpcyB0byBob3BlZnVsbHkgYWxsb3cgdGhlIE9TIHRvIHN3aXRjaCB0aGUgdXNlcidzIG91dHB1dCBhdWRpbyBkZXZpY2VcbiAgICAgICAgICAgICAgICAvLyBpbnRvIGhhbGYtZHVwbGV4IChpLmUuIHN0ZXJlbykgbW9kZSBpbiB0aGUgY2FzZSB3aGVyZSB0aGF0IG91dHB1dCBkZXZpY2UgaXMgQmx1ZXRvb3RoLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGhhc24ndCBncmFudGVkIHBlcm1hbmVudCBtaWMgcGVybWlzc2lvbnMgdG8gb3VyIHNjcmlwdCwgZG9pbmcgdGhpcyB3b3VsZCBicmVhayBmZWF0dXJlcyBsaWtlIHB1c2gtdG8tdGFsayxcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGUgYnJvd3NlciB3b3VsZCBwcm9tcHQgdGhlIHVzZXIgZm9yIHBlcm1pc3Npb24gdG8gYWNjZXNzIHRoZSBtaWNyb3Bob25lIGV2ZXJ5IHRpbWUgdGhleSB1bm11dGVkLlxuICAgICAgICAgICAgICAgIGxldCByYXZpQXVkaW9TdHJlYW0gPSBzdHJlYW1Db250cm9sbGVyLl9pbnB1dEF1ZGlvU3RyZWFtO1xuICAgICAgICAgICAgICAgIGlmIChyYXZpQXVkaW9TdHJlYW0gJiYgbmV3TXV0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByYXZpQXVkaW9TdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2s6IE1lZGlhU3RyZWFtVHJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBgTWVkaWFUcmFja0NvbnN0cmFpbnRzYCBhcmUgdmVyeSBsaWtlbHkgdG8gYmUgdGhlIHNhbWUgYWNyb3NzIGFsbCBgTWVkaWFTdHJlYW1UcmFja3NgLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGh1cywgaW4gdGhlIGNhc2Ugb2Ygb3ZlcndyaXRpbmcgdGhpcyB2YWx1ZSBtdWx0aXBsZSB0aW1lcyBkdWUgdG8gbXVsdGlwbGUgdHJhY2tzIGNvbnRhaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aGluIHRoZSBgcmF2aUF1ZGlvU3RyZWFtYCwgdGhlcmUgc2hvdWxkIGJlIG5vIHByb2JsZW1zLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkTWVkaWFUcmFja0NvbnN0cmFpbnRzID0gdHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc2V0SW5wdXRBdWRpbyhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFN1Y2Nlc3NmdWxseSBzZXQgbXV0ZSBzdGF0ZSB0byBcXGB0cnVlXFxgIGJ5IHN0b3BwaW5nIGFsbCBpbnB1dCBtZWRpYSB0cmFja3MhYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJhdmlBdWRpb1N0cmVhbSAmJiAhbmV3TXV0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TWVkaWFTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0aGlzLl9jYWNoZWRNZWRpYVRyYWNrQ29uc3RyYWludHMsIHZpZGVvOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zZXRJbnB1dEF1ZGlvKG5ld01lZGlhU3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFN1Y2Nlc3NmdWxseSBzZXQgbXV0ZSBzdGF0ZSB0byBcXGBmYWxzZVxcYCBieSBnZXR0aW5nIG5ldyBpbnB1dCBtZWRpYSBzdHJlYW0hYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmF2aUF1ZGlvU3RyZWFtICYmICFuZXdNdXRlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhdmlBdWRpb1N0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgU3VjY2Vzc2Z1bGx5IHNldCBtdXRlIHN0YXRlIHRvIFxcYGZhbHNlXFxgIGJ5IGVuYWJsaW5nIGFsbCB0cmFja3Mgb24gXFxgX3JhdmlTZXNzaW9uLnN0cmVhbUNvbnRyb2xsZXIuX2lucHV0QXVkaW9TdHJlYW1cXGAhYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IG11dGUgc3RhdGU6IE5vIFxcYF9pbnB1dEF1ZGlvU3RyZWFtXFxgIG9uIFxcYF9yYXZpU2Vzc2lvbi5zdHJlYW1Db250cm9sbGVyXFxgLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IG11dGUgc3RhdGU6IE5vIFxcYF9yYXZpU2Vzc2lvblxcYCwgb3IgXFxgX3JhdmlTZXNzaW9uLmdldFN0cmVhbUNvbnRyb2xsZXIoKVxcYCByZXR1cm5lZCBudWxsLmApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgb3V0cHV0IGBNZWRpYVN0cmVhbWAgZnJvbSB0aGUgTWl4ZXIuIFRoaXMgaXMgdGhlIGZpbmFsLCBtaXhlZCwgc3BhdGlhbGl6ZWQgYXVkaW8gc3RyZWFtIGNvbnRhaW5pbmdcbiAgICAgKiBhbGwgc291cmNlcyBzZW50IHRvIHRoZSBNaXhlci5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWl4ZWQsIHNwYXRpYWxpemVkIGBNZWRpYVN0cmVhbWAgZnJvbSB0aGUgTWl4ZXIuIFJldHVybnMgYG51bGxgIGlmIGl0J3Mgbm90IHBvc3NpYmxlIHRvIG9idGFpbiB0aGF0IGBNZWRpYVN0cmVhbWAuXG4gICAgICovXG4gICAgZ2V0T3V0cHV0QXVkaW9NZWRpYVN0cmVhbSgpOiBNZWRpYVN0cmVhbSB7XG4gICAgICAgIGlmICghdGhpcy5fcmF2aVNlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRTdHJlYW1Db250cm9sbGVyKCk7XG5cbiAgICAgICAgaWYgKCFzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHJlYW1Db250cm9sbGVyLmdldEF1ZGlvU3RyZWFtKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiwgYW5kXG4gICAgICogZmlyZXMgdGhlIG9uQ2hhbmdlIGhhbmRsZXIgaWYgdGhhdCBzdGF0ZSBoYXMsIGluIGZhY3QsIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHN0YXRlXG4gICAgICovXG4gICAgX3NldEN1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlKHN0YXRlOiBIaUZpQ29ubmVjdGlvblN0YXRlcyk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgaWYgKHRoaXMub25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQodGhpcy5fY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faGlmaURpYWdub3N0aWNzLmZpcmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXRDdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSgpOiBIaUZpQ29ubmVjdGlvblN0YXRlcyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBSQVZJIFNpZ25hbGluZyBTdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBldmVudCBcbiAgICAgKi9cbiAgICBhc3luYyBvblJBVklTaWduYWxpbmdTdGF0ZUNoYW5nZWQoZXZlbnQ6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgTmV3IFJBVkkgc2lnbmFsaW5nIHN0YXRlOiBcXGAke2V2ZW50LnN0YXRlfVxcYGApO1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFJhdmlTaWduYWxpbmdTdGF0ZXMuVU5BVkFJTEFCTEU6XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUoSGlGaUNvbm5lY3Rpb25TdGF0ZXMuVW5hdmFpbGFibGUpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2Rpc2Nvbm5lY3RGcm9tSGlGaU1peGVyKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3JDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIubG9nKGBFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSB0cnlpbmcgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb24uIEVycm9yOlxcbiR7ZXJyb3JDbG9zaW5nfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIFJBVkkgU2Vzc2lvbiBTdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqL1xuICAgIGFzeW5jIG9uUkFWSVNlc3Npb25TdGF0ZUNoYW5nZWQoZXZlbnQ6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgTmV3IFJBVkkgc2Vzc2lvbiBzdGF0ZTogXFxgJHtldmVudC5zdGF0ZX1cXGBgKTtcbiAgICAgICAgdGhpcy5fcmF2aURpYWdub3N0aWNzLmZpcmUoKTtcbiAgICAgICAgc3dpdGNoIChldmVudC5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBSYXZpU2Vzc2lvblN0YXRlcy5DT05ORUNURUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fbWl4ZXJQZWVyS2V5VG9TdGF0ZUNhY2hlRGljdCA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEN1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlKEhpRmlDb25uZWN0aW9uU3RhdGVzLkNvbm5lY3RlZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkRJU0NPTk5FQ1RFRDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUgPT09IEhpRmlDb25uZWN0aW9uU3RhdGVzLlVuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZShIaUZpQ29ubmVjdGlvblN0YXRlcy5EaXNjb25uZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2Rpc2Nvbm5lY3RGcm9tSGlGaU1peGVyKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3JDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIubG9nKGBFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSB0cnlpbmcgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb24uIEVycm9yOlxcbiR7ZXJyb3JDbG9zaW5nfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmF2aVNlc3Npb25TdGF0ZXMuRkFJTEVEOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSA9PT0gSGlGaUNvbm5lY3Rpb25TdGF0ZXMuVW5hdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEN1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlKEhpRmlDb25uZWN0aW9uU3RhdGVzLkZhaWxlZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkNMT1NFRDpcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIGFuIFwiVW5hdmFpbGFibGVcIiBzdGF0ZS4gKFRoaXMgd2lsbCBob3BlZnVsbHlcbiAgICAgICAgICAgICAgICAvLyBiZSBhYmxlIHRvIGdvIGF3YXkgb25jZSBjaGFuZ2VzIGZyb20gSElGSS02MjkgYXJlIGNvbXBsZXRlLCBidXQgaXMgc2FmZSB0byBsZWF2ZSBpbiBmb3Igbm93LilcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUgPT09IEhpRmlDb25uZWN0aW9uU3RhdGVzLlVuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZShIaUZpQ29ubmVjdGlvblN0YXRlcy5EaXNjb25uZWN0ZWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnRDb2xsZWN0aW5nV2ViUlRDU3RhdHMoY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmF2aVNlc3Npb24pIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYENvdWxkbid0IHN0YXJ0IGNvbGxlY3RpbmcgV2ViUlRDIHN0YXRzOiBObyBcXGBfcmF2aVNlc3Npb25cXGAhYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc3RhdHNPYnNlcnZlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BDb2xsZWN0aW5nV2ViUlRDU3RhdHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXRzT2JzZXJ2ZXJDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgICAgIHRoaXMuX3JhdmlTZXNzaW9uLmFkZFN0YXRzT2JzZXJ2ZXIodGhpcy5fc3RhdHNPYnNlcnZlckNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBzdG9wQ29sbGVjdGluZ1dlYlJUQ1N0YXRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JhdmlTZXNzaW9uKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBDb3VsZG4ndCBzdG9wIGNvbGxlY3RpbmcgV2ViUlRDIHN0YXRzOiBObyBcXGBfcmF2aVNlc3Npb25cXGAhYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yYXZpU2Vzc2lvbi5yZW1vdmVTdGF0c09ic2VydmVyKHRoaXMuX3N0YXRzT2JzZXJ2ZXJDYWxsYmFjayk7XG5cbiAgICAgICAgdGhpcy5fc3RhdHNPYnNlcnZlckNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YSAtIFRoZSBuZXcgdXNlciBkYXRhIHRoYXQgd2Ugd2FudCB0byBzZW5kIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBzZXJ2ZXIuXG4gICAgICogQHJldHVybnMgSWYgdGhpcyBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bCwgcmV0dXJucyBgeyBzdWNjZXNzOiB0cnVlLCBzdHJpbmdpZmllZERhdGFGb3JNaXhlcjogPHRoZSByYXcgZGF0YSB0aGF0IHdhcyB0cmFuc21pdHRlZCB0byB0aGUgc2VydmVyPn1gLiBJZiB1bnN1Y2Nlc3NmdWwsIHJldHVybnNcbiAgICAgKiBgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IDxhbiBlcnJvciBtZXNzYWdlPiB9YC5cbiAgICAgKi9cbiAgICBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIoY3VycmVudEhpZmlBdWRpb0FQSURhdGE6IEhpRmlBdWRpb0FQSURhdGEsIHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YT86IEhpRmlBdWRpb0FQSURhdGEpOiBhbnkge1xuICAgICAgICBpZiAoIXRoaXMubWl4ZXJJbmZvW1wiY29ubmVjdGVkXCJdIHx8ICF0aGlzLl9yYXZpU2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogYENhbid0IHRyYW5zbWl0IGRhdGEgdG8gbWl4ZXI7IG5vdCBjb25uZWN0ZWQgdG8gbWl4ZXIuYFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkYXRhRm9yTWl4ZXI6IGFueSA9IHt9O1xuXG4gICAgICAgIC8vIGlmIGEgcG9zaXRpb24gaXMgc3BlY2lmaWVkIHdpdGggdmFsaWQgY29tcG9uZW50cywgbGV0J3MgY29uc2lkZXIgYWRkaW5nIHBvc2l0aW9uIHBheWxvYWRcbiAgICAgICAgaWYgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnBvc2l0aW9uICYmICh0eXBlb2YgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLngpID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgJiYgKHR5cGVvZiAoY3VycmVudEhpZmlBdWRpb0FQSURhdGEucG9zaXRpb24ueSkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAmJiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi56KSA9PT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgICAgIC8vIERldGVjdCB0aGUgcG9zaXRpb24gY29tcG9uZW50cyB3aGljaCBoYXZlIHJlYWxseSBjaGFuZ2VkIGNvbXBhcmVkIHRvIHRoZSBwcmV2aW91cyBzdGF0ZSBrbm93biBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkQ29tcG9uZW50czogeyB4OiBib29sZWFuLCB5OiBib29sZWFuLCB6OiBib29sZWFuLCBjaGFuZ2VkOiBib29sZWFuIH0gPSB7IHg6IGZhbHNlLCB5OiBmYWxzZSwgejogZmFsc2UsIGNoYW5nZWQ6IGZhbHNlIH07XG4gICAgICAgICAgICBpZiAocHJldmlvdXNIaWZpQXVkaW9BUElEYXRhICYmIHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi54ICE9PSBwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEucG9zaXRpb24ueCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy54ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi55ICE9PSBwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEucG9zaXRpb24ueSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy55ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi56ICE9PSBwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEucG9zaXRpb24ueikge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy56ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy54ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy55ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy56ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU29tZSBwb3NpdGlvbiBjb21wb25lbnRzIGhhdmUgY2hhbmdlZCwgbGV0J3MgZmlsbCBpbiB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgaWYgKGNoYW5nZWRDb21wb25lbnRzLmNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhbnNsYXRlZFBvc2l0aW9uID0gSGlGaUF4aXNVdGlsaXRpZXMudHJhbnNsYXRlUG9pbnQzRFRvTWl4ZXJTcGFjZShvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24sIGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uIGRhdGEgaXMgc2VudCBpbiBtaWxsaW1ldGVycyBpbnRlZ2VycyB0byByZWR1Y2UgSlNPTiBzaXplLlxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkQ29tcG9uZW50cy54KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcInhcIl0gPSBNYXRoLnJvdW5kKHRyYW5zbGF0ZWRQb3NpdGlvbi54ICogMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkQ29tcG9uZW50cy55KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcInlcIl0gPSBNYXRoLnJvdW5kKHRyYW5zbGF0ZWRQb3NpdGlvbi55ICogMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkQ29tcG9uZW50cy56KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcInpcIl0gPSBNYXRoLnJvdW5kKHRyYW5zbGF0ZWRQb3NpdGlvbi56ICogMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgb3JpZW50YXRpb24gaXMgc3BlY2lmaWVkIHdpdGggdmFsaWQgY29tcG9uZW50cywgbGV0J3MgY29uc2lkZXIgYWRkaW5nIG9yaWVudGF0aW9uIHBheWxvYWRcbiAgICAgICAgaWYgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdCAmJiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQudykgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAmJiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueCkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAmJiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueSkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAmJiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueikgPT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgICAgICAvLyBEZXRlY3QgdGhlIG9yaWVudGF0aW9uIGNvbXBvbmVudHMgd2hpY2ggaGF2ZSByZWFsbHkgY2hhbmdlZCBjb21wYXJlZCB0byB0aGUgcHJldmlvdXMgc3RhdGUga25vd24gZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAgICBsZXQgY2hhbmdlZENvbXBvbmVudHM6IHsgdzogYm9vbGVhbiwgeDogYm9vbGVhbiwgeTogYm9vbGVhbiwgejogYm9vbGVhbiwgY2hhbmdlZDogYm9vbGVhbiB9ID0geyB3OiBmYWxzZSwgeDogZmFsc2UsIHk6IGZhbHNlLCB6OiBmYWxzZSwgY2hhbmdlZDogZmFsc2UgfTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEgJiYgcHJldmlvdXNIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQudyAhPT0gcHJldmlvdXNIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC53KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLncgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC54ICE9PSBwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LngpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMueCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEhpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnkgIT09IHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy55ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueiAhPT0gcHJldmlvdXNIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC56KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnogPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLncgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnogPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTb21lIG9yaWVudGF0aW9uIGNvbXBvbmVudHMgaGF2ZSBjaGFuZ2VkLCBsZXQncyBmaWxsIGluIHRoZSBwYXlsb2FkXG4gICAgICAgICAgICBpZiAoY2hhbmdlZENvbXBvbmVudHMuY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBtaXhlciBleHBlY3RzIFF1YXRlcm5pb24gY29tcG9uZW50cyBpbiBpdHMgc3BhY2UgYW5kIHRvIGJlIG11bGl0aXBsaWVkIGJ5IDEwMDAuXG4gICAgICAgICAgICAgICAgbGV0IHRyYW5zbGF0ZWRPcmllbnRhdGlvbiA9IEhpRmlBeGlzVXRpbGl0aWVzLnRyYW5zbGF0ZU9yaWVudGF0aW9uUXVhdDNEVG9NaXhlclNwYWNlKG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbiwgY3VycmVudEhpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0KTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkQ29tcG9uZW50cy53KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcIldcIl0gPSB0cmFuc2xhdGVkT3JpZW50YXRpb24udyAqIDEwMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkQ29tcG9uZW50cy54KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcIlhcIl0gPSB0cmFuc2xhdGVkT3JpZW50YXRpb24ueCAqIDEwMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkQ29tcG9uZW50cy55KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcIllcIl0gPSB0cmFuc2xhdGVkT3JpZW50YXRpb24ueSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIChjaGFuZ2VkQ29tcG9uZW50cy56KSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBzZW5kIFogYWxsIHRoZSB0aW1lIGF0IHRoZSBtb21lbnQgdW50aWwgd2UgbWVyZ2UgdGhlIGZpeCBodHRwczovL2dpdGh1Yi5jb20vaGlnaGZpZGVsaXR5L2F1ZGlvbmV0LWhpZmkvcHVsbC8yNzFcbiAgICAgICAgICAgICAgICBkYXRhRm9yTWl4ZXJbXCJaXCJdID0gdHJhbnNsYXRlZE9yaWVudGF0aW9uLnogKiAxMDAwO1xuICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiAoY3VycmVudEhpZmlBdWRpb0FQSURhdGEudm9sdW1lVGhyZXNob2xkKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgZGF0YUZvck1peGVyW1wiVFwiXSA9IGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnZvbHVtZVRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLmhpRmlHYWluKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgZGF0YUZvck1peGVyW1wiZ1wiXSA9IE1hdGgubWF4KDAsIGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLmhpRmlHYWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnVzZXJBdHRlbnVhdGlvbikgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcImFcIl0gPSBjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS51c2VyQXR0ZW51YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS51c2VyUm9sbG9mZikgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcInJcIl0gPSBNYXRoLm1heCgwLCBjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS51c2VyUm9sbG9mZik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWUpID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkVXNlckdhaW5zOiBPdGhlclVzZXJHYWluTWFwID0ge307XG4gICAgICAgICAgICBsZXQgaWRUb0dhaW5zID0gT2JqZWN0LmVudHJpZXMoY3VycmVudEhpZmlBdWRpb0FQSURhdGEuX290aGVyVXNlckdhaW5RdWV1ZSk7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNPdGhlclVzZXJHYWlucyA9IHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YSA/IHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YS5fb3RoZXJVc2VyR2FpblF1ZXVlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZFRvR2FpbiBvZiBpZFRvR2FpbnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFzaGVkVmlzaXRJZCA9IGlkVG9HYWluWzBdO1xuICAgICAgICAgICAgICAgIGxldCBnYWluID0gaWRUb0dhaW5bMV07XG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mKGdhaW4pID09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNPdGhlclVzZXJHYWlucyAmJiBwcmV2aW91c090aGVyVXNlckdhaW5zW2hhc2hlZFZpc2l0SWRdID09PSBnYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFuZ2VkVXNlckdhaW5zW2hhc2hlZFZpc2l0SWRdID0gZ2FpbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5lbnRyaWVzKGNoYW5nZWRVc2VyR2FpbnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcIlZcIl0gPSBjaGFuZ2VkVXNlckdhaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRhdGFGb3JNaXhlcikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBjYWxsIHRoaXMgYSBcInN1Y2Nlc3NcIiBldmVuIHRob3VnaCB3ZSBkaWRuJ3Qgc2VuZCBhbnl0aGluZyB0byB0aGUgbWl4ZXIuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZWREYXRhRm9yTWl4ZXI6IEpTT04uc3RyaW5naWZ5KHt9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb21tYW5kQ29udHJvbGxlciA9IHRoaXMuX3JhdmlTZXNzaW9uLmdldENvbW1hbmRDb250cm9sbGVyKCk7XG5cbiAgICAgICAgICAgIGlmIChjb21tYW5kQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGxldCBzdHJpbmdpZmllZERhdGFGb3JNaXhlciA9IEpTT04uc3RyaW5naWZ5KGRhdGFGb3JNaXhlcik7XG4gICAgICAgICAgICAgICAgY29tbWFuZENvbnRyb2xsZXIuc2VuZElucHV0KHN0cmluZ2lmaWVkRGF0YUZvck1peGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZmllZERhdGFGb3JNaXhlcjogc3RyaW5naWZpZWREYXRhRm9yTWl4ZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBDYW4ndCB0cmFuc21pdCBkYXRhIHRvIG1peGVyOyBubyBcXGBjb21tYW5kQ29udHJvbGxlclxcYCEuYFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgb3VyIFwiTWl4ZXIgSW5mb1wiLiBIYXBwZW5zIHVwb24gaW5zdGFudGlhdGlvbiBhbmQgd2hlbiBkaXNjb25uZWN0aW5nIGZyb20gdGhlIG1peGVyLlxuICAgICAqL1xuICAgIHByaXZhdGUgX3Jlc2V0TWl4ZXJJbmZvKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1peGVySW5mbyA9IHtcbiAgICAgICAgICAgIFwiY29ubmVjdGVkXCI6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsIi8qKlxuICogVGhpcyBtb2R1bGUgcGVydGFpbnMgdG8gVXNlciBEYXRhIFN1YnNjcmlwdGlvbnMsIHdoaWNoIGFsbG93IGNsaWVudHMgdG8gcmVjZWl2ZSB1cGRhdGVzIGZyb20gdGhlIFNlcnZlciBhYm91dCBhbGwgbmV3IFVzZXIgRGF0YS5cbiAqIFNlZSBbW2FkZFVzZXJEYXRhU3Vic2NyaXB0aW9uXV0uXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG4vKipcbiAqIFdoZW4gYWRkaW5nIGEgbmV3IFVzZXIgRGF0YSBTdWJzY3JpcHRpb24sIGEgY2xpZW50IG11c3Qgc3BlY2lmeSBvbmUgb2YgdGhlIFwiY29tcG9uZW50c1wiIGxpc3RlZCBhcyBhIHBhcnQgb2YgdGhpcyBgZW51bWAuXG4gKiBGb3IgZXhhbXBsZSwgc3Vic2NyaWJpbmcgdG8gYFBvc2l0aW9uYCB1cGRhdGVzIGVuc3VyZXMgdGhhdCBhIFN1YnNjcmliZXIgd2lsbCByZWNlaXZlIGFsbCBjaGFuZ2VzIHRvIHRoYXQgdXNlcidzIHBvc2l0aW9uLlxuICovXG5leHBvcnQgZW51bSBBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHMge1xuICAgIFBvc2l0aW9uID0gXCJQb3NpdGlvblwiLFxuICAgIE9yaWVudGF0aW9uRXVsZXIgPSBcIk9yaWVudGF0aW9uIChFdWxlcilcIixcbiAgICBPcmllbnRhdGlvblF1YXQgPSBcIk9yaWVudGF0aW9uIChRdWF0ZXJuaW9uKVwiLFxuICAgIFZvbHVtZURlY2liZWxzID0gXCJWb2x1bWUgKERlY2liZWxzKVwiLFxuICAgIElzU3RlcmVvID0gXCJJc1N0ZXJlb1wiXG59XG5cbi8qKlxuICogVXNlciBEYXRhIFN1YnNjcmlwdGlvbnMgYWxsb3cgY2xpZW50IEFQSSB1c2VycyB0byBwZXJmb3JtIGFjdGlvbnMsIHN1Y2ggYXMgbG9nZ2luZywgd2hlbiB0aGUgY2xpZW50XG4gKiByZWNlaXZlcyBuZXcgVXNlciBEYXRhIGZyb20gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIFNlcnZlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFVzZXJEYXRhU3Vic2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdXNlcidzIGBwcm92aWRlZFVzZXJJRGAgYXNzb2NpYXRlZCB3aXRoIHRoZSBTdWJzY3JpcHRpb24uIFNlZSB7QGxpbmsgSGlGaUF1ZGlvQVBJRGF0YX0uIE9wdGlvbmFsLiBJZiB1bnNldCwgdGhlIFN1YnNjcmlwdGlvbiBjYWxsYmFja1xuICAgICAqIHdpbGwgYmUgY2FsbGVkIGZvciBhbGwgdXNlcnMnIGRhdGEgd2hlbiBpdCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHByb3ZpZGVkVXNlcklEOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIFVzZXIgRGF0YSBjb21wb25lbnRzIHRvIHdoaWNoIHdlIHdhbnQgdG8gc3Vic2NyaWJlLCBzdWNoIGFzIFBvc2l0aW9uLCBPcmllbnRhdGlvbkV1bGVyLCBvciBWb2x1bWVEZWNpYmVscy5cbiAgICAgKi9cbiAgICBjb21wb25lbnRzOiBBcnJheTxBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHM+O1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGNsaWVudCByZWNlaXZlcyBuZXcgVXNlciBEYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgYGNvbXBvbmVudGAgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIFRoZSBmaXJzdCBhbmQgb25seSBhcmd1bWVudCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBvZiB0eXBlIGBBcnJheTxSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE+YC5cbiAgICAgKi9cbiAgICBjYWxsYmFjazogRnVuY3Rpb247XG4gICAgXG4gICAgY29uc3RydWN0b3IoeyBwcm92aWRlZFVzZXJJRCA9IG51bGwsIGNvbXBvbmVudHMsIGNhbGxiYWNrIH06IHsgcHJvdmlkZWRVc2VySUQ/OiBzdHJpbmcsIGNvbXBvbmVudHM6IEFycmF5PEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cz4sIGNhbGxiYWNrOiBGdW5jdGlvbiB9KSB7XG4gICAgICAgIHRoaXMucHJvdmlkZWRVc2VySUQgPSBwcm92aWRlZFVzZXJJRDtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbn0iLCIvKipcbiAqIFRoaXMgbW9kdWxlIGRlZmluZXMgYSBudW1iZXIgb2YgY29uc3RhbnRzIHVzZWQgdGhyb3VnaG91dCB0aGUgQVBJIGNvZGUuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG4vKipcbiAqIERlZmluZXMgYSBudW1iZXIgb2YgY29uc3RhbnRzIHVzZWQgdGhyb3VnaG91dCB0aGUgQVBJIGNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBIaUZpQ29uc3RhbnRzIHtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIHRoYXQgbXVzdCBwYXNzIGJldHdlZW4gQVBJIHRyYW5zbWlzc2lvblxuICAgICAqIG9mIGRhdGEgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgc3RhdGljIE1JTl9UUkFOU01JVF9SQVRFX0xJTUlUX1RJTUVPVVRfTVM6IG51bWJlciA9IDEwO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGRlZmF1bHQgYW1vdW50IG9mIHRpbWUgdGhhdCBtdXN0IHBhc3MgYmV0d2VlbiBBUEkgdHJhbnNtaXNzaW9uXG4gICAgICogb2YgZGF0YSBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgREVGQVVMVF9UUkFOU01JVF9SQVRFX0xJTUlUX1RJTUVPVVRfTVM6IG51bWJlciA9IDUwO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9kdWN0aW9uIGVuZHBvaW50IGZvciBvdXIgSGlnaCBGaWRlbGl0eSBhdWRpbyBjb25uZWN0aW9ucy5cbiAgICAgKi9cbiAgICBzdGF0aWMgREVGQVVMVF9QUk9EX0hJR0hfRklERUxJVFlfRU5EUE9JTlQ6IHN0cmluZyA9IFwiYXBpLmhpZ2hmaWRlbGl0eS5jb21cIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBwb3J0IGZvciBzaWduYWxpbmcgY29ubmVjdGlvbnMgdG8gb3VyIEhpZ2ggRmlkZWxpdHkgYXVkaW8gc2VydmVycy5cbiAgICAgKi9cbiAgICBzdGF0aWMgREVGQVVMVF9QUk9EX0hJR0hfRklERUxJVFlfUE9SVDogbnVtYmVyID0gNDQzO1xuXG4gICAgY29uc3RydWN0b3IoKSB7fVxufTtcbiIsImltcG9ydCB7IEhpRmlNaXhlclNlc3Npb24gfSBmcm9tIFwiLi4vY2xhc3Nlcy9IaUZpTWl4ZXJTZXNzaW9uXCI7XG5pbXBvcnQgeyBSYXZpU2Vzc2lvbiwgU1RBVFNfV0FUQ0hFUl9GSUxURVIgfSBmcm9tIFwiLi4vbGlicmF2aS9SYXZpU2Vzc2lvblwiO1xuXG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IG5vb3AgPSAoXzphbnkpOmFueSA9PiB1bmRlZmluZWQ7XG5jb25zdCB4U3RvcmFnZSA9IGlzQnJvd3NlciA/IHdpbmRvdy5sb2NhbFN0b3JhZ2UgOiB7Z2V0SXRlbTogbm9vcCwgc2V0SXRlbTogbm9vcCwgcmVtb3ZlSXRlbTogbm9vcH07XG5jb25zdCB4QWRkRXZlbnRMaXN0ZW5lcjphbnkgPSBpc0Jyb3dzZXIgPyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA6IG5vb3A7XG5jb25zdCB4UmVtb3ZlRXZlbnRMaXN0ZW5lcjphbnkgPSBpc0Jyb3dzZXIgPyB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciA6IG5vb3A7XG5jb25zdCB4RG9jdW1lbnQgPSBpc0Jyb3dzZXIgPyB3aW5kb3cuZG9jdW1lbnQgOiB7dmlzaWJpbGl0eVN0YXRlOiB0cnVlLCBhZGRFdmVudExpc3RlbmVyOiBub29wLCByZW1vdmVFdmVudExpc3RlbmVyOiBub29wfTtcbmNvbnN0IHhOYXZpZ2F0b3IgPSBpc0Jyb3dzZXIgPyB3aW5kb3cubmF2aWdhdG9yIDoge29uTGluZTogdHJ1ZSwgdXNlckFnZW50OiBgTm9kZUpTICR7KHByb2Nlc3MucmVwb3J0LmdldFJlcG9ydCgpIGFzIGFueSkuaGVhZGVyLm5vZGVqc1ZlcnNpb259YH07XG5sZXQgeGZldGNoID0gaXNCcm93c2VyICYmIHdpbmRvdy5mZXRjaDtcbmlmICghaXNCcm93c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgeGZldGNoID0gcmVxdWlyZSgnbm9kZS1mZXRjaCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgOyAvLyBSZW1haW5zIGZhbHNleS4gRG9uJ3QgcmVwb3J0LCBkb24ndCBsb2dcbiAgICB9XG59XG5cbmNvbnN0IG5vbk9wZXJhdGl2ZSA9IFwibm9uLW9wZXJhdGl2ZVwiO1xuXG5TVEFUU19XQVRDSEVSX0ZJTFRFUi5zZXQoJ3JlbW90ZS1pbmJvdW5kLXJ0cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU1RBVFNfV0FUQ0hFUl9GSUxURVIuZ2V0KCdyZW1vdGUtaW5ib3VuZC1ydHAnKS5jb25jYXQoWydwYWNrZXRzTG9zdCcsICd0b3RhbFJvdW5kVHJpcFRpbWUnXSkpO1xuU1RBVFNfV0FUQ0hFUl9GSUxURVIuc2V0KCdpbmJvdW5kLXJ0cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU1RBVFNfV0FUQ0hFUl9GSUxURVIuZ2V0KCdpbmJvdW5kLXJ0cCcpLmNvbmNhdChbJ3BhY2tldHNMb3N0JywgJ3BhY2tldHNSZWNlaXZlZCcsICdqaXR0ZXInXSkpO1xuU1RBVFNfV0FUQ0hFUl9GSUxURVIuc2V0KCdvdXRib3VuZC1ydHAnLCBbJ3R5cGUnLCAncmV0cmFuc21pdHRlZFBhY2tldHNTZW50JywgJ3BhY2tldHNTZW50J10pO1xuXG5TVEFUU19XQVRDSEVSX0ZJTFRFUi5zZXQoJ2NhbmRpZGF0ZS1wYWlyJywgWyd3cml0YWJsZScsICdzdGF0ZScsICdub21pbmF0ZWQnLCAnbG9jYWxDYW5kaWRhdGVJZCcsICdyZW1vdGVDYW5kaWRhdGVJZCddKTtcblNUQVRTX1dBVENIRVJfRklMVEVSLnNldCgncmVtb3RlLWNhbmRpZGF0ZScsIFsnaWQnLCAnYWRkcmVzcycsICdpcCcsICdjYW5kaWRhdGVUeXBlJywgJ3Byb3RvY29sJ10pO1xuU1RBVFNfV0FUQ0hFUl9GSUxURVIuc2V0KCdsb2NhbC1jYW5kaWRhdGUnLCBbJ2lkJywgJ2FkZHJlc3MnLCAnaXAnLCAnY2FuZGlkYXRlVHlwZScsICdwcm90b2NvbCddKTtcblxuaW50ZXJmYWNlIENhbmRpZGF0ZVJlcG9ydCB7XG4gICAgaXA/OiBzdHJpbmc7XG4gICAgYWRkcmVzcz86IHN0cmluZztcbiAgICBjYW5kaWRhdGVUeXBlPzogc3RyaW5nO1xuICAgIHByb3RvY29sPzogc3RyaW5nO1xufVxubGV0IG5TdGF0c0NsaWVudHMgPSAwO1xubGV0IGJyb3dzZXJTdGF0czogQ2FuZGlkYXRlUmVwb3J0ID0ge307XG5sZXQgcmVtb3RlU3RhdHM6IENhbmRpZGF0ZVJlcG9ydCA9IHt9O1xubGV0IHJlcG9ydHM6YW55O1xuY29uc3QgdXNlRGVidWdQcmVmaXhlcyA9IGZhbHNlO1xuXG4vKiogXG4gKiBAaW50ZXJuYWxcbiAqIFRoaXMgaXMgbm90IGdlbmVyYWwgcHVycG9zZSwgYnV0IHNwZWNpZmljYWxseSBpbiBzdXBwb3J0IG9mIGludGVybmFsIEhpRmlkZWxpdHkgY29ubmVjdGlvbiBmYWlsdXJlcy5cbiAqIEl0IGlzIG5vdCBpbnRlbmRlZCB0byBiZSBzdXBwb3J0ZWQgZm9yIGxvbmcgdGVybS5cbiAqXG4gKiBBbiBpbnN0YW5jZSBvZiBEaWFnbm9zdGljcyBtYWludGFpbnMgYSBzZXQgb2YgaW5mb3JtYXRpb24sIGFuZCBoYXMgb3BlcmF0aW9ucyB0byB1cGRhdGUgdGhhdCBpbmZvcm1hdGlvbiwgYW5kIHRvIHJlcG9ydCBpdC5cbiAqIFRoZXJlIGNhbiBiZSBtdWx0aXBsZSBzdWNoIGluc3RhbmNlcywgdGhhdCBhcmUgcmVwb3J0ZWQgaW4gZGlmZmVyZW50IGNpcmN1bXN0YW5jZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEaWFnbm9zdGljcyB7XG4gICAgbGFiZWw6IHN0cmluZztcbiAgICB1cmw6IHN0cmluZztcbiAgICBpZGVudGlmaWVyOiBzdHJpbmc7XG4gICAgc2Vzc2lvbjogSGlGaU1peGVyU2Vzc2lvbjtcbiAgICByYXZpOiBSYXZpU2Vzc2lvbjtcbiAgICBleHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2U6IGJvb2xlYW47XG4gICAgd2ViU29ja2V0OiBhbnk7XG4gICAgcnRjOiBhbnk7XG4gICAgZmlyZU9uOiBBcnJheTxzdHJpbmc+O1xuICAgIGZpcmVMaXN0ZW5lcjogRnVuY3Rpb247XG4gICAgb25saW5lTGlzdGVuZXI6IEZ1bmN0aW9uO1xuXG4gICAgY29uc3RydWN0b3Ioe3VybCA9IFwiaHR0cHM6Ly93ZWJydGMtZGlhZy5oaWdoZmlkZWxpdHkuY29tL2FwaS92MS9sb2dzL3Bvc3RfbG9nc1wiLFxuICAgICAgICAgICAgICAgICBsYWJlbCwgc2Vzc2lvbiwgcmF2aSwgZmlyZU9uID0gW119Ont1cmw/OnN0cmluZywgbGFiZWw6c3RyaW5nLCBzZXNzaW9uOkhpRmlNaXhlclNlc3Npb24sIHJhdmk6UmF2aVNlc3Npb24sIGZpcmVPbj86QXJyYXk8c3RyaW5nPn0pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7dXJsLCBsYWJlbCwgc2Vzc2lvbiwgcmF2aSwgZmlyZU9ufSk7XG4gICAgICAgIHRoaXMuY2hlY2tQZXJzaXN0ZWQoKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLmZpcmVMaXN0ZW5lciA9ICgpID0+IHRoaXMuZmlyZSgpO1xuICAgICAgICB0aGlzLm9ubGluZUxpc3RlbmVyID0gKCkgPT4gdGhpcy5jaGVja1BlcnNpc3RlZCgpO1xuICAgIH1cbiAgICAvKiogXG4gICAgICogQW4gaW5zdGFuY2UgaXMgcHJpbWVkIHdoZW4gZW50ZXJpbmcgdGhlIHN0YXRlIHdlIGFyZSBpbnRlcmVzdGVkIGluLCB1bnRpbCB0aGUgcmVwb3J0IGlzIGZpcmVkLlxuICAgICAqL1xuICAgIHByaW1lKGlkZW50aWZpZXI6c3RyaW5nKSB7IC8vIGUuZy4sIGhhc2hlZFZpc2l0SUQuIERvIE5PVCB1c2UgYW55IHBlcnNvbmFsbHkgaWRlbnRpZmlhYmxlIGluZm9ybWF0aW9uLiBEYXRhIGlzIGEgbGlhYmlsaXR5LCBub3QgYW4gYXNzZXQuXG4gICAgICAgIGlmICh0aGlzLmlzUHJpbWVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5jaGVja1BlcnNpc3RlZCgpOyAvLyBCZWNhdXNlIHRoaXMgaXMgYSBsaWtlbHkgdGltZSB0byBiZSBzdWNjZXNzZnVsLlxuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICAgICAgICB0aGlzLmdyYWJSVENJbnRlcm5hbHMoKTtcbiAgICAgICAgRGlhZ25vc3RpY3Muc3RhcnRTdGF0cyh0aGlzLnNlc3Npb24pO1xuICAgICAgICB0aGlzLmZpcmVPbi5mb3JFYWNoKGV2ZW50ID0+ICh4RG9jdW1lbnQgYXMgYW55KS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmZpcmVMaXN0ZW5lcikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoaXMgd2hlbiB3ZSBnZXQgaW50byBhIHN0YXRlIHRoYXQgd2Ugd2FudCB0byBrbm93IG1vcmUgYWJvdXQsIGUuZy4sIHdoZW4gbGVhdmluZyB0aGUgdGhpbmcgdGhhdCBjYXVzZWQgdXMgdG8gcHJpbWUoKS5cbiAgICAgKi9cbiAgICBhc3luYyBmaXJlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNQcmltZWQoKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCByZXBvcnRTdHJpbmcgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghIGF3YWl0IHRoaXMucmVwb3J0KHJlcG9ydFN0cmluZykpIHtcbiAgICAgICAgICAgIHRoaXMucGVyc2lzdChyZXBvcnRTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIG5vdGVFeHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZXhwbGljaXRBcHBsaWNhdGlvbkNsb3NlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBNb3N0bHkgaW50ZXJuYWwgc3R1ZmYuXG4gICAgLy8gc3RhdGUuLi5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgcHJpbWUoKS4gVXN1YWxseSBpbnRlcm5hbCB0byB0aGUgb3BlcmF0aW9ucyBvZiB0aGUgRGlhZ25vc3RpY3MsIGJ1dCBjYW4gYmUgY2FsbGVkIGZyb20gb3V0c2lkZS5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgRGlhZ25vc3RpY3Muc3RvcFN0YXRzKHRoaXMuc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IG5vbk9wZXJhdGl2ZTtcbiAgICAgICAgdGhpcy5leHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXQgPSB0aGlzLnJ0YyA9IHt9O1xuICAgICAgICAvLyBkb24ndCBsZWF2ZSB0aGVtIGhhbmdpbmcgYXJvdW5kLiBFLmcuLCBiZWZvcmV1bmxvYWQgY2FuIG1lc3Mgd2l0aCB0aGUgYmZjYWNoZS5cbiAgICAgICAgdGhpcy5maXJlT24uZm9yRWFjaChldmVudCA9PiAoeERvY3VtZW50IGFzIGFueSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5maXJlTGlzdGVuZXIpKTtcbiAgICAgICAgcmVwb3J0cyA9IHtcbiAgICAgICAgICAgICdvdXRib3VuZC1ydHAnOiB7fSxcbiAgICAgICAgICAgICdpbmJvdW5kLXJ0cCc6IHt9LFxuICAgICAgICAgICAgJ3JlbW90ZS1pbmJvdW5kLXJ0cCc6IHt9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNQcmltZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkZW50aWZpZXIgIT09IG5vbk9wZXJhdGl2ZTtcbiAgICB9XG4gICAgLy8gc3RyaW5ncy4uLlxuICAgIC8qKlxuICAgICAqIEFuc3dlciBhIHNpbmdsZSAobG9uZykgbG9nIGxpbmUgdG8gcmVwb3J0LlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfSAke3RoaXMuaWRlbnRpZmllcn0gYCArXG4gICAgICAgICAgICB0aGlzLnMoJ2xvZ1JlYXNvbicsICdzZXNzaW9uRU5EJykgK1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdHMoJ2Jyb3dzZXJTdGF0cycpICtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXRzKCdtaXhlclN0YXRzJykgK1xuICAgICAgICAgICAgdGhpcy5ydHBTdGF0cygpICtcbiAgICAgICAgICAgIHRoaXMucnRjU3RhdGVzKCkgK1xuICAgICAgICAgICAgdGhpcy5zKCdOVU1fQ09OTkVDVEVEJywgdGhpcy5zZXNzaW9uLmNvbmN1cnJlbmN5LCAnXFxuJykgK1xuICAgICAgICAgICAgdGhpcy5zKCdBUFBTVEFURScsIHRoaXMuc2Vzc2lvbi5nZXRDdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSgpLCAnXFxuJykgK1xuICAgICAgICAgICAgdGhpcy5zKCdSQVZJU1RBVEUnLCB0aGlzLnJhdmkuZ2V0U3RhdGUoKSkgK1xuICAgICAgICAgICAgdGhpcy5zKCdPTkxJTkUnLCB4TmF2aWdhdG9yLm9uTGluZSA/ICd5ZXMnIDogJ25vJykgK1xuICAgICAgICAgICAgdGhpcy5zKCdYUExJQ0lUQ0xPU0VEJywgdGhpcy5leHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2UgPyAneWVzJyA6ICdubycpICtcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eUluZm8oKSArXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JbmZvKCkgK1xuICAgICAgICAgICAgKHVzZURlYnVnUHJlZml4ZXMgPyAnXFxuJyA6ICcnKSArXG4gICAgICAgICAgICBgIFske3hOYXZpZ2F0b3IudXNlckFnZW50fV1gO1xuICAgIH1cbiAgICBzKG5hbWU6c3RyaW5nLCB2YWx1ZTphbnksIGRlYnVnUHJlZml4ID0gJycpIHtcbiAgICAgICAgbGV0IHNlcGFyYXRvciA9IGlzTmFOKHZhbHVlKSA/ICdfJyA6ICc6JztcbiAgICAgICAgcmV0dXJuIGAke3VzZURlYnVnUHJlZml4ZXMgPyBkZWJ1Z1ByZWZpeCA6ICcnfSAke3RoaXMubGFiZWx9JHtuYW1lfSR7c2VwYXJhdG9yfSR7dmFsdWV9YDtcbiAgICB9XG4gICAgY29ubmVjdGlvbkluZm8oKSB7XG4gICAgICAgIGNvbnN0IGluZm86YW55ID0gKHhOYXZpZ2F0b3IgYXMgYW55KS5jb25uZWN0aW9uIHx8ICh4TmF2aWdhdG9yIGFzIGFueSkubW96Q29ubmVjdGlvbiB8fCAoeE5hdmlnYXRvciBhcyBhbnkpLndlYmtpdENvbm5lY3Rpb24gfHwge307XG4gICAgICAgIHJldHVybiB0aGlzLnMoJ0RFVklDRScsIGluZm8udHlwZSwgJ1xcbicpICtcbiAgICAgICAgICAgIHRoaXMucygnUkFUSU5HJywgaW5mby5lZmZlY3RpdmVUeXBlKSArXG4gICAgICAgICAgICB0aGlzLnMoJ0RMJywgaW5mby5kb3dubGluaykgK1xuICAgICAgICAgICAgdGhpcy5zKCdSVFQnLCBpbmZvLnJ0dCk7XG4gICAgfVxuICAgIHZpc2liaWxpdHlJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zKCdWSVNJQkxJVFknLCB4RG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSBmaXJlLCBJJ2QgbGlrZSB0byBkaXJlY3RseSBhc2sgdGhlIFJUQ1BlZXJDb25uZWN0aW9uIGFuZCBvdXIgc2lnbmFsaW5nIFdlYlNvY2tldCBzb21lIHF1ZXN0aW9ucywgYXMgYSBzYW5pdHkgY2hlY2tcbiAgICAgKiB0aGF0IHRoaW5ncyBtYXRjaCB0aGUgUmF2aSBzdGF0ZS4gQnV0IGlmIGFsbCBnb2VzIHdlbGwsIHdlJ3ZlIGFscmVhZHkgcmVsZWFzZWQgdGhlbS4gU28gaGVyZSB3ZSBncmFiIHRoZW0gd2hpbGUgd2UgY2FuIGFuZFxuICAgICAqIGhvbGQgb3VyIG93biByZWZlcmVuY2VzLCB0byBiZSBjbGVhcmVkIG9uIHJlc2V0KCk7XG4gICAgICovIFxuICAgIGdyYWJSVENJbnRlcm5hbHMoKSB7XG4gICAgICAgIGxldCByYXZpOmFueSA9IHRoaXMucmF2aSxcbiAgICAgICAgICAgIHJhdmlSVEM6YW55ID0gcmF2aS5fcmF2aUltcGxlbWVudGF0aW9uLFxuICAgICAgICAgICAgc2lnbmFsaW5nOmFueSA9IHJhdmlSVEMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24uX3NpZ25hbGluZ0ltcGxlbWVudGF0aW9uO1xuICAgICAgICB0aGlzLndlYlNvY2tldCA9IHNpZ25hbGluZy5fd2ViU29ja2V0O1xuICAgICAgICB0aGlzLnJ0YyA9IHJhdmlSVEMuX3J0Y0Nvbm5lY3Rpb247XG4gICAgfVxuICAgIHJ0Y1N0YXRlcygpIHtcbiAgICAgICAgLy8gVGhpcyBiaXphcnJlIHBhdHRlcm4gaXMgdG8gZ2V0IGFzIG11Y2ggaW5mbyBhcyBwb3NzaWJsZSwgZXZlbiBmcm9tIGJyb3dzZXJzIHN1Y2ggYXMgRmlyZWZveCB0aGF0XG4gICAgICAgIC8vIHRocm93IGVycm9ycyBmb3Igc29tZSBwcm9wZXJ0aWVzLlxuICAgICAgICBsZXQgY29sbGVjdG9yOmFueSA9IHt9LFxuICAgICAgICAgICAgc2FmZWx5R2V0ID0gKHByb3BlcnR5OnN0cmluZywgc291cmNlOmFueSA9IHRoaXMucnRjKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdG9yW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3JbcHJvcGVydHldID0gZS5uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIHNhZmVseUdldCgncmVhZHlTdGF0ZScsIHRoaXMud2ViU29ja2V0KTtcbiAgICAgICAgWydjb25uZWN0aW9uU3RhdGUnLCAnc2lnbmFsaW5nU3RhdGUnLCAnaWNlQ29ubmN0aW9uU3RhdGUnLCdpY2VHYXRoZXJpbmdTdGF0ZSddLmZvckVhY2gocCA9PiBzYWZlbHlHZXQocCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zKCdXZWJTb2NrZXQnLCBjb2xsZWN0b3IucmVhZHlTdGF0ZSwgJ1xcbicpICtcbiAgICAgICAgICAgIHRoaXMucygnUlRDJywgY29sbGVjdG9yLmNvbm5lY3Rpb25TdGF0ZSkgK1xuICAgICAgICAgICAgdGhpcy5zKCdTSUdOQUxJTkcnLCBjb2xsZWN0b3Iuc2lnbmFsaW5nU3RhdGUpICtcbiAgICAgICAgICAgIHRoaXMucygnSUNFJywgY29sbGVjdG9yLmljZUNvbm5lY3Rpb25TdGF0ZSkgK1xuICAgICAgICAgICAgdGhpcy5zKCdHQVRIRVJJTkcnLCBjb2xsZWN0b3IuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgIH1cbiAgICBjb25uZWN0aW9uU3RhdHMoa2luZDpzdHJpbmcpIHtcbiAgICAgICAgbGV0IHJlcG9ydCA9IGtpbmQgPT09ICdicm93c2VyU3RhdHMnID8gIGJyb3dzZXJTdGF0cyA6IHJlbW90ZVN0YXRzO1xuICAgICAgICByZXR1cm4gdGhpcy5zKGtpbmQrJ0lQJywgcmVwb3J0LmlwIHx8IHJlcG9ydC5hZGRyZXNzLCAnXFxuJykgK1xuICAgICAgICAgICAgdGhpcy5zKGtpbmQrJ1RZUEUnLCByZXBvcnQuY2FuZGlkYXRlVHlwZSkgK1xuICAgICAgICAgICAgdGhpcy5zKGtpbmQrJ1BST1RPQ09MJywgcmVwb3J0LnByb3RvY29sKTtcbiAgICB9XG4gICAgcnRwU3RhdHMoKSB7XG4gICAgICAgIGxldCBzOnN0cmluZyA9ICcnO1xuICAgICAgICBPYmplY3Qua2V5cyhyZXBvcnRzKS5mb3JFYWNoKHJlcG9ydE5hbWUgPT4ge1xuICAgICAgICAgICAgbGV0IHJlcG9ydCA9IHJlcG9ydHNbcmVwb3J0TmFtZV0sXG4gICAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocmVwb3J0KS5mb3JFYWNoKHByb3BlcnR5TmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgcyArPSB0aGlzLnMoYCR7cmVwb3J0TmFtZX1fJHtwcm9wZXJ0eU5hbWV9YCwgcmVwb3J0W3Byb3BlcnR5TmFtZV0sIGZpcnN0ID8gJ1xcbicgOiAnJyk7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIFxuICAgIC8vIFBob25pbmcgaG9tZS4uLlxuICAgIC8qKlxuICAgICAqIFJldHVybiBzdWNjZXNzLCBvciBhIHByb21pc2UgZm9yIHN1Y2Nlc3MuXG4gICAgICovXG4gICAgcmVwb3J0KHJlcG9ydFN0cmluZzpzdHJpbmcpIHtcbiAgICAgICAgaWYgKCF4TmF2aWdhdG9yLm9uTGluZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXhmZXRjaCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIGJlYWNvbiBpcyBzdWNjZXNzZnVsbHkgcXVldWVkLCBub3Qgc2VudC5cbiAgICAgICAgLy8gVWx0aW1hdGVseSwgd2Ugd291bGQgbmVlZCBhIHZlcmlmaWNhdGlvbiAoZS5nLiwgbmV4dCBzZXNzaW9uKSB0byBzZWUgaWYgdGhlIHByZXZpb3VzIGlkZW50aWZpZXIgd2FzIGxvZ2dlZC5cbiAgICAgICAgLy8gQSBmYWlsdXJlIGdldHMgbG9nZ2VkIHRvIGNvbnNvbGUgaW4gc29tZSBicm93c2VycywgYnV0IHRoZXkgZG9uJ3QgYWN0dWFsbHkgZW1pdCBhbiBlcnJvciBldmVudC5cbiAgICAgICAgLy8gcmV0dXJuIG5hdmlnYXRvci5zZW5kQmVhY29uKHRoaXMudXJsLCByZXBvcnRTdHJpbmcpO1xuICAgICAgICAvLyBJbnN0ZWFkLCBsZXQncyBQT1NUIGV4YWN0bHkgYXMgc2VuZEJlYWNvbiB3b3VsZCwgYW5kIGNoZWNrIHN1Y2Nlc3M6XG4gICAgICAgIHJldHVybiB4ZmV0Y2godGhpcy51cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ3RleHQvcGxhaW4nIH0sXG4gICAgICAgICAgICBib2R5OiByZXBvcnRTdHJpbmdcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2U6UmVzcG9uc2UpID0+IHJlc3BvbnNlLm9rLCAoeDphbnkpID0+IGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHJlcG9ydFN0cmluZyB0byB0aGUgc2V0IG9mIGRhdGEgYmVpbmcgc2F2ZWQgZm9yIGxhdGVyIHJlcG9ydGluZy5cbiAgICAgKi9cbiAgICBwZXJzaXN0KHJlcG9ydFN0cmluZzpzdHJpbmcpIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nID0geFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmxhYmVsKSB8fCBcIlwiO1xuICAgICAgICAvLyBCeSBjb25zdHJ1Y3Rpb24gZXhpc3RpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgZW1wdHkgb3Igb25lIGxpbmUuIEl0IGNvdWxkIGhhdmUgbXVsdGlwbGUgbGluZXMgaWZcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBidWcsIG9yIGlmIHRoZSBhcHBsaWNhdGlvbiBzaXRlIGxpbWl0cyB0aGUgY29ubmVjdC1zcmMgKG9yIGRlZmF1bHQtc3JjKVxuICAgICAgICAvLyBpbiBpdHMgQ29udGVudC1TZWN1cml0eS1Qb2xpY3kgaGVhZGVyIHdpdGhvdXQgYWxsb3dpbmcgdGhpcy51cmwuXG4gICAgICAgIC8vIElmIGl0IGlzIG1vcmUgdGhhbiBhIGxpbmUsIHdlIGFyZSBhY2N1bXVsYXRpbmcgc3R1ZmYgYW5kIHJlYWxseSBvdWdodCB0byBwaG9uZSBob21lIHRocm91Z2ggdGhlIG1peGVyIHdoZW4gY29ubmVjdGVkLlxuICAgICAgICBpZiAoZXhpc3RpbmcpIGV4aXN0aW5nICs9IFwiXFxuXCI7XG4gICAgICAgIHhTdG9yYWdlLnNldEl0ZW0odGhpcy5sYWJlbCwgZXhpc3RpbmcgKyByZXBvcnRTdHJpbmcpO1xuICAgICAgICAvLyBBbiBvcHRpbWl6YXRpb24gdG8gZ2V0IGNhdWdodCB1cCBvbiBkYXRhIHF1aWNrZXIgaW4gdGhlIGNhc2Ugd2hlcmUgbmV0d29yayBpcyBsb3N0IGFuZCByZXR1cm5zIHdoaWxlIHRhYiBpcyBzdGlsbCB1cC5cbiAgICAgICAgeEFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMub25saW5lTGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSdzIGFueXRoaW5nIHBlcnNpc3RlZCwgdHJ5IHRvIHJlcG9ydCBpdC4gSWYgc3VjY2Vzc2Z1bCwgY2xlYXIgcGVyc2lzdGVuY2UuXG4gICAgICovXG4gICAgYXN5bmMgY2hlY2tQZXJzaXN0ZWQoKSB7XG4gICAgICAgIHhSZW1vdmVFdmVudExpc3RlbmVyKCdvbmxpbmUnLCB0aGlzLm9ubGluZUxpc3RlbmVyKTtcbiAgICAgICAgbGV0IGV4aXN0aW5nID0geFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmxhYmVsKTtcbiAgICAgICAgaWYgKCFleGlzdGluZykgcmV0dXJuO1xuICAgICAgICBpZiAoISBhd2FpdCB0aGlzLnJlcG9ydChleGlzdGluZykpIHJldHVybjtcbiAgICAgICAgeFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmxhYmVsKTtcbiAgICB9XG4gICAgLy8gUlRDIHN0YXRzLi4uXG4gICAgLy8gUmF2aSBvbmx5IGFsbG93cyBvbmUgc3RhdHMgY29sbGVjdGlvbiBmdW5jdGlvbiBhdCBhIHRpbWUsIHNvIHdlJ2xsIGhhdmUgdG8gc2hhcmVcbiAgICAvLyBhbW9uZyBhbGwgdGhlIGRpYWdub3N0aWNzLlxuICAgIHN0YXRpYyBzdGFydFN0YXRzKHNlc3Npb246SGlGaU1peGVyU2Vzc2lvbikgeyAvLyBSZXN1bHRzIG5vdCBkZWZpbmVkIGlmIGNhbGxlZCB3aXRoIGRpZmZlcmVudCBzZXNzaW9uLlxuICAgICAgICBpZiAoblN0YXRzQ2xpZW50cysrID4gMCkgcmV0dXJuOyAvLyBTb21lb25lIHByaW1lZCBiZWZvcmUgdGhpcyBjYWxsIChhbmQgc2luY2UgdGhlIGZpbmFsIHJlc2V0KS5cbiAgICAgICAgc2Vzc2lvbi5zdGFydENvbGxlY3RpbmdXZWJSVENTdGF0cygobmV4dDphbnksIHByZXZpb3VzOmFueSkgPT4ge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gbmV4dC5maW5kKChyZXBvcnQ6YW55KSA9PiByZXBvcnQud3JpdGFibGUgfHwgcmVwb3J0Lm5vbWluYXRlZCksXG4gICAgICAgICAgICAgICAgbG9jYWxSZXBvcnQgPSBuZXh0LmZpbmQoKHJlcG9ydDphbnkpID0+IHJlcG9ydC5pZCA9PT0gc2VsZWN0ZWQubG9jYWxDYW5kaWRhdGVJZCksXG4gICAgICAgICAgICAgICAgcmVtb3RlUmVwb3J0ID0gbmV4dC5maW5kKChyZXBvcnQ6YW55KSA9PiByZXBvcnQuaWQgPT09IHNlbGVjdGVkLnJlbW90ZUNhbmRpZGF0ZUlkKTtcbiAgICAgICAgICAgIGlmIChsb2NhbFJlcG9ydCkgIGJyb3dzZXJTdGF0cyA9IGxvY2FsUmVwb3J0O1xuICAgICAgICAgICAgaWYgKHJlbW90ZVJlcG9ydCkgcmVtb3RlU3RhdHMgPSByZW1vdGVSZXBvcnQ7XG4gICAgICAgICAgICBmdW5jdGlvbiBub3RlKHR5cGU6c3RyaW5nLCBkZWx0YVByb3BlcnRpZXM6QXJyYXk8c3RyaW5nPiwgYWJzb2x1dGVQcm9wZXJ0aWVzOkFycmF5PHN0cmluZz4gPSBbXSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRSZXBvcnQobGlzdDphbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QuZmluZCgocmVwb3J0OmFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcG9ydC50eXBlID09IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXNSZXBvcnQgPSBmaW5kUmVwb3J0KHByZXZpb3VzKSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlcG9ydCA9IGZpbmRSZXBvcnQobmV4dCk7XG4gICAgICAgICAgICAgICAgZGVsdGFQcm9wZXJ0aWVzLmZvckVhY2gocHJvcGVydHkgPT4gcmVwb3J0c1t0eXBlXVtwcm9wZXJ0eV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXBvcnQgJiYgKG5leHRSZXBvcnRbcHJvcGVydHldIC0gKHByZXZpb3VzUmVwb3J0ID8gcHJldmlvdXNSZXBvcnRbcHJvcGVydHldIDogMCkpKTtcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVByb3BlcnRpZXMuZm9yRWFjaChwcm9wZXJ0eSA9PiByZXBvcnRzW3R5cGVdW3Byb3BlcnR5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJlcG9ydCAmJiBuZXh0UmVwb3J0W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3RlKCdvdXRib3VuZC1ydHAnLCBbJ3JldHJhbnNtaXR0ZWRQYWNrZXRzU2VudCcsICdwYWNrZXRzU2VudCddKTtcbiAgICAgICAgICAgIG5vdGUoJ2luYm91bmQtcnRwJywgWydwYWNrZXRzTG9zdCcsICdwYWNrZXRzUmVjZWl2ZWQnXSwgWydqaXR0ZXInXSk7XG4gICAgICAgICAgICBub3RlKCdyZW1vdGUtaW5ib3VuZC1ydHAnLCBbJ3BhY2tldHNMb3N0J10sIFsncm91bmRUcmlwVGltZScsICd0b3RhbFJvdW5kVHJpcFRpbWUnLCAnaml0dGVyJ10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHN0b3BTdGF0cyhzZXNzaW9uOkhpRmlNaXhlclNlc3Npb24pIHtcbiAgICAgICAgaWYgKCFuU3RhdHNDbGllbnRzKSByZXR1cm47XG4gICAgICAgIGlmICgtLW5TdGF0c0NsaWVudHMgPiAwKSByZXR1cm47ICAgLy8gU29tZW9uZSBpcyBzdGlsbCBwcmltZWQuICAgICBcbiAgICAgICAgc2Vzc2lvbi5zdG9wQ29sbGVjdGluZ1dlYlJUQ1N0YXRzKCk7XG4gICAgICAgIGJyb3dzZXJTdGF0cyA9IHJlbW90ZVN0YXRzID0ge307XG4gICAgfVxufVxuXG4iLCJkZWNsYXJlIHZhciBISUZJX0FQSV9WRVJTSU9OOiBzdHJpbmc7XG5cbi8vIENoZWNrIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHlcbmltcG9ydCB7IEhpRmlVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvSGlGaVV0aWxpdGllc1wiO1xuZXhwb3J0IHsgSGlGaVV0aWxpdGllcyB9O1xubGV0IGlzQnJvd3NlckNvbnRleHQgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCc7XG5pZiAoaXNCcm93c2VyQ29udGV4dCkge1xuICAgIEhpRmlVdGlsaXRpZXMuY2hlY2tCcm93c2VyQ29tcGF0aWJpbGl0eSgpO1xufVxubGV0IGFwaVZlcnNpb24gPSB0eXBlb2YgKEhJRklfQVBJX1ZFUlNJT04pID09PSBcInN0cmluZ1wiID8gSElGSV9BUElfVkVSU0lPTiA6IFwidW5rbm93blwiO1xuZXhwb3J0IHsgYXBpVmVyc2lvbiBhcyBoaUZpQVBJVmVyc2lvbiB9OyBcbmV4cG9ydCB7IGFwaVZlcnNpb24gfTsgXG5cblxuLy8gVmVyYm9zaXR5IGNhbiBiZSBnb29kIHNvbWV0aW1lcyFcbi8vIFRoZSBmaXJzdCBzZWN0aW9uIG9mIGBleHBvcnRgcyBoZXJlIGV4cG9zZSB0aGUgQ2xpZW50IExpYnJhcnkncyBlbnRyeSBwb2ludHNcbi8vIHVzaW5nIHZlcmJvc2UgbGFuZ3VhZ2UuIFRoaXMgdXN1YWxseSBtZWFucyB0aGF0IGV2ZXJ5IGVudHJ5IHBvaW50IGlzIHByZXBlbnRlZCB3aXRoIGBIaUZpYC5cbi8vIERvaW5nIHRoaXMgaGVscHMgcmVkdWNlIG5hbWVzcGFjZSBjb2xsaXNpb25zIGluIHVzZXIgYXBwbGljYXRpb25zLlxuLy8gU29tZSBwZW9wbGUgZG9uJ3Qgd2FudCB0byB0eXBlIGBIaUZpYCBldmVyeSB0aW1lIHRoZXkgd2FudCB0byB1c2Ugb3VyIENsaWVudCBMaWJyYXJ5LFxuLy8gc28gd2UgYWxzbyBvZmZlciBzaG9ydGVyIHN5bm9ueW1zIGZvciBldmVyeSBMaWJyYXJ5IGVudHJ5IHBvaW50LlxuLy8gU2Nyb2xsIGRvd24gdG8gY2hlY2sgb3V0IHRob3NlIHNob3J0ZXIgc3lub255bXMuXG5leHBvcnQgeyBIaUZpQXVkaW9BUElEYXRhLCBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEsIE9yaWVudGF0aW9uRXVsZXIzRCwgT3JpZW50YXRpb25RdWF0M0QsIFBvaW50M0QsIGV1bGVyVG9RdWF0ZXJuaW9uLCBldWxlckZyb21RdWF0ZXJuaW9ufSBmcm9tIFwiLi9jbGFzc2VzL0hpRmlBdWRpb0FQSURhdGFcIjtcbmV4cG9ydCB7IEhpRmlDb21tdW5pY2F0b3IsIEhpRmlDb25uZWN0aW9uU3RhdGVzLCBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXMgfSBmcm9tIFwiLi9jbGFzc2VzL0hpRmlDb21tdW5pY2F0b3JcIjtcbmV4cG9ydCB7IFdlYlJUQ1Nlc3Npb25QYXJhbXMgfSBmcm9tIFwiLi9saWJyYXZpL1JhdmlTZXNzaW9uXCI7XG5leHBvcnQgeyBBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHMsIFVzZXJEYXRhU3Vic2NyaXB0aW9uIH0gZnJvbSBcIi4vY2xhc3Nlcy9IaUZpVXNlckRhdGFTdWJzY3JpcHRpb25cIjtcbmV4cG9ydCB7IEhpRmlMb2dMZXZlbCwgSGlGaUxvZ2dlciB9IGZyb20gXCIuL3V0aWxpdGllcy9IaUZpTG9nZ2VyXCI7XG5leHBvcnQgeyBIaUZpQ29uc3RhbnRzIH0gZnJvbSBcIi4vY29uc3RhbnRzL0hpRmlDb25zdGFudHNcIjtcbmV4cG9ydCB7IEhpRmlBeGVzLCBIaUZpSGFuZGVkbmVzcywgSGlGaUF4aXNDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4vY2xhc3Nlcy9IaUZpQXhpc0NvbmZpZ3VyYXRpb25cIjtcblxuLy8gSGVyZSBhcmUgdmFyaW91cyBleHBsaWNpdCBleHBvcnRzIGZyb20gd2l0aGluIHRoZSBgSGlGaVV0aWxpdGllc2AgY2xhc3MgZm9yIGNvbnZlbmllbmNlLlxubGV0IGdldEJlc3RBdWRpb0NvbnN0cmFpbnRzID0gSGlGaVV0aWxpdGllcy5nZXRCZXN0QXVkaW9Db25zdHJhaW50cztcbmV4cG9ydCB7IGdldEJlc3RBdWRpb0NvbnN0cmFpbnRzIH07XG5sZXQgcHJlY2lzZUludGVydmFsID0gSGlGaVV0aWxpdGllcy5wcmVjaXNlSW50ZXJ2YWw7XG5leHBvcnQgeyBwcmVjaXNlSW50ZXJ2YWwgfTtcblxuLy8gU2hvcnQgc3lub255bXMgZm9yIHRoZSBhYm92ZSBzdGFydCBoZXJlIVxuLy8gUGxlYXNlIGxldCB1cyBrbm93IGlmIGFueSBvZiB0aGVzZSBgZXhwb3J0c2AgY2F1c2UgbmFtZXNwYWNlIGNvbGxpc2lvbnNcbi8vIGluIHlvdXIgYXBwbGljYXRpb24uXG5leHBvcnQgeyBIaUZpQ29tbXVuaWNhdG9yIGFzIENvbW11bmljYXRvciwgSGlGaUNvbm5lY3Rpb25TdGF0ZXMgYXMgQ29ubmVjdGlvblN0YXRlcywgSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzIGFzIFVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzIH0gZnJvbSBcIi4vY2xhc3Nlcy9IaUZpQ29tbXVuaWNhdG9yXCI7XG5leHBvcnQgeyBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEgYXMgUmVjZWl2ZWRBdWRpb0FQSURhdGEsIEhpRmlBdWRpb0FQSURhdGEgYXMgQXVkaW9BUElEYXRhIH0gZnJvbSBcIi4vY2xhc3Nlcy9IaUZpQXVkaW9BUElEYXRhXCI7XG5leHBvcnQgeyBIaUZpTG9nZ2VyIGFzIExvZ2dlciwgSGlGaUxvZ0xldmVsIGFzIExvZ0xldmVsIH0gZnJvbSBcIi4vdXRpbGl0aWVzL0hpRmlMb2dnZXJcIjtcbmV4cG9ydCB7IEhpRmlVdGlsaXRpZXMgYXMgVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL0hpRmlVdGlsaXRpZXNcIjtcbmV4cG9ydCB7IEhpRmlDb25zdGFudHMgYXMgQ29uc3RhbnRzIH0gZnJvbSBcIi4vY29uc3RhbnRzL0hpRmlDb25zdGFudHNcIjtcbmV4cG9ydCB7IEhpRmlBeGVzIGFzIEF4ZXMsIEhpRmlIYW5kZWRuZXNzIGFzIEhhbmRlZG5lc3MsIEhpRmlBeGlzQ29uZmlndXJhdGlvbiBhcyBBeGlzQ29uZmlndXJhdGlvbiB9IGZyb20gXCIuL2NsYXNzZXMvSGlGaUF4aXNDb25maWd1cmF0aW9uXCI7XG4iLCJpbXBvcnQgeyBSYXZpVXRpbHMgfSBmcm9tICcuL1JhdmlVdGlscyc7XG5cbi8qKlxuICogVXNlZCBmb3Igc3RvcmluZyB0aGUgYmluYXJ5IGNvbW1hbmQgaGFuZGxlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IF9CSU5BUllfQ09NTUFORF9LRVkgPSBcIl9CSU5BUllcIjtcblxuXG4vKipcbiAqIE1vdXNlIHN0YXRlIG1lc3NhZ2UgaXMgNyBmbG9hdHMgYWthIDcgKiA0ID0gMjggYnl0ZXNcbiAqL1xuY29uc3QgX01PVVNFX1NUQVRFX0JVRkZFUl9TSVpFID0gMjg7XG5cbmVudW0gX0tFWV9DT0RFX1RBQkxFIHtcbiAgXCJDb250cm9sTGVmdFwiID0gMCxcbiAgXCJBbHRMZWZ0XCIgPSAxLFxuICBcIk9TTGVmdFwiID0gMixcbiAgXCJTcGFjZVwiID0gMyxcbiAgXCJPU1JpZ2h0XCIgPSA0LFxuICBcIkFsdFJpZ2h0XCIgPSA1LFxuICBcIkNvbnRyb2xSaWdodFwiID0gNixcblxuICBcIlNoaWZ0TGVmdFwiID0gNyxcbiAgXCJTaGlmdFJpZ2h0XCIgPSA4LFxuICBcIkNvbW1hXCIgPSA5LFxuICBcIlBlcmlvZFwiID0gMTAsXG4gIFwiU2xhc2hcIiA9IDExLFxuIFxuICBcIkNhcHNMb2NrXCIgPSAxMixcbiAgXCJFbnRlclwiID0gMTMsXG4gIFwiU2VtaWNvbG9uXCIgPSAxNCxcbiAgXCJRdW90ZVwiID0gMTUsXG5cbiAgXCJUYWJcIiA9IDE2LFxuICBcIkJyYWNrZXRMZWZ0XCIgPSAxNyxcbiAgXCJCcmFja2V0UmlnaHRcIiA9IDE4LFxuICBcIkJhY2tzbGFzaFwiID0gMTksXG5cbiAgXCJCYWNrcXVvdGVcIiA9IDIwLFxuICBcIk1pbnVzXCIgPSAyMSxcbiAgXCJFcXVhbFwiID0gMjIsXG5cbiAgXCJEaWdpdDBcIiA9IDIzLFxuICBcIkRpZ2l0MVwiID0gMjQsXG4gIFwiRGlnaXQyXCIgPSAyNSxcbiAgXCJEaWdpdDNcIiA9IDI2LFxuICBcIkRpZ2l0NFwiID0gMjcsXG4gIFwiRGlnaXQ1XCIgPSAyOCxcbiAgXCJEaWdpdDZcIiA9IDI5LFxuICBcIkRpZ2l0N1wiID0gMzAsXG4gIFwiRGlnaXQ4XCIgPSAzMSxcbiAgXCJEaWdpdDlcIiA9IDMyLFxuXG4gIFwiQmFja3NwYWNlXCIgPSAzMyxcblxuICBcIkVzY2FwZVwiID0gMzQsXG4gXG4gIFwiQXJyb3dMZWZ0XCIgPSAzNSxcbiAgXCJBcnJvd1JpZ2h0XCIgPSAzNixcbiAgXCJBcnJvd0Rvd25cIiA9IDM3LFxuICBcIkFycm93VXBcIiA9IDM4LFxuICBcIlBhZ2VEb3duXCIgPSAzOSxcbiAgXCJQYWdlVXBcIiA9IDQwLFxuICBcIkVuZFwiID0gNDEsXG4gIFwiSG9tZVwiID0gNDIsXG4gIFwiRGVsZXRlXCIgPSA0MyxcbiAgXCJJbnNlcnRcIiA9IDQ0LFxuXG4gIFwiTnVtcGFkMFwiID0gNDUsXG4gIFwiTnVtcGFkMVwiID0gNDYsXG4gIFwiTnVtcGFkMlwiID0gNDcsXG4gIFwiTnVtcGFkM1wiID0gNDgsXG4gIFwiTnVtcGFkNFwiID0gNDksXG4gIFwiTnVtcGFkNVwiID0gNTAsXG4gIFwiTnVtcGFkNlwiID0gNTEsXG4gIFwiTnVtcGFkN1wiID0gNTIsXG4gIFwiTnVtcGFkOFwiID0gNTMsXG4gIFwiTnVtcGFkOVwiID0gNTQsXG4gXG4gIFwiTnVtcGFkRGVjaW1hbFwiID0gNTUsXG4gIFwiTnVtcGFkRW50ZXJcIiA9IDU2LFxuICBcIk51bXBhZEFkZFwiID0gNTcsXG4gIFwiTnVtcGFkU3VidHJhY3RcIiA9IDU4LFxuICBcIk51bUxvY2tcIiA9IDU5LFxuICBcIk51bXBhZEVxdWFsXCIgPSA2MCxcbiAgXCJOdW1wYWRNdWx0aXBseVwiID0gNjEsXG4gIFwiTnVtcGFkRGl2aWRlXCIgPSA2MixcbiBcbiAgXCJLZXlBXCIgPSA2MyxcbiAgXCJLZXlCXCIgPSA2NCxcbiAgXCJLZXlDXCIgPSA2NSxcbiAgXCJLZXlEXCIgPSA2NixcbiAgXCJLZXlFXCIgPSA2NyxcbiAgXCJLZXlGXCIgPSA2OCxcbiAgXCJLZXlHXCIgPSA2OSxcbiAgXCJLZXlIXCIgPSA3MCxcbiAgXCJLZXlJXCIgPSA3MSxcbiAgXCJLZXlKXCIgPSA3MixcbiAgXCJLZXlLXCIgPSA3MyxcbiAgXCJLZXlMXCIgPSA3NCxcbiAgXCJLZXlNXCIgPSA3NSxcbiAgXCJLZXlOXCIgPSA3NixcbiAgXCJLZXlPXCIgPSA3NyxcbiAgXCJLZXlQXCIgPSA3OCxcbiAgXCJLZXlRXCIgPSA3OSxcbiAgXCJLZXlSXCIgPSA4MCxcbiAgXCJLZXlTXCIgPSA4MSxcbiAgXCJLZXlUXCIgPSA4MixcbiAgXCJLZXlVXCIgPSA4MyxcbiAgXCJLZXlWXCIgPSA4NCxcbiAgXCJLZXlXXCIgPSA4NSxcbiAgXCJLZXlYXCIgPSA4NixcbiAgXCJLZXlZXCIgPSA4NyxcbiAgXCJLZXlaXCIgPSA4OCxcbn07XG5jb25zdCBfS0VZQk9BUkRfU1RBVEVfQlVGRkVSX1NJWkUgPSAxMjtcblxuLyoqIFxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIFRoaXMgY2xhc3MgaGFuZGxlcyBxdWV1aW5nLCBtYW5hZ2luZywgYW5kIHRyYW5zbWl0dGluZyBjb21tYW5kcyBmcm9tIGEgUkFWSSBKYXZhU2NyaXB0IGNsaWVudFxuICogdG8gYSBSQVZJIHNlcnZlci4gXG4gKiBUaGlzIGNsYXNzIGlzIHByb3ZpZGVkIGJ5IGEge0BsaW5rIFJhdmlTZXNzaW9ufSBhbmQgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gKlxuICogRXhhbXBsZSB1c2FnZSAoc2VuZGluZyBpbmZvcm1hdGlvbiBvbiBtb3VzZSBkb3VibGUtY2xpY2spOlxuICogXG4gKiBgYGBcbiAqIHZhciBjb21tYW5kQ29udHJvbGxlciA9IHJhdmlTZXNzaW9uLmdldENvbW1hbmRDb250cm9sbGVyKCk7XG4gKiBsZXQgaGFuZGxlTW91c2VEb3VibGVDbGljayA9IChldmVudCkgPT4ge1xuICogICB2YXIgcG9zID0gbW91c2VIYW5kbGVyKGV2ZW50KVxuICogICBjb21tYW5kQ29udHJvbGxlci5zZW5kSW5wdXQoe1wiY1wiOiBcIkRvdWJsZUNsaWNrXCIsIFwicFwiOiBwb3MgfSlcbiAqIH07XG4gKmBgYFxuICovXG5leHBvcnQgY2xhc3MgUmF2aUNvbW1hbmRDb250cm9sbGVyIHtcbiAgX2NvbW1hbmRRdWV1ZU1hcDogTWFwPHN0cmluZywgYW55PjtcbiAgX251bVF1ZXVlZENvbW1hbmRzOiBudW1iZXI7XG4gIF9jb21tYW5kUXVldWVJbnRlcnZhbDogbnVtYmVyO1xuICBfY29tbWFuZFB1bXBUaW1lcjogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+O1xuXG4gIF9pbnB1dFRhcmdldDogSFRNTEVsZW1lbnQ7XG4gIF9rZXlib2FyZFRhcmdldDogSFRNTEVsZW1lbnQ7XG5cbiAgX21vdXNlU3RhdGVCdWZmZXI6IEFycmF5QnVmZmVyO1xuICBfbW91c2VTdGF0ZVVpbnQ4OiBVaW50OEFycmF5O1xuICBfbW91c2VTdGF0ZUZsb2F0OiBGbG9hdDMyQXJyYXk7XG5cbiAgX2tleWJvYXJkU3RhdGVCdWZmZXI6IEFycmF5QnVmZmVyO1xuICBfa2V5Ym9hcmRTdGF0ZTogVWludDhBcnJheTtcblxuICBfaW5wdXREYXRhQ2hhbm5lbDogUlRDRGF0YUNoYW5uZWw7XG4gIF9jb21tYW5kRGF0YUNoYW5uZWw6IFJUQ0RhdGFDaGFubmVsO1xuXG4gIC8qKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKlxuICAgKiBDb21tYW5kLWNoYW5uZWwgcmVsYXRlZDogXG4gICAqIHRoaXMuX2NvbW1hbmREYXRhQ2hhbm5lbDtcbiAgICogdGhpcy5fY29tbWFuZFF1ZXVlTWFwO1xuICAgKiB0aGlzLl9udW1RdWV1ZWRDb21tYW5kcztcbiAgICogdGhpcy5fY29tbWFuZFB1bXBUaW1lcjtcbiAgICogdGhpcy5fY29tbWFuZFF1ZXVlSW50ZXJ2YWw7XG4gICAqXG4gICAqIElucHV0LWNoYW5uZWwgcmVsYXRlZDpcbiAgICogdGhpcy5faW5wdXREYXRhQ2hhbm5lbDtcbiAgICogdGhpcy5faW5wdXRUYXJnZXQ7XG4gICAqIHRoaXMuX2tleWJvYXJkVGFyZ2V0O1xuICAgKi9cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUkFWSSBjb21tYW5kIGNvbnRyb2xsZXIuIFxuICAgKiBEZWZhdWx0cyB0aGUgY29tbWFuZFF1ZXVlSW50ZXJ2YWwgdG8gMSBzZWNvbmRcbiAgICogYW5kIGluaXRpYWxpemVzIHZhcmlhYmxlcy5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiY29uc3RydWN0b3JcIiwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgXG4gICAgdGhpcy5fY29tbWFuZFF1ZXVlTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX251bVF1ZXVlZENvbW1hbmRzID0gMDtcbiAgICB0aGlzLl9jb21tYW5kUXVldWVJbnRlcnZhbCA9IDEwMDA7XG4gICAgdGhpcy5fY29tbWFuZFB1bXBUaW1lciA9IG51bGw7XG5cbiAgICB0aGlzLl9pbnB1dFRhcmdldDtcbiAgICB0aGlzLl9rZXlib2FyZFRhcmdldDtcblxuICAgIC8vIE1vdXNlIHN0YXRlIGJ1ZmZlciBjb250YWlucyB0aGUgJ00nIGNoYXIgdG8gaW5kaWNhdGUgdGhlIHBheWxvYWQgb24gdGhlIGlucHV0IGRhdGEgY2hhbm5lbFxuICAgIHRoaXMuX21vdXNlU3RhdGVCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoX01PVVNFX1NUQVRFX0JVRkZFUl9TSVpFICsgNCk7XG4gICAgLy8gc2V0ICdNJyBhcyB0aGUgZmlyc3QgY2hhciBvZiB0aGUgTW91c2VkU3RhdGUgYnVmZmVyXG4gICAgdGhpcy5fbW91c2VTdGF0ZVVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fbW91c2VTdGF0ZUJ1ZmZlcik7XG4gICAgdGhpcy5fbW91c2VTdGF0ZVVpbnQ4WzBdID0gMHg0RFxuICAgIC8vIEFsbG9jYXRlIHRoZSB2aWV3IG9uIHRoZSBtb3VzZSBidWZmZXIgYXMgZmxvYXRzIHN0YXJ0aW5nIG9uIHRoZSAybmQgYnl0ZVxuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdCA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fbW91c2VTdGF0ZUJ1ZmZlciwgNCApO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFswXSA9IC0xLjA7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzFdID0gLTEuMDtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMl0gPSAtMS4wO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFszXSA9IC0xLjA7XG4gICAgXG4gICAgLy8gS2V5Ym9hcmQgc3RhdGUgYnVmZmVyIGNvbnRhaW5zIHRoZSAnaycgY2hhciB0byBpbmRpY2F0ZSB0aGUgcGF5bG9hZFxuICAgIHRoaXMuX2tleWJvYXJkU3RhdGVCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoX0tFWUJPQVJEX1NUQVRFX0JVRkZFUl9TSVpFICsgMSk7XG4gICAgdGhpcy5fa2V5Ym9hcmRTdGF0ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2tleWJvYXJkU3RhdGVCdWZmZXIpO1xuICAgIHRoaXMuX2tleWJvYXJkU3RhdGVbMF0gPSAweDRCOyAvLyBzZXQgJ0snIGFzIHRoZSBmaXJzdCBjaGFyIG9mIHRoZSBLZXlib2FyZFN0YXRlIGJ1ZmZlclxuICB9XG4gIFxuICAvKipcbiAgICogU2V0IHRoZSBpbnRlcnZhbCBhdCB3aGljaCB3ZSBzaG91bGQgc2VuZCBjb21tYW5kc1xuICAgKiB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge2ludH0gcXVldWVJbnRlcnZhbCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJldHdlZW5cbiAgICogc2VuZGluZyBjb21tYW5kcy4gRGVmYXVsdHMgdG8gMTAwMCAoMSBzZWNvbmQpLlxuICAgKi9cbiAgc2V0Q29tbWFuZFF1ZXVlSW50ZXJ2YWwocXVldWVJbnRlcnZhbDogbnVtYmVyKSB7XG4gICAgdGhpcy5fY29tbWFuZFF1ZXVlSW50ZXJ2YWwgPSBxdWV1ZUludGVydmFsO1xuICAgIC8vIElmIHRoZSBjb21tYW5kIHF1ZXVlIGlzIHJ1bm5pbmcsIHN0b3AgaXQgYW5kXG4gICAgLy8gcmVzdGFydCBpdC5cbiAgICBpZiAodGhpcy5fY29tbWFuZFB1bXBUaW1lcikge1xuICAgICAgdGhpcy5zdG9wTW9uaXRvcmluZ1F1ZXVlcygpO1xuICAgICAgdGhpcy5tb25pdG9yUXVldWVzKCk7XG4gICAgfVxuICB9XG4gIFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgbGlzdGVuaW5nIGZvciByZXNwb25zZXMgdG8gcXVldWVkIGNvbW1hbmRzXG4gICAqIEBjYWxsYmFjayBSYXZpQ29tbWFuZENvbnRyb2xsZXJ+Y29tbWFuZENhbGxiYWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZSBUaGUgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyXG4gICAqL1xuICAvKipcbiAgICogUXVldWUgdXAgYSBjb21tYW5kIHRvIGJlIHNlbnQgd2hlbiByZWFkeSwgYWxvbmdcbiAgICogdGhlIFwiY29tbWFuZFwiIGRhdGEgY2hhbm5lbC5cbiAgICogU2VlIGFsc28ge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI3NlbmRJbnB1dH1cbiAgICogdG8gc2VuZCBpbW1lZGlhdGUgaW5wdXQgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGhlcmUgaXMgYSByZXF1ZXN0IGZvciBhIG5ldyB2aWRlbyBrZXlmcmFtZTpcbiAgICogYGBgXG4gICAqIGNvbW1hbmRDb250cm9sbGVyLnF1ZXVlQ29tbWFuZChcInZpZGVvLmZvcmNlS2V5RnJhbWVcIiwge30sIGhhbmRsZXIpXG4gICAqXG4gICAqIGBgYFxuICAgKiBOT1RFOiBUaGVzZSBjb21tYW5kcyBzZW50IHRvIHRoZSBSQVZJIHNlcnZlciB3aWxsIGJlIHNlbnQgYXMgSlNPTixcbiAgICogYW5kIGhhbmRsZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGVzZSBjb21tYW5kcyBhcmUgZXhwZWN0ZWQgdG9cbiAgICogcmVjZWl2ZSBKU09OIGFzIGEgcmVzcG9uc2UuIElmIHlvdSBuZWVkIHRvIHByb2Nlc3MgYmluYXJ5IGRhdGFcbiAgICogcmVjZWl2ZWQgaW4gcmVzcG9uc2UgdG8gYSBjb21tYW5kLCB5b3Ugc2hvdWxkIHNlbmQgdGhlIGNvbW1hbmQgXG4gICAqIHdpdGhvdXQgYSBoYW5kbGVyLCBhbmQgdGhlbiBBTFNPIHNwZWNpZnkgYSBnbG9iYWwgYmluYXJ5IGxpc3RlbmVyXG4gICAqIHdpdGgge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI2FkZEJpbmFyeUhhbmRsZXJ9XG4gICAqIHRvIGlkZW50aWZ5IGFuZCBhcHByb3ByaWF0ZWx5IHByb2Nlc3MgdGhlIHJlc3BvbnNlLiBCaW5hcnlcbiAgICogZGF0YSBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIGEgY29tbWFuZCwgYW5kIHNvIGFsbCBiaW5hcnkgaGFuZGxlcnNcbiAgICogYXJlIGV4ZWN1dGVkIGZvciBhbGwgYmluYXJ5IGRhdGEgcmVjZWl2ZWQ7IGJpbmFyeSBoYW5kbGVycyBzaG91bGRcbiAgICogdGhlbXNlbHZlcyBkZXRlcm1pbmUgaWYgdGhlIGRhdGEgdGhleSd2ZSBiZWVuIGdpdmVuIGlzIHRoZSBkYXRhXG4gICAqIHRoZXkncmUgZXhwZWN0aW5nLiAoQW5kIGlmIHlvdSB3YW50IHRvIHNlbmQgdGhlIGNvbW1hbmQgYXMgYmluYXJ5XG4gICAqIGZyb20gdGhlIEpTIHNpZGUsIHVzZSB7bGluayBSYXZpQ29tbWFuZENvbnRyb2xsZXIjcXVldWVCaW5hcnlDb21tYW5kfSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmQgVGhlIGNvbW1hbmQgdG8gYWRkIHRvIHRoZSBxdWV1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gICBQYXJhbWV0ZXJzIHRvIGluY2x1ZGUgYWxvbmcgd2l0aCB0aGUgY29tbWFuZFxuICAgKiBAcGFyYW0ge1JhdmlDb21tYW5kQ29udHJvbGxlcn5jb21tYW5kQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhbnkgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXG4gICAqL1xuICBxdWV1ZUNvbW1hbmQoY29tbWFuZDogc3RyaW5nLCBwYXJhbTogYW55LCBoYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIC8vIEFkZCB0aGUgY29tbWFuZCB0byB0aGUgcXVldWUgZm9yIHRoaXMgcGFydGljdWxhclxuICAgIC8vIHR5cGUgb2YgY29tbWFuZFxuICAgIHZhciBjb21tYW5kUXVldWUgPSB0aGlzLl9jb21tYW5kUXVldWVNYXAuZ2V0KGNvbW1hbmQpO1xuICAgIGlmICghY29tbWFuZFF1ZXVlKSB7XG4gICAgICBjb21tYW5kUXVldWUgPSB7IHRvU2VuZDogW10sIGxpc3RlbmVyOiBbXSB9O1xuICAgICAgdGhpcy5fY29tbWFuZFF1ZXVlTWFwLnNldChjb21tYW5kLCBjb21tYW5kUXVldWUpO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVySW5zdGFuY2UgPSBudWxsO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAvLyBGb3Igbm93LCBhbGwgaGFuZGxlcnMgYXNzb2NpYXRlZCB3aXRoIGFjdHVhbCBzZW50IGNvbW1hbmRzXG4gICAgICAvLyBhcmUgbm90IFwic3RpY2t5XCIgKGkuZS4gdGhleSBvbmx5IGV4ZWN1dGUgb25jZSwgd2hlbiB0aGUgY29tbWFuZCByZXR1cm5zKVxuICAgICAgLy8gYW5kIHRoZXkgRE8gaGF2ZSBhIFwibWF0Y2hpbmcgc2VudCBjb21tYW5kXCJcbiAgICAgIGhhbmRsZXJJbnN0YW5jZSA9IG5ldyBSYXZpQ29tbWFuZEhhbmRsZXJJbnN0YW5jZShoYW5kbGVyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGNvbW1hbmRRdWV1ZS50b1NlbmQucHVzaCggbmV3IFJhdmlDb21tYW5kSW5zdGFuY2UoY29tbWFuZCwgcGFyYW0sIGhhbmRsZXJJbnN0YW5jZSkgKTtcblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiB3YWl0aW5nIGNvbW1hbmRzIHNlcGFyYXRlbHkgc28gd2UgZG9uJ3QgaGF2ZVxuICAgIC8vIHRvIGtlZXAgY2FsY3VsYXRpbmcgaXQgd2hlbiB3ZSBjaGVjayBmb3IgcXVldWVkIGNvbW1hbmRzXG4gICAgdGhpcy5fbnVtUXVldWVkQ29tbWFuZHMrKztcbiAgICBcbiAgICBSYXZpVXRpbHMubG9nKFwiQWRkZWQgY29tbWFuZCBcIiArIGNvbW1hbmQsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXVlIHVwIGEgYmluYXJ5IG1lc3NhZ2UgdG8gYmUgc2VudCB3aGVuIHJlYWR5LCBhbG9uZ1xuICAgKiB0aGUgXCJjb21tYW5kXCIgZGF0YSBjaGFubmVsLlxuICAgKiBTZWUgYWxzbyB7bGluayBSYXZpQ29tbWFuZENvbnRyb2xsZXIjc2VuZElucHV0fVxuICAgKiB0byBzZW5kIGltbWVkaWF0ZSBpbnB1dCB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBOT1RFOiBZb3UgY2FuIG5vdCBpbmNsdWRlIGEgaGFuZGxlciBpbiB0aGlzIG1ldGhvZCwgYmVjYXVzZVxuICAgKiBiaW5hcnkgbWVzc2FnZXMgYXJlIG5vdCBjdXJyZW50bHkgZGlzdGluZ3Vpc2hhYmxlIGZyb20gZWFjaFxuICAgKiBvdGhlciBhcyByZWdhcmRzIGhhbmRsZXJzIChpLmUuIHRoZXJlIGlzIG5vIFwiY29tbWFuZFwiIGFzc29jaWF0ZWRcbiAgICogd2l0aCBhIGJpbmFyeSBtZXNzYWdlKS4gSWYgeW91IHdhbnQgdG8gYXNzaWduIGEgaGFuZGxlciB0aGF0XG4gICAqIHdpbGwgcHJvY2VzcyBiaW5hcnkgbWVzc2FnZXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLCB1c2VcbiAgICoge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI2FkZEJpbmFyeUhhbmRsZXJ9XG4gICAqIHRvIGlkZW50aWZ5IGFuZCBhcHByb3ByaWF0ZWx5IHByb2Nlc3MgdGhlIHJlc3BvbnNlLiBCaW5hcnlcbiAgICogZGF0YSBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIGFuIGluZGl2aWR1YWwgY29tbWFuZCwgYW5kIHNvIGFsbCBiaW5hcnkgaGFuZGxlcnNcbiAgICogYXJlIGV4ZWN1dGVkIGZvciBhbGwgYmluYXJ5IGRhdGEgcmVjZWl2ZWQ7IGJpbmFyeSBoYW5kbGVycyBzaG91bGRcbiAgICogdGhlbXNlbHZlcyBkZXRlcm1pbmUgaWYgdGhlIGRhdGEgdGhleSd2ZSBiZWVuIGdpdmVuIGlzIHRoZSBkYXRhXG4gICAqIHRoZXkncmUgZXhwZWN0aW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBtZXNzYWdlIEFuIEFycmF5QnVmZmVyIChleHBlY3RlZCBieSB0aGUgc2VydmVyIHRvIGJlIGEgVWludDhBcnJheSkgdGhhdCBzaG91bGQgYmUgc2VudCB0byB0aGUgc2VydmVyXG4gICAqL1xuICBxdWV1ZUJpbmFyeUNvbW1hbmQobWVzc2FnZTogQXJyYXlCdWZmZXIpIHtcbiAgICAvLyBBZGQgdGhlIGNvbW1hbmQgdG8gdGhlIGJpbmFyeSBxdWV1ZSBcbiAgICBsZXQgY29tbWFuZCA9IF9CSU5BUllfQ09NTUFORF9LRVk7XG4gICAgdmFyIGNvbW1hbmRRdWV1ZSA9IHRoaXMuX2NvbW1hbmRRdWV1ZU1hcC5nZXQoY29tbWFuZCk7XG4gICAgaWYgKCEgY29tbWFuZFF1ZXVlKSB7XG4gICAgICBjb21tYW5kUXVldWUgPSB7IHRvU2VuZDogW10sIGxpc3RlbmVyOiBbXSB9O1xuICAgICAgdGhpcy5fY29tbWFuZFF1ZXVlTWFwLnNldChjb21tYW5kLCBjb21tYW5kUXVldWUpO1xuICAgIH1cblxuICAgIGNvbW1hbmRRdWV1ZS50b1NlbmQucHVzaCggbmV3IFJhdmlDb21tYW5kSW5zdGFuY2UobWVzc2FnZSwgbnVsbCwgbnVsbCkgKTtcblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiB3YWl0aW5nIGNvbW1hbmRzIHNlcGFyYXRlbHkgc28gd2UgZG9uJ3QgaGF2ZVxuICAgIC8vIHRvIGtlZXAgY2FsY3VsYXRpbmcgaXQgd2hlbiB3ZSBjaGVjayBmb3IgcXVldWVkIGNvbW1hbmRzXG4gICAgdGhpcy5fbnVtUXVldWVkQ29tbWFuZHMrKztcbiAgICBcbiAgICBSYXZpVXRpbHMubG9nKFwiQWRkZWQgYmluYXJ5IGNvbW1hbmRcIiwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gIH1cblxuICBcbiAgLyoqXG4gICAqIEFkZCBhIGNvbW1hbmQgaGFuZGxlciBvbmx5LCB3aXRob3V0IGFsc28gcXVldWluZyB1cCBhIGNvbW1hbmQgdG8gc2VuZC5cbiAgICogVGhpcyBsaXN0ZW5lciB3aWxsIHdhdGNoIGZvciBhIG1lc3NhZ2UgdG8gYmUgcmVjZWl2ZWQgZnJvbSB0aGVcbiAgICogc2VydmVyIChvbiB0aGUgXCJjb21tYW5kXCIgZGF0YSBjaGFubmVsKSB0aGF0IG1hdGNoZXMgdGhlIGV4cGVjdGVkXG4gICAqIG1lc3NhZ2UgbmFtZS4gV2hlbiByZWNlaXZlZCwgdGhlIGxpc3RlbmVyIHdpbGwgZXhlY3V0ZSwgYW5kIHRoZW4gZWl0aGVyIHN0aWNrIGFyb3VuZCBhbmRcbiAgICoga2VlcCB3YXRjaGluZyAoaWYgdGhlIFwiaXNTdGlja3lcIiBmbGFnIGlzIHNldCB0byB0cnVlKVxuICAgKiBvciBkZS1yZWdpc3RlciBpdHNlbGYgKGlmIFwiaXNTdGlja3lcIiBpcyBmYWxzZSkgYW5kIHN0b3AgbGlzdGVuaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRNZXNzYWdlIFRoZSBzdHJpbmcgdG8gd2F0Y2ggZm9yIGZyb20gdGhlIHNlcnZlciwgc29tZXRoaW5nIGxpa2UgXCJtZXNzYWdlLmxvY2F0aW9uXCJcbiAgICogQHBhcmFtIHtSYXZpQ29tbWFuZENvbnRyb2xsZXJ+Y29tbWFuZENhbGxiYWNrfSBoYW5kbGVyIEEgaGFuZGxlciB0aGF0IHNob3VsZCBwcm9jZXNzIGFueSBldmVudHMgbGFiZWxlZCB3aXRoIGV4cGVjdGVkTWVzc2FnZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RpY2t5IFdoZXRoZXIgdGhlIGhhbmRsZXIgc2hvdWxkIGV4ZWN1dGUgZXZlcnkgdGltZSB0aGUgbWVzc2FnZSBpcyByZWNlaXZlZCAodHJ1ZSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBqdXN0IHRoZSBmaXJzdCB0aW1lIChmYWxzZSlcbiAgICovXG4gIGFkZE1lc3NhZ2VIYW5kbGVyKGV4cGVjdGVkTWVzc2FnZTogc3RyaW5nLCBoYW5kbGVyOiBGdW5jdGlvbiwgaXNTdGlja3k6IGJvb2xlYW4pIHtcblxuICAgIC8vIFRoZSBjb21tYW5kIHF1ZXVlIG1hcCBpcyB1c2VkIHRvIHRyYWNrIGFsbCBjb21tYW5kcy9saXN0ZW5lcnM7XG4gICAgLy8gZW5zdXJlIHRoYXQgdGhpcyBwYXJ0aWN1bGFyIFwiZXhwZWN0ZWRNZXNzYWdlXCIgaGFzIGFuIGVudHJ5XG4gICAgdmFyIG1lc3NhZ2VFbnRyeSA9IHRoaXMuX2NvbW1hbmRRdWV1ZU1hcC5nZXQoZXhwZWN0ZWRNZXNzYWdlKTtcbiAgICBpZiAoISBtZXNzYWdlRW50cnkpIHtcbiAgICAgIG1lc3NhZ2VFbnRyeSA9IHsgdG9TZW5kOiBbXSwgbGlzdGVuZXI6IFtdIH07XG4gICAgICB0aGlzLl9jb21tYW5kUXVldWVNYXAuc2V0KGV4cGVjdGVkTWVzc2FnZSwgbWVzc2FnZUVudHJ5KTtcbiAgICB9XG4gICAgXG4gICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgd2FudCB0byBwdXQgYW55dGhpbmcgaW4gaXRzIFwidG9TZW5kXCIgYXJyYXksIGJ1dFxuICAgIC8vIHdlIGRvIHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIuXG4gICAgdmFyIGhhbmRsZXJJbnN0YW5jZSA9IG5ldyBSYXZpQ29tbWFuZEhhbmRsZXJJbnN0YW5jZShoYW5kbGVyLCBpc1N0aWNreSwgZmFsc2UpO1xuICAgIG1lc3NhZ2VFbnRyeS5saXN0ZW5lci5wdXNoKGhhbmRsZXJJbnN0YW5jZSk7IFxuXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGxpc3RlbmluZyBmb3IgYmluYXJ5IHNlcnZlciBtZXNzYWdlc1xuICAgKiBAY2FsbGJhY2sgUmF2aUNvbW1hbmRDb250cm9sbGVyfmJpbmFyeUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBhcyBhIFVpbnQ4QXJyYXkgdHlwZWQgYXJyYXlcbiAgICovXG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIGZvciBiaW5hcnkgZGF0YSBvbmx5LCB3aXRob3V0IGFsc28gcXVldWluZyB1cCBhIGNvbW1hbmQgdG8gc2VuZC5cbiAgICogVGhpcyBsaXN0ZW5lciB3aWxsIHdhdGNoIGZvciBhIGJpbmFyeSBtZXNzYWdlIHRvIGJlIHJlY2VpdmVkIGZyb20gdGhlXG4gICAqIHNlcnZlciAob24gdGhlIFwiY29tbWFuZFwiIGRhdGEgY2hhbm5lbCkuXG4gICAqIFdoZW4gcmVjZWl2ZWQsIHRoZSBsaXN0ZW5lciB3aWxsIGV4ZWN1dGUsIGFuZCB0aGVuIGVpdGhlciBzdGljayBhcm91bmQgYW5kXG4gICAqIGtlZXAgd2F0Y2hpbmcgKGlmIHRoZSBcImlzU3RpY2t5XCIgZmxhZyBpcyBzZXQgdG8gdHJ1ZSlcbiAgICogb3IgZGUtcmVnaXN0ZXIgaXRzZWxmIChpZiBcImlzU3RpY2t5XCIgaXMgZmFsc2UpIGFuZCBzdG9wIGxpc3RlbmluZy5cbiAgICpcbiAgICogTk9URTogQmluYXJ5IGRhdGEgaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhIGNvbW1hbmQsIGFuZCBzbyBhbGwgYmluYXJ5IGhhbmRsZXJzXG4gICAqIGFyZSBleGVjdXRlZCBmb3IgYWxsIGJpbmFyeSBkYXRhIHJlY2VpdmVkOyBiaW5hcnkgaGFuZGxlcnMgc2hvdWxkXG4gICAqIHRoZW1zZWx2ZXMgZGV0ZXJtaW5lIGlmIHRoZSBkYXRhIHRoZXkndmUgYmVlbiBnaXZlbiBpcyB0aGUgZGF0YVxuICAgKiB0aGV5J3JlIGV4cGVjdGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtSYXZpQ29tbWFuZENvbnRyb2xsZXJ+YmluYXJ5Q2FsbGJhY2t9IGhhbmRsZXIgQSBoYW5kbGVyIHRoYXQgc2hvdWxkIHByb2Nlc3MgYW55IGV2ZW50cyBsYWJlbGVkIHdpdGggZXhwZWN0ZWRNZXNzYWdlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdGlja3kgV2hldGhlciB0aGUgaGFuZGxlciBzaG91bGQgZXhlY3V0ZSBldmVyeSB0aW1lIHRoZSBtZXNzYWdlIGlzIHJlY2VpdmVkICh0cnVlKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGp1c3QgdGhlIGZpcnN0IHRpbWUgKGZhbHNlKVxuICAgKi9cbiAgYWRkQmluYXJ5SGFuZGxlcihoYW5kbGVyOiBGdW5jdGlvbiwgaXNTdGlja3k6IGJvb2xlYW4pIHtcbiAgICAvLyBTdG9yZSB0aGVzZSBoYW5kbGVycyBpbiB0aGUgc2FtZSBtYXAgYXMgdGhlIG90aGVyIGxpc3RlbmVyLW9ubHkgaGFuZGxlcnMsXG4gICAgLy8gYnV0IGp1c3QgdXNlIGEgc2luZ2xlIGNvbnN0YW50IGtleS5cbiAgICB0aGlzLmFkZE1lc3NhZ2VIYW5kbGVyKF9CSU5BUllfQ09NTUFORF9LRVksIGhhbmRsZXIsIGlzU3RpY2t5KTtcbiAgICAvLyBOT1RFOiBDdXJyZW50bHksIHdlIGRvbid0IHN1cHBvcnQgYW55IHNvcnQgb2YgXCJjb21tYW5kXCIgYXNzb2NpYXRlZFxuICAgIC8vIHdpdGggYmluYXJ5IG1lc3NhZ2VzIC0tIHdoZW4gd2UgZ2V0IGEgYmluYXJ5IG1lc3NhZ2UsIGFsbCBiaW5hcnlcbiAgICAvLyBoYW5kbGVycyBhcmUgY2FsbGVkLiBXZSBtYXkgZGVjaWRlIHRvIHJldGhpbmsgdGhpcyBpbiB0aGUgZnV0dXJlLlxuICB9XG4gIFxuICAvKipcbiAgICogU2VuZCBhbiBpbnB1dCBldmVudCBkaXJlY3RseSBmcm9tIHRoZSB1c2VyIHRvIHRoZSBSQVZJIHNlcnZlciBhbG9uZ1xuICAgKiB0aGUgXCJpbnB1dFwiIGRhdGEgY2hhbm5lbC5cbiAgICogU2VlIGFsc28ge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI3F1ZXVlQ29tbWFuZH0sIHdoaWNoIHF1ZXVlcyBjb21tYW5kcyBmb3IgbGF0ZXIgc2VuZGluZy5cbiAgICogVGhpcyBtZXRob2QgZG9lcyBub3QgZGVmaW5lIGNhbGxiYWNrcy5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGhlcmUgaXMgYW4gZXZlbnQgaGFuZGxlciBmb3Igc2VuZGluZyBtb3VzZSBtb3ZlbWVudDpcbiAgICogYGBgXG4gICAqIGxldCBoYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICogICB2YXIgcG9zID0gbW91c2VIYW5kbGVyKGV2ZW50KVxuICAgKiAgIGNvbW1hbmRDb250cm9sbGVyLnNlbmRJbnB1dCh7XCJjXCI6IFwiTW91c2VNb3ZlXCIsIFwicFwiOiBwb3MgfSlcbiAgICogfTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dEV2ZW50IEFuIGV2ZW50IHRvIHNlbmQuXG4gICAqL1xuICBzZW5kSW5wdXQoaW5wdXRFdmVudDogYW55KSB7XG4gICAgaWYgKHRoaXMuX2lucHV0RGF0YUNoYW5uZWwgJiYgdGhpcy5faW5wdXREYXRhQ2hhbm5lbC5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIC8vIFRoaXMgZ2V0cyBqdXN0IFdBWSB0b28gbm9pc3kgdG9vIHF1aWNrbHksXG4gICAgICAvLyBidXQgdW5jb21tZW50IGlmIG5lZWRlZDpcbiAgICAgIC8vIFJhdmlVdGlscy5sb2coXCJTZW5kaW5nIGlucHV0OlwiICsgSlNPTi5zdHJpbmdpZnkoaW5wdXRFdmVudCksIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgdGhpcy5faW5wdXREYXRhQ2hhbm5lbC5zZW5kKGlucHV0RXZlbnQpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEtpY2sgb2ZmIHBvbGxpbmcgZm9yIHF1ZXVlZCBjb21tYW5kcy5cbiAgICogRXZlcnkgc2Vjb25kLCB0aGlzIHdpbGwgc2VuZCB0aGVcbiAgICogbmV4dCBxdWV1ZWQgY29tbWFuZCBmcm9tIHRoZSBjb21tYW5kUXVldWUuXG4gICAqIFRoaXMgZG9lcyBub3QgbmVlZCB0byBiZSBjYWxsZWQgZXh0ZXJuYWxseTtcbiAgICogaXQgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBhcHByb3ByaWF0ZVxuICAgKiBjb21tYW5kIGRhdGEgY2hhbm5lbCBpcyBvcGVuZWQuIChTZWUge0BsaW5rIFJhdmlDb21tYW5kQ29udHJvbGxlciNfc2V0Q29tbWFuZERhdGFDaGFubmVsfSlcbiAgICogSG93ZXZlciwgaXQgY2FuIGJlIGNhbGxlZCBleHRlcm5hbGx5IGlmIGF0IGFueSBwb2ludFxuICAgKiB5b3UgbmVlZCB0byBzdG9wIGFuZCB0aGVuIHJlc3RhcnQgdGhlIHF1ZXVlIG1vbml0b3JpbmdcbiAgICogcHJvY2Vzcy5cbiAgICovXG4gIG1vbml0b3JRdWV1ZXMoKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIkJlZ2luIG1vbml0b3JpbmcgZm9yIHF1ZXVlZCBjb21tYW5kc1wiLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICB0aGlzLl9jb21tYW5kUHVtcFRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5fcHJvY2Vzc1NlbmRpbmdRdWV1ZWRDb21tYW5kcy5iaW5kKHRoaXMpLCB0aGlzLl9jb21tYW5kUXVldWVJbnRlcnZhbCk7ICBcbiAgfVxuICBcbiAgLyoqXG4gICAqIFN0b3AgcG9sbGluZyBmb3IgcXVldWVkIGNvbW1hbmRzIGFuZFxuICAgKiBubyBsb25nZXIgc2VuZCB0aGVtLiBDYWxsZWQgd2hlbiBhIFJBVkkgc2Vzc2lvbiBpcyBjbG9zZWRcbiAgICogKHNlZSB7QGxpbmsgUmF2aVNlc3Npb24jY2xvc2V9KS4gQ2FuIGFsc28gYmUgY2FsbGVkXG4gICAqIGV4dGVybmFsbHkgdG8gaGFsdCBjb21tYW5kIHByb2Nlc3NpbmcgaWYgbmVlZGVkLlxuICAgKi9cbiAgc3RvcE1vbml0b3JpbmdRdWV1ZXMoKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIlN0b3AgbW9uaXRvcmluZyBmb3IgcXVldWVkIGNvbW1hbmRzXCIsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY29tbWFuZFB1bXBUaW1lcik7XG4gICAgdGhpcy5fY29tbWFuZFB1bXBUaW1lciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgbmV4dCBxdWV1ZWQgY29tbWFuZC5cbiAgICogdGhpcyBnZXRzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgcXVldWUgbW9uaXRvclxuICAgKiBhbmQsIGluIGdlbmVyYWwsIHNob3VsZCBub3QgYmUgY2FsbGVkIGV4dGVybmFsbHkuXG4gICAqIFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NTZW5kaW5nUXVldWVkQ29tbWFuZHMoKSB7XG4gICAgaWYgKHRoaXMuX251bVF1ZXVlZENvbW1hbmRzIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gRm9yIGVhY2ggdHlwZSBvZiBjb21tYW5kIGluIHRoZSBtYXAsIHdlIGNhbiBzZW5kIHRoZSBmaXJzdCBvbmUgb2YgdGhlbS5cbiAgICB0aGlzLl9jb21tYW5kUXVldWVNYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZTogYW55LCBrZXk6IGFueSwgbWFwOiBhbnkpIHtcbiAgICAgIC8vIGlmIHRoaXMgcGFydGljdWxhciBjb21tYW5kIGhhcyBhIHF1ZXVlIG9mIGluc3RhbmNlcy4uLlxuICAgICAgaWYgKHZhbHVlLnRvU2VuZC5sZW5ndGgpIHtcbiAgICAgICAgLy8gR3JhYiB0aGUgZmlyc3Qgb25lIG9mZiB0aGUgcXVldWVcbiAgICAgICAgdmFyIGNvbW1hbmRJbnN0YW5jZSA9IHZhbHVlLnRvU2VuZC5zaGlmdCgpO1xuXG4gICAgICAgIC8vIElmIGEgaGFuZGxlciBpcyBkZWZpbmVkIHRoZW4gcHV0IGl0IG9uIHRoZSBsaXN0ZW5lciBtYXBcbiAgICAgICAgaWYgKGNvbW1hbmRJbnN0YW5jZS5faGFuZGxlcikge1xuICAgICAgICAgIC8vIEFkZCBpdCB0byB0aGUgbGlzdCBvZiBsaXN0ZW5lcnMgZm9yIGxhdGVyIGhhbmRsZXIgaGFuZGxpbmdcbiAgICAgICAgICB2YWx1ZS5saXN0ZW5lci5wdXNoKGNvbW1hbmRJbnN0YW5jZS5faGFuZGxlcik7ICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGV0J3Mgc2VuZCB0aGUgY29tbWFuZCFcbiAgICAgICAgaWYgKCB0aGlzLl9zZW5kQ29tbWFuZEluc3RhbmNlKGNvbW1hbmRJbnN0YW5jZSkgKSB7XG4gICAgICAgICAgdGhpcy5fbnVtUXVldWVkQ29tbWFuZHMtLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2VuZCBmYWlsZWQuIENvbW1hbmREYXRhQ2hhbm5lbCBtYXkgaGF2ZSBiZWVuIGRpc2Nvbm5lY3RlZC4gV2lsbCBub3QgcmV0cnkuXCIsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgICAgIC8vIElmIHdlIGRpZCB3YW50IHRvIHJldHJ5LCB0aG91Z2g6XG4gICAgICAgICAgLy92YWx1ZS50b1NlbmQucHVzaChjb21tYW5kSW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgYSBwYWlyIHsgY29tbWFuZCwgcGF5bG9hZCB9IHRvIGJlIHNlbnQgaGFzIGEgbWVzc2FnZSBvbiB0aGUgQ29tbWFuZERhdGFDaGFubmVsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb21tYW5kIC0gVGhlIGFjdHVhbCBzdHJpbmcgY29tbWFuZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF5bG9hZCAtIEFueSBwYXJhbWV0ZXJzIHRvIGJlIHNlbnQgb3IgcmVjZWl2ZWQgdGhlIGNvbW1hbmRcbiAgICogXG4gICAqIEByZXR1cm4gdGhlIG1lc3NhZ2UgYXMgYSB7c3RyaW5nfSBhcyBleHBlY3RlZCBieSB0aGUgc2VydmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplSnNvbkNvbW1hbmRNZXNzYWdlVG9TZW5kKGNvbW1hbmQ6IHN0cmluZywgcGF5bG9hZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcImNcIjogY29tbWFuZCwgXCJwXCI6IHBheWxvYWR9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnNlcmlhbGl6ZSBhIHJlY2VpdmVkIGNvbW1hbmQgbWVzc2FnZSBcbiAgICogSWYgdGhlIG1lc3NhZ2UgaXMgcGFyc2VkIGNvcnJlY3RseSB0aGVuIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgdmFsaWQgXCJDb21tYW5kTWVzc2FnZVwiIG9iamVjdFxuICAgKiBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcga2V5c1xuICAgKiAtIHtzdHJpbmd9ICdjb21tYW5kJyAtIFRoZSBjb21tYW5kIHRva2VuIGlkZW50aWZ5aW5nIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgbWVzc2FnZVxuICAgKiAtIHtzdHJpbmd9ICdwYXlsb2FkJyAtIFRoZSBhY3R1YWwgZGF0YSByZWNlaXZlZCBmcm9tIHRoZSBtZXNzYWdlXG4gICAqIFxuICAgKiBJZiB0aGUgcGFyc2luZyBkb2Vzbid0IG1hdGNoIGEgdmFsaWQgY29tbWFuZE1lc3NhZ2UgdGhlbiB0aGUgZnVuY3Rpb24gcmV0dXJucyBudWxsIGFuZCBsb2cgdGhlIHByb2JsZW1cbiAgICogXG4gICAqIEByZXR1cm4gQSB2YWxpZCBcIkNvbW1hbmRNZXNzYWdlXCIgb2JqZWN0IGFzIGRldGFpbGVkIGFib3ZlIG9yIG51bGxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91bnNlcmlhbGl6ZUpzb25Db21tYW5kTWVzc2FnZUZyb21SZWNlaXZlZChtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBsZXQgY29tbWFuZE1lc3NhZ2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1hbmRNZXNzYWdlID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKGBDb3VsZG4ndCBwYXJzZSBjb21tYW5kIG1lc3NhZ2UhIEVycm9yOlxcbiR7ZX1cXG4gRnVsbCBtZXNzYWdlIGNvbnRlbnRzOlxcbiR7bWVzc2FnZX1gLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjb21tYW5kTWVzc2FnZSBpcyBleHBlY3RlZCB0byBoYXZlIDIga2V5czpcbiAgICAvLyAnYyc6IHRoZSBjb21tYW5kIG5hbWUsIHRoZSB0b2tlbiBpZGVudGlmeWluZyB0aGUgY29tbWFuZCBkZXN0aW5hdGlvbiBmb3IgdGhpcyBtZXNzYWdlXG4gICAgLy8gJ3AnOiB0aGUgcGF5bG9hZCBkYXRhLCB0aGUgYWN0dWFsIGluZm9ybWF0aW9uIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlclxuICAgIGlmIChjb21tYW5kTWVzc2FnZSAmJiBjb21tYW5kTWVzc2FnZS5jICYmIGNvbW1hbmRNZXNzYWdlLnApIHtcbiAgICAgIHJldHVybiB7J2NvbW1hbmQnOiBjb21tYW5kTWVzc2FnZS5jLCAncGF5bG9hZCc6IGNvbW1hbmRNZXNzYWdlLnAgfTtcbiAgICB9XG4gICAgUmF2aVV0aWxzLmVycihcIk1lc3NhZ2UgY2Fubm90IGJlIHVuc2VyaWFsaXplZCBpbnRvIGEgQ29tbWFuZE1lc3NhZ2U6IFwiICsgbWVzc2FnZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBcbiAgICogU2VuZCBhIHBhcnRpY3VsYXIgY29tbWFuZCBpbnN0YW5jZSBpbW1lZGlhdGVseSAtLVxuICAgKiB0aGlzIGdldHMgdXNlZCBpbnRlcm5hbGx5IGJ5IHtAbGluayBSYXZpQ29tbWFuZENvbnRyb2xsZXIjX3Byb2Nlc3NTZW5kaW5nUXVldWVkQ29tbWFuZHN9XG4gICAqIGFuZCBpbiBnZW5lcmFsLCBzaG91bGQgbm90IGJlIGNhbGxlZCBleHRlcm5hbGx5LlxuICAgKiBcbiAgICogQHBhcmFtIHtSYXZpQ29tbWFuZEluc3RhbmNlfSBjb21tYW5kSW5zdGFuY2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZW5kQ29tbWFuZEluc3RhbmNlKGNvbW1hbmRJbnN0YW5jZTogUmF2aUNvbW1hbmRJbnN0YW5jZSkge1xuICAgIC8vIFJhdGhlciB0aGFuIGNoZWNraW5nIGZvciBhbiBvcGVuIGNoYW5uZWwgZXZlcnkgdGltZSwganVzdCB0cnkgaXQgYW5kXG4gICAgLy8gY2F0Y2ggYW55IGVycm9yc1xuICAgIHRyeSB7XG4gICAgICBsZXQgbWVzc2FnZSA9IGNvbW1hbmRJbnN0YW5jZS5fY29tbWFuZDtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gdGhpcy5fc2VyaWFsaXplSnNvbkNvbW1hbmRNZXNzYWdlVG9TZW5kKGNvbW1hbmRJbnN0YW5jZS5fY29tbWFuZCwgY29tbWFuZEluc3RhbmNlLl9wYXJhbSk7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJTZW5kaW5nIGNvbW1hbmQgXCIgKyBtZXNzYWdlLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJTZW5kaW5nIGJpbmFyeSBjb21tYW5kXCIsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tbWFuZERhdGFDaGFubmVsLnNlbmQobWVzc2FnZSk7XG4gICAgICAvLyB3ZSBkb24ndCBnZXQgYW55dGhpbmcgYmFjaywgc28ganVzdCBhc3N1bWUgaXQgc2VudCBpZiBpdCBkaWRuJ3QgdGhyb3cgYW4gZXJyb3IuLi5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIlJlY2VpdmVkIGVycm9yIHdoaWxlIHNlbmRpbmc6IFwiICsgZXJyLm1lc3NhZ2UsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFxuICAgKiBQcm9jZXNzIHRoZSBsaXN0ZW5lciBmb3IgdGhlIG1lc3NhZ2UgZnJvbSB0aGUgUkFWSSBzZXJ2ZXIgLS1cbiAgICogdGhpcyBnZXRzIHVzZWQgaW50ZXJuYWxseSBieSB7QGxpbmsgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9ufVxuICAgKiBhbmQgaW4gZ2VuZXJhbCwgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZXh0ZXJuYWxseS5cbiAgICogXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tU2VydmVyTWVzc2FnZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NMaXN0ZW5pbmdDb21tYW5kKGZyb21TZXJ2ZXJNZXNzYWdlOiBhbnkpIHtcblxuICAgIGxldCBzZXJ2ZXJEYXRhID0gZnJvbVNlcnZlck1lc3NhZ2UuZGF0YTtcbiAgICBsZXQgY29tbWFuZE1lc3NhZ2UgPSBudWxsO1xuXG4gICAgLy8gRmlyc3Qgb2ZmLCBpcyB0aGlzIGEgYmluYXJ5IG1lc3NhZ2Ugb3IgYSBKU09OIG1lc3NhZ2U/XG4gICAgLy8gSWYgaXQncyBhIEpTT04gbWVzc2FnZSwgaXQnbGwgYmUgYSBzdHJpbmc7IGlmIGl0J3MgYVxuICAgIC8vIGJpbmFyeSBtZXNzYWdlLCBpdCdsbCBiZSBhbiBBcnJheUJ1ZmZlci5cbiAgICAvLyAoQW5kIGlmIGl0J3MgbmVpdGhlciBvZiB0aG9zZSwgd2UnbGwgbGVhdmUgY29tbWFuZE1lc3NhZ2VcbiAgICAvLyB1bnNldCBhbmQgcGljayBpdCB1cCBsYXRlci4pXG4gICAgaWYgKHNlcnZlckRhdGEpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VydmVyRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSXQncyBKU09OLiBUaGUgY29tbWFuZCBpbmZvIGlzIGFscmVhZHkgaW4gdGhlIG1lc3NhZ2UuXG4gICAgICAgIGNvbW1hbmRNZXNzYWdlID0gdGhpcy5fdW5zZXJpYWxpemVKc29uQ29tbWFuZE1lc3NhZ2VGcm9tUmVjZWl2ZWQoc2VydmVyRGF0YSk7XG4gICAgICAgIHRoaXMuX2NvbnRpbnVlUHJvY2Vzc2luZ0xpc3RlbmluZ0NvbW1hbmQoY29tbWFuZE1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIGlmIChzZXJ2ZXJEYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe1xuICAgICAgICAvLyBJdCdzIGJpbmFyeS4gV2UnbGwgd3JhcCBpdCBpbiBhIHR5cGVkIGFycmF5XG4gICAgICAgIC8vIGFuZCB0aGVuIGluIGEgSmF2YVNjcmlwdCBzdHJ1Y3RcbiAgICAgICAgLy8gc28gdGhhdCBpdCBjYW4gYmUgcHJvY2Vzc2VkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgLy8gXCJwYXlsb2FkXCIgY29kZSBwYXRoIGFzIHRoZSBKU09OIGRhdGFcbiAgICAgICAgY29tbWFuZE1lc3NhZ2UgPSB7ICdjb21tYW5kJyA6IF9CSU5BUllfQ09NTUFORF9LRVksICdwYXlsb2FkJyA6IG5ldyBVaW50OEFycmF5KHNlcnZlckRhdGEpfTtcbiAgICAgICAgLy8gTk9URTogQ3VycmVudGx5LCB3ZSBkb24ndCBuYXRpdmVseSBpbmNsdWRlIGFueSBzb3J0IG9mIFwiY29tbWFuZFwiIGFzc29jaWF0ZWRcbiAgICAgICAgLy8gd2l0aCBiaW5hcnkgbWVzc2FnZXMgLS0gd2hlbiB3ZSBnZXQgYSBiaW5hcnkgbWVzc2FnZSwgYWxsIGJpbmFyeVxuICAgICAgICAvLyBoYW5kbGVycyBhcmUgY2FsbGVkLiBXZSBtYXkgZGVjaWRlIHRvIHJldGhpbmsgdGhpcyBpbiB0aGUgZnV0dXJlLlxuICAgICAgICB0aGlzLl9jb250aW51ZVByb2Nlc3NpbmdMaXN0ZW5pbmdDb21tYW5kKGNvbW1hbmRNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VydmVyRGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgc2VydmVyRGF0YS5hcnJheUJ1ZmZlcigpXG4gICAgICAgICAgLnRoZW4oKHByb2Nlc3NlZEFycmF5QnVmZmVyKSA9PiB7XG4gICAgICAgICAgICBjb21tYW5kTWVzc2FnZSA9IHsgJ2NvbW1hbmQnIDogX0JJTkFSWV9DT01NQU5EX0tFWSwgJ3BheWxvYWQnIDogbmV3IFVpbnQ4QXJyYXkocHJvY2Vzc2VkQXJyYXlCdWZmZXIpfTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRpbnVlUHJvY2Vzc2luZ0xpc3RlbmluZ0NvbW1hbmQoY29tbWFuZE1lc3NhZ2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jb250aW51ZVByb2Nlc3NpbmdMaXN0ZW5pbmdDb21tYW5kKGNvbW1hbmRNZXNzYWdlOiBhbnkpIHtcbiAgICBpZiAoIWNvbW1hbmRNZXNzYWdlKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKFwiUmVjZWl2ZWQgaW52YWxpZCBjb21tYW5kIG1lc3NhZ2UsIGlnbm9yaW5nOiBcIiArIEpTT04uc3RyaW5naWZ5KGNvbW1hbmRNZXNzYWdlKSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTGV0J3MgdHJ5IHRvIGZpbmQgdGhlIG1hdGNoaW5nIGxpc3RlbmVyKHMpIGZvciB0aGUgY29tbWFuZE1lc3NhZ2UgcmVjZWl2ZWQ6XG4gICAgdmFyIGZvdW5kQ29tbWFuZEluc3RhbmNlID0gdGhpcy5fY29tbWFuZFF1ZXVlTWFwLmdldChjb21tYW5kTWVzc2FnZS5jb21tYW5kKTtcbiAgICBpZiAoZm91bmRDb21tYW5kSW5zdGFuY2UpIHtcbiAgICAgIC8vIEhvdyBtYW55IGxpc3RlbmVycyBkb2VzIGl0IGhhdmU/XG4gICAgICB2YXIgbGVuZ3RoID0gZm91bmRDb21tYW5kSW5zdGFuY2UubGlzdGVuZXIubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgLyoqXG4gICAgICAgIFRPRE86IFdlIG5lZWQgdG8gYWRkIGJvdGggc2VydmVyICYgY2xpZW50IGZ1bmN0aW9uYWxpdHkgdGhhdFxuICAgICAgICB3aWxsIHRyYWNrIHRoZSBcImluc3RhbmNlXCIgb2YgYSBjb21tYW5kIGFuZCB0cmlnZ2VyIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgICBsaXN0ZW5lci4gUmlnaHQgbm93IHRoaXMgY291bGQgYmVoYXZlIHVuZXhwZWN0ZWRseSBpbiB0aGUgc2l0dWF0aW9uXG4gICAgICAgIHdoZXJlIHdlIHJlZ2lzdGVyIHR3byBkaWZmZXJlbnQgbGlzdGVuZXJzIGZvciB0aGUgc2FtZSBjb21tYW5kXG4gICAgICAgIGFuZCB0aGUgXCJ3cm9uZ1wiIG9uZSByZXR1cm5zIGZpcnN0LiBTZWUgQklHV09STEQtNDU2LiBXZSBjYW4gbWFrZVxuICAgICAgICB0aGlzIGNvZGUgY2xlYW5lciBvbmNlIHRoYXQncyBpbXBsZW1lbnRlZC5cblxuICAgICAgICBJbiB0aGUgbWVhbnRpbWUsIHdlJ2xsIGxlYXZlIHRoZSBcImluc3RhbmNlIG9mIGEgY29tbWFuZFwiIGJlaGF2aW9yIGFzIGlzLlxuICAgICAgICBBbmQgaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIgd2l0aCBhIFwibWF0Y2hpbmcgc2VudCBjb21tYW5kXCIsIHdlJ2xsXG4gICAgICAgIGV4ZWN1dGUgYWxsIHRoZSByZWxldmFudCBcImxpc3Rlbi1vbmx5XCIgbGlzdGVuZXJzLlxuXG4gICAgICAgIE5PVEU6IFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgYSBnaXZlbiBjb21tYW5kTWVzc2FnZSBcImNvbW1hbmRcIiBzdHJpbmdcbiAgICAgICAgKGUuZy4gXCJjb21tYW5kLmFib3V0XCIgb3IgXCJtZXNzYWdlLmxvY2F0aW9uXCIpIHdpbGwgb25seSBoYXZlIE9ORSBUWVBFXG4gICAgICAgIG9mIGxpc3RlbmVyOiBcIm1hdGNoaW5nIHNlbnQgY29tbWFuZFwiIG9yIFwibGlzdGVuLW9ubHlcIi4gSWYgeW91IHF1ZXVlXG4gICAgICAgIGEgY29tbWFuZCB3aXRoIGEgbGlzdGVuZXIsIGFuZCB0aGVuIEFMU08gdHJ5IHRvXG4gICAgICAgIGFzc29jaWF0ZSBhIGxpc3Rlbi1vbmx5IGxpc3RlbmVyIHdpdGggdGhhdCBzYW1lIGNvbW1hbmQgbmFtZSxcbiAgICAgICAgc3RyYW5nZSB0aGluZ3Mgd2lsbCBoYXBwZW4uIChTcGVjaWZpY2FsbHksIHRoZSBjb21tYW5kIGhhbmRsZXIgZm9yXG4gICAgICAgIHRoZSBzZW50IGNvbW1hbmQgd2lsbCBiZSB0aGUgb25seSB0aGluZyBleGVjdXRlZCB3aGVuIHlvdSBnZXQgdGhlIGZpcnN0XG4gICAgICAgIHJlc3BvbnNlIGJhY2ssIGJ1dCBpZiB5b3UgZ2V0IHN1YnNlcXVlbnQgcmVzcG9uc2VzIGJhY2ssIHRoZW4gdGhlXG4gICAgICAgIGxpc3Rlbi1vbmx5IGxpc3RlbmVyKHMpIHdpbGwgZXhlY3V0ZS4pIFdlIGNhbiByZW1vdmUgdGhpcyByZXN0cmljdGlvblxuICAgICAgICBvbmNlIEJJR1dPUkxELTQ1NiBpcyBpbXBsZW1lbnRlZC5cbiAgICAgICAgKiovXG4gICAgICAgIGlmIChmb3VuZENvbW1hbmRJbnN0YW5jZS5saXN0ZW5lclswXSAmJiBmb3VuZENvbW1hbmRJbnN0YW5jZS5saXN0ZW5lclswXS5faGFzTWF0Y2hpbmdTZW50Q29tbWFuZCkge1xuICAgICAgICAgIC8vIFRoZXJlIHdhcyBhbiBvcmlnaW5hbCBjb21tYW5kIHNlbnQgdGhhdCB3ZSdyZSBsaXN0ZW5pbmcgZm9yIGEgcmVzcG9uc2UgZm9yLCBcbiAgICAgICAgICAvLyBjb21tYW5kIHNlbnQsIHNvIHRoYXQgbWVhbnMgd2UganVzdCBleGVjdXRlIHRoZSBmaXJzdCBoYW5kbGVyLFxuICAgICAgICAgIC8vIHdoYXRldmVyIGl0IGlzLlxuICAgICAgICAgIHZhciBjb21tYW5kSW5zdGFuY2UgPSBmb3VuZENvbW1hbmRJbnN0YW5jZS5saXN0ZW5lci5zaGlmdCgpO1xuICAgICAgICAgIGlmIChjb21tYW5kSW5zdGFuY2UgJiYgY29tbWFuZEluc3RhbmNlLl9oYW5kbGVyKSB7XG4gICAgICAgICAgICBjb21tYW5kSW5zdGFuY2UuX2hhbmRsZXIoY29tbWFuZE1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICByZXR1cm47IC8vIHN1Y2Nlc3MsIGVuZCBvZiB0aGUgKGZpcnN0KSBsaXN0ZW5lclxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSYXZpVXRpbHMuZXJyKFwiVW5kZWZpbmVkIGNvbW1hbmQgaGFuZGxlcjogXCIgKyBjb21tYW5kTWVzc2FnZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld0xpc3RlbmVycyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZvdW5kQ29tbWFuZEluc3RhbmNlLmxpc3RlbmVyW2ldO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICYmIGxpc3RlbmVyLl9oYW5kbGVyKSB7XG4gICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gZXhlY3V0ZSB0aGUgaGFuZGxlclxuICAgICAgICAgICAgICBsaXN0ZW5lci5faGFuZGxlcihjb21tYW5kTWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIFJhdmlVdGlscy5lcnIoXCJVbmRlZmluZWQgbWVzc2FnZSBoYW5kbGVyOiBcIiArIGNvbW1hbmRNZXNzYWdlLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGl0J3Mgc3RpY2t5LCBhZGQgaXQgdG8gdGhlIFwibmV3XCIgbGlzdFxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICYmIGxpc3RlbmVyLl9pc1N0aWNreSkge1xuICAgICAgICAgICAgICBuZXdMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSB3aXRoIG9ubHkgdGhlIHN0aWNreSBvbmVzXG4gICAgICAgICAgZm91bmRDb21tYW5kSW5zdGFuY2UubGlzdGVuZXIgPSBuZXdMaXN0ZW5lcnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG5vIGxpc3RlbmVyIGRlZmluZWQsIGp1c3QgbW92ZSBvbiwgdGhpcyBpcyBhbiBvayBwYXRoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFxuICAgKiBTZXQgdGhlIGlucHV0IGRhdGEgY2hhbm5lbC5cbiAgICpcbiAgICogQHBhcmFtIHtSVENEYXRhQ2hhbm5lbH0gaW5wdXREYXRhQ2hhbm5lbCBUaGUgZGF0YUNoYW5uZWwgdG8gdXNlLiBXaGlsZSB0aGlzIGlzIGRlZmluZWQgYXMgYW4gUlRDRGF0YUNoYW5uZWwsXG4gICAqIGh5cG90aGV0aWNhbGx5IHNvbWUgb3RoZXIga2luZCBvZiBzdHJlYW0gdGhhdCBvZmZlcnMgdGhlIHNhbWUgQVBJIGFuZCBjYWxsYmFja3MgYXMgYW4gUlRDRGF0YUNoYW5uZWxcbiAgICogY291bGQgYWxzbyBiZSB1c2VkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldElucHV0RGF0YUNoYW5uZWwoaW5wdXREYXRhQ2hhbm5lbDogUlRDRGF0YUNoYW5uZWwpIHtcbiAgICB0aGlzLl9pbnB1dERhdGFDaGFubmVsID0gaW5wdXREYXRhQ2hhbm5lbDtcbiAgICBSYXZpVXRpbHMubG9nKFwiUmVjZWl2ZWQgbmV3IGlucHV0IGRhdGEgY2hhbm5lbCB3aXRoIGlkIFwiICsgdGhpcy5faW5wdXREYXRhQ2hhbm5lbC5pZCwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG5cbiAgICB0aGlzLl9pbnB1dERhdGFDaGFubmVsLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIFJhdmlVdGlscy5sb2coXCJfaW5wdXREYXRhQ2hhbm5lbCBvbm9wZW4sIHN0YXRlIGlzIFwiICsgdGhpcy5faW5wdXREYXRhQ2hhbm5lbC5yZWFkeVN0YXRlLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9pbnB1dERhdGFDaGFubmVsLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiX2lucHV0RGF0YUNoYW5uZWwgb25jbG9zZSwgc3RhdGUgaXMgXCIgKyB0aGlzLl9pbnB1dERhdGFDaGFubmVsLnJlYWR5U3RhdGUsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2lucHV0RGF0YUNoYW5uZWwub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2U6IGFueSkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIl9pbnB1dERhdGFDaGFubmVsIGdvdCBtZXNzYWdlOiBcIiArIChtZXNzYWdlLmRhdGEpLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogXG4gICAqIFNldCB0aGUgY29tbWFuZCBkYXRhIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7UlRDRGF0YUNoYW5uZWx9IGNvbW1hbmREYXRhQ2hhbm5lbCBUaGUgZGF0YUNoYW5uZWwgdG8gdXNlLiBXaGlsZSB0aGlzIGlzIGRlZmluZWQgYXMgYW4gUlRDRGF0YUNoYW5uZWwsXG4gICAqIGh5cG90aGV0aWNhbGx5IHNvbWUgb3RoZXIga2luZCBvZiBzdHJlYW0gdGhhdCBvZmZlcnMgdGhlIHNhbWUgQVBJIGFuZCBjYWxsYmFja3MgYXMgYW4gUlRDRGF0YUNoYW5uZWxcbiAgICogY291bGQgYWxzbyBiZSB1c2VkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldENvbW1hbmREYXRhQ2hhbm5lbChjb21tYW5kRGF0YUNoYW5uZWw6IFJUQ0RhdGFDaGFubmVsKSB7XG4gICAgdGhpcy5fY29tbWFuZERhdGFDaGFubmVsID0gY29tbWFuZERhdGFDaGFubmVsO1xuICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCBuZXcgZGF0YSBjaGFubmVsIHdpdGggaWQgXCIgKyB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwuaWQsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICBcbiAgICB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIl9jb21tYW5kRGF0YUNoYW5uZWwgb25vbnBlbiwgc3RhdGUgaXMgXCIgKyB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwucmVhZHlTdGF0ZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICAvLyBLaWNrIG9mZiB0aGUgbW9uaXRvcmluZyBvZiB0aGUgY29tbWFuZCBxdWV1ZXMgaW4gdGhlIGNvbW1hbmQgY29udHJvbGxlci5cbiAgICAgIHRoaXMubW9uaXRvclF1ZXVlcygpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2NvbW1hbmREYXRhQ2hhbm5lbC5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIl9jb21tYW5kRGF0YUNoYW5uZWwgb25jbG9zZSwgc3RhdGUgaXMgXCIgKyB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwucmVhZHlTdGF0ZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICAvLyBTdG9wIG1vbml0b3JpbmcgdGhlIGNvbW1hbmQgcXVldWVcbiAgICAgIHRoaXMuc3RvcE1vbml0b3JpbmdRdWV1ZXMoKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2U6IGFueSkge1xuICAgICAgdGhpcy5fcHJvY2Vzc0xpc3RlbmluZ0NvbW1hbmQobWVzc2FnZSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgXG4gIC8qKlxuICAgKiBTZXQgYSBET00gZWxlbWVudCB0aGF0IGlzIHVzZWQgdG8gdHJhY2sgaW5wdXQgZXZlbnQgKG1vdXNlICYgdG91Y2gpXG4gICAqIHNldmVyYWwgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byB0aGUgZWxlbWVudCBhbmQgY29tbXVuaWNhdGUgaW5wdXQgZXZlbnRzIHRvIFJhdmkgU2VydmVyIHRocm91Z2ggdGhlIGlucHV0IGNoYW5uZWxcbiAgICogQHBhcmFtIHtFbGVtZW50fSBpbnB1dFRhcmdldEVsZW1lbnQgUmVmZXJlbmNlIHRvIHRoZSBKYXZhU2NyaXB0IERPTSBlbGVtZW50IHVzZWQgdG8gdHJhY2sgaW5wdXQgZXZlbnRzIFxuICAgKi9cbiAgc2V0SW5wdXRUYXJnZXQoaW5wdXRUYXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9pbnB1dFRhcmdldCkge1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZW1vdmUgPSBudWxsO1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZWVudGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX2lucHV0VGFyZ2V0Lm9ubW91c2VsZWF2ZSA9IG51bGw7XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNlZG93biA9IG51bGw7XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNldXAgPSBudWxsO1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub253aGVlbCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5faW5wdXRUYXJnZXQgPSBpbnB1dFRhcmdldEVsZW1lbnQ7XG5cbiAgICBpZiAodGhpcy5faW5wdXRUYXJnZXQpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZW1vdmUgPSAgZnVuY3Rpb24oZXZlbnQpIHsgdGhhdC5fdHJhY2tNb3VzZShldmVudCk7IH07XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNlZW50ZXIgPSBudWxsO1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZWxlYXZlID0gbnVsbDtcbiAgICAgIHRoaXMuX2lucHV0VGFyZ2V0Lm9ubW91c2Vkb3duID0gZnVuY3Rpb24oZXZlbnQpIHsgdGhhdC5fY2FwdHVyZU1vdXNlRG93bihldmVudCk7IH07XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNldXAgPSBmdW5jdGlvbihldmVudCkgeyB0aGF0Ll9yZXNldE1vdXNlRG93bihldmVudCk7IH07XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbndoZWVsID0gIGZ1bmN0aW9uKGV2ZW50KSB7IHRoYXQuX3doZWVsTW91c2UoZXZlbnQpOyB9O1xuICAgIH1cbiAgfVxuXG4gc2V0S2V5Ym9hcmRUYXJnZXQoaW5wdXRUYXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9rZXlib2FyZFRhcmdldCkge1xuICAgICAgdGhpcy5fa2V5Ym9hcmRUYXJnZXQub25rZXlkb3duID0gbnVsbDtcbiAgICAgIHRoaXMuX2tleWJvYXJkVGFyZ2V0Lm9ua2V5dXAgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX2tleWJvYXJkVGFyZ2V0ID0gaW5wdXRUYXJnZXRFbGVtZW50O1xuXG4gICAgaWYgKHRoaXMuX2tleWJvYXJkVGFyZ2V0KSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2tleWJvYXJkVGFyZ2V0Lm9ua2V5ZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7IHRoYXQuX29uS2V5Ym9hcmREb3duKGV2ZW50KTsgfTtcbiAgICAgIHRoaXMuX2tleWJvYXJkVGFyZ2V0Lm9ua2V5dXAgPSBmdW5jdGlvbihldmVudCkgeyB0aGF0Ll9vbktleWJvYXJkVXAoZXZlbnQpOyB9O1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFxuICAgKi9cbiAgX2NhcHR1cmVNb3VzZURvd24oZTogTW91c2VFdmVudCkge1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFswXSA9IGUub2Zmc2V0WDtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMV0gPSBlLm9mZnNldFk7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzJdID0gZS5vZmZzZXRYO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFszXSA9IGUub2Zmc2V0WTtcblxuICAgIHRoaXMuX21vdXNlU3RhdGVVaW50OFsxXSA9IGUuYnV0dG9ucztcblxuICAgIC8vIEFuZCBzZW5kIHN0YXRlXG4gICAgdGhpcy5fc2VuZE1vdXNlU3RhdGUoKTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogXG4gICAqL1xuICBfcmVzZXRNb3VzZURvd24oZTogTW91c2VFdmVudCkge1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFswXSA9IC0xLjA7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzFdID0gLTEuMDtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMl0gPSAtMS4wO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFszXSA9IC0xLjA7XG5cbiAgICB0aGlzLl9tb3VzZVN0YXRlVWludDhbMV0gPSBlLmJ1dHRvbnM7XG5cbiAgICAvLyBBbmQgc2VuZCBzdGF0ZVxuICAgIHRoaXMuX3NlbmRNb3VzZVN0YXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFxuICAgKi9cbiAgX3RyYWNrTW91c2UoZTogTW91c2VFdmVudCkge1xuICAgIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBtb3VzZSBwb3MgaW4gdGhlIG91c2VTdGF0ZUJ1ZmZmZXJcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMF0gPSBlLm9mZnNldFg7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzFdID0gZS5vZmZzZXRZO1xuXG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzRdID0gdGhpcy5faW5wdXRUYXJnZXQub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzVdID0gdGhpcy5faW5wdXRUYXJnZXQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgdGhpcy5fbW91c2VTdGF0ZVVpbnQ4WzFdID0gZS5idXR0b25zO1xuXG4gICAgLy8gQW5kIHNlbmQgc3RhdGVcbiAgICB0aGlzLl9zZW5kTW91c2VTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFxuICAgKi9cbiAgX3doZWVsTW91c2UoZTogV2hlZWxFdmVudCkge1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFs2XSA9IGUuZGVsdGFZO1xuICAgIHRoaXMuX3NlbmRNb3VzZVN0YXRlKCk7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzZdID0gMDtcbiAgfVxuXG4gIF9zZW5kTW91c2VTdGF0ZSgpIHtcbiAgICB0aGlzLnNlbmRJbnB1dCh0aGlzLl9tb3VzZVN0YXRlQnVmZmVyKTtcbiAgfVxuXG4gIF9rZXlCeXRlTnVtKGM6IGFueSkge1xuICAgIHJldHVybiBjID4+IDM7XG4gIH1cbiAgX2tleUJpdE1hc2soYzogYW55KSB7XG4gICAgcmV0dXJuICgxIDw8IChjICUgOCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25LZXlib2FyZERvd24oZTogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBjID0gX0tFWV9DT0RFX1RBQkxFWzxhbnk+IGUuY29kZV07XG4gICAgbGV0IGtleUJ5dGVOdW0gPSAxICsgdGhpcy5fa2V5Qnl0ZU51bShjKTtcbiAgICBsZXQga2V5Qnl0ZU1hc2sgPSB0aGlzLl9rZXlCaXRNYXNrKGMpO1xuICAgIGlmICgodGhpcy5fa2V5Ym9hcmRTdGF0ZVtrZXlCeXRlTnVtXSAmIGtleUJ5dGVNYXNrKSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9rZXlib2FyZFN0YXRlW2tleUJ5dGVOdW1dIHw9IGtleUJ5dGVNYXNrO1xuICAgICAgICB0aGlzLl9zZW5kS2V5Ym9hcmRTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uS2V5Ym9hcmRVcChlOiBLZXlib2FyZEV2ZW50KSB7XG4gICAgbGV0IGMgPSBfS0VZX0NPREVfVEFCTEVbPGFueT4gZS5jb2RlXTtcbiAgICBsZXQga2V5Qnl0ZU51bSA9IDEgKyB0aGlzLl9rZXlCeXRlTnVtKGMpO1xuICAgIGxldCBrZXlCeXRlTWFzayA9IHRoaXMuX2tleUJpdE1hc2soYyk7XG4gICAgaWYgKCh0aGlzLl9rZXlib2FyZFN0YXRlW2tleUJ5dGVOdW1dICYga2V5Qnl0ZU1hc2spICE9PSAwKSB7XG4gICAgICAgIHRoaXMuX2tleWJvYXJkU3RhdGVba2V5Qnl0ZU51bV0gXj0ga2V5Qnl0ZU1hc2s7XG4gICAgICAgIHRoaXMuX3NlbmRLZXlib2FyZFN0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX3NlbmRLZXlib2FyZFN0YXRlKCkge1xuICAgIHRoaXMuc2VuZElucHV0KHRoaXMuX2tleWJvYXJkU3RhdGVCdWZmZXIpO1xuICB9XG5cbn0gLy8gRW5kIG9mIHRoZSBSYXZpQ29tbWFuZENvbnRyb2xsZXIgY2xhc3NcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiogXG4gKlxuICogQSBjb21tYW5kIGluc3RhbmNlIGZvciB1c2Ugd2l0aCB0aGUgXG4gKiBSYXZpQ29tbWFuZENvbnRyb2xsZXIuIFRoaXMgaXMganVzdFxuICogYSBzcGVjaWFsaXplZCBvYmplY3QgdG8gdHJhY2sgdGhlIGNvbWJpbmF0aW9uIG9mXG4gKiBhIGNvbW1hbmQgdHlwZSwgdGhlIHBhcmFtZXRlcnMgZm9yIHRoYXQgY29tbWFuZCxcbiAqIGFuZCB0aGUgaGFuZGxlciB0byBiZSB1c2VkIGZvciB0aGUgY29tbWFuZCByZXN1bHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZCAtIFRoZSBhY3R1YWwgc3RyaW5nIGNvbW1hbmQgdG8gc2VuZFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtIC0gQW55IHBhcmFtZXRlcnMgdG8gYmUgc2VudCB0byB0aGUgY29tbWFuZFxuICogQHBhcmFtIHtSYXZpQ29tbWFuZENvbnRyb2xsZXIuUmF2aUNvbW1hbmRIYW5kbGVySW5zdGFuY2V9IGhhbmRsZXIgLSBBIGNhbGxiYWNrIGhhbmRsZXIgdG8gdXNlIHdoZW4gdGhlIGNvbW1hbmQgcmV0dXJucyBmcm9tIHRoZSBzZXJ2ZXJcbiAqIFxuICogQGNsYXNzIFJhdmlDb21tYW5kQ29udHJvbGxlci5SYXZpQ29tbWFuZEluc3RhbmNlXG4gKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBjb21tYW5kIHRoYXQgc2hvdWxkIGJlIFxuICogcXVldWVkIHVwIGluIHRoZSBSYXZpQ29tbWFuZENvbnRyb2xsZXIncyBjb21tYW5kIHF1ZXVlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJhdmlDb21tYW5kSW5zdGFuY2Uge1xuICBfY29tbWFuZDogYW55O1xuICBfcGFyYW06IGFueTtcbiAgX2hhbmRsZXI6IGFueTtcblxuICAvKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKiB0aGlzLl9jb21tYW5kO1xuICAgKiB0aGlzLl9wYXJhbTtcbiAgICogdGhpcy5faGFuZGxlcjtcbiAgICovXG4gIFxuICAvKiogXG4gICAqIEBwcml2YXRlIFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29tbWFuZDogYW55LCBwYXJhbTogYW55LCBoYW5kbGVyOiBhbnkpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiY29uc3RydWN0b3JcIiwgXCJSYXZpQ29tbWFuZEluc3RhbmNlXCIpO1xuICAgIHRoaXMuX2NvbW1hbmQgPSBjb21tYW5kO1xuICAgIHRoaXMuX3BhcmFtID0gcGFyYW07XG4gICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XG4gIH1cbn1cblxuLyoqIFxuICpcbiAqIEEgaGFuZGxlciBpbnN0YW5jZSBmb3IgdXNlIHdpdGggdGhlIFxuICogUmF2aUNvbW1hbmRDb250cm9sbGVyLiBUaGlzIGp1c3RcbiAqIHRyYWNrcyB0aGUgaGFuZGxlciBmdW5jdGlvbiBhbmQgd2hldGhlciBvciBcbiAqIG5vdCBpdCdzIFwic3RpY2t5LlwiIEhhbmRsZXJzIHRoYXQgYXJlIGFzc29jaWF0ZWRcbiAqIHdpdGggYSBwYXJ0aWN1bGFyIFNFTlQgY29tbWFuZCBhcmUgTk9UIHN0aWNreSBieVxuICogZGVmYXVsdCAoaS5lLiB0aGV5IGV4ZWN1dGUgb25jZSwgYW5kIHRoZW4gc3RvcFxuICogbGlzdGVuaW5nKSwgYnV0IGxpc3RlbmVycyB0aGF0IGFyZSByZWdpc3RlcmVkXG4gKiBieSB0aGVtc2VsdmVzIGNhbiBiZSBlaXRoZXIgc3RpY2t5IG9yIG5vdCBzdGlja3kuXG4gKiBAcGFyYW0ge1JhdmlDb21tYW5kQ29udHJvbGxlcn5jb21tYW5kQ2FsbGJhY2t9IGhhbmRsZXIgLSBBIGNhbGxiYWNrIGhhbmRsZXIgdG8gdXNlIHdoZW4gdGhlIGNvbW1hbmQgcmV0dXJucyBmcm9tIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdGlja3kgLSBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBzdGlja3MgYXJvdW5kIGZvcmV2ZXIgKHRydWUpIG9yIHN0b3BzIGxpc3RlbmluZyBhZnRlciBpdCBnZXRzXG4gKiBpdHMgZmlyc3QgcmVzcG9uc2UgKGZhbHNlKVxuICogQHBhcmFtIHtib29sZWFufSBoYXNNYXRjaGluZ1NlbnRDb21tYW5kIC0gV2hldGhlciBvciBub3QgdGhpcyBoYW5kbGVyIGhhcyBhIG1hdGNoaW5nIGNvbW1hbmQgdGhhdCB3YXMvaXMgZ29pbmcgdG8gYmUgXG4gKiBzZW50IHRvIHRoZSBzZXJ2ZXIgKHRydWUpLCBvciBpZiBpdCdzIGp1c3QgbGlzdGVuaW5nIGZvciBzb21ldGhpbmcgdGhlIHNlcnZlciBtaWdodCBzZW5kIG9uIGl0cyBvd24gKGZhbHNlKVxuICogXG4gKiBAY2xhc3MgUmF2aUNvbW1hbmRDb250cm9sbGVyLlJhdmlDb21tYW5kSGFuZGxlckluc3RhbmNlXG4gKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBoYW5kbGVyIHRoYXQgY2FuIGJlIFxuICogdXNlZCB0byBwcm9jZXNzIG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlclxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJhdmlDb21tYW5kSGFuZGxlckluc3RhbmNlIHtcbiAgX2hhbmRsZXI6IGFueTtcbiAgX2lzU3RpY2t5OiBib29sZWFuO1xuICBfaGFzTWF0Y2hpbmdTZW50Q29tbWFuZDogYm9vbGVhbjtcblxuICAvKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzOlxuICAgKiB0aGlzLl9oYW5kbGVyO1xuICAgKiB0aGlzLl9pc1N0aWNreTtcbiAgICogdGhpcy5faGFzTWF0Y2hpbmdTZW50Q29tbWFuZDtcbiAgICovXG4gIC8qKiBcbiAgICogQHByaXZhdGUgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihoYW5kbGVyOiBhbnksIGlzU3RpY2t5OiBib29sZWFuLCBoYXNNYXRjaGluZ1NlbnRDb21tYW5kOiBib29sZWFuKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aUNvbW1hbmRIYW5kbGVySW5zdGFuY2VcIik7XG4gICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdGhpcy5faXNTdGlja3kgPSBpc1N0aWNreTtcbiAgICB0aGlzLl9oYXNNYXRjaGluZ1NlbnRDb21tYW5kID0gaGFzTWF0Y2hpbmdTZW50Q29tbWFuZDtcbiAgfVxufVxuIiwiXG5pbXBvcnQgeyBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiwgUmF2aVNpZ25hbGluZ1N0YXRlcyB9IGZyb20gJy4vUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24nO1xuaW1wb3J0IHsgUmF2aVN0cmVhbUNvbnRyb2xsZXIgfSBmcm9tICcuL1JhdmlTdHJlYW1Db250cm9sbGVyJztcbmltcG9ydCB7IFJhdmlVdGlscyB9IGZyb20gJy4vUmF2aVV0aWxzJztcbmltcG9ydCB7IFJhdmlDb21tYW5kQ29udHJvbGxlciB9IGZyb20gJy4vUmF2aUNvbW1hbmRDb250cm9sbGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBXZWJSVENTZXNzaW9uUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGppdHRlciBidWZmZXIgZHVyYXRpb24uIFVuaXRzIGFyZSBzZWNvbmRzLiBUaGUgZGVmYXVsdCBpcyAwIHNlY29uZHMuXG4gICAqIFxuICAgKiBJbiBwcmFjdGljZSwgdGhpcyBzaG91bGQgYWx3YXlzIGJlIHNldCB0byAwIHNlY29uZHMsIHdoaWNoIGlzIHRoZSBkZWZhdWx0LiBTZXR0aW5nIHRoZSBtaW5pbXVtIGppdHRlciBidWZmZXIgZHVyYXRpb24gdG8gWCBzZWNvbmRzIG1lYW5zXG4gICAqIHRoYXQgYWxsIGF1ZGlvIHNlbnQgdG8gdGhlIHNlcnZlciB3aWxsIGFsd2F5cyBiZSBidWZmZXJlZCBhdCBsZWFzdCBieSBYIHNlY29uZHMuIFRoaXMgaXMgcmFyZWx5IGRlc2lyYWJsZTsgbG93ZXIgbGF0ZW5jeSBpcyBhbG1vc3QgYWx3YXlzIHByZWZlcnJlZC5cbiAgICogWW91IG1heSwgaG93ZXZlciwgd2FudCB0byBzZXQgdGhlIG1heGltdW0gaml0dGVyIGJ1ZmZlciBkdXJhdGlvbiBpZiB5b3VyIHVzZXJzIGFyZSBleHBlcmllbmNpbmcgZnJlcXVlbnQgYXVkaW8gZHJvcC1vdXRzOyByZWZlciB0byBgYXVkaW9NYXhKaXR0ZXJCdWZmZXJEdXJhdGlvbmAgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGF1ZGlvTWluSml0dGVyQnVmZmVyRHVyYXRpb24/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBqaXR0ZXIgYnVmZmVyIGR1cmF0aW9uLiBVbml0cyBhcmUgc2Vjb25kcy4gVGhlIGRlZmF1bHQgaXMgMSBzZWNvbmQuXG4gICAqIFxuICAgKiBTZXQgdGhlIGppdHRlciBidWZmZXIgZHVyYXRpb24gaGlnaCB0byByZWR1Y2UgdGhlIHBvc3NpYmlsaXR5IG9mIGF1ZGlvIGRyb3BvdXRzIGF0IHRoZSBjb3N0XG4gICAqIG9mIHBvdGVudGlhbGx5IGhpZ2hlciByb3VuZC10cmlwIGF1ZGlvIGxhdGVuY3kgb24gcG9vciBjb25uZWN0aW9ucy5cbiAgICovXG4gIGF1ZGlvTWF4Sml0dGVyQnVmZmVyRHVyYXRpb24/OiBudW1iZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIGEgdXNlciB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCAob3Igc2VydmVyLXByb3ZpZGVkKVxuICogU1RVTiBhbmQgVFVSTiBjb25maWd1cmF0aW9uIHRoYXQgaXMgb2ZmZXJlZCBieSB0aGUgY2xpZW50LiBOb3RlIHRoYXQgaWYgYSBjdXN0b20gc3R1biBhbmQgdHVybiBjb25maWd1cmF0aW9uIGlzXG4gKiB1c2VkLCBhbGwgb2YgaXRzIHZhbHVlcyBtdXN0IGJlIHByb3ZpZGVkIVxuICogKFNldHRpbmcgdGhlc2UgdmFsdWVzIGRvZXMgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB3aGF0IHRoZSBzZXJ2ZXIgb2ZmZXJzIGZvciBpdHMgc3R1biBhbmQgdHVybiBjb25maWd1cmF0aW9uO1xuICogaG93ZXZlciwgdGhlIHNlcnZlcnMgYXJlIGdlbmVyYWxseSBleHBlY3RlZCB0byBiZSBjb25maWd1cmVkIHNvIGFzIHRvIGJlIGVhc2lseSByZWFjaGFibGUgd2l0aG91dCB0aGUgbmVlZCBmb3IgVFVSTlxuICogb3IgdGhyb3VnaCB0aGUgdXNlIG9mIHRoZSBzdGFuZGFyZCBUVVJOIHNlcnZlcnMuKVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBTVFVOIHNlcnZlciBVUkxzIHRvIHVzZS4gVGhpcyBzaG91bGQgYmUgYSBsaXN0IG9mIHN0cmluZ3MsIGVhY2ggb2Ygd2hpY2ggaXMgaW4gdGhlXG4gICAqIGZvcm1hdCBcInN0dW46eC55LnpcIiBvciBcInN0dW46eC55Lno6cG9ydFwiLiBGb3IgaW5zdGFuY2U6XG4gICAqXG4gICAqIFsgXCJzdHVuOmZvby5iYXIuY29tOjE5MzAyXCIsIFwic3R1bjpiYXIuYmF6LmNvbVwiIF1cbiAgICovXG4gICBzdHVuVXJsczogc3RyaW5nW107XG4gICAvKipcbiAgICAqIEEgbGlzdCBvZiBUVVJOIHNlcnZlciBVUkxzIHRvIHVzZS4gVGhpcyBzaG91bGQgYmUgYSBsaXN0IG9mIHN0cmluZ3MsIGVhY2ggb2Ygd2hpY2ggaXMgaW4gdGhlXG4gICAgKiBmb3JtYXQgXCJ0dXJuOngueS56XCIgb3IgXCJ0dXJuOngueS56OnBvcnRcIi4gRm9yIGluc3RhbmNlOlxuICAgICpcbiAgICAqIFsgXCJ0dXJuOmZvby5iYXIuY29tOjM0NzhcIiwgXCJ0dXJuOmJhci5iYXouY29tXCIgXVxuICAgICpcbiAgICAqL1xuICAgdHVyblVybHM6IHN0cmluZ1tdO1xuICAgLyoqXG4gICAgKiBBIFRVUk4gdXNlcm5hbWUgdG8gdXNlIHdoZW4gY29ubmVjdGluZyB0byB0aGUgc3BlY2lmaWVkIFRVUk4gc2VydmVyKHMpLlxuICAgICovXG4gICB0dXJuVXNlcm5hbWU6IHN0cmluZztcbiAgIC8qKlxuICAgICogQSBUVVJOIGNyZWRlbnRpYWwgKHBhc3N3b3JkKSB0byB1c2Ugd2hlbiBjb25uZWN0aW5nIHRvIHRoZSBzcGVjaWZpZWQgVFVSTiBzZXJ2ZXIocykuXG4gICAgKi9cbiAgIHR1cm5DcmVkZW50aWFsOiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogRW51bSBmb3IgcmVwcmVzZW50aW5nIGRpZmZlcmVudCBwb3NzaWJsZSBzdGF0ZXNcbiAqIHRoYXQgYSBSQVZJIHNlc3Npb24gbWlnaHQgYmUgaW4uXG4gKiBcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGVudW0gUmF2aVNlc3Npb25TdGF0ZXMge1xuICBORVcgPSBcIm5ld1wiLFxuICBDT05ORUNUSU5HID0gXCJjaGVja2luZ1wiLFxuICBDT05ORUNURUQgPSBcImNvbm5lY3RlZFwiLFxuICBDT01QTEVURUQgPSBcImNvbXBsZXRlZFwiLFxuICBESVNDT05ORUNURUQgPSBcImRpc2Nvbm5lY3RlZFwiLFxuICBGQUlMRUQgPSBcImZhaWxlZFwiLFxuICBDTE9TRUQgPSBcImNsb3NlZFwiXG59O1xuXG4vKiogXG4gKiBAaW50ZXJuYWxcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgY29tbXVuaWNhdGlvbnMgc2Vzc2lvbiBiZXR3ZWVuIGEgUkFWSSBKUyBjbGllbnQgYW5kIGEgUkFWSSBzZXJ2ZXIuXG4gKiBUaGlzIGNsYXNzIHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgYnkgdGhlIFJBVkkgY29uc3VtZXIsIGFuZCB0aGVuIHVzZWQgdG8gb3Blbiwgd29yayB3aXRoLCBhbmQgY2xvc2UgXG4gKiBSQVZJIHNlc3Npb25zIGFzIG5lZWRlZC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBSYXZpU2Vzc2lvbiB7XG4gIC8qKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKlxuICAgKiB0aGlzLl91dWlkICAgICAgICAgICAgICAgICAvLyBBIFVVSUQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcGFydGljdWxhciBSYXZpU2Vzc2lvblxuICAgKiB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzICAvLyBBIGxpc3Qgb2YgaGFuZGxlcnMgdG8gY2FsbCB3aGVuIHNvbWV0aGluZyAoZS5nLiBzdGF0ZSksIFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMsIGluY2x1ZGluZyB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZFxuICAgKlxuICAgKiB0aGlzLl9yYXZpSW1wbGVtZW50YXRpb24gICAvLyBUaGUgaW1wbGVtZW50YXRpb24gb2YgZXhhY3RseSBob3cgdG8gaW1wbGVtZW50IHRoZSBSQVZJIGNvbm5lY3Rpb24gKGUuZy4gd2l0aCBXZWJSVEMpXG4gICAqIHRoaXMuX2NvbW1hbmRDb250cm9sbGVyXG4gICAqIHRoaXMuX3N0cmVhbUNvbnRyb2xsZXJcbiAgICpcbiAgICogdGhpcy5fc3RhdGUgICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgY29ubmVjdGlvblxuICAgKlxuICAgKiBfcmVzb2x2ZU9wZW4sIF9yZWplY3RPcGVuLCBfcmVzb2x2ZUNsb3NlLCBhbmQgX3JlamVjdENsb3NlOiBVc2VkIGZvciByZXNvbHZpbmcgdGhlIFByb21pc2VzXG4gICAqICAgICBtYWRlIGJ5IHRoZSBvcGVuIGFuZCBjbG9zZSBmdW5jdGlvbnMsIHdoaWNoIGdldCBoYW5kbGVkIG91dHNpZGUgb2YgdGhvc2UgZnVuY3Rpb25zIHRoZW1zZWx2ZXNcbiAgICovXG4gIF9zdGF0ZUNoYW5nZUhhbmRsZXJzOiBTZXQ8RnVuY3Rpb24+O1xuICBfdXVpZDogc3RyaW5nO1xuXG4gIF9jb21tYW5kQ29udHJvbGxlcjogUmF2aUNvbW1hbmRDb250cm9sbGVyO1xuICBfc3RyZWFtQ29udHJvbGxlcjogUmF2aVN0cmVhbUNvbnRyb2xsZXI7XG5cbiAgX3N0YXRlOiBSYXZpU2Vzc2lvblN0YXRlcztcblxuICBfcmF2aUltcGxlbWVudGF0aW9uOiBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb247XG5cbiAgX3Jlc29sdmVPcGVuOiBGdW5jdGlvbjsgX3JlamVjdE9wZW46IEZ1bmN0aW9uO1xuICBfcmVzb2x2ZUNsb3NlOiBGdW5jdGlvbjsgX3JlamVjdENsb3NlOiBGdW5jdGlvbjtcbiAgXG4gIF9vcGVuaW5nVGltZW91dDogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSYXZpU2Vzc2lvbi5cbiAgICogRGVmYXVsdHMgdG8gdXNpbmcgbmV3IFJhdmlDb21tYW5kQ29udHJvbGxlciBhbmQgUmF2aVN0cmVhbUNvbnRyb2xsZXJzXG4gICAqIGFuZCBpbml0aWFsaXplcyB0aGUgc3RhdGUgdG8gUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VELlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIEluaXRpYWxpemUgdGhlIGxpc3Qgb2YgaGFuZGxlcnMgYW5kIHRoZSBVVUlEXG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl91dWlkID0gUmF2aVV0aWxzLmNyZWF0ZVVVSUQoKTtcbiAgICBcbiAgICAvLyBBbmQgdGhlIGNvbW1hbmQgY29udHJvbGxlciBhbmQgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICB0aGlzLl9jb21tYW5kQ29udHJvbGxlciA9IG5ldyBSYXZpQ29tbWFuZENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyID0gbmV3IFJhdmlTdHJlYW1Db250cm9sbGVyKHRoaXMuX2NvbW1hbmRDb250cm9sbGVyKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuICAgIHRoaXMuX3N0YXRlID0gUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VEO1xuICAgIFxuICAgIC8vIElmIHdlIHdhbnRlZCB0byB1c2UgYSBkaWZmZXJlbnQgY29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbixcbiAgICAvLyB3ZSB3b3VsZCBuZXcoKSBpdCBoZXJlLiAoVE9ETzogTWFrZSB0aGlzIGNvbmZpZ3VyYWJsZSBpbiBzb21lXG4gICAgLy8gaW50ZXJlc3Rpbmcgd2F5LiBGb3Igbm93LCBpdCdzIGVub3VnaCBqdXN0IHRvIG1ha2UgaXQgZWFzaWx5IFxuICAgIC8vIHN3YXBwYWJsZSBpbiB0aGUgY29kZSBoZXJlLilcbiAgICB0aGlzLl9yYXZpSW1wbGVtZW50YXRpb24gPSBuZXcgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uKHRoaXMpO1xuICAgIC8vIFdoZW4gc29tZW9uZSBzZXRzIGFuIGlucHV0IGF1ZGlvIHN0cmVhbSBvbiB0aGUgc3RyZWFtIGNvbnRyb2xsZXIsXG4gICAgLy8gcGFzcyB0aGF0IGFsb25nIHRvIHRoZSBpbXBsZW1lbnRhdGlvbidzIF9hZGRBdWRpb0lucHV0U3RyZWFtIG1ldGhvZC5cbiAgICBjb25zdCByYXZpSW1wbCA9IHRoaXMuX3JhdmlJbXBsZW1lbnRhdGlvbjtcbiAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyLnNldElucHV0QXVkaW9DaGFuZ2VIYW5kbGVyKHJhdmlJbXBsLl9hZGRBdWRpb0lucHV0U3RyZWFtLmJpbmQocmF2aUltcGwpKTtcbiAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyLnNldElucHV0VmlkZW9DaGFuZ2VIYW5kbGVyKHJhdmlJbXBsLl9hZGRWaWRlb0lucHV0U3RyZWFtLmJpbmQocmF2aUltcGwpKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgUkFWSSBzZXNzaW9uLlxuICAgKiBcbiAgICogQHJldHVybnMge1JhdmlTZXNzaW9uU3RhdGVzfVxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgVVVJRCBvZiB0aGUgc2Vzc2lvblxuICAgKiBcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldFVVSUQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3V1aWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGxpc3RlbmluZyB0byBzdGF0ZSBjaGFuZ2VzXG4gICAqIEBjYWxsYmFjayBSYXZpU2Vzc2lvbn5zdGF0ZUNoYW5nZUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBBbiBvYmplY3QgdGhhdCB3aWxsIGNvbnRhaW4gaW5mb3JtYXRpb25cbiAgICogYWJvdXQgdGhlIHN0YXRlIGNoYW5nZS4gVGhpcyBpbmNsdWRlcyB0aGUgXCJldmVudC5zdGF0ZVwiIGtleSxcbiAgICogd2hpY2ggd2lsbCBoYXZlIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZSBmcm9tIHRoZSBSYXZpU2Vzc2lvblN0YXRlcyBlbnVtLlxuICAgKi9cbiAgLyoqXG4gICAqIEFkZCBhIGhhbmRsZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBzdGF0ZVxuICAgKiBjaGFuZ2UgZXZlbnRzLlxuICAgKiBUaGVzZSBhcmUgc3RvcmVkIGluIGEgU2V0IG9mIEZ1bmN0aW9uczsgdGhlcmVmb3JlLCBhIGdpdmVuIGZ1bmN0aW9uXG4gICAqIGNhbiBvbmx5IGV4aXN0IG9uY2UgaW4gdGhpcyBTZXQuXG4gICAqIFxuICAgKiBAcGFyYW0ge1JhdmlTZXNzaW9ufnN0YXRlQ2hhbmdlQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGFkZCBzdWNjZWVkZWRcbiAgICovXG4gIGFkZFN0YXRlQ2hhbmdlSGFuZGxlcihjaGFuZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzLmFkZChjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIGFkZGluZyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyOiBcIiArXG4gICAgICAgIGVyci5tZXNzYWdlLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgaGFuZGxlciBzbyB0aGF0IGl0IHN0b3BzIGxpc3RlbmluZyBmb3Igc3RhdGVcbiAgICogY2hhbmdlIGV2ZW50cy5cbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aVNlc3Npb25+c3RhdGVDaGFuZ2VDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBoYXMgYmVlbiBoYW5kbGluZyBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHJlbW92YWwgd2FzIHN1Y2Nlc3NmdWwgKGkuZS4gZGlkIG5vdCB0aHJvdyBhbiBlcnJvciAtLSBub3RlIHRoYXQgdGhpcyBkb2VzXG4gICAqIE5PVCBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciB3YXMgaW4gdGhlIHNldCBpbiB0aGUgZmlyc3QgcGxhY2UpXG4gICAqL1xuICByZW1vdmVTdGF0ZUNoYW5nZUhhbmRsZXIoY2hhbmdlSGFuZGxlcjogRnVuY3Rpb24pIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycy5kZWxldGUoY2hhbmdlSGFuZGxlcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIFJhdmlVdGlscy5lcnIoXCJFcnJvciByZW1vdmluZyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyOiBcIiArXG4gICAgICAgIGVyci5tZXNzYWdlLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgdGhlIFJhdmlDb21tYW5kQ29udHJvbGxlciBmb3IgdXNlIHdpdGggdGhpcyBSYXZpU2Vzc2lvbi5cbiAgICogVGhlIHtsaW5rIFJhdmlDb21tYW5kQ29udHJvbGxlcn0gaXMgdXNlZCB0byBzZW5kIGNvbW1hbmRzIGFuZCBpbnB1dCB0byB0aGUgUkFWSSBzZXJ2ZXIuXG4gICAqIFxuICAgKiBAcmV0dXJucyB7UmF2aUNvbW1hbmRDb250cm9sbGVyfVxuICAgKi9cbiAgZ2V0Q29tbWFuZENvbnRyb2xsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRDb250cm9sbGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgUmF2aVN0cmVhbUNvbnRyb2xsZXIgZm9yIHVzZSB3aXRoIHRoaXMgUmF2aVNlc3Npb24uXG4gICAqIFRoZSB7bGluayBSYXZpU3RyZWFtQ29udHJvbGxlcn0gaXMgdXNlZCB0byBzZW5kIGNvbW1hbmRzIGFuZCBpbnB1dCB0byB0aGUgUkFWSSBzZXJ2ZXIuXG4gICAqIFxuICAgKiBAcmV0dXJucyB7UmF2aVN0cmVhbUNvbnRyb2xsZXJ9XG4gICAqL1xuICBnZXRTdHJlYW1Db250cm9sbGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW1Db250cm9sbGVyO1xuICB9XG4gIFxuICAvKipcbiAgICogT3BlbiBhIFJBVkkgY29ubmVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24uIFJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgd2lsbCByZXNvbHZlIHdpdGggdGhlIGNvbm5lY3RlZCBzdGF0ZSBvbmNlIHRoZSBSYXZpU2Vzc2lvbiBpcyBjb25uZWN0ZWQuXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gX19uYW1lZFBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHNpZ25hbGluZ0Nvbm5lY3Rpb25cbiAgICogQHBhcmFtIHRpbWVvdXQgQSB0aW1vdXQgaW4gbXMgYWZ0ZXIgd2hpY2ggdG8gdGltZW91dCB0aGUgYXR0ZW1wdCB0byBjb25uZWN0LiBEZWZhdWx0cyB0byA1MDAwICg1IHNlY29uZHMpLlxuICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGFwcGxpZWQgdG8gdGhlIHNlcnZlciBzaWRlIG9mIHRoZSBzZXNzaW9uLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLFxuICAgKiBtZWFuaW5nIHRoYXQgd2UnbGwgcmVseSBvbiB0aGUgZGVmYXVsdCB2YWx1ZXMgYXMgZGVmaW5lZCBvbiB0aGUgc2VydmVyLlxuICAgKiAgICAgICAgICAgIFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIG9wZW5SQVZJU2Vzc2lvbih7c2lnbmFsaW5nQ29ubmVjdGlvbiwgdGltZW91dCA9IDUwMDAsIHBhcmFtcyA9IG51bGwsIGN1c3RvbVN0dW5BbmRUdXJuID0gbnVsbH06IHsgc2lnbmFsaW5nQ29ubmVjdGlvbjogUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24sIHRpbWVvdXQ/OiBudW1iZXIsIHBhcmFtcz86IFdlYlJUQ1Nlc3Npb25QYXJhbXMsIGN1c3RvbVN0dW5BbmRUdXJuPzogQ3VzdG9tU1RVTmFuZFRVUk5Db25maWd9KSB7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFJhdmlTZXNzaW9uU3RhdGVzLkNPTk5FQ1RFRCB8fCB0aGlzLl9zdGF0ZSA9PT0gUmF2aVNlc3Npb25TdGF0ZXMuQ09NUExFVEVEKSB7XG4gICAgICAgIC8vIFJlZi4gaWNlY29ubmVjdGlvbnN0YXRlcyBhdCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDUGVlckNvbm5lY3Rpb24vaWNlQ29ubmVjdGlvblN0YXRlXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgICBcIlRoZXJlIGlzIGFscmVhZHkgYW4gb3BlbiBSQVZJIHNlc3Npb24uIFRvIHJlY29ubmVjdCwgZmlyc3QgY2xvc2UgdGhlIGV4aXN0aW5nIGNvbm5lY3Rpb24sIGFuZCB0aGVuIGF0dGVtcHQgdG8gb3BlbiBhZ2Fpbi5cIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXZpU2Vzc2lvbiA9IHRoaXM7XG4gICAgLy8gVGVsbCBvdXIgY29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbiBhYm91dCB0aGlzIHNpZ25hbGluZyBjb25uZWN0aW9uIC0tXG4gICAgLy8gaXQgbWF5IG5lZWQgdG8gdGFsayB0byBpdCBkaXJlY3RseSB3aGlsZSBpdCdzIGF0dGVtcHRpbmcgdG8gbmVnb3RpYXRlXG4gICAgLy8gdGhlIGNvbm5lY3Rpb24uXG4gICAgdGhpcy5fcmF2aUltcGxlbWVudGF0aW9uLl9hc3NpZ25TaWduYWxpbmdDb25uZWN0aW9uKHNpZ25hbGluZ0Nvbm5lY3Rpb24pO1xuXG4gICAgLy8gU2V0IGEgdGltZW91dCBpbiBjYXNlIHRoZSBzZXNzaW9uIGdldHMgaHVuZyB1cCBzb21ld2hlcmVcbiAgICB0aGlzLl9vcGVuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJSYXZpU2Vzc2lvbi5vcGVuIHRpbWVkIG91dCBhZnRlciBcIiArIHRpbWVvdXQgKyBcIiBtc1wiO1xuICAgICAgICBSYXZpVXRpbHMubG9nKGVycm9yTWVzc2FnZSwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgICAgcmF2aVNlc3Npb24uX2Z1bGZpbGxQcm9taXNlcyh7IG1lc3NhZ2U6IGVycm9yTWVzc2FnZSB9LCBSYXZpU2Vzc2lvblN0YXRlcy5GQUlMRUQpO1xuICAgICAgICAvLyBDbG9zZSB0aGUgc2Vzc2lvbiB0byBjbGVhbiB1cCBvYmplY3RzLiBXZSd2ZSBhbHJlYWR5IHJlamVjdGVkIHRoZSBwcm9taXNlIGFib3ZlLlxuICAgICAgICByYXZpU2Vzc2lvbi5jbG9zZVJBVklTZXNzaW9uKCk7XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmF2aVNlc3Npb24uX3Jlc29sdmVPcGVuID0gcmVzb2x2ZTtcbiAgICAgIHJhdmlTZXNzaW9uLl9yZWplY3RPcGVuID0gcmVqZWN0O1xuXG4gICAgICAvLyBTdGFydCB0aGUgXCJvcGVuaW5nXCIgcHJvY2Vzc1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIk9wZW5pbmcgUkFWSSBzZXNzaW9uXCIsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgICB0aGlzLl9zdGF0ZSA9IFJhdmlTZXNzaW9uU3RhdGVzLk5FVztcbiAgICAgIHJhdmlTZXNzaW9uLl9yYXZpSW1wbGVtZW50YXRpb24uX29wZW4ocGFyYW1zLCBjdXN0b21TdHVuQW5kVHVybik7XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDbG9zZSBhIFJBVkkgY29ubmVjdGlvbiwgaW5jbHVkaW5nIHNodXR0aW5nIGRvd24gdGhlIFxuICAgKiByZWxldmFudCBSYXZpU3RyZWFtQ29udHJvbGxlciBhbmQgUmF2aUNvbW1hbmRDb250cm9sbGVyLiBSZXR1cm5zIGEgUHJvbWlzZVxuICAgKiB0aGF0IHdpbGwgcmVzb2x2ZSB3aXRoIHRoZSBjbG9zZWQgc3RhdGUgb25jZSB0aGUgUmF2aVNlc3Npb24gaXMgY2xvc2VkLlxuICAgKiBcbiAgICogQHBhcmFtIHtSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbn0gc2lnbmFsaW5nQ29ubmVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGNsb3NlUkFWSVNlc3Npb24oKSB7XG4gICAgdmFyIHJhdmlTZXNzaW9uID0gdGhpcztcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFJhdmlTZXNzaW9uU3RhdGVzLkNMT1NFRCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgXCJSQVZJIHNlc3Npb24gaXMgYWxyZWFkeSBjbG9zZWQuXCJcbiAgICApO1xuICAgXG4gICAgLy8gU3RhcnQgYnkgY2xvc2luZyBvdXQgY29tbWFuZCBjb250cm9sbGVyXG4gICAgLy8gYW5kIHRoZSBzdHJlYW0gY29udHJvbGxlci5cbiAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyLl9zdG9wKCk7XG4gICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIuc3RvcE1vbml0b3JpbmdRdWV1ZXMoKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByYXZpU2Vzc2lvbi5fcmVzb2x2ZUNsb3NlID0gcmVzb2x2ZTtcbiAgICAgIHJhdmlTZXNzaW9uLl9yZWplY3RDbG9zZSA9IHJlamVjdDtcblxuICAgICAgUmF2aVV0aWxzLmxvZyhcIkNsb3NpbmcgUkFWSSBzZXNzaW9uXCIsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgICByYXZpU2Vzc2lvbi5fcmF2aUltcGxlbWVudGF0aW9uLl9jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBHZXRzIGNhbGxlZCB3aGVuZXZlciB0aGUgc3RhdGUgY2hhbmdlcyAoYW5kIHNvbWV0aW1lcyB3aGVuIGl0IGRvZXNuJ3QsXG4gICAqIGJ1dCB3aGVuIHdlIGp1c3Qgd2FudCB0byBtYWtlIHN1cmUpLiBEZXBlbmRpbmcgb24gdGhlIG5ldyAob3IgY3VycmVudCkgc3RhdGUsXG4gICAqIHRoaXMgd2lsbCBhcHByb3ByaWF0ZWx5IGZ1bGZpbGwgb3V0c3RhbmRpbmcgcHJvbWlzZXMgdGhhdCBhcmUgcGVuZGluZ1xuICAgKiBpbiBlaXRoZXIgdGhlIG9wZW4gb3IgY2xvc2UgbWV0aG9kIChvciBib3RoKS5cbiAgICovXG4gIF9mdWxmaWxsUHJvbWlzZXMoZXZlbnQ6IGFueSA9IHt9LCBzdGF0ZTogUmF2aVNlc3Npb25TdGF0ZXMpIHtcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gZXZlbnQucmVhc29uIHx8IGV2ZW50Lm1lc3NhZ2UgfHwgc3RhdGU7XG4gICAgc3dpdGNoKHN0YXRlKSB7XG4gICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkNPTk5FQ1RFRDpcbiAgICAgIGNhc2UgUmF2aVNlc3Npb25TdGF0ZXMuQ09NUExFVEVEOlxuICAgICAgICBpZiAodGhpcy5fb3BlbmluZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9vcGVuaW5nVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl9vcGVuaW5nVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVPcGVuKSB0aGlzLl9yZXNvbHZlT3BlbigpO1xuICAgICAgICBpZiAodGhpcy5fcmVqZWN0Q2xvc2UpIHRoaXMuX3JlamVjdENsb3NlKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2Vzc2lvblN0YXRlcy5ESVNDT05ORUNURUQ6XG4gICAgICAgIC8vIE5PVEU6IFBlciBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDUGVlckNvbm5lY3Rpb24jUlRDSWNlQ29ubmVjdGlvblN0YXRlX2VudW1cbiAgICAgICAgLy8gXCJkaXNjb25uZWN0ZWRcIiBpcyBhIHBvdGVudGlhbGx5IHRyYW5zaWVudCBzdGF0ZSwgc28gaW4gdGhpcyBjYXNlIHdlIHdpbGwgc2ltcGx5IHdhaXQgdW50aWwgd2VcbiAgICAgICAgLy8gZ2V0IHRvIGNvbm5lY3RlZCwgY29tcGxldGUsIG9yIGZhaWxlZC5cbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIl9mdWxmaWxsUHJvbWlzZXM6IFBvc3NpYmxlIHRyYW5zaXRvcnkgc3RhdGUgRElTQ09OTkVDVEVEOyBsZWF2aW5nIHByb21pc2VzIHBlbmRpbmdcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkZBSUxFRDpcbiAgICAgICAgaWYgKHRoaXMuX29wZW5pbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb3BlbmluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5fb3BlbmluZ1RpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZWplY3RPcGVuKSB0aGlzLl9yZWplY3RPcGVuKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGlmICh0aGlzLl9yZWplY3RDbG9zZSkgdGhpcy5fcmVqZWN0Q2xvc2UoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgLy8gRXhwbGljaXRseSBjYWxsIHRoZSBpbXBsZW1lbnRhdGlvbidzIFwiY2xvc2VcIiBtZXRob2QgdG8gbWFrZVxuICAgICAgICAvLyByZWFsbHksIHJlYWxseSBzdXJlIGl0J3MgY2xvc2VkIGluIGFkZGl0aW9uIHRvIGJlaW5nIFwiZmFpbGVkXCIuXG4gICAgICAgIC8vIFRoZXNlIGFyZSBOT1QgdGhlIHNhbWUgc3RhdGUhIEEgXCJmYWlsZWRcIiBjb25uZWN0aW9uIG1heSBzdGlsbCBiZVxuICAgICAgICAvLyBhd2FyZSBvZiBpdHMgc2lnbmFsaW5nIGNvbm5lY3Rpb24gYW5kIG90aGVyIG5pY2V0aWVzLlxuICAgICAgICAvLyBLaWNrIG9mZiB0aGF0IGNsb3NlIGluIGEgdGltZW91dCB0byBnZXQgaXQgdG8gcnVuIGFzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGZyb20gdGhlIFByb21pc2UgcmVqZWN0aW9uLlxuICAgICAgICBsZXQgcmF2aVNlc3Npb24gPSB0aGlzO1xuICAgICAgICBjb25zdCBjbG9zZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByYXZpU2Vzc2lvbi5fcmF2aUltcGxlbWVudGF0aW9uLl9jbG9zZSgpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkNMT1NFRDpcbiAgICAgICAgaWYgKHRoaXMuX29wZW5pbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb3BlbmluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5fb3BlbmluZ1RpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZWplY3RPcGVuKSB0aGlzLl9yZWplY3RPcGVuKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGlmICh0aGlzLl9yZXNvbHZlQ2xvc2UpIHRoaXMuX3Jlc29sdmVDbG9zZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERvIG5vdGhpbmcgZm9yIHRoZSBcImluIHByb2dyZXNzXCIgc3RhdGVzLCBsaWtlIFwiTkVXXCIgb3IgXCJDT05ORUNUSU5HXCJcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIl9mdWxmaWxsUHJvbWlzZXM6IFNraXBwaW5nIGluLXByb2dyZXNzIHN0YXRlIFwiICsgc3RhdGUsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgfVxuICB9XG4gIFxuICBcbiAgXG4gIC8qKlxuICAgKiBIYW5kbGVyIGZvciB3aGVuZXZlciBhIG5ldyBcInRyYWNrIGNoYW5uZWxcIiBzaG93cyB1cC4gKFdoZW4gdGhpcyBldmVudCBoYXBwZW5zXG4gICAqIHNob3VsZCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiwgYW5kIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0cmFjayBzaG91bGQgYmUgXG4gICAqIHN0b3JlZCBpbiB0aGUgcGFzc2VkIGV2ZW50IG9iamVjdC4pXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9PbnRyYWNrKGV2ZW50OiBhbnkpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGNvZGUgaXMgd29ya2luZyBpZiB3ZSBoYXZlIG9ubHkgb25lIG1lZGlhIHRyYWNrICh2aWRlbyBPUiBhdWRpbyksIG5vdCBzdXJlIGl0IHdvcmtzIHdpdGggbW9yZVxuICAgIC8vIE5lZWQgdG8gbWFrZSBpdCBtb3JlIHJvYnVzdCB3aXRoIGRpZmZlcmVudCBicmFuY2hlcyBiYXNlZCBvbiB0aGUgZXZlbnQgaW5mb1xuICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCBuZXcgdHJhY2s6IFwiLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgIFJhdmlVdGlscy5sb2coZXZlbnQsIFwiUmF2aVNlc3Npb25cIik7XG5cbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQudHJhY2sgJiYgZXZlbnQudHJhY2sua2luZCA9PT0gXCJ2aWRlb1wiKSB7IFxuICAgICAgUmF2aVV0aWxzLmxvZyhcIkFkZGluZyByZW1vdGUgdmlkZW8gdHJhY2sgdG8gc3RyZWFtIGNvbnRyb2xsZXJcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgIHRoaXMuX3N0cmVhbUNvbnRyb2xsZXIuX3NldFZpZGVvU3RyZWFtKGV2ZW50LnN0cmVhbXNbMF0pO1xuICAgICAgdGhpcy5fc3RyZWFtQ29udHJvbGxlci5fb25WaWRlb1N0cmVhbVN0YXRlQ2hhbmdlZChcInJlYWR5XCIpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQudHJhY2sgJiYgZXZlbnQudHJhY2sua2luZCA9PT0gXCJhdWRpb1wiKSB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiQWRkaW5nIHJlbW90ZSBhdWRpbyB0cmFjayB0byBzdHJlYW0gY29udHJvbGxlclwiLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgICAgdGhpcy5fc3RyZWFtQ29udHJvbGxlci5fc2V0QXVkaW9TdHJlYW0oZXZlbnQuc3RyZWFtc1swXSk7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogSGFuZGxlciBmb3Igd2hlbmV2ZXIgYSBuZXcgXCJkYXRhIGNoYW5uZWxcIiBzaG93cyB1cC4gKFdoZW4gdGhpcyBldmVudCBoYXBwZW5zIHNob3VsZCBiZSBkZXRlcm1pbmVkXG4gICAqIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiwgYW5kIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGFubmVsIHNob3VsZCBiZSBzdG9yZWQgaW4gdGhlIHBhc3NlZCBldmVudCBvYmplY3QuKVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RvT25kYXRhY2hhbm5lbChldmVudDogYW55KSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIlJlY2VpdmVkIG5ldyBjaGFubmVsOiBcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICBSYXZpVXRpbHMubG9nKGV2ZW50LCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgIFxuICAgIHN3aXRjaCAoZXZlbnQuY2hhbm5lbC5sYWJlbCkge1xuICAgICAgY2FzZSBcInJhdmkuaW5wdXRcIjpcbiAgICAgICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIuX3NldElucHV0RGF0YUNoYW5uZWwoZXZlbnQuY2hhbm5lbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJhdmkuY29tbWFuZFwiOlxuICAgICAgICB0aGlzLl9jb21tYW5kQ29udHJvbGxlci5fc2V0Q29tbWFuZERhdGFDaGFubmVsKGV2ZW50LmNoYW5uZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCB1bmtub3duIGRhdGEgY2hhbm5lbCBuYW1lZCBcIiArIGV2ZW50LmNoYW5uZWwubGFiZWwsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBcbiAgICogR2VuZXJpYyBoYW5kbGVyIFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50OiBhbnkgPSB7fSwgc3RhdGU6IFJhdmlTZXNzaW9uU3RhdGVzKSB7XG4gICAgZXZlbnRbXCJzdGF0ZVwiXSA9IHN0YXRlO1xuXG4gICAgLy8gQWx3YXlzIHRyeSB0byBmdWxmaWxsIGFueSBvcGVuIHByb21pc2VzLCBldmVuIGlmIHRoZSBzdGF0ZSBoYXNuJ3QgY2hhbmdlZFxuICAgIHRoaXMuX2Z1bGZpbGxQcm9taXNlcyhldmVudCwgc3RhdGUpO1xuXG4gICAgLy8gQnV0IG9ubHkgY2FsbCBoYW5kbGVycyBpZiB0aGUgc3RhdGUgZGlkLCBpbiBmYWN0LCBjaGFuZ2VcbiAgICBpZiAoc3RhdGUgIT09IHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIGV2ZW50W1wic3RhdGVcIl0gPSBzdGF0ZTtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIl9oYW5kbGVTdGF0ZUNoYW5nZTogXCIgKyBSYXZpVXRpbHMuc2FmZWx5UHJpbnRhYmxlKGV2ZW50KSwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBsaXN0ZW5pbmcgdG8gc3RhdHNcbiAgICogQGNhbGxiYWNrIFJhdmlTZXNzaW9ufnN0YXRzT2JzZXJ2ZXJDYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdHMgQW4gb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIGluZm9ybWF0aW9uXG4gICAqIGFib3V0IHRoZSBzdGF0cyByZWNvcmRlZFxuICAgKi9cbiAgLyoqXG4gICAqIEFkZCBhIGhhbmRsZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBuZXcgc3RhdHMgZ2VuZXJhdGVkLlxuICAgKiBUaGVzZSBhcmUgc3RvcmVkIGluIGEgU2V0IG9mIEZ1bmN0aW9uczsgdGhlcmVmb3JlLCBhIGdpdmVuIGZ1bmN0aW9uXG4gICAqIGNhbiBvbmx5IGV4aXN0IG9uY2UgaW4gdGhpcyBTZXQuXG4gICAqIFxuICAgKiBAcGFyYW0ge1JhdmlTZXNzaW9ufnN0YXRzT2JzZXJ2ZXJDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBzaG91bGQgaGFuZGxlIGEgc3RhdGUgY2hhbmdlIGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYWRkIHN1Y2NlZWRlZFxuICAgKi9cbiAgYWRkU3RhdHNPYnNlcnZlcihvYnNlcnZlcjogRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fcmF2aUltcGxlbWVudGF0aW9uLl9hZGRTdGF0c09ic2VydmVyKG9ic2VydmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBoYW5kbGVyIHNvIHRoYXQgaXQgc3RvcHMgbGlzdGVuaW5nIGZvciBzdGF0cyB1cGRhdGVzLlxuICAgKiBcbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn5zdGF0c09ic2VydmVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHJlbW92YWwgd2FzIHN1Y2Nlc3NmdWwgKGkuZS4gZGlkIG5vdCB0aHJvdyBhbiBlcnJvciAtLSBub3RlIHRoYXQgdGhpcyBkb2VzXG4gICAqIE5PVCBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciB3YXMgaW4gdGhlIHNldCBpbiB0aGUgZmlyc3QgcGxhY2UpXG4gICAqL1xuICByZW1vdmVTdGF0c09ic2VydmVyKG9ic2VydmVyOiBGdW5jdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9yYXZpSW1wbGVtZW50YXRpb24uX3JlbW92ZVN0YXRzT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICB9XG4gIFxufSAvLyBFbmQgb2YgdGhlIFJhdmlTZXNzaW9uIGNsYXNzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbiAvKipcbiAgKiBAaW50ZXJuYWxcbiAqIENvbnN0YW50cyB1c2VkIGFzIHRoZSBkZWZhdWx0IGZpbHRlciBmb3IgdGhlIHN0YXRzIGNvbGxlY3RlZCBpbiB0aGUgUmF2aVN0YXRzV2F0Y2hlclxuICovXG5leHBvcnQgY29uc3QgU1RBVFNfV0FUQ0hFUl9GSUxURVIgPSBuZXcgTWFwKFtcbiAgW1wicmVtb3RlLWluYm91bmQtcnRwXCIsIFtcImlkXCIsIFwidHlwZVwiLCBcInRpbWVzdGFtcFwiLCBcInJvdW5kVHJpcFRpbWVcIiwgXCJqaXR0ZXJcIl0gXSxcbiAgW1wiaW5ib3VuZC1ydHBcIiwgW1wiaWRcIiwgXCJ0eXBlXCIsIFwidGltZXN0YW1wXCIsIFwiaml0dGVyQnVmZmVyRGVsYXlcIiwgXCJqaXR0ZXJCdWZmZXJFbWl0dGVkQ291bnRcIiwgXCJieXRlc1JlY2VpdmVkXCJdXVxuXSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBTdGF0c1dhdGNoZXIgaXMgdGhlIG9iamVjdCByZXNwb25zaWJsZSBmb3IgY2FsbGluZyBnZXRTdGF0cyBmcm9tIHRoZVxuICogUlRDUGVlckNvbm5lY3Rpb24gYXQgcmVndWxhciBpbnRlcnZhbHMuXG4gKiBUaGUgY2FwdHVyZWQgbWV0cmljcyBhcmUgZmlsdGVyZWQgYW5kIHBhc3NlZCBvbiB0byB0aGUgc3RhdHNPYnNlcnZlcihzKS5cbiAqIFRoZSBmaWx0ZXIgaXMgYSBkaWN0aW9uYXJ5IG9mIHRoZSByZXBvcnQgdHlwZSBhbmQgZmllbGRzLlxuICogQ3VycmVudCBkZWZhdWx0IHZhbHVlIGlzIGRlZmluZWQgaW4gU1RBVFNfV0FUQ0hFUl9GSUxURVIuXG4gKiBTdGF0c09ic2VydmVyIGlzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyAyIHBhcmFtZXRlcnMsIHRoZSBjdXJyZW50IHJlY29yZCBhbmQgdGhlIHByZXZpb3VzIHJlY29yZC5cbiAqIFNldmVyYWwgU3RhdHNPYnNlcnZlciBjYWxsYmFja3MgY2FuIGJlIGFkZGVkL3JlbW92ZWQgYnkgdXNlciBjb2RlIHRocm91Z2ggdGhlIGNvcnJlc3BvbmRpbmcgbWV0aG9kcyBvZiB0aGUgb2JqZWN0LlxuICogdGhlc2UgbWV0aG9kcyBhcmUgZXhwb3NlZCBwdWJsaWNhbGx5IG9uIHRoZSBSYXZpU2Vzc2lvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJhdmlXZWJSVENTdGF0c1dhdGNoZXIge1xuICBfcmF2aUltcGxlbWVudGF0aW9uOiBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb247XG4gIF9vYnNlcnZlcnM6IFNldDxGdW5jdGlvbj47XG4gIF9maWx0ZXI6IE1hcDxzdHJpbmcsIEFycmF5PGFueT4+O1xuICBfaW50ZXJ2YWw6IG51bWJlcjtcbiAgX3ByZXZTdGF0czogQXJyYXk8YW55PjtcblxuICBcbiAgLyoqXG4gICAqIFwiQ2xhc3NcIiB2YXJpYWJsZXMgdG8gYmUgYXdhcmUgb2Y6XG4gICAqIHRoaXMuX29ic2VydmVycyBpcyB0aGUgc2V0IG9mIG9ic2VydmVyIGNhbGxiYWNrcyByZWdpc3RlcmVkIGJ5IHVzZXIgY29kZVxuICAgKiB0aGlzLl9pbnRlcnZhbCBpcyB0aGUgaW50ZXJ2YWwgdGlja2luZyB0aGUgZ2V0U3RhdHMgY2FsbFxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFJhdmlTdGF0c1dhdGNoZXJcbiAgICogQHBhcmFtIHtSYXZpV2ViUlRDSW1wbGVtZW50YXRpb259IHdlYlJUQ0ltcGxlbWVudGF0aW9uIFRoZSBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24gYmVpbmcgd2F0Y2hlZFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdlYlJUQ0ltcGxlbWVudGF0aW9uOiBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24pIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiY29uc3RydWN0b3JcIiwgXCJSYXZpU3RhdHNXYXRjaGVyXCIpO1xuICAgIHRoaXMuX3JhdmlJbXBsZW1lbnRhdGlvbiA9IHdlYlJUQ0ltcGxlbWVudGF0aW9uO1xuICAgIHRoaXMuX29ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9maWx0ZXIgPSBTVEFUU19XQVRDSEVSX0ZJTFRFUjtcbiAgICB0aGlzLl9pbnRlcnZhbCA9IDA7XG4gICAgdGhpcy5fcHJldlN0YXRzID0gW107IFxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSB3YXRjaGVyXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBvYnNlcnZlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG5ldyBzdGF0cyBnZW5lcmF0ZWQuXG4gICAqIFRoZXNlIGFyZSBzdG9yZWQgaW4gYSBTZXQgb2YgRnVuY3Rpb25zOyB0aGVyZWZvcmUsIGEgZ2l2ZW4gZnVuY3Rpb25cbiAgICogY2FuIG9ubHkgZXhpc3Qgb25jZSBpbiB0aGlzIFNldC5cbiAgICogXG4gICAqIHN0YXRzT2JzZXJ2ZXJDYWxsYmFjayBmdW5jdGlvbiByZWNlaXZlcyAyIHBhcmFtZXRlcnMsIHRoZSBjdXJyZW50IHJlY29yZCBhbmQgdGhlIHByZXZpb3VzIHJlY29yZC5cbiAgICogZnVuY3Rpb24obmV3U3RhdHMsIHByZXZTdGF0cylcbiAgICogdGhlIFN0YXRzIHBhcmFtZXRlciBpcyBhbiBBcnJheSBvZiBvYmplY3RzLCBhIGZpbHRlcmVkIGRvd24gdmVyc2lvbiBvZiB0aGUgZGljdGlvbm5hcmllcyByZXR1cm5lZCBieSBcbiAgICogUlRDUGVlckNvbm5lY3Rpb24uZ2V0U3RhdHNcbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aVN0YXRzV2F0Y2hlcn5zdGF0c09ic2VydmVyQ2FsbGJhY2t9IG9ic2VydmVyIEEgY2FsbGJhY2sgd2hpY2ggd2lsbCByZWNlaXZlIHRoZSBzdGF0cyBzYW1wbGVzXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYWRkIHN1Y2NlZWRlZFxuICAgKi9cbiAgYWRkT2JzZXJ2ZXIob2JzZXJ2ZXI6IEZ1bmN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX29ic2VydmVycy5hZGQob2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5fb25PYnNlcnZlckNoYW5nZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKFwiRXJyb3IgYWRkaW5nIGEgc3RhdHMgb2JzZXJ2ZXI6IFwiICtcbiAgICAgICAgZXJyLm1lc3NhZ2UsIFwiUmF2aVN0YXRzV2F0Y2hlclwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBvYnNlcnZlciBzbyB0aGF0IGl0IHN0b3BzIGxpc3RlbmluZyBmb3Igc3RhdHMgdXBkYXRlcy5cbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aVNlc3Npb25+c3RhdHNPYnNlcnZlckNhbGxiYWNrfSBvYnNlcnZlciBBIGNhbGxiYWNrIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgc2V0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcmVtb3ZhbCB3YXMgc3VjY2Vzc2Z1bCAoaS5lLiBkaWQgbm90IHRocm93IGFuIGVycm9yIC0tIG5vdGUgdGhhdCB0aGlzIGRvZXNcbiAgICogTk9UIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIHdhcyBpbiB0aGUgc2V0IGluIHRoZSBmaXJzdCBwbGFjZSlcbiAgICovXG4gIHJlbW92ZU9ic2VydmVyKG9ic2VydmVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9vYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgIHRoaXMuX29uT2JzZXJ2ZXJDaGFuZ2UoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIHJlbW92aW5nIGEgc3RhdHMgb2JzZXJ2ZXIgaGFuZGxlcjogXCIgK1xuICAgICAgICBlcnIubWVzc2FnZSwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgXG4gIC8vIFdoZW5ldmVyIG9ic2VydmVyKHMpIGFyZSBhZGRlZCBvciByZW1vdmUsXG4gIC8vIGxldCdzIG1ha2Ugc3VyZSB0aGUgd2F0Y2hlciBpcyBydW5uaW5nIGlmIHRoZXJlIGlzIGFueSBvYnNlcnZlci5cbiAgLy8gYW5kIGxldCdzIHR1cm4gb2ZmIHRoZSBjb2xsZWN0aW9uIG9mIHN0YXRzIGlmIHRoZSBzZXQgb2Ygb2JzZXJ2ZXJzIGlzIGVtcHR5LlxuICBfb25PYnNlcnZlckNoYW5nZSgpIHtcbiAgICBjb25zdCBJTlRFUlZBTCA9IDEwMDA7XG5cbiAgICB0aGlzLl9wcmV2U3RhdHMgPSBbXTtcbiAgICAvLyBzb21lIG9ic2VydmVycywgdGhlbiBtYWtlIHN1cmUgd2UgcnVuXG4gICAgaWYgKHRoaXMuX29ic2VydmVycy5zaXplID4gMCkge1xuICAgICAgaWYgKCF0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgICBzZXRJbnRlcnZhbChhc3luYyAoaGFuZGxlcjogYW55LCB0aW1lb3V0OiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHRoaXMuX3JhdmlJbXBsZW1lbnRhdGlvbi5fZ2V0U3RhdHMoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBsZXQgZmlsdGVyZWRTdGF0czphbnkgPSBbXTtcbiAgICAgICAgICBpZiAoc3RhdHMpIHtcbiAgICAgICAgICAgIHN0YXRzLmZvckVhY2goKHJlcG9ydDogYW55KSA9PiB7XG4gICAgICAgICAgICAgIC8vIEZpbHRlciBvbiB0aGUgcmVwb3J0IHR5cGVcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbHRlci5oYXMocmVwb3J0LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0ZWQgZmllbGRzIG11c3QgYmUgYSB2YWxpZCBhcnJheSBvZiBmaWVsZHM6XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkRmllbGRzID0gdGhpcy5fZmlsdGVyLmdldChyZXBvcnQudHlwZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gVGhlbiB3aXRoaW4gdGhlIHJlcG9ydCB0eXBlLCBwaWNrIG9uIHRoZSB3YW50ZWQgZmllbGRzXG4gICAgICAgICAgICAgICAgbGV0IGZpbHRlcmVkUmVwb3J0OiBhbnkgPSB7fTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEZpZWxkcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkUmVwb3J0W2tleV0gPSByZXBvcnRba2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZmlsdGVyZWQgcmVwb3J0IGZvdW5kIGluIHRoZSByZXN1bHQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRTdGF0cy5wdXNoKGZpbHRlcmVkUmVwb3J0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFN0YXRzIGhhdmUgYmVlbiBjb2xsZWN0ZWQsIG5vdyBsZXQncyBicm9hZGNhc3RcbiAgICAgICAgICBpZiAoZmlsdGVyZWRTdGF0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVycy5mb3JFYWNoICgob2JzZXJ2ZXIpPT57XG4gICAgICAgICAgICAgIG9ic2VydmVyKGZpbHRlcmVkU3RhdHMsIHRoaXMuX3ByZXZTdGF0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZWNvcmQgdGhlIHByb2R1Y2VkIHN0YXRzIGFzIHRoZSBtb3N0IHJlY2VudCBvbmVcbiAgICAgICAgICB0aGlzLl9wcmV2U3RhdHMgPSBmaWx0ZXJlZFN0YXRzO1xuICAgICAgICB9LCBJTlRFUlZBTCApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyBvYnNlcnZlcnMsIG1ha2Ugc3VyZSB3ZSBhcmUgc3RvcHBlZFxuICAgICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKlxuVE9ETzogQWRkIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYSBSQVZJIFBlZXIgQ29ubmVjdGlvbiBcImNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb25cIlxuY2xhc3Mgc2hvdWxkIGxvb2sgbGlrZS4gU29tZSBpbml0aWFsIG5vdGVzOlxuQ29uc3RydWN0b3I6IFRha2VzIGluIGEgUmF2aVNlc3Npb24gc28gdGhhdCBpdCBjYW4gdXNlIGl0cyBoYW5kbGVycy4gVGhlIGltcGxlbWVudGF0aW9uIGNsYXNzXG5pcyBleHBlY3RlZCB0byBhc3NpZ24gdGhlIFJhdmlTZXNzaW9uJ3MgX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBzdGF0ZSkgXG5oYW5kbGVyIHRvIGFueSBhcHByb3ByaWF0ZSBldmVudHMgdGhyb3duIGJ5IGl0cyBpbXBsZW1lbnRhdGlvbiBcbihhbmQvb3IgdGhyb3duIGJ5IGl0c2VsZikuXG5TaW1pbGFybHksIGl0IGlzIGV4cGVjdGVkIHRvIGNhbGwgdGhlIHBhcmVudCdzIF9kb09uZGF0YWNoYW5uZWwgYW5kIF9kb09udHJhY2tcbm1ldGhvZHMgd2hlbiBpdCBoYXMgZGF0YSBjaGFubmVsIGFuZCB0cmFjayBjaGFubmVscyByZWFkeS5cbiAgRXhwZWN0ZWQgbWV0aG9kczpcbiAgY29uc3RydWN0b3IocmF2aVNlc3Npb24pO1xuICBfYXNzaWduU2lnbmFsaW5nQ29ubmVjdGlvbigpO1xuICBfYWRkQXVkaW9JbnB1dFN0cmVhbShpbnB1dFN0cmVhbSk7XG4gIF9hZGRWaWRlb0lucHV0U3RyZWFtKGlucHV0U3RyZWFtKTtcbiAgX29wZW4oKTsgXG4gIF9jbG9zZSgpO1xuKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFVzZSB0aGUgY29ycmVjdCBjbGFzc2VzIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIGJlaW5nIFxuICogY2FsbGVkIGZyb20gbm9kZSBvciB0aGUgYnJvd3Nlci5cbiAqL1xubGV0IGNyb3NzUGxhdGZvcm1SVENQZWVyQ29ubmVjdGlvbjphbnkgPSBudWxsO1xubGV0IGNyb3NzUGxhdGZvcm1SVENTZXNzaW9uRGVzY3JpcHRpb246YW55ID0gbnVsbDtcbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gbm9kZSBjb250ZXh0XG4gIGNyb3NzUGxhdGZvcm1SVENQZWVyQ29ubmVjdGlvbiA9IHJlcXVpcmUoJ3dydGMnKS5SVENQZWVyQ29ubmVjdGlvbjtcbiAgY3Jvc3NQbGF0Zm9ybVJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IHJlcXVpcmUoJ3dydGMnKS5SVENTZXNzaW9uRGVzY3JpcHRpb247XG59IGVsc2Uge1xuICAvLyBicm93c2VyIGNvbnRleHRcbiAgY3Jvc3NQbGF0Zm9ybVJUQ1BlZXJDb25uZWN0aW9uID0gUlRDUGVlckNvbm5lY3Rpb247XG4gIGNyb3NzUGxhdGZvcm1SVENTZXNzaW9uRGVzY3JpcHRpb24gPSBSVENTZXNzaW9uRGVzY3JpcHRpb247XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBDb25zdGFudHMgdXNlZCBkdXJpbmcgc2Vzc2lvbiBuZWdvdGlhdGlvblxuICovXG5jb25zdCBERUZBVUxUX1NUVU5fQ09ORklHID0ge1xuICAndXJscyc6IFsnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMiddXG59O1xuY29uc3QgTEVHQUNZX1RVUk5fQ09ORklHID0ge1xuICAndXJscyc6IFsndHVybjp0dXJuLmhpZ2hmaWRlbGl0eS5jb206MzQ3OCddLFxuICAndXNlcm5hbWUnOiAnY2xvdWR1c2VyJyxcbiAgJ2NyZWRlbnRpYWwnOiAnY2hhcmlvdC10cmF2ZXN0eS1ob29rJ1xufTtcbmxldCBwZWVyQ29ubmVjdGlvbkNvbmZpZyA9IHtcbiAgJ2ljZVNlcnZlcnMnOiBbXG4gICAgREVGQVVMVF9TVFVOX0NPTkZJRyxcbiAgICBMRUdBQ1lfVFVSTl9DT05GSUdcbiAgXVxufTtcblxuLyoqIFxuICogQGludGVybmFsXG4gKiBBIFdlYlJUQyBpbXBsZW1lbnRhdGlvbiBmb3IgYSBSQVZJIHBlZXIgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uIHtcbiAgX3JhdmlTZXNzaW9uOiBSYXZpU2Vzc2lvbjtcbiAgX25lZ290aWF0b3I6IGFueTtcbiAgX3N0YXRzV2F0Y2hlcjogUmF2aVdlYlJUQ1N0YXRzV2F0Y2hlcjtcbiAgX3J0Y0Nvbm5lY3Rpb246IHR5cGVvZiBjcm9zc1BsYXRmb3JtUlRDUGVlckNvbm5lY3Rpb247XG4gIF9yYXZpQXVkaW9TZW5kZXJzOiBhbnk7XG4gIF9yYXZpVmlkZW9TZW5kZXJzOiBhbnk7XG4gIF9zaWduYWxpbmdDb25uZWN0aW9uOiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgX2N1c3RvbVN0dW5BbmRUdXJuOiBDdXN0b21TVFVOYW5kVFVSTkNvbmZpZztcbiAgXG4gIC8vIE5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgaW5wdXQgc3RyZWFtcyBpbiBjYXNlIHRoZXkgZ2V0IHNldFxuICAvLyBiZWZvcmUgdGhlIGFjdHVhbCBSVEMgY29ubmVjdGlvbiBpcyBhdmFpbGFibGUuXG4gIF9hdWRpb0lucHV0U3RyZWFtOiBNZWRpYVN0cmVhbTtcbiAgX3ZpZGVvSW5wdXRTdHJlYW06IE1lZGlhU3RyZWFtO1xuICBfc2hvcnRDaXJjdWl0SGFuZGxlcjogRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFwiQ2xhc3NcIiB2YXJpYWJsZXMgdG8gYmUgYXdhcmUgb2Y6XG4gICAqIHRoaXMuX3J0Y0Nvbm5lY3Rpb24gICAgICAgLy8gVGhlIGFjdHVhbCBSVENQZWVyQ29ubmVjdGlvblxuICAgKiB0aGlzLl9yYXZpU2Vzc2lvbiAgICAgICAgIC8vIFRoZSBcIm93bmluZ1wiIFJhdmlTZXNzaW9uXG4gICAqIHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24gLy8gQSBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHdoZW4gbmVnb3RpYXRpbmcgdGhlIHNlc3Npb25cbiAgICogdGhpcy5fbmVnb3RpYXRvciAgICAgICAgICAvLyBBIGJvdW5kIHZlcnNpb24gb2YgdGhlIGNvbm5lY3Rpb24gc2V0dXAgbWV0aG9kIHRoYXQgY2FuIGJlIHVzZWQgZm9yIG1lc3NhZ2UgaGFuZGxpbmdcbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn0gcmF2aVNlc3Npb24gVGhlIG93bmVyIG9mIHRoaXMgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocmF2aVNlc3Npb246IFJhdmlTZXNzaW9uKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgIHRoaXMuX3JhdmlTZXNzaW9uID0gcmF2aVNlc3Npb247XG4gICAgdGhpcy5fbmVnb3RpYXRvciA9IHRoaXMuX3NldHVwQ29ubmVjdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3N0YXRzV2F0Y2hlciA9IG5ldyBSYXZpV2ViUlRDU3RhdHNXYXRjaGVyKHRoaXMpO1xuICAgIHRoaXMuX3JhdmlBdWRpb1NlbmRlcnMgPSBbXTtcbiAgICB0aGlzLl9yYXZpVmlkZW9TZW5kZXJzID0gW107XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBSVEMgY29ubmVjdGlvbiB0byBhIG5ldyBmcmVzaCBvbmUuIFRoaXMgZ2V0cyBjYWxsZWQgb25jZSB3ZVxuICAgKiBoYXZlIHJlY2VpdmVkIHRoZSBpbml0aWFsIFNEUCBmcm9tIHRoZSBzZXJ2ZXIgKHNvIHRoYXQgd2UgY2FuIGF0dGFjaFxuICAgKiBkeW5hbWljIFRVUk4gaW5mb3JtYXRpb24gdG8gaXQgd2hlbiBpdCdzIGNyZWF0ZWQsIGFzIG5lZWRlZCkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdFJ0Y0Nvbm5lY3Rpb24oKSB7XG4gICAgY29uc3QgcmF2aVNlc3Npb24gPSB0aGlzLl9yYXZpU2Vzc2lvbjtcbiAgICBjb25zdCBzZXNzaW9uSW1wbGVtZW50YXRpb24gPSB0aGlzO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIG5ldyBSVEMgY29ubmVjdGlvbiAoZm9yIG5vZGUgb3IgdGhlIGJyb3dzZXIpXG4gICAgdGhpcy5fcnRjQ29ubmVjdGlvbiA9IG5ldyBjcm9zc1BsYXRmb3JtUlRDUGVlckNvbm5lY3Rpb24ocGVlckNvbm5lY3Rpb25Db25maWcpO1xuICAgIGNvbnN0IHJ0Y0Nvbm5lY3Rpb24gPSB0aGlzLl9ydGNDb25uZWN0aW9uO1xuICAgIFxuICAgIC8vIENsZWFyIG91dCBhbnkgb2xkIHRyYWNrIHNlbmRlcnNcbiAgICBsZXQgc2VuZGVycyA9IHJ0Y0Nvbm5lY3Rpb24uZ2V0U2VuZGVycygpO1xuICAgIHNlbmRlcnMuZm9yRWFjaCgoc2VuZGVyOiBhbnkpID0+IHtcbiAgICAgIHNlbmRlci5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgfSk7XG4gICAgdGhpcy5fcmF2aUF1ZGlvU2VuZGVycyA9IFtdO1xuICAgIHRoaXMuX3JhdmlWaWRlb1NlbmRlcnMgPSBbXTtcbiAgICBcbiAgICAvLyBUaGlzIG5ldyBSVENDb25uZWN0aW9uJ3Mgc3RhdGUgY2hhbmdlIGV2ZW50cyB3aWxsIGp1c3RcbiAgICAvLyBjYWxsIGJhY2sgdXAgdG8gdGhlIG1haW4gUmF2aVNlc3Npb24ncyBcbiAgICAvLyBzdGF0ZUNoYW5nZUhhbmRsZXJzLlxuICAgIC8vIE5PVEU6IFRha2UgYSBsb29rIGF0IEJJR1dPUkxELTEwNjIgYW5kIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1BlZXJDb25uZWN0aW9uI1JUQ0ljZUNvbm5lY3Rpb25TdGF0ZV9lbnVtXG4gICAgLy8gYW5kXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1BlZXJDb25uZWN0aW9uI1JUQ1BlZXJDb25uZWN0aW9uU3RhdGVfZW51bVxuICAgIC8vIHRvIHNlZSB3aHkgd2UncmUgbGlzdGVuaW5nIG9uIGljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSBpbnN0ZWFkIG9mIHBlZXJjb25uZWN0aW9uc3RhdGVjaGFuZ2VcbiAgICBydGNDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgXG4gICAgICBpZiAocnRjQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUgPT09IFwiY29ubmVjdGVkXCIgfHwgcnRjQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUgPT0gXCJjb21wbGV0ZWRcIikge1xuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2Vzc2lvbiBoYXMgZnVsbHkgY29ubmVjdGVkOyByZW1vdmluZyBzaG9ydC1jaXJjdWl0IGhhbmRsZXJcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIHNlc3Npb25JbXBsZW1lbnRhdGlvbi5fc2lnbmFsaW5nQ29ubmVjdGlvbi5yZW1vdmVTdGF0ZUNoYW5nZUhhbmRsZXIoc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9zaG9ydENpcmN1aXRIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHJhdmlTZXNzaW9uLl9oYW5kbGVTdGF0ZUNoYW5nZShldmVudCwgcnRjQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUpOyBcbiAgICB9KTtcblxuICAgIC8vIFNpbWlsaWFybHksIGxpc3RlbiBhdCB0aGUgUmF2aVNlc3Npb24gbGV2ZWwgZm9yIHRyYWNrIGFuZCBkYXRhIGNoYW5uZWwgZXZlbnRzXG4gICAgcnRjQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdkYXRhY2hhbm5lbCcsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgcmF2aVNlc3Npb24uX2RvT25kYXRhY2hhbm5lbChldmVudCk7IH0pO1xuICAgIHJ0Y0Nvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCBmdW5jdGlvbihldmVudDogYW55KSB7IHJhdmlTZXNzaW9uLl9kb09udHJhY2soZXZlbnQpOyB9KTtcblxuICAgIC8vIEhvd2V2ZXIsIHdlIG5lZWQgdG8gbGlzdGVuIGF0IG91ciBvd24gUlRDIGltcGxlbWVudGF0aW9uIGxldmVsIGZvciBpY2UgY2FuZGlkYXRlIGV2ZW50cywgXG4gICAgLy8gYmVjYXVzZSB0aGV5J3JlIHBhcnQgb2YgdGhlIHNlc3Npb24gbmVnb3RpYXRpb25cbiAgICBydGNDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9kb09uaWNlY2FuZGlkYXRlKGV2ZW50KTsgfSk7XG5cbiAgICAvLyBXaGVuIGEgbmVnb3RpYXRpb25uZWVlZGVkIGlzIHRyaWdnZXJlZCBmcm9tIHRoaXMgcGVlciwgc2lnbmFsIHRoZSBzZXJ2ZXIgc2lkZSB0byBpbml0aWF0ZSBhbiBvZmZlclxuICAgIC8vIEluIFJhdmksIHRoZSB3ZWJydGMgbmVnb3RpYXRpb24gaXMgYWx3YXlzIGluaXRpYXRlZCBmcm9tIHRoZSBzZXJ2ZXIgc2lkZVxuICAgIHJ0Y0Nvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignbmVnb3RpYXRpb25uZWVkZWQnLCBmdW5jdGlvbihldmVudDogYW55KSB7IHNlc3Npb25JbXBsZW1lbnRhdGlvbi5fZG9Pbm5lZ290aWF0aW9ubmVlZGVkKGV2ZW50KTsgfSk7XG5cbiAgICAvLyBXYXRjaCB0aGUgc2lnbmFsaW5nIHN0YXRlIGNoYW5nZXMgZm9yIGRlYnVnLlxuICAgIHJ0Y0Nvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcInNpZ25hbGluZ3N0YXRlY2hhbmdlXCIsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9kb09uc2lnbmFsaW5nc3RhdGVjaGFuZ2VkKGV2ZW50KTsgfSk7XG5cbiAgfVxuICBcbiAgLyoqXG4gICAqIFRlbGwgdGhpcyBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24gd2hhdCBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiB0byB1c2UuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgb3duaW5nIFJhdmlTZXNzaW9uLiBcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2Fzc2lnblNpZ25hbGluZ0Nvbm5lY3Rpb24oc2lnbmFsaW5nQ29ubmVjdGlvbjogUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24pIHtcbiAgICB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uID0gc2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEFkZCBhbiBpbnB1dCBzdHJlYW0gdG8gdGhpcyBjb25uZWN0aW9uLiAoVGhpcyBjYW4gYmUgZG9uZSBhdFxuICAgKiBhbnkgcG9pbnQgZHVyaW5nIHRoZSBjb25uZWN0aW9uLCB3aGljaCBpcyB3aHkgaXQncyBhIHNlcGFyYXRlIG1ldGhvZC4pXG4gICAqIFxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG93bmluZyBSYXZpU2Vzc2lvbiB3aGVuIGl0cyBzdHJlYW0gY29udHJvbGxlclxuICAgKiBnZXRzIGFuIGlucHV0IHN0cmVhbS4gXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9hZGRBdWRpb0lucHV0U3RyZWFtKHN0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICBjb25zdCBydGNDb25uZWN0aW9uID0gdGhpcy5fcnRjQ29ubmVjdGlvbjtcbiAgICBjb25zdCBzZXNzaW9uSW1wbGVtZW50YXRpb24gPSB0aGlzO1xuICAgIHZhciByZXR2YWwgPSBmYWxzZTtcblxuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIHRoaXMuX2F1ZGlvSW5wdXRTdHJlYW0gPSBzdHJlYW07XG4gICAgICBpZiAoISBydGNDb25uZWN0aW9uKSB7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJTZXR0aW5nIGF1ZGlvIGlucHV0IHN0cmVhbSB3aXRob3V0IGF2YWlsYWJsZSBSVEMgY29ubmVjdGlvbjsgd2lsbCBzdG9yZSBpdCB1bnRpbCByZWFkeVwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGtlZXAgdHJhY2sgb2YgdGhlIHNlbmRlcnMgdGhhdCB3ZSBpbnRlcmFjdCB3aXRoXG4gICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gdGhlIGxpc3Qgb2Ygc2VuZGVycyBvbiB0aGUgUlRDIGNvbm5lY3Rpb24sXG4gICAgICAvLyBiZWNhdXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlJ3JlIG9ubHkgd29ya2luZyB3aXRoIFxuICAgICAgLy8gc2VuZGVycyB0aGF0IG1hdGNoIG91ciBvd24gcGFyYW1ldGVycy5cbiAgICAgIGNvbnN0IGN1cnJlbnRTZW5kZXJzID0gdGhpcy5fcmF2aUF1ZGlvU2VuZGVycztcbiAgICAgIFxuICAgICAgLy8gTGlzdCBvZiBuZXcgdHJhY2tzIGluIHRoZSBwYXNzZWQgc3RyZWFtXG4gICAgICBjb25zdCBuZXdBdWRpb1RyYWNrcyA9IHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgICAgY29uc3QgbnVtTmV3VHJhY2tzID0gbmV3QXVkaW9UcmFja3MubGVuZ3RoO1xuXG4gICAgICBsZXQgaT0wO1xuICAgICAgZm9yIChpOyBpIDwgY3VycmVudFNlbmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRm9yIGVhY2ggb2YgdGhlIHRyYWNrcyB0aGF0IHdlIGFscmVhZHkga25vdyBhYm91dCxcbiAgICAgICAgLy8gcmVwbGFjZSB0aGVtIHdpdGggYSB0cmFjayBmcm9tIHRoZSBuZXcgc3RyZWFtLlxuICAgICAgICAvLyAoTm90ZTogdGhpcyBzZWVtcyB0byBhZGQgYSBsaXR0bGUgbGF0ZW5jeSB3aGVuIGl0IGdldHMgY2FsbGVkLFxuICAgICAgICAvLyBidXQgb24gdGhlIHBsdXMgc2lkZSwgZG9lcyBub3QgdHJpZ2dlciBhIHJlbmVnb3RpYXRpb24uIFRoZSBsYXRlbmN5XG4gICAgICAgIC8vIHRlbmRzIHRvIGRpc3NpcGF0ZSBvdmVyIHRpbWUuKVxuICAgICAgICBpZiAoaSA8IG51bU5ld1RyYWNrcykge1xuICAgICAgICAgIFJhdmlVdGlscy5sb2coXCJSZXBsYWNpbmcgYXVkaW8gdHJhY2sgI1wiICsgaSArIFwiICBpbiBydGNDb25uZWN0aW9uXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAgIGN1cnJlbnRTZW5kZXJzW2ldLnJlcGxhY2VUcmFjayhuZXdBdWRpb1RyYWNrc1tpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgdHJhY2tzIGluIHRoZSBvbGQgc3RyZWFtIHRoYW5cbiAgICAgICAgICAvLyBpbiB0aGUgbmV3IG9uZSwgc2V0IHRoZSBleHRyYXMgdG8gbnVsbCBcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2V0dGluZyBhdWRpbyBzZW5kZXIgI1wiICsgaSArIFwiIHRvIG51bGxcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgICAgY3VycmVudFNlbmRlcnNbaV0ucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIHRyYWNrcyBpbiB0aGUgbmV3IHN0cmVhbSB0aGVuXG4gICAgICAvLyBpbiB0aGUgb2xkLCBhZGQgdGhlbVxuICAgICAgZm9yIChpOyBpIDwgbnVtTmV3VHJhY2tzOyBpKyspIHtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIkFkZGluZyBsb2NhbCBhdWRpbyB0cmFjayAjXCIgKyBpICsgXCIgdG8gcnRjQ29ubmVjdGlvblwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgY3VycmVudFNlbmRlcnMucHVzaChydGNDb25uZWN0aW9uLmFkZFRyYWNrKG5ld0F1ZGlvVHJhY2tzW2ldLCBzdHJlYW0pKTtcbiAgICAgICAgLy8gV2UgZXhwZWN0IHRoZSAnbmVnb3RpYXRpb25uZWVkZWQnIGV2ZW50IHRvIGZpcmVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgc3RyZWFtIGFzc2lnbmVkIGlzIG51bGwgbWVhbmluZyB3ZSB3YW50IHRvIGtpbGwgYW55IGlucHV0IGF1ZGlvIHN0cmVhbVxuICAgICAgICBjb25zdCBjdXJyZW50U2VuZGVycyA9IHRoaXMuX3JhdmlBdWRpb1NlbmRlcnM7XG5cbiAgICAgICAgLy8gc2ltcGx5IHNldCBhbGwgdGhlIGV4aXN0aW5nIHNlbmRlcnMgdG8gbnVsbCB0cmFjay5cbiAgICAgICAgbGV0IGk9MDtcbiAgICAgICAgZm9yIChpOyBpIDwgY3VycmVudFNlbmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2V0dGluZyBhdWRpbyBzZW5kZXIgI1wiICsgaSArIFwiIHRvIG51bGxcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgICAgY3VycmVudFNlbmRlcnNbaV0ucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR2YWw7XG4gIH1cblxuICBfYWRkVmlkZW9JbnB1dFN0cmVhbShzdHJlYW06IE1lZGlhU3RyZWFtKSB7XG4gICAgY29uc3QgcnRjQ29ubmVjdGlvbiA9IHRoaXMuX3J0Y0Nvbm5lY3Rpb247XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHJldHZhbCA9IGZhbHNlO1xuXG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgdGhpcy5fdmlkZW9JbnB1dFN0cmVhbSA9IHN0cmVhbTtcbiAgICAgIGlmICghIHJ0Y0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNldHRpbmcgdmlkZW8gaW5wdXQgc3RyZWFtIHdpdGhvdXQgYXZhaWxhYmxlIFJUQyBjb25uZWN0aW9uOyB3aWxsIHN0b3JlIGl0IHVudGlsIHJlYWR5XCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2Uga2VlcCB0cmFjayBvZiB0aGUgc2VuZGVycyB0aGF0IHdlIGludGVyYWN0IHdpdGhcbiAgICAgIC8vIHNlcGFyYXRlbHkgZnJvbSB0aGUgbGlzdCBvZiBzZW5kZXJzIG9uIHRoZSBSVEMgY29ubmVjdGlvbixcbiAgICAgIC8vIGJlY2F1c2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UncmUgb25seSB3b3JraW5nIHdpdGggXG4gICAgICAvLyBzZW5kZXJzIHRoYXQgbWF0Y2ggb3VyIG93biBwYXJhbWV0ZXJzLlxuICAgICAgY29uc3QgY3VycmVudFNlbmRlcnMgPSB0aGlzLl9yYXZpVmlkZW9TZW5kZXJzO1xuICAgICAgXG4gICAgICAvLyBMaXN0IG9mIG5ldyB0cmFja3MgaW4gdGhlIHBhc3NlZCBzdHJlYW1cbiAgICAgIGNvbnN0IG5ld1ZpZGVvVHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICBjb25zdCBudW1OZXdUcmFja3MgPSBuZXdWaWRlb1RyYWNrcy5sZW5ndGg7XG4gICAgICBcbiAgICAgIC8vIEF0IHRoZSBtb21lbnQsIHJhdmkgY2xpZW50IHNlc3Npb24gb25seSBzdXBwb3J0IG9uZSBvdXRib3VuZCB2aWRlbyB0cmFja1xuICAgICAgaWYgKG51bU5ld1RyYWNrcyA+IDApIHtcbiAgICAgICAgLy8gSWYgY3VycmVudCB2aWRlbyBzZW5kZXIgZXhpc3RzIGFscmVhZHksIGp1c3QgcmVwbGFjZSB0cmFja1xuICAgICAgICBpZiAoY3VycmVudFNlbmRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIFJhdmlVdGlscy5sb2coXCJSZXBsYWNpbmcgdmlkZW8gdHJhY2sgIzAgaW4gcnRjQ29ubmVjdGlvblwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgICBjdXJyZW50U2VuZGVyc1swXS5yZXBsYWNlVHJhY2sobmV3VmlkZW9UcmFja3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVsc2UganVzdCBhZGQgdGhlIG5ldyB0cmFjayB0byB0aGUgUGVlckNvbm5lY3Rpb24uXG4gICAgICAgICAgUmF2aVV0aWxzLmxvZyhcIkFkZGluZyB2aWRlbyB0cmFjayAjMCB0byBydGNDb25uZWN0aW9uXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAgIGN1cnJlbnRTZW5kZXJzLnB1c2gocnRjQ29ubmVjdGlvbi5hZGRUcmFjayhuZXdWaWRlb1RyYWNrc1swXSkpO1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCB0aGUgJ25lZ290aWF0aW9ubmVlZGVkJyBldmVudCB0byBmaXJlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dmFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJBc3NpZ25lZCB2aWRlbyBzdHJlYW0gZG9lc24ndCBjb250YWluIHZpZG9lIHRyYWNrXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgfSAgICAgICAgICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlIHN0cmVhbSBhc3NpZ25lZCBpcyBudWxsIG1lYW5pbmcgd2Ugd2FudCB0byBraWxsIGFueSBpbnB1dCB2aWRlbyBzdHJlYW1cbiAgICAgIGNvbnN0IGN1cnJlbnRTZW5kZXJzID0gdGhpcy5fcmF2aVZpZGVvU2VuZGVycztcblxuICAgICAgLy8gc2ltcGx5IHNldCBhbGwgdGhlIGV4aXN0aW5nIHNlbmRlcnMgdG8gbnVsbCB0cmFjay5cbiAgICAgIGxldCBpPTA7XG4gICAgICBmb3IgKGk7IGkgPCBjdXJyZW50U2VuZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2V0dGluZyB2aWRlbyBzZW5kZXIgI1wiICsgaSArIFwiIHRvIG51bGxcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIGN1cnJlbnRTZW5kZXJzW2ldLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIGEgc2Vzc2lvbi4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIHRoaXMgYnkgYWRkaW5nIGEgaGFuZGxlciB0byB0aGUgc2lnbmFsaW5nQ29ubmVjdGlvblxuICAgKiB0aGF0IHdpbGwgbGlzdGVuIGZvciBcInJlYWR5IHRvIG5lZ290aWF0ZSBjb25uZWN0aW9uXCIgbWVzc2FnZXMgc28gdGhhdCB0aGUgXG4gICAqIF9zZXR1cENvbm5lY3Rpb24gbWV0aG9kIGNhbiB0aGVuIG5lZ290aWF0ZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBvd25pbmcgUmF2aVNlc3Npb24uIFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb3BlbihwYXJhbXM6IFdlYlJUQ1Nlc3Npb25QYXJhbXMsIGN1c3RvbVN0dW5BbmRUdXJuOiBDdXN0b21TVFVOYW5kVFVSTkNvbmZpZykge1xuICAgIFJhdmlVdGlscy5sb2coXCJBdHRlbXB0aW5nIHRvIG9wZW4gY29ubmVjdGlvbi4uLlwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICB0aGlzLl9jdXN0b21TdHVuQW5kVHVybiA9IGN1c3RvbVN0dW5BbmRUdXJuO1xuICAgIGlmICh0aGlzLl9ydGNDb25uZWN0aW9uXG4gICAgICAgICYmICh0aGlzLl9ydGNDb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PSAnY29ubmVjdGluZydcbiAgICAgICAgICAgIHx8IHRoaXMuX3J0Y0Nvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlID09ICdjb25uZWN0ZWQnKSlcbiAgICB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiV2UgYWxyZWFkeSBoYXZlIGEgY29ubmVjdGlvbiBpbiBwcm9ncmVzcy4gV2lsbCBub3QgYXR0ZW1wdCBhIG5ldyBvbmUuXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgLy8gVHJpZ2dlciBzdGF0ZSBjaGFuZ2UgaGFuZGxlciBvbiB0aGUgb3duaW5nIHNlc3Npb24gdG8gZmluYWxpemUgYW55IFxuICAgICAgLy8gcmVzaWR1YWwgUHJvbWlzZXNcbiAgICAgIHRoaXMuX3JhdmlTZXNzaW9uLl9oYW5kbGVTdGF0ZUNoYW5nZSh7XCJzdGF0ZVwiOnRoaXMuX3J0Y0Nvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlfSwgdGhpcy5fcnRjQ29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUpOyBcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2lnbmFsaW5nQ29ubmVjdGlvbikge1xuICAgICAgLy8gQWRkIGEgaGFuZGxlciBmb3Igc3RhdGUgY2hhbmdlIGV2ZW50cyBvbnRvIHRoZSBwcm92aWRlZFxuICAgICAgLy8gc2lnbmFsaW5nIGNvbm5lY3Rpb24uIFRoaXMgc2hvdWxkIGxpc3RlbiBmb3IgdGhlIGFwcHJvcHJpYXRlIFxuICAgICAgLy8gXCJyZWFkeSB0byBuZWdvdGlhdGUgY29ubmVjdGlvblwiIG1lc3NhZ2UgZnJvbSB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24uXG4gICAgICB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uLmFkZE1lc3NhZ2VIYW5kbGVyKHRoaXMuX25lZ290aWF0b3IpO1xuICAgICAgXG4gICAgICAvLyBBZGQgYSBzdGF0ZSBjaGFuZ2UgaGFuZGxlciB0byB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24uIElmIHRoZVxuICAgICAgLy8gY29ubmVjdGlvbiBjbG9zZXMgb3IgZmFpbHMgX3doaWxlIHdlJ3JlIGluIHRoZSBwcm9jZXNzIG9mIG5lZ290aWF0aW5nXG4gICAgICAvLyB0aGUgY29ubmVjdGlvbl8gKGkuZS4gYmVmb3JlIHRoZSBjb25uZWN0aW9uIGlzIGZ1bGx5IG9wZW4pLCB3ZSBzaG91bGQgc3RvcCB0cnlpbmcuXG4gICAgICAvLyBXZSByZW1vdmUgdGhpcyBoYW5kbGVyIG9uY2UgdGhlIFdlYlJUQyBjb25uZWN0aW9uIGlzIGZ1bGx5IG9wZW4sIGJlY2F1c2UgaWYgdGhlIFxuICAgICAgLy8gc2lnbmFsaW5nIGNvbm5lY3Rpb24gY2xvc2VzIF9hZnRlcl8gd2UndmUgZ290IGEgc3RhYmxlIGNvbm5lY3Rpb24sIHdlIHdhbnQgdG9cbiAgICAgIC8vIGxlYXZlIG91ciB3ZWJydGMgY29ubmVjdGlvbiBvcGVuIGFzIGxvbmcgYXMgcG9zc2libGUuXG4gICAgICB0aGlzLl9zaG9ydENpcmN1aXRIYW5kbGVyID0gdGhpcy5fY2FuY2VsT3BlbmluZ1Byb2Nlc3NPblNpZ25hbGluZ0Rpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24uYWRkU3RhdGVDaGFuZ2VIYW5kbGVyKHRoaXMuX3Nob3J0Q2lyY3VpdEhhbmRsZXIpO1xuXG4gICAgICAvLyBTZW5kIHRoZSBtYWdpYyBzdHJpbmcgZm9yIG9wZW5pbmcgYSBjb25uZWN0aW9uLlxuICAgICAgLy8gd2l0aCBwYXJhbXMgZXZlbnR1YWxseVxuICAgICAgbGV0IG1lc3NhZ2U6IGFueSA9IHt9O1xuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgIG1lc3NhZ2UgPSBwYXJhbXM7XG4gICAgICAgICAgbWVzc2FnZVtcInNlc3Npb25JRFwiXSA9IHRoaXMuX3JhdmlTZXNzaW9uLmdldFVVSUQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVzc2FnZSA9IHRoaXMuX3JhdmlTZXNzaW9uLmdldFVVSUQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2lnbmFsaW5nQ29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KHsncmVxdWVzdCc6IG1lc3NhZ2V9KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBhIHNlc3Npb24gdGhhdCdzIGluIHRoZSBwcm9jZXNzIG9mIGJlaW5nIG9wZW5lZC4gVGhpcyBnZXRzIGNhbGxlZCBpZlxuICAgKiB3ZSByZWNlaXZlIGEgc3RhdGUgY2hhbmdlIGZyb20gdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uIGFmdGVyIHRoZSBcIm9wZW5cIiBoYXMgYWxyZWFkeVxuICAgKiBiZWVuIGNhbGxlZC4gSWYgc28gKGFuZCBpZiB0aGF0IHN0YXRlIGNoYW5nZSBpcyBhbiBlcnJvci9jbG9zZSksIHdlIHNob3J0LWNpcmN1aXRcbiAgICogdGhlIHByb2Nlc3Mgb2Ygb3BlbmluZyB0aGUgc2Vzc2lvbiBhbmQgY2xvc2Ugb3V0IGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBUaGlzIGhhbmRsZXIgaXMgYWRkZWQgYnkgdGhlIF9vcGVuKCkgbWV0aG9kIGFuZCByZW1vdmVkIHdoZW4gZWl0aGVyIHRoZSBjb25uZWN0aW9uIGlzXG4gICAqIGNvbm5lY3RlZCBvciB3aGVuIHRoZSBfY2xvc2UoKSBtZXRob2QgaXMgY2FsbGVkLCB3aGljaGV2ZXIgY29tZXMgZmlyc3QuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9jYW5jZWxPcGVuaW5nUHJvY2Vzc09uU2lnbmFsaW5nRGlzY29ubmVjdCAoZXZlbnQ6IGFueSkge1xuICAgIGxldCBzdGF0ZSA9IGV2ZW50LnN0YXRlIHx8IFwidW5rbm93blwiO1xuICAgIGNvbnN0IHJhdmlTZXNzaW9uID0gdGhpcy5fcmF2aVNlc3Npb247XG4gICAgc3dpdGNoKHN0YXRlKSB7XG4gICAgICBjYXNlIFJhdmlTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEOlxuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2lnbmFsaW5nIHN0YXRlIGNsb3NlZCBiZWZvcmUgc2Vzc2lvbiB3YXMgZXN0YWJsaXNoZWQ7IGNsb3NpbmcgUmF2aVNlc3Npb25cIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIHJhdmlTZXNzaW9uLl9oYW5kbGVTdGF0ZUNoYW5nZShldmVudCwgUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VEKTtcbiAgICAgICAgLy8gQ2FsbCBfY2xvc2UgdG8gY2xlYW4gdXAgYWZ0ZXIgb3Vyc2VsdmVzXG4gICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2lnbmFsaW5nU3RhdGVzLkVSUk9SOlxuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2lnbmFsaW5nIHN0YXRlIGVycm9yZWQgb3V0IGJlZm9yZSBzZXNzaW9uIHdhcyBlc3RhYmxpc2hlZDsgY2xvc2luZyBSYXZpU2Vzc2lvblwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgcmF2aVNlc3Npb24uX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBSYXZpU2Vzc2lvblN0YXRlcy5GQUlMRUQpO1xuICAgICAgICB0aGlzLl9jbG9zZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUmF2aVNpZ25hbGluZ1N0YXRlcy5VTkFWQUlMQUJMRTpcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNpZ25hbGluZyBzdGF0ZSByZWFjaGVkICd1bmF2YWlsYWJsZScgYmVmb3JlIHNlc3Npb24gd2FzIGVzdGFibGlzaGVkOyBjbG9zaW5nIFJhdmlTZXNzaW9uXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICByYXZpU2Vzc2lvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTZXNzaW9uU3RhdGVzLkZBSUxFRCk7XG4gICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNpZ25hbGluZyBzdGF0ZSBoYXMgY2hhbmdlZCBkdXJpbmcgb3BlbmluZyBvZiBSQVZJIHNlc3Npb24sIGJ1dCBpcyBhbiBPSyBjaGFuZ2UuIE5ldyBzdGF0ZTogXCIgKyBzdGF0ZSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgfVxuICB9XG4gIFxuICBcbiAgLyoqXG4gICAqIENsb3NlIGEgc2Vzc2lvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBvd25pbmcgUmF2aVNlc3Npb24uIFxuICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBBTFdBWVMgZ29lcyB0aHJvdWdoIGl0cyBjbGVhbnVwIHByb2Nlc3MsXG4gICAqIGV2ZW4gaWYgdGhlcmUgaXNuJ3QgYW4gdW5kZXJseWluZyBSVEMgY29ubmVjdGlvbiBvciB0aGUgdW5kZXJseWluZ1xuICAgKiBSVEMgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGNsb3NlZC4gVGhpcyBpcyB0byBtYWtlIHN1cmUgdGhhdCBvdGhlciB0aGluZ3NcbiAgICogKGUuZy4gc3RhdGUgY2hhbmdlIGhhbmRsZXJzIG9uIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBhbmQgcHJvbWlzZXMpIGFsd2F5c1xuICAgKiBnZXQgY2xlYW5lZCB1cCBhcHByb3ByaWF0ZWx5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfY2xvc2UoKSB7XG4gICAgdGhpcy5fc3RhdHNXYXRjaGVyLnN0b3AoKTtcbiAgICBjb25zdCByYXZpU2Vzc2lvbiA9IHRoaXMuX3JhdmlTZXNzaW9uO1xuICAgIFJhdmlVdGlscy5sb2coXCJjbG9zaW5nXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuXG4gICAgaWYgKHRoaXMuX3J0Y0Nvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMuX3J0Y0Nvbm5lY3Rpb24uY2xvc2UoKTsgICAgXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIG91ciBzZXNzaW9uLW5lZ290aWF0aW5nIG1lc3NhZ2UgaGFuZGxlciBmcm9tIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvblxuICAgIHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24ucmVtb3ZlTWVzc2FnZUhhbmRsZXIodGhpcy5fbmVnb3RpYXRvcik7XG5cbiAgICAvLyBSZW1vdmUgdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uJ3Mgc3RhdGUgY2hhbmdlIGhhbmRsZXIgdGhhdCB3b3VsZCBoYXZlXG4gICAgLy8gc2hvcnQtY2lyY3VpdGVkIGNvbm5lY3Rpb24gbG9naWMgaWYgdGhlIHNpZ25hbGluZyBkaXNjb25uZWN0cyB3aGlsZVxuICAgIC8vIHdlJ3JlIHN0aWxsIHRyeWluZyB0byBuZWdvdGlhdGVcbiAgICB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uLnJlbW92ZVN0YXRlQ2hhbmdlSGFuZGxlcih0aGlzLl9zaG9ydENpcmN1aXRIYW5kbGVyKTtcblxuICAgIC8vIF9ydGNDb25uZWN0aW9uIHdpbGwgYmUgcmVpbml0aWFsaXplZCBpZi93aGVuIGl0J3MgbmVlZGVkIGFnYWluLCBuZXh0IHRpbWVcbiAgICAvLyBhIGNvbm5lY3QgaXMgYXR0ZW1wZWQgYW5kIGFuIHNkcCBvZmZlciBhcnJpdmVzLlxuICAgIHRoaXMuX3J0Y0Nvbm5lY3Rpb24gPSBudWxsO1xuXG4gICAgLy8gTWFrZSBhYnNvbHV0ZWx5IHN1cmUgdGhlIG93bmluZyBzZXNzaW9uIGtub3dzIHdlJ3ZlIGNsb3NlZFxuICAgIHJhdmlTZXNzaW9uLl9oYW5kbGVTdGF0ZUNoYW5nZSh7fSwgUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHNlbmQgbG9jYWwgSUNFIGNhbmRpZGF0ZSBwcm9wb3NhbHMgdG8gdGhlIHNlcnZlci5cbiAgICogXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9PbmljZWNhbmRpZGF0ZShldmVudDogYW55KSB7XG4gICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSAmJiBldmVudC5jYW5kaWRhdGUgIT0gXCJcIikge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIlNlbmRpbmcgbG9jYWwgSUNFIGNhbmRpZGF0ZTogXCIgKyBKU09OLnN0cmluZ2lmeShldmVudC5jYW5kaWRhdGUpLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgIHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24uc2VuZChKU09OLnN0cmluZ2lmeSh7J2ljZSc6IGV2ZW50LmNhbmRpZGF0ZSwgJ3V1aWQnOiB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRVVUlEKCl9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJhdmlVdGlscy5sb2coXCJFbmQgb2YgbG9jYWwgSUNFIGNhbmRpZGF0ZXNcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBIYW5kbGUgcmVuZWdvdGlhdGlvbiB3aGVuIG5lZWRlZC5cbiAgICogXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9Pbm5lZ290aWF0aW9ubmVlZGVkKGV2ZW50OiBhbnkpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwibmVlZCByZW5lZ290aWF0aW9uIHBsZWFzZVwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICBjb25zdCBtc2cgPSB7XG4gICAgICByZW5lZ290aWF0ZTogXCJwbGVhc2VcIixcbiAgICAgIHV1aWQ6IHRoaXMuX3JhdmlTZXNzaW9uLmdldFVVSUQoKVxuICAgIH07XG4gICAgY29uc3QgZGVzYyA9IEpTT04uc3RyaW5naWZ5KG1zZyk7XG4gICBcbiAgICAvLyBuZWdvdGlhdGlvbiBuZWVkZWQgYnV0IG9ubHkgaWYgd2UgYXJlIG5vdCBhbHJlYWR5IGN1cnJlbnRseSBuZWdvdGlhdGluZ1xuICAgIGlmICh0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uICYmIHRoaXMuX3J0Y0Nvbm5lY3Rpb24gJiYgdGhpcy5fcnRjQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gXCJzdGFibGVcIikge1xuICAgICAgdGhpcy5fc2lnbmFsaW5nQ29ubmVjdGlvbi5zZW5kKGRlc2MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgc2lnbmFsaW5nIHN0YXRlIGNoYW5nZS5cbiAgICogXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9PbnNpZ25hbGluZ3N0YXRlY2hhbmdlZChldmVudDogYW55KSB7XG4gICAgaWYgKHRoaXMuX3J0Y0Nvbm5lY3Rpb24pIHtcbiAgICAgIC8vIHNpbXBsZSBsb2dnaW5nIGZvciBub3dcbiAgICAgIFJhdmlVdGlscy5sb2coXCJTaWduYWxpbmdTdGF0ZSBjaGFuZ2VkOiBcIiArIHRoaXMuX3J0Y0Nvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2ZvcmNlQml0cmF0ZVVwKHNkcDogc3RyaW5nKSB7XG4gICAgLy8gTmVlZCB0byBmb3JtYXQgdGhlIFNEUCBkaWZmZXJlbnRseSBpZiB0aGUgaW5wdXQgaXMgc3RlcmVvLCBzbyBcbiAgICAvLyByZWFjaCB1cCBpbnRvIG91ciBvd25lcidzIHN0cmVhbSBjb250cm9sbGVyIHRvIGZpbmQgb3V0LlxuICAgIGNvbnN0IGxvY2FsQXVkaW9Jc1N0ZXJlbyA9IHRoaXMuX3JhdmlTZXNzaW9uLl9zdHJlYW1Db250cm9sbGVyLmlzU3RlcmVvSW5wdXQoKTtcbiAgICAvLyBVc2UgMTI4a2JwcyBmb3Igc3RlcmVvIHVwc3RyZWFtIGF1ZGlvLCA2NGticHMgZm9yIG1vbm9cbiAgICBjb25zdCBiaXRyYXRlID0gbG9jYWxBdWRpb0lzU3RlcmVvID8gMTI4MDAwIDogNjQwMDA7XG5cbiAgICAvLyBTRFAgbXVuZ2luZzogdXNlIDEyOGticHMgZm9yIHN0ZXJlbyB1cHN0cmVhbSBhdWRpbywgNjRrYnBzIGZvciBtb25vXG4gICAgcmV0dXJuIHNkcC5yZXBsYWNlKC9hPWZtdHA6MTExIC9nLCAnYT1mbXRwOjExMSBtYXhhdmVyYWdlYml0cmF0ZT0nK2JpdHJhdGUrJzsnKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZm9yY2VTdGVyZW9Eb3duKHNkcDogc3RyaW5nKSB7XG4gICAgLy8gbXVuZ2UgdGhlIFNEUCBhbnN3ZXI6IHJlcXVlc3QgMTI4a2JwcyBzdGVyZW8gZm9yIGRvd25zdHJlYW0gYXVkaW9cbiAgICByZXR1cm4gc2RwLnJlcGxhY2UoL2E9Zm10cDoxMTEgL2csICdhPWZtdHA6MTExIG1heGF2ZXJhZ2ViaXRyYXRlPTEyODAwMDtzcHJvcC1zdGVyZW89MTtzdGVyZW89MTsnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIGFsbCBtZXNzYWdlcyBvbiB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24gKHNlZSB0aGUgX29wZW4oKSBtZXRob2QpLCBhbmRcbiAgICogd2F0Y2hlcyBmb3IgdGhlIGFwcHJvcHJpYXRlIFNEUC1yZWxhdGVkIGV2ZW50cyBzbyB0aGF0IGl0IGNhbiBuZWdvdGlhdGUgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBDb25uZWN0aW9uKGV2ZW50OiBhbnkpIHtcbiAgICBsZXQgZnVsbE1lc3NhZ2U6YW55ID0gXCJcIjtcbiAgICBsZXQgc2lnbmFsOmFueSA9IFwiXCI7XG5cbiAgICBcbiAgICAvLyBMb2NhbCBjb3BpZXMgb2YgdXNlZnVsIHZhcmlhYmxlcyB0byBhdm9pZCBoYXZpbmcgdG8gYmluZFxuICAgIGNvbnN0IHJhdmlTZXNzaW9uID0gdGhpcy5fcmF2aVNlc3Npb247XG4gICAgY29uc3Qgc2lnbmFsaW5nQ29ubmVjdGlvbiA9IHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb247XG4gICAgY29uc3Qgc2Vzc2lvbkltcGxlbWVudGF0aW9uID0gdGhpcztcbiAgICBcbiAgICAvLyBKdXN0IGluIGNhc2UsIG1ha2Ugc3VyZSB3ZSBoYXZlIGV2ZXJ5dGhpbmcgd2UgbmVlZFxuICAgIGlmICghcmF2aVNlc3Npb24gfHwgIXNpZ25hbGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgIFJhdmlVdGlscy5lcnIoXCJNaXNzaW5nIG9uZSBvZiByYXZpU2Vzc2lvbiBvciBzaWduYWxpbmdDb25uZWN0aW9uISBDYW4ndCBzZXQgdXAgY29ubmVjdGlvbi5cIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgbWVzc2FnZSwgYW5kIHRoYXQgaXQncyBmb3IgdGhpcyBwYXJ0aWN1bGFyIFJBVkkgc2Vzc2lvblxuICAgIGlmIChldmVudCAmJiBldmVudC5kYXRhKSB7XG4gICAgICBSYXZpVXRpbHMubG9nKCdNZXNzYWdlIGZyb20gc2VydmVyOiAnICsgZXZlbnQuZGF0YSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICBmdWxsTWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJhdmlVdGlscy5sb2coJ05vIG1lc3NhZ2UgcmVjZWl2ZWQgYnkgb25NZXNzYWdlIGhhbmRsZXInLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgIHJldHVybjsgLy8gTm8gbWVzc2FnZVxuICAgIH1cbiAgICBzaWduYWwgPSBmdWxsTWVzc2FnZVtyYXZpU2Vzc2lvbi5nZXRVVUlEKCldO1xuICAgIGlmICghc2lnbmFsKSByZXR1cm47IC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgZm9yIG1lXG5cbiAgICAvLyBXZSBoYXZlIGEgc2lnbmFsOyBjaGVjayBmaXJzdCB0byBzZWUgaWYgaXQncyBhbiBTRFBcbiAgICBpZiAoc2lnbmFsLnNkcCkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIlJlY2VpdmVkIHNkcCB0eXBlPVwiICsgc2lnbmFsLnR5cGUsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuXG4gICAgICAvLyB1c2UgdXNlci1zcGVjaWZpZWQgVFVSTiBjb25maWcgaWYgZm91bmRcbiAgICAgIGlmIChzZXNzaW9uSW1wbGVtZW50YXRpb24uX2N1c3RvbVN0dW5BbmRUdXJuKSB7XG4gICAgICAgIGNvbnN0IENVU1RPTV9UVVJOX0NPTkZJRyA9IHtcbiAgICAgICAgICAndXJscyc6IHNlc3Npb25JbXBsZW1lbnRhdGlvbi5fY3VzdG9tU3R1bkFuZFR1cm4udHVyblVybHMsXG4gICAgICAgICAgJ3VzZXJuYW1lJzogc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9jdXN0b21TdHVuQW5kVHVybi50dXJuVXNlcm5hbWUsXG4gICAgICAgICAgJ2NyZWRlbnRpYWwnOiBzZXNzaW9uSW1wbGVtZW50YXRpb24uX2N1c3RvbVN0dW5BbmRUdXJuLnR1cm5DcmVkZW50aWFsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IENVU1RPTV9TVFVOX0NPTkZJRyA9IHtcbiAgICAgICAgICAndXJscyc6IHNlc3Npb25JbXBsZW1lbnRhdGlvbi5fY3VzdG9tU3R1bkFuZFR1cm4uc3R1blVybHNcbiAgICAgICAgfTtcbiAgICAgICAgcGVlckNvbm5lY3Rpb25Db25maWcgPSB7XG4gICAgICAgICAgJ2ljZVNlcnZlcnMnOiBbXG4gICAgICAgICAgICBDVVNUT01fU1RVTl9DT05GSUcsXG4gICAgICAgICAgICBDVVNUT01fVFVSTl9DT05GSUdcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICAvLyBncmFiIHRoZSBUVVJOIGNvbmZpZyBpZiBmb3VuZFxuICAgICAgfSBlbHNlIGlmIChzaWduYWwudHVybiAmJiBzaWduYWwudHVybi51cmxzICYmIHNpZ25hbC50dXJuLnVzZXJuYW1lICYmIHNpZ25hbC50dXJuLmNyZWRlbnRpYWwpIHtcbiAgICAgICAgLy8gV2UgYXBwZWFyIHRvIG5lZWQgdG8gaHVtb3IgVHlwZVNjcmlwdCBieSBzZXR0aW5nIHRoaXMgdG8gYSBjb25zdGFudCB0aGVcbiAgICAgICAgLy8gc2FtZSB3YXkgd2UgZG8gZm9yIHRoZSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IERZTkFNSUNfVFVSTl9DT05GSUcgPSB7XG4gICAgICAgICAgJ3VybHMnOiBzaWduYWwudHVybi51cmxzLFxuICAgICAgICAgICd1c2VybmFtZSc6IHNpZ25hbC50dXJuLnVzZXJuYW1lLFxuICAgICAgICAgICdjcmVkZW50aWFsJzogc2lnbmFsLnR1cm4uY3JlZGVudGlhbFxuICAgICAgICB9O1xuICAgICAgICBwZWVyQ29ubmVjdGlvbkNvbmZpZyA9IHtcbiAgICAgICAgICAnaWNlU2VydmVycyc6IFtcbiAgICAgICAgICAgIERFRkFVTFRfU1RVTl9DT05GSUcsXG4gICAgICAgICAgICBEWU5BTUlDX1RVUk5fQ09ORklHXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBTQUQgU1RBVEUgT0YgQUZGQUlSUzogdGhlcmUgaXMgbm8gd2F5IChBRkFJQ1QpIHRvIG1vZGlmeVxuICAgICAgLy8gX3J0Y0Nvbm5lY3Rpb24uY29uZmlndXJhdGlvbiBhZnRlciB0aGUgUnRjQ29ubmVjdGlvbiBjdG9yLlxuICAgICAgLy8gV09SS0FST1VORDogd2Ugd2FpdCB1bnRpbCB0aGUgZmlyc3Qgd2Vic29ja2V0IG1lc3NhZ2UgKGUuZy4gdGhlIHNkcCBvZmZlciksXG4gICAgICAvLyB3aGljaCBjb3VsZCBpbmNsdWRlIFRVUk4gY29uZmlnIGluZm8sIGJlZm9yZSB3ZSBpbml0aWFsaXplIF9ydGNDb25uZWN0aW9uLlxuICAgICAgaWYgKCF0aGlzLl9ydGNDb25uZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2luaXRSdGNDb25uZWN0aW9uKCk7XG4gICAgICAgIC8vIElmIHNvbWVvbmUgaGFzIGFscmVhZHkgc2V0IHRoZSBhdWRpbyBpbnB1dCBzdHJlYW0sIGFkZCBpdCB0byB0aGUgcnRjIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gbm93IHRoYXQgaXQncyBiZWVuIGluaXRpYWxpemVkLlxuICAgICAgICBpZiAodGhpcy5fYXVkaW9JbnB1dFN0cmVhbSkge1xuICAgICAgICAgIHRoaXMuX2FkZEF1ZGlvSW5wdXRTdHJlYW0odGhpcy5fYXVkaW9JbnB1dFN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ZpZGVvSW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICB0aGlzLl9hZGRWaWRlb0lucHV0U3RyZWFtKHRoaXMuX3ZpZGVvSW5wdXRTdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcnRjQ29ubmVjdGlvbiA9IHRoaXMuX3J0Y0Nvbm5lY3Rpb247XG4gICAgXG4gICAgICAvLyBGb3JjZSBvdXIgZGVzaXJlZCBiaXRyYXRlIGJ5IG11bmdpbmcgdGhlIFNEUCwgYW5kIGNyZWF0ZSBhIHNlc3Npb24gZGVzY3JpcHRpb24gZm9yIGl0XG4gICAgICBzaWduYWwuc2RwID0gc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9mb3JjZUJpdHJhdGVVcChzaWduYWwuc2RwKTsgXG4gICAgICBjb25zdCBkZXNjID0gbmV3IGNyb3NzUGxhdGZvcm1SVENTZXNzaW9uRGVzY3JpcHRpb24oc2lnbmFsKTtcblxuICAgICAgLy8gU2V0IHRoZSBkZXNjcmlwdGlvbiBvbiB0aGUgUlRDIGNvbm5lY3Rpb24sIGFuZCBzZW5kIGFuZCBoYW5kbGUgdGhlIHZhcmlvdXMgU0RQc1xuICAgICAgcnRjQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjKVxuICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBhbnN3ZXJcbiAgICAgICByZXR1cm4gcnRjQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgIH0pXG4gICAgICAudGhlbihmdW5jdGlvbihhbnN3ZXI6IGFueSkge1xuICAgICAgICAvLyBGb3JjZSBzdGVyZW8gb24gdGhlIGRvd25zdHJlYW0gc3RyZWFtIGJ5IG11bmdpbmcgdGhlIFNEUFxuICAgICAgICBhbnN3ZXIuc2RwID0gc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9mb3JjZVN0ZXJlb0Rvd24oYW5zd2VyLnNkcCk7IFxuICAgICAgICBSYXZpVXRpbHMubG9nKFwiQW5zd2VyOlwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhhbnN3ZXIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAvLyBzZXQgbG9jYWwgZGVzY3JpcHRpb25cbiAgICAgICAgcmV0dXJuIHJ0Y0Nvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgICAgdHlwZTogXCJhbnN3ZXJcIixcbiAgICAgICAgICBzZHA6IHJ0Y0Nvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbixcbiAgICAgICAgICB1dWlkOiByYXZpU2Vzc2lvbi5nZXRVVUlEKClcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGVzYyA9IEpTT04uc3RyaW5naWZ5KG1zZyk7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJTZW5kaW5nIGFuc3dlciB0byBzZXJ2ZXJcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIC8vIFNlbmQgdGhlIGZpbmFsIHJlc3VsdCBiYWNrIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5zZW5kKGRlc2MpO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKHNpZ25hbC5pY2UpIHtcbiAgICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCByZW1vdGUgSUNFIGNhbmRpZGF0ZTogXCIgKyBKU09OLnN0cmluZ2lmeShzaWduYWwuaWNlKSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICBpZiAodGhpcy5fcnRjQ29ubmVjdGlvbikge1xuICAgICAgICB0aGlzLl9ydGNDb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShzaWduYWwuaWNlKVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiQWRkZWQgcmVtb3RlIGNhbmRpZGF0ZVwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGU6IGFueSkge1xuICAgICAgICAgIFJhdmlVdGlscy5lcnIoXCJFcnJvciBhdHRlbXB0aW5nIHRvIGFkZCByZW1vdGUgSUNFIGNhbmRpZGF0ZTogXCIgKyBlLm1lc3NhZ2UsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEtlZXAgdHJhY2sgb2YgaWNlIGNhbmRpZGF0ZXMgdW50aWwgd2UgaGF2ZSBhbiBydGNDb25uZWN0aW9uXG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJJZ25vcmUgaWNlIGNhbmRpZGF0ZSB1bnRpbCB3ZSBoYXZlIGFuIHJ0Y0Nvbm5lY3Rpb24sIGljZT0nXCIgKyBKU09OLnN0cmluZ2lmeShzaWduYWwpICsgXCInXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb21lIG90aGVyIGhhbmRsZXIncyBwcm9ibGVtXG4gICAgICBSYXZpVXRpbHMubG9nKFwiVW5rbm93biBtZXNzYWdlIFwiICsgSlNPTi5zdHJpbmdpZnkoc2lnbmFsKSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogQWRkIGEgaGFuZGxlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG5ldyBzdGF0cyBnZW5lcmF0ZWQuXG4gICAqIFRoZXNlIGFyZSBzdG9yZWQgaW4gYSBTZXQgb2YgRnVuY3Rpb25zOyB0aGVyZWZvcmUsIGEgZ2l2ZW4gZnVuY3Rpb25cbiAgICogY2FuIG9ubHkgZXhpc3Qgb25jZSBpbiB0aGlzIFNldC5cbiAgICogXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmF2aVNlc3Npb25+c3RhdHNPYnNlcnZlckNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2sgaGFuZGxlciB0aGF0IHNob3VsZCBoYW5kbGUgYSBzdGF0ZSBjaGFuZ2UgZXZlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBhZGQgc3VjY2VlZGVkXG4gICAqL1xuICBfYWRkU3RhdHNPYnNlcnZlcihvYnNlcnZlcjogRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHNXYXRjaGVyLmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBoYW5kbGVyIHNvIHRoYXQgaXQgc3RvcHMgbGlzdGVuaW5nIGZvciBzdGF0cyB1cGRhdGVzLlxuICAgKiBcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn5zdGF0c09ic2VydmVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHJlbW92YWwgd2FzIHN1Y2Nlc3NmdWwgKGkuZS4gZGlkIG5vdCB0aHJvdyBhbiBlcnJvciAtLSBub3RlIHRoYXQgdGhpcyBkb2VzXG4gICAqIE5PVCBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciB3YXMgaW4gdGhlIHNldCBpbiB0aGUgZmlyc3QgcGxhY2UpXG4gICAqL1xuICBfcmVtb3ZlU3RhdHNPYnNlcnZlcihvYnNlcnZlcjogRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHNXYXRjaGVyLnJlbW92ZU9ic2VydmVyKG9ic2VydmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvc2UgdGhlIGdldFN0YXRzIGNhbGwgb24gdGhlIHJ0Y1BlZXJDb25uZWN0aW9uXG4gICAqIHVzZWQgYnkgdGhlIHN0YXRzV2F0Y2hlclxuICAgKi9cbiAgYXN5bmMgX2dldFN0YXRzKHNlbGVjdG9yOiBhbnkgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuX3J0Y0Nvbm5lY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydGNDb25uZWN0aW9uLmdldFN0YXRzKHNlbGVjdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgUmF2aVV0aWxzIH0gZnJvbSBcIi4vUmF2aVV0aWxzXCI7XG5cbi8qKlxuICogRW51bSBmb3IgcmVwcmVzZW50aW5nIGRpZmZlcmVudCBwb3NzaWJsZSBzdGF0ZXNcbiAqIHRoYXQgYSBSQVZJIHNpZ25hbGluZ0Nvbm5lY3Rpb24gbWlnaHQgYmUgaW4uXG4gKlxuICogXCJVTkFWQUlMQUJMRVwiIGlzIGEgY3VzdG9tIHN0YXRlIHRoYXQgZ2V0cyBzZXRcbiAqIGlmIHRoZSBzZXJ2ZXIgaXMgaW4gYSBcInJ1bm5pbmcsIGJ1dCBub3QgY3VycmVudGx5XG4gKiBhY2NlcHRpbmcgaW5jb21pbmcgY29ubmVjdGlvbnNcIiBzdGF0ZS5cbiAqIFxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZW51bSBSYXZpU2lnbmFsaW5nU3RhdGVzIHtcbiAgQ09OTkVDVElORyA9IFwiY29ubmVjdGluZ1wiLFxuICBPUEVOID0gXCJvcGVuXCIsXG4gIEVSUk9SID0gXCJlcnJvclwiLFxuICBDTE9TSU5HID0gXCJjbG9zaW5nXCIsXG4gIENMT1NFRCA9IFwiY2xvc2VkXCIsXG4gIFVOQVZBSUxBQkxFID0gXCJ1bmF2YWlsYWJsZVwiXG59O1xuXG4vKiogXG4gKlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIFNpZ25hbGluZyBjb25uZWN0aW9uIHNwZWNpZmljYWxseSBmb3IgaGFuZGxpbmcgUkFWSSBzZXNzaW9ucy5cbiAqIFRoaXMgZ2V0cyB1c2VkIGJ5IHRoZSBSYXZpU2Vzc2lvbiAoYW5kIGl0cyBQZWVyQ29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbilcbiAqIHRvIHNldCB1cCBhIFJhdmlTZXNzaW9uIGNvbm5lY3Rpb24uXG4gKiBUaGlzIGNsYXNzIHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgYnkgdGhlIFJBVkkgY29uc3VtZXIsIGFuZCB0aGVuIHVzZWQgdG8gb3Blbiwgd29yayB3aXRoLCBhbmQgY2xvc2UgXG4gKiBSQVZJIHNlc3Npb25zIGFzIG5lZWRlZC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiB7XG4gIC8qKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKlxuICAgKiB0aGlzLl9zdGF0ZWNoYW5nZUhhbmRsZXJzICAgLy8gQSBsaXN0IG9mIGhhbmRsZXJzIHRvIGNhbGwgd2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VzXG4gICAqIHRoaXMuX21lc3NhZ2VIYW5kbGVycyAgICAgICAvLyBBIGxpc3Qgb2YgaGFuZGxlcnMgdG8gY2FsbCB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZFxuICAgKlxuICAgKiB0aGlzLl9zaWduYWxpbmdJbXBsZW1lbnRhdGlvbiAgIC8vIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBzaWduYWxpbmcgdG8gdXNlXG4gICAqXG4gICAqIHRoaXMuX3N0YXRlICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIGNvbm5lY3Rpb25cbiAgICpcbiAgICogX3Jlc29sdmVPcGVuLCBfcmVqZWN0T3BlbiwgX3Jlc29sdmVDbG9zZSwgYW5kIF9yZWplY3RDbG9zZTogVXNlZCBmb3IgcmVzb2x2aW5nIHRoZSBQcm9taXNlc1xuICAgKiAgICAgbWFkZSBieSB0aGUgb3BlbiBhbmQgY2xvc2UgZnVuY3Rpb25zLCB3aGljaCBnZXQgaGFuZGxlZCBvdXRzaWRlIG9mIHRob3NlIGZ1bmN0aW9ucyB0aGVtc2VsdmVzXG4gICAqL1xuICBfc3RhdGVDaGFuZ2VIYW5kbGVyczogU2V0PEZ1bmN0aW9uPjtcbiAgX21lc3NhZ2VIYW5kbGVyczogU2V0PEZ1bmN0aW9uPjtcbiAgX3N0YXRlOiBSYXZpU2lnbmFsaW5nU3RhdGVzO1xuICBfc2lnbmFsaW5nSW1wbGVtZW50YXRpb246IFJhdmlTaWduYWxpbmdXZWJTb2NrZXRJbXBsZW1lbnRhdGlvbjtcblxuICBfcmVzb2x2ZU9wZW46IEZ1bmN0aW9uOyBfcmVqZWN0T3BlbjogRnVuY3Rpb247XG4gIF9yZXNvbHZlQ2xvc2U6IEZ1bmN0aW9uOyBfcmVqZWN0Q2xvc2U6IEZ1bmN0aW9uO1xuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblxuICAgKiBEZWZhdWx0cyB0aGUgaGFuZGxlcnNcbiAgICogYW5kIGluaXRpYWxpemVzIHRoZSBzdGF0ZSB0byBSYXZpU2lnbmFsaW5nU3RhdGVzLkNMT1NFRC5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiQ29uc3RydWN0b3JcIiwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHRoZSBsaXN0IG9mIGhhbmRsZXJzXG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlcnMgPSBuZXcgU2V0KCk7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcbiAgICB0aGlzLl9zdGF0ZSA9IFJhdmlTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEO1xuICAgIFxuICAgIC8vIElmIHdlIHdhbnRlZCB0byB1c2UgYSBkaWZmZXJlbnQgc2lnbmFsaW5nIGltcGxlbWVudGF0aW9uLFxuICAgIC8vIHdlIHdvdWxkIG5ldygpIGl0IGhlcmUuIChUT0RPOiBNYWtlIHRoaXMgY29uZmlndXJhYmxlIGluIHNvbWVcbiAgICAvLyBpbnRlcmVzdGluZyB3YXkuIEZvciBub3csIGl0J3MgZW5vdWdoIGp1c3QgdG8gbWFrZSBpdCBlYXNpbHkgXG4gICAgLy8gc3dhcHBhYmxlIGluIHRoZSBjb2RlIGhlcmUuKVxuICAgIHRoaXMuX3NpZ25hbGluZ0ltcGxlbWVudGF0aW9uID0gbmV3IFJhdmlTaWduYWxpbmdXZWJTb2NrZXRJbXBsZW1lbnRhdGlvbih0aGlzKTtcbiAgICBcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uXG4gICAqIFxuICAgKiBAcmV0dXJucyB7UmF2aVNpZ25hbGluZ1N0YXRlc31cbiAgICovXG4gIGdldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBsaXN0ZW5pbmcgdG8gc3RhdGUgY2hhbmdlc1xuICAgKiBAY2FsbGJhY2sgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25+c3RhdGVDaGFuZ2VDYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgQW4gb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIGluZm9ybWF0aW9uXG4gICAqIGFib3V0IHRoZSBzdGF0ZSBjaGFuZ2UuIFRoaXMgaW5jbHVkZXMgdGhlIFwiZXZlbnQuc3RhdGVcIiBrZXksXG4gICAqIHdoaWNoIHdpbGwgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgdmFsdWUgZnJvbSB0aGUgUmF2aVNlc3Npb25TdGF0ZXMgZW51bS5cbiAgICovXG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIHRvIHRoZSBzZXQgb2Ygc3RhdGUgY2hhbmdlIGhhbmRsZXJzLlxuICAgKiBBbGwgaGFuZGxlcnMgaW4gdGhpcyBzZXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2l0aCBhIGNvcHkgb2YgdGhlIGV2ZW50XG4gICAqIGFueSB0aW1lIHRoZSBzdGF0ZSBvZiB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24gY2hhbmdlcy5cbiAgICogVGhlc2UgYXJlIHN0b3JlZCBpbiBhIFNldCBvZiBGdW5jdGlvbnM7IHRoZXJlZm9yZSwgYSBnaXZlbiBmdW5jdGlvblxuICAgKiBjYW4gb25seSBleGlzdCBvbmNlIGluIHRoaXMgU2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1JhdmlTaWduYWxpbmdDb25uZWN0aW9ufnN0YXRlQ2hhbmdlQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGFkZCBzdWNjZWVkZWRcbiAgICovXG4gIGFkZFN0YXRlQ2hhbmdlSGFuZGxlcihjaGFuZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzLmFkZChjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIGFkZGluZyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyOiBcIiArXG4gICAgICAgIGVyci5tZXNzYWdlLCBcIlJhdmlTaWduYWxpbmdDb25uZWN0aW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgaGFuZGxlciBmcm9tIHRoZSBsaXN0IG9mIHN0YXRlIGNoYW5nZSBoYW5kbGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbn5zdGF0ZUNoYW5nZUNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2sgaGFuZGxlciB0aGF0IGhhcyBiZWVuIGhhbmRsaW5nIGEgc3RhdGUgY2hhbmdlIGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcmVtb3ZhbCB3YXMgc3VjY2Vzc2Z1bCAoaS5lLiBkaWQgbm90IHRocm93IGFuIGVycm9yIC0tIG5vdGUgdGhhdCB0aGlzIGRvZXNcbiAgICogTk9UIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIHdhcyBpbiB0aGUgc2V0IGluIHRoZSBmaXJzdCBwbGFjZSlcbiAgICovXG4gIHJlbW92ZVN0YXRlQ2hhbmdlSGFuZGxlcihjaGFuZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXR2YWwgPSB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzLmRlbGV0ZShjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIHJlbW92aW5nIGEgc3RhdGUgY2hhbmdlIGhhbmRsZXI6IFwiICtcbiAgICAgICAgZXJyLm1lc3NhZ2UsIFwiUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25cIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgbGlzdGVuaW5nIGZvciBtZXNzYWdlc1xuICAgKiBAY2FsbGJhY2sgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25+bWVzc2FnZUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEEgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICovXG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIHRvIHRoZSBsaXN0IG9mIG1lc3NhZ2UgcmVjZWl2ZWQgaGFuZGxlcnMuXG4gICAqIEFsbCBoYW5kbGVycyBpbiB0aGlzIGxpc3Qgd2lsbCBiZSB0cmlnZ2VyZWQgd2l0aCBhIGNvcHkgb2YgdGhlIFxuICAgKiBpbmNvbWluZyBtZXNzYWdlIGFueSB0aW1lIGEgbWVzc2FnZSBpcyByZWNlaXZlZC5cbiAgICogVGhlc2UgYXJlIHN0b3JlZCBpbiBhIFNldCBvZiBGdW5jdGlvbnM7IHRoZXJlZm9yZSwgYSBnaXZlbiBmdW5jdGlvblxuICAgKiBjYW4gb25seSBleGlzdCBvbmNlIGluIHRoaXMgU2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1JhdmlTaWduYWxpbmdDb25uZWN0aW9ufm1lc3NhZ2VDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBzaG91bGQgaGFuZGxlIGEgbWVzc2FnZSByZWNlaXZlZCBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGFkZCBzdWNjZWVkZWRcbiAgICovXG4gIGFkZE1lc3NhZ2VIYW5kbGVyKG1lc3NhZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlcnMuYWRkKG1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIGFkZGluZyBhIG1lc3NhZ2UgaGFuZGxlcjogXCIgK1xuICAgICAgICBlcnIubWVzc2FnZSwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGhhbmRsZXIgZnJvbSB0aGUgbGlzdCBvZiBtZXNzYWdlIHJlY2VpdmVkIGhhbmRsZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JhdmlTaWduYWxpbmdDb25uZWN0aW9ufm1lc3NhZ2VDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBoYXMgYmVlbiBoYW5kbGluZyBhIG1lc3NhZ2UgcmVjZWl2ZWQgZXZlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSByZW1vdmFsIHdhcyBzdWNjZXNzZnVsIChpLmUuIGRpZCBub3QgdGhyb3cgYW4gZXJyb3IgLS0gbm90ZSB0aGF0IHRoaXMgZG9lc1xuICAgKiBOT1QgaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgd2FzIGluIHRoZSBzZXQgaW4gdGhlIGZpcnN0IHBsYWNlKVxuICAgKi9cbiAgcmVtb3ZlTWVzc2FnZUhhbmRsZXIobWVzc2FnZUhhbmRsZXI6IEZ1bmN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVycy5kZWxldGUobWVzc2FnZUhhbmRsZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKFwiRXJyb3IgcmVtb3ZpbmcgYSBzdGF0ZSBjaGFuZ2UgaGFuZGxlcjogXCIgK1xuICAgICAgICBlcnIubWVzc2FnZSwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gYSBzaWduYWxpbmcgY29ubmVjdGlvbiB0byBhIHBhcnRpY3VsYXIgVVJMLiBSZXR1cm5zIGEgUHJvbWlzZVxuICAgKiB0aGF0IHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiBpcyBjb25uZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBVUkwgVGhlIFVSTCBvZiB0aGUgc2lnbmFsaW5nIHNlcnZlcidzIGVuZHBvaW50IChlLmcuICd3c3M6Ly9mb28uYmFyLmJhejo4ODg5JylcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBvcGVuUkFWSVNpZ25hbGluZ0Nvbm5lY3Rpb24oVVJMOiBzdHJpbmcpIHtcbiAgICB2YXIgc2lnbmFsaW5nQ29ubmVjdGlvbiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBSYXZpU2lnbmFsaW5nU3RhdGVzLk9QRU4pIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgIFwiVGhlcmUgaXMgYWxyZWFkeSBhbiBvcGVuIFdlYlNvY2tldCBjb25uZWN0aW9uLiBUbyByZWNvbm5lY3QsIGZpcnN0IGNsb3NlIHRoZSBleGlzdGluZyBXZWJTb2NrZXQgYW5kIHRoZW4gYXR0ZW1wdCB0byBvcGVuIGFnYWluLlwiXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9yZXNvbHZlT3BlbiA9IHJlc29sdmU7XG4gICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9yZWplY3RPcGVuID0gcmVqZWN0O1xuICAgICAgLy8gU3RhcnQgdGhlIFwib3BlbmluZ1wiIHByb2Nlc3NcbiAgICAgIFJhdmlVdGlscy5sb2coXCJPcGVuaW5nIHNpZ25hbGluZyBjb25uZWN0aW9uIHRvIFwiICsgVVJMLCBcIlJhdmlTaWduYWxpbmdDb250cm9sbGVyXCIpO1xuICAgICAgbGV0IGV2ZW50ID0ge1wic3RhdGVcIjpSYXZpU2lnbmFsaW5nU3RhdGVzLkNPTk5FQ1RJTkd9O1xuICAgICAgdGhpcy5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuQ09OTkVDVElORyk7IFxuXG4gICAgICAvLyBBbmQgY2FsbCB0aGUgaW1wbGVtZW50YXRpb24ncyBvcGVuIG1ldGhvZFxuICAgICAgdGhpcy5fc2lnbmFsaW5nSW1wbGVtZW50YXRpb24uX29wZW4oVVJMKTtcbiAgICB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBzaWduYWxpbmcgc2VydmVyXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICovXG4gIHNlbmQobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fc2lnbmFsaW5nSW1wbGVtZW50YXRpb24uX3NlbmQobWVzc2FnZSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24uIFJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgdGhlIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjbG9zZVJBVklTaWduYWxpbmdDb25uZWN0aW9uKCkge1xuICAgIHZhciBzaWduYWxpbmdDb25uZWN0aW9uID0gdGhpcztcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFJhdmlTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICBcIlNpZ25hbGluZyBjb25uZWN0aW9uIGlzIGFscmVhZHkgY2xvc2VkLlwiXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9yZXNvbHZlQ2xvc2UgPSByZXNvbHZlO1xuICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5fcmVqZWN0Q2xvc2UgPSByZWplY3Q7XG4gICAgICAvLyBTdGFydCB0aGUgXCJjbG9zaW5nXCIgcHJvY2Vzc1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIkNsb3Npbmcgc2lnbmFsaW5nIGNvbm5lY3Rpb25cIiwgXCJSYXZpU2lnbmFsaW5nQ29udHJvbGxlclwiKTtcbiAgICAgIGxldCBldmVudCA9IHtcInN0YXRlXCI6UmF2aVNpZ25hbGluZ1N0YXRlcy5DTE9TSU5HfTtcbiAgICAgIHRoaXMuX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBSYXZpU2lnbmFsaW5nU3RhdGVzLkNMT1NJTkcpOyBcblxuICAgICAgLy8gQW5kIGNhbGwgdGhlIGltcGxlbWVudGF0aW9uJ3Mgb3BlbiBtZXRob2RcbiAgICAgIHRoaXMuX3NpZ25hbGluZ0ltcGxlbWVudGF0aW9uLl9jbG9zZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEdlbmVyaWMgaGFuZGxlcnMgKi9cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVTdGF0ZUNoYW5nZShldmVudDogYW55ID0ge30sIHN0YXRlOiBSYXZpU2lnbmFsaW5nU3RhdGVzKSB7XG4gICAgLy8gQWx3YXlzIHRyeSB0byBmdWxmaWxsIGFueSBvcGVuIHByb21pc2VzLCBldmVuIGlmIHRoZSBzdGF0ZSBoYXNuJ3QgY2hhbmdlZFxuICAgIHRoaXMuX2Z1bGZpbGxQcm9taXNlcyhldmVudCwgc3RhdGUpO1xuXG4gICAgLy8gQnV0IG9ubHkgY2FsbCBoYW5kbGVycyBpZiB0aGUgc3RhdGUgZGlkLCBpbiBmYWN0LCBjaGFuZ2VcbiAgICBpZiAoc3RhdGUgIT09IHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIGV2ZW50W1wic3RhdGVcIl0gPSBzdGF0ZTtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIl9oYW5kbGVTdGF0ZUNoYW5nZTogXCIgKyBSYXZpVXRpbHMuc2FmZWx5UHJpbnRhYmxlKGV2ZW50KSwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogR2V0cyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHN0YXRlIGNoYW5nZXMgKGFuZCBzb21ldGltZXMgd2hlbiBpdCBkb2Vzbid0LFxuICAgKiBidXQgd2hlbiB3ZSBqdXN0IHdhbnQgdG8gbWFrZSBzdXJlKS4gRGVwZW5kaW5nIG9uIHRoZSBuZXcgKG9yIGN1cnJlbnQpIHN0YXRlLFxuICAgKiB0aGlzIHdpbGwgYXBwcm9wcmlhdGVseSBmdWxmaWxsIG91dHN0YW5kaW5nIHByb21pc2VzIHRoYXQgYXJlIHBlbmRpbmdcbiAgICogaW4gZWl0aGVyIHRoZSBvcGVuIG9yIGNsb3NlIG1ldGhvZCAob3IgYm90aCkuXG4gICAqL1xuICBfZnVsZmlsbFByb21pc2VzKGV2ZW50OiBhbnkgPSB7fSwgc3RhdGU6IFJhdmlTaWduYWxpbmdTdGF0ZXMpIHtcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gZXZlbnQucmVhc29uIHx8IGV2ZW50Lm1lc3NhZ2UgfHwgc3RhdGU7XG4gICAgUmF2aVV0aWxzLmxvZyhcIl9mdWxmaWxsUHJvbWlzZXM6IEhhbmRsaW5nIHN0YXRlIFwiICsgc3RhdGUsIFwiUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25cIik7XG4gICAgc3dpdGNoKHN0YXRlKSB7XG4gICAgICBjYXNlIFJhdmlTaWduYWxpbmdTdGF0ZXMuT1BFTjpcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVPcGVuKSB0aGlzLl9yZXNvbHZlT3BlbigpO1xuICAgICAgICBpZiAodGhpcy5fcmVqZWN0Q2xvc2UpIHRoaXMuX3JlamVjdENsb3NlKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2lnbmFsaW5nU3RhdGVzLkNMT1NFRDpcbiAgICAgICAgaWYgKHRoaXMuX3JlamVjdE9wZW4pIHRoaXMuX3JlamVjdE9wZW4oZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVDbG9zZSkgdGhpcy5fcmVzb2x2ZUNsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2lnbmFsaW5nU3RhdGVzLkVSUk9SOlxuICAgICAgICBpZiAodGhpcy5fcmVqZWN0T3BlbikgdGhpcy5fcmVqZWN0T3BlbihlcnJvck1lc3NhZ2UpO1xuICAgICAgICBpZiAodGhpcy5fcmVqZWN0Q2xvc2UpIHRoaXMuX3JlamVjdENsb3NlKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2lnbmFsaW5nU3RhdGVzLlVOQVZBSUxBQkxFOlxuICAgICAgICBpZiAodGhpcy5fcmVqZWN0T3BlbikgdGhpcy5fcmVqZWN0T3BlbihlcnJvck1lc3NhZ2UpO1xuICAgICAgICBpZiAodGhpcy5fcmVzb2x2ZUNsb3NlKSB0aGlzLl9yZXNvbHZlQ2xvc2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBEbyBub3RoaW5nIGZvciB0aGUgXCJpbiBwcm9ncmVzc1wiIHN0YXRlcywgbGlrZSBcIk9QRU5JTkdcIiBvciBcIkNMT1NJTkdcIlxuICAgICAgICBSYXZpVXRpbHMubG9nKFwiX2Z1bGZpbGxQcm9taXNlczogU2tpcHBpbmcgaW4tcHJvZ3Jlc3Mgc3RhdGUgXCIgKyBzdGF0ZSwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZU1lc3NhZ2UobWVzc2FnZTogYW55KSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIl9kb09ubWVzc2FnZTogXCIgKyBSYXZpVXRpbHMuc2FmZWx5UHJpbnRhYmxlKG1lc3NhZ2UpLCBcIlJhdmlTaWduYWxpbmdDb25uZWN0aW9uXCIpO1xuICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gdGhlIHNlcnZlciBzaWRlIGlzIGluIGFuIFwidW5hdmFpbGFibGVcIiBzdGF0ZSAtLSBpdCB3aWxsXG4gICAgLy8gc2VuZCBiYWNrIGEgc3BlY2lhbCBKU09OIHBhY2tldCBtYXJraW5nIGl0c2VsZiBhcyBcInNlcnZpY2UtdW5hdmFpbGFibGVcIi4gSGFuZGxlIHRoaXMgc2l0dWF0aW9uXG4gICAgLy8gZXhwbGljaXRseSBhcyBhIGN1c3RvbSBzdGF0ZS4gKFRoaXMgaXMga2luZCBvZiBhIGxvdCBvZiBjb2RlIGZvciBhIHJhcmUgb2NjdXJyZW5jZSwgYnV0IHdlXG4gICAgLy8gZG9uJ3Qgc2VuZCBhIHRvbiBvZiBtZXNzYWdlcyBvdmVyIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBhbmQgc28gSSBmZWVsIHJlYXNvbmFibHkgb2theSBhYm91dFxuICAgIC8vIGRvaW5nIHRoaXMgY2hlY2sgb24gZXZlcnkgbWVzc2FnZS4gLU1DSCkpXG4gICAgaWYgKG1lc3NhZ2UuZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VEYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VEYXRhLmVycm9yICYmIG1lc3NhZ2VEYXRhLmVycm9yID09PSBcInNlcnZpY2UtdW5hdmFpbGFibGVcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVN0YXRlQ2hhbmdlKHt9LCBSYXZpU2lnbmFsaW5nU3RhdGVzLlVOQVZBSUxBQkxFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IHBhcnNlIHRoZSBtZXNzYWdlIGFzIEpTT04sIGl0J3MgZGVmaW5pdGVseVxuICAgICAgICAgICAgLy8gbm90IHRoZSBcInVuYXZhaWxhYmxlXCIgbWVzc2FnZSBhbmQgcHJvYmFibHkgbWVhbnQgZm9yIHNvbWVvbmUgZWxzZSxcbiAgICAgICAgICAgIC8vIHNvIG5vLW9wIGhlcmUgYW5kIGp1c3QgbGV0IHRoZSByZXN0IG9mIHRoZSBjb2RlIGRlYWwgd2l0aCBpdC5cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVyKG1lc3NhZ2UpOyBcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbn0gLy8gRW5kIG9mIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLypcblRPRE86IEFkZCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGEgUmF2aVNpZ25hbGluZyBcImNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb25cIlxuY2xhc3Mgc2hvdWxkIGxvb2sgbGlrZS5cblxuQ29uc3RydWN0b3I6IHRha2VzIGEgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24gc28gdGhhdCBpdCBjYW4gdXNlIGl0cyBoYW5kbGVycy4gVGhlIGNsYXNzXG5pcyBleHBlY3RlZCB0byBhc3NpZ24gdGhlIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uJ3MgX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBzdGF0ZSkgYW5kIF9oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpXG5oYW5kbGVycyB0byBhcHByb3ByaWF0ZSBldmVudHMgKGFuZC9vciB0aHJvdyB0aG9zZSBldmVudHMgaXRzZWxmKS5cblxuUmVxdWlyZWQgbWV0aG9kczogX29wZW4oVVJMKSwgX3NlbmQobWVzc2FnZSksIGFuZCBfY2xvc2UoKVxuXG4qL1xuXG4vKipcbiAqIFVzZSB0aGUgY29ycmVjdCBjbGFzc2VzIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIGJlaW5nIFxuICogY2FsbGVkIGZyb20gbm9kZSBvciB0aGUgYnJvd3Nlci5cbiAqL1xubGV0IGNyb3NzUGxhdGZvcm1XZWJTb2NrZXQ6YW55ID0gbnVsbDtcbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gbm9kZSBjb250ZXh0XG4gIGNyb3NzUGxhdGZvcm1XZWJTb2NrZXQgPSByZXF1aXJlKCd3cycpO1xufSBlbHNlIHtcbiAgLy8gYnJvd3NlciBjb250ZXh0XG4gIGNyb3NzUGxhdGZvcm1XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG59XG5cbi8qKiBcbiAqIEEgV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIGZvciB0aGUgUmF2aVNpZ25hbGluZyBjbGFzc1xuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUmF2aVNpZ25hbGluZ1dlYlNvY2tldEltcGxlbWVudGF0aW9uIHtcbiAgX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uOiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgX3dlYlNvY2tldDogYW55O1xuICBcbiAgLyoqXG4gICAqIFwiQ2xhc3NcIiB2YXJpYWJsZXMgdG8gYmUgYXdhcmUgb2Y6XG4gICAqIHRoaXMuX3dlYlNvY2tldCAgICAgIC8vIFRoZSBhY3R1YWwgY29ubmVjdGVkIHdlYiBzb2NrZXRcbiAgICogdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24gLy8gdGhlIFwicGFyZW50XCIgc2lnbmFsaW5nIGNvbm5lY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSYXZpU2lnbmFsaW5nV2ViU29ja2V0SW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn0gcmF2aVNlc3Npb24gVGhlIG93bmVyIG9mIHRoaXMgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb246IFJhdmlTaWduYWxpbmdDb25uZWN0aW9uKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aVNpZ25hbGluZ1dlYlNvY2tldEltcGxlbWVudGF0aW9uXCIpO1xuICAgIHRoaXMuX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uID0gcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb247XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29wZW4oc29ja2V0QWRkcmVzczogc3RyaW5nKSB7XG4gICAgdmFyIHNpZ25hbGluZ0Nvbm5lY3Rpb24gPSB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjtcblxuICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBhbiBvcGVuIHdlYnNvY2tldCwgbWFrZSBzdXJlIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBrbm93cyBhYm91dCBpdCwgYW5kIHJldHVybiBpbW1lZGlhdGVseVxuICAgIGlmICh0aGlzLl93ZWJTb2NrZXQgJiYgdGhpcy5fd2ViU29ja2V0LnJlYWR5U3RhdGUgPT09IGNyb3NzUGxhdGZvcm1XZWJTb2NrZXQuT1BFTikge1xuICAgICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9oYW5kbGVTdGF0ZUNoYW5nZSh7fSwgUmF2aVNpZ25hbGluZ1N0YXRlcy5PUEVOKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3dlYlNvY2tldCA9IG5ldyBjcm9zc1BsYXRmb3JtV2ViU29ja2V0KHNvY2tldEFkZHJlc3MpO1xuXG4gICAgLy8gVGhlIFdlYlNvY2tldCdzIG9wZW4sIGVycm9yLCBhbmQgY2xvc2UgZXZlbnRzIHdpbGwganVzdFxuICAgIC8vIGNhbGwgYmFjayB1cCB0byB0aGUgbWFpbiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbidzIFxuICAgIC8vIHN0YXRlQ2hhbmdlSGFuZGxlcnMuXG4gICAgLy8gKFdlIGNhbid0IHNldCB0aGVzZSB1bnRpbCB3ZSBhdHRlbXB0IHRvIG9wZW4gdGhlXG4gICAgLy8gV2ViU29ja2V0LCBiZWNhdXNlIHRoZXJlJ3Mgbm8gb3RoZXIgV2ViU29ja2V0IGNvbnN0cnVjdG9yLilcbiAgICB0aGlzLl93ZWJTb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgc2lnbmFsaW5nQ29ubmVjdGlvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuT1BFTik7IH0pO1xuICAgIHRoaXMuX3dlYlNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgc2lnbmFsaW5nQ29ubmVjdGlvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuRVJST1IpOyB9KTtcbiAgICB0aGlzLl93ZWJTb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBmdW5jdGlvbihldmVudDogYW55KSB7IFxuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuY29kZSAmJiBldmVudC5jb2RlID4gNDAwMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBcImNsb3NlXCIgZXZlbnQgaXMgcmVhbGx5IGFuIGVycm9yLCBiZWNhdXNlIHdlJ3JlXG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgb25lIG9mIG91ciBjdXN0b20gZXJyb3IgY29kZXMuIFRyZWF0IGl0IGFzIHN1Y2guXG4gICAgICAgICAgICBSYXZpVXRpbHMuZXJyKFwiX2hhbmRsZVN0YXRlQ2hhbmdlOiBzaWduYWxpbmcgZXJyb3IgY29kZSBcIiArIGV2ZW50LmNvZGUgKyBcIjogIFwiICsgZXZlbnQucmVhc29uLCBcIlJhdmlTaWduYWxpbmdDb25uZWN0aW9uXCIpO1xuICAgICAgICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuRVJST1IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQW55IGFkZGl0aW9uYWwgbWVzc2FnaW5nIGhhbmRsaW5nIGdldHMgZG9uZSBieSB0aGUgbWFpblxuICAgIC8vIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uJ3MgbWVzc2FnZUhhbmRsZXJzXG4gICAgdGhpcy5fd2ViU29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihldmVudDogYW55KSB7IHNpZ25hbGluZ0Nvbm5lY3Rpb24uX2hhbmRsZU1lc3NhZ2UoZXZlbnQpOyB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VuZChtZXNzYWdlOiBhbnkpIHtcbiAgICBpZiAodGhpcy5fd2ViU29ja2V0ICYmIHRoaXMuX3dlYlNvY2tldC5yZWFkeVN0YXRlID09PSBjcm9zc1BsYXRmb3JtV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNlbmRpbmcgbWVzc2FnZSB0byBzZXJ2ZXI6IFwiICsgbWVzc2FnZSwgXCJSYXZpU2lnbmFsaW5nV2ViU29ja2V0SW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIHRoaXMuX3dlYlNvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2xvc2UoKSB7XG4gICAgdmFyIHNpZ25hbGluZ0Nvbm5lY3Rpb24gPSB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IGNsb3NlZCwgbWFrZSBzdXJlIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBrbm93cyBhYm91dCBpdCBhbmQgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgaWYgKCEgdGhpcy5fd2ViU29ja2V0IHx8IHRoaXMuX3dlYlNvY2tldC5yZWFkeVN0YXRlID09PSBjcm9zc1BsYXRmb3JtV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9oYW5kbGVTdGF0ZUNoYW5nZSh7fSwgUmF2aVNpZ25hbGluZ1N0YXRlcy5DTE9TRUQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3dlYlNvY2tldC5jbG9zZSgpO1xuICAgIHRoaXMuX3dlYlNvY2tldCA9IG51bGw7XG4gIH1cbn1cblxuIiwiaW1wb3J0IHsgUmF2aUNvbW1hbmRDb250cm9sbGVyIH0gZnJvbSBcIi4vUmF2aUNvbW1hbmRDb250cm9sbGVyXCI7XG5pbXBvcnQgeyBSYXZpVXRpbHMgfSBmcm9tIFwiLi9SYXZpVXRpbHNcIjtcblxuLyoqIFxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIEhhbmRsZXMgaW50ZXJhY3Rpbmcgd2l0aCBtZWRpYSBzdHJlYW1zIGZvciBSQVZJIHNlc3Npb25zLlxuICogVGhpcyBjbGFzcyBpcyBwcm92aWRlZCBieSBhIHtAbGluayBSYXZpU2Vzc2lvbn0gYW5kIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICpcbiAqIEV4YW1wbGUgdXNhZ2UgKHNldHRpbmcgYW4gYXVkaW8gb3V0cHV0IGNvbnRhaW5lcik6IFxuICogXG4gKiBgYGBcbiAqIHZhciBzdHJlYW1Db250cm9sbGVyID0gcmF2aVNlc3Npb24uZ2V0U3RyZWFtQ29udHJvbGxlcigpO1xuICogc3RyZWFtQ29udHJvbGxlci5zZXRBdWRpb0NvbnRhaW5lcihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVtb3RlQXVkaW8nKSk7XG4gKmBgYFxuICogICBcbiAqL1xuZXhwb3J0IGNsYXNzIFJhdmlTdHJlYW1Db250cm9sbGVyIHtcbiAgX2NvbW1hbmRDb250cm9sbGVyOiBSYXZpQ29tbWFuZENvbnRyb2xsZXI7XG4gIF9hdWRpb1N0cmVhbTogTWVkaWFTdHJlYW07XG4gIF92aWRlb1N0cmVhbTogTWVkaWFTdHJlYW07XG4gIF9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkOiBGdW5jdGlvbjtcbiAgX29uSW5wdXRBdWRpb0NoYW5nZWQ6IEZ1bmN0aW9uO1xuICBfb25JbnB1dFZpZGVvQ2hhbmdlZDogRnVuY3Rpb247XG4gIF92aWRlb0NvbnRhaW5lcjogSFRNTFZpZGVvRWxlbWVudDtcbiAgX2F1ZGlvQ29udGFpbmVyOiBIVE1MQXVkaW9FbGVtZW50O1xuICBfaW5wdXRBdWRpb1N0cmVhbTogTWVkaWFTdHJlYW07XG4gIF9pc1N0ZXJlbzogYm9vbGVhbjtcbiAgX2lucHV0VmlkZW9TdHJlYW06IE1lZGlhU3RyZWFtO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUkFWSSBzdHJlYW0gY29udHJvbGxlci4gXG4gICAqIE5lZWRzIGFjY2VzcyB0byBhIFJhdmlDb21tYW5kQ29udHJvbGxlciBzbyBpdCBjYW4gc2VuZCB2aWRlby1yZWxhdGVkIGNvbW1hbmRzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJhdmlDb21tYW5kQ29udHJvbGxlcjogUmF2aUNvbW1hbmRDb250cm9sbGVyKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aVN0cmVhbUNvbnRyb2xsZXJcIik7XG4gICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIgPSByYXZpQ29tbWFuZENvbnRyb2xsZXI7XG4gICAgXG4gICAgLy8gVGhlIGF1ZGlvIHN0cmVhbSBhbmQgdmlkZW8gc3RyZWFtIGdldCBzZXQgYnkgdGhlIFJhdmlTZXNzaW9uIHdoZW4gdGhlXG4gICAgLy8gYXBwcm9wcmlhdGUgZXZlbnRzIGFyZSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICB0aGlzLl9hdWRpb1N0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fdmlkZW9TdHJlYW0gPSBudWxsO1xuICAgIFxuICAgIC8vIERlZmF1bHQgZm9yIHRoZSB2aWRlbyBzdHJlYW0gc3RhdGUgY2hhbmdlIGhhbmRsZXJcbiAgICB0aGlzLl9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24gKHN0YXRlOiBhbnkpIHsgUmF2aVV0aWxzLmxvZyhcIm9udmlkZW9zdHJlYW1zdGF0ZWNoYW5nZWQgXCIgKyBzdGF0ZSwgXCJSYXZpU3RyZWFtQ29udHJvbGxlclwiKTt9XG4gICAgLy8gRGVmYXVsdCBmb3IgdGhlIGlucHV0IGF1ZGlvIHN0cmVhbSBjaGFuZ2UgaGFuZGxlclxuICAgIHRoaXMuX29uSW5wdXRBdWRpb0NoYW5nZWQgPSBudWxsO1xuICAgIHRoaXMuX29uSW5wdXRWaWRlb0NoYW5nZWQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBzdHJlYW0gY29udHJvbGxlciBpcyBhd2FyZSBvZiBhIHZpZGVvIHN0cmVhbSBjb21pbmcgZnJvbSB0aGUgUkFWSSBzZXJ2ZXIsIFxuICAgKiByZXR1cm4gaXQuIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyB2aWRlbyBzdHJlYW0gYXZhaWxhYmxlLlxuICAgKiBAcmV0dXJucyB7TWVkaWFTdHJlYW19XG4gICAqL1xuICBnZXRWaWRlb1N0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlkZW9TdHJlYW07XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZXQgYSB2aWRlbyBzdHJlYW0gZm9yIHRoaXMgc3RyZWFtIGNvbnRyb2xsZXIuIElmIHRoZXJlIGlzIGFsc28gYSB2aWRlbyBjb250YWluZXJcbiAgICogc2V0LCB0aGlzIHdpbGwgYXR0YWNoIHRoZSBzdHJlYW0gdG8gdGhhdCB2aWRlbyBjb250YWluZXIgYXMgd2VsbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRWaWRlb1N0cmVhbSh2aWRlb1N0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICB0aGlzLl92aWRlb1N0cmVhbSA9IHZpZGVvU3RyZWFtO1xuICAgIGlmICh0aGlzLl92aWRlb0NvbnRhaW5lcikge1xuICAgICAgdGhpcy5fdmlkZW9Db250YWluZXIuc3JjT2JqZWN0ID0gdGhpcy5fdmlkZW9TdHJlYW07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBsaXN0ZW5pbmcgdG8gdmlkZW8gc3RyZWFtIHN0YXRlIGNoYW5nZXNcbiAgICogQGNhbGxiYWNrIFJhdmlTdHJlYW1Db250cm9sbGVyfnZpZGVvU3RhdGVDaGFuZ2VDYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgQW4gb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIGluZm9ybWF0aW9uXG4gICAqIGFib3V0IHRoZSBzdGF0ZSBjaGFuZ2UuIFxuICAgKiBUT0RPOiBMaXN0IHRoZSBwb3NzaWJsZSBzdGF0ZXMuIFxuICAgKi9cbiAgLyoqXG4gICAqIFNldCB0aGUgRE9NIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBkaXNwbGF5IGluY29taW5nIFJBVkkgdmlkZW9cbiAgICogQSBjYWxsYmFjayBoYW5kbGVyIGNhbiBhbHNvIGJlIHNwZWNpZmllZCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB2aWRlbyBzdHJlYW0gY2hhbmdlIHN0YXRlXG4gICAqIFRoaXMgY2FsbCBtdXN0IGhhcHBlbiBiZWZvcmUgc3RhcnRpbmcgYSBzZXNzaW9uIGFuZCB0aGUgdmlkZW8gZWxlbWVudCBpcyBpbW11dGFibGVcbiAgICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSB2aWRlb0VsZW1lbnQgUmVmZXJlbmNlIHRvIHRoZSBKYXZhU2NyaXB0IERPTSBlbGVtZW50IGluIHdoaWNoIHRvIGRpc3BsYXkgdmlkZW8uIFxuICAgKiBJdCBpcyBleHBlY3RlZCB0aGF0IHRoaXMgZWxlbWVudCBpcyBhIFwidmlkZW9cIiBlbGVtZW50LiBXaGVuIGEgdmlkZW8gdHJhY2sgaXMgb2J0YWluZWRcbiAgICogZnJvbSB0aGUgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uLCB0aGlzIGVsZW1lbnQncyBzcmNPYmplY3Qgd2lsbCBiZSBzZXQgYWNjb3JkaW5nbHkuXG4gICAqIEBwYXJhbSB7UmF2aVN0cmVhbUNvbnRyb2xsZXJ+dmlkZW9TdGF0ZUNoYW5nZUNhbGxiYWNrfSBvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkIE9wdGlvbmFsIGNhbGxiYWNrIHRvIGNhdGNoIGNoYW5nZXMgb2YgdGhlIHZpZGVvIHN0cmVhbSBjaGFuZ2Ugc3RhdGVzLlxuICAgKi9cbiAgc2V0VmlkZW9Db250YWluZXIodmlkZW9FbGVtZW50OiBIVE1MVmlkZW9FbGVtZW50LCBvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkOiBGdW5jdGlvbikge1xuICAgIHRoaXMuX3ZpZGVvQ29udGFpbmVyID0gdmlkZW9FbGVtZW50O1xuICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBiZWVuIGEgdmlkZW8gc3RyZWFtIGFzc2lnbmVkLCBhdHRhY2ggaXRcbiAgICBpZiAodGhpcy5fdmlkZW9TdHJlYW0pIHtcbiAgICAgIHRoaXMuX3ZpZGVvQ29udGFpbmVyLnNyY09iamVjdCA9IHRoaXMuX3ZpZGVvU3RyZWFtO1xuICAgIH1cbiAgICB0aGlzLnNldFZpZGVvU3RhdGVDaGFuZ2VIYW5kbGVyKG9udmlkZW9zdHJlYW1zdGF0ZWNoYW5nZWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogQXNzaWduIGEgY2FsbGJhY2sgaGFuZGxlciBmb3Igd2hlbiB0aGUgdmlkZW8gc3RyZWFtIHN0YXRlIGNoYW5nZXNcbiAgICogQHBhcmFtIHtSYXZpU3RyZWFtQ29udHJvbGxlcn52aWRlb1N0YXRlQ2hhbmdlQ2FsbGJhY2t9IG9udmlkZW9zdHJlYW1zdGF0ZWNoYW5nZWQgQ2FsbGJhY2sgdG8gY2F0Y2ggY2hhbmdlcyBvZiB0aGUgdmlkZW8gc3RyZWFtIGNoYW5nZSBzdGF0ZXMuXG4gICAqL1xuICBzZXRWaWRlb1N0YXRlQ2hhbmdlSGFuZGxlcihvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkOiBGdW5jdGlvbikge1xuICAgIGlmIChvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkID0gb252aWRlb3N0cmVhbXN0YXRlY2hhbmdlZDtcbiAgICB9IFxuICB9XG5cbiAgLyoqXG4gICAqIFRlbGwgdGhlIFJBVkkgc2VydmVyIHRvIGluY2x1ZGUgdGhlIHZpZGVvIFwiZGFzaGJvYXJkXCIgYXMgcGFydCBvZiB0aGUgdmlkZW8gc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBvciBmYWxzZSwgdG8gc2hvdyBvciBub3Qgc2hvdyB0aGUgZGFzaGJvYXJkLlxuICAgKi9cbiAgc2hvd1ZpZGVvRGFzaGJvYXJkKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9jb21tYW5kQ29udHJvbGxlci5xdWV1ZUNvbW1hbmQoXCJ2aWRlby5zaG93RGFzaGJvYXJkXCIsIHtcImVuYWJsZWRcIjogZW5hYmxlZH0sIG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBUZWxsIHRoZSBSQVZJIHNlcnZlciB0byBpbmNsdWRlIGEgXCJyZW1vdGUgY3Vyc29yXCIgYXMgcGFydCBvZiB0aGUgdmlkZW8gc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBvciBmYWxzZSwgdG8gc2hvdyBvciBub3Qgc2hvdyB0aGUgcmVtb3RlIGN1cnNvci5cbiAgICovXG4gIHNob3dWaWRlb0N1cnNvcihlbmFibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIucXVldWVDb21tYW5kKFwidmlkZW8uc2hvd0N1cnNvclwiLCB7XCJlbmFibGVkXCI6IGVuYWJsZWR9LCBudWxsKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIElmIHRoZSBzdHJlYW0gY29udHJvbGxlciBpcyBhd2FyZSBvZiBhbiBhdWRpbyBzdHJlYW0gY29taW5nIGZyb20gdGhlIFJBVkkgc2VydmVyLCBcbiAgICogcmV0dXJuIGl0LiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gYXVkaW8gc3RyZWFtIGF2YWlsYWJsZS5cbiAgICogQHJldHVybnMge01lZGlhU3RyZWFtfVxuICAgKi9cbiAgZ2V0QXVkaW9TdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1ZGlvU3RyZWFtO1xuICB9XG4gIFxuICAvKipcbiAgICogU2V0IGFuIGF1ZGlvIHN0cmVhbSBmb3IgdGhpcyBzdHJlYW0gY29udHJvbGxlci4gSWYgdGhlcmUgaXMgYWxzbyBhbiBhdWRpbyBjb250YWluZXJcbiAgICogc2V0LCB0aGlzIHdpbGwgYXR0YWNoIHRoZSBzdHJlYW0gdG8gdGhhdCBhdWRpbyBjb250YWluZXIgYXMgd2VsbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRBdWRpb1N0cmVhbShhdWRpb1N0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICB0aGlzLl9hdWRpb1N0cmVhbSA9IGF1ZGlvU3RyZWFtO1xuICAgIGlmICh0aGlzLl9hdWRpb0NvbnRhaW5lcikge1xuICAgICAgdGhpcy5fYXVkaW9Db250YWluZXIuc3JjT2JqZWN0ID0gdGhpcy5fYXVkaW9TdHJlYW07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgRE9NIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBwbGF5IGluY29taW5nIFJBVkkgYXVkaW9cbiAgICogQHBhcmFtIHtFbGVtZW50fSBhdWRpb0VsZW1lbnQgUmVmZXJlbmNlIHRvIHRoZSBKYXZhU2NyaXB0IERPTSBlbGVtZW50IGluIHdoaWNoIHRvIHBsYXkgYXVkaW9cbiAgICogc2VudCBmcm9tIHRoZSByZW1vdGUgUkFWSSBzZXJ2ZXIuIFxuICAgKiBJdCBpcyBleHBlY3RlZCB0aGF0IHRoaXMgZWxlbWVudCBpcyBhbiBcImF1ZGlvXCIgZWxlbWVudC4gV2hlbiBhbiBhdWRpbyB0cmFjayBpcyBvYnRhaW5lZFxuICAgKiBmcm9tIHRoZSBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24sIHRoaXMgZWxlbWVudCdzIHNyY09iamVjdCB3aWxsIGJlIHNldCBhY2NvcmRpbmdseS5cbiAgICovXG4gIHNldEF1ZGlvQ29udGFpbmVyKGF1ZGlvRWxlbWVudDogSFRNTEF1ZGlvRWxlbWVudCkge1xuICAgIHRoaXMuX2F1ZGlvQ29udGFpbmVyID0gYXVkaW9FbGVtZW50O1xuICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBiZWVuIGFuIGF1ZGlvIHN0cmVhbSBhc3NpZ25lZCwgYXR0YWNoIGl0XG4gICAgaWYgKHRoaXMuX2F1ZGlvU3RyZWFtKSB7XG4gICAgICB0aGlzLl9hdWRpb0NvbnRhaW5lci5zcmNPYmplY3QgPSB0aGlzLl9hdWRpb1N0cmVhbTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdHJlYW0gdGhhdCBzaG91bGQgYmUgdXNlZCB0byBzZW5kIFJBVkkgYXVkaW8uXG4gICAqIFxuICAgKiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiBgYGBcbiAgICogICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlLCB2aWRlbzogZmFsc2UgfSlcbiAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgKiAgICAgc3RyZWFtQ29udHJvbGxlci5zZXRJbnB1dEF1ZGlvKHN0cmVhbSk7XG4gICAqICAgfSlcbiAgICogIFxuICAgKmBgYFxuICAgKiBJZiB0aGVyZSBpcyBhIGNhbGxiYWNrIGFzc2lnbmVkIHZpYSBzZXRJbnB1dEF1ZGlvQ2hhbmdlSGFuZGxlcigpLFxuICAgKiBpdCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgc3RyZWFtIGlzIHNldC5cbiAgICogXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbSBUaGUgYXVkaW8gc3RyZWFtIGJlaW5nIHVzZWQgdG8gY2FwdHVyZSBsb2NhbCBtZWRpYS5cbiAgICogR2VuZXJhbGx5IHRoaXMgd2lsbCBiZSByZXR1cm5lZCBmcm9tIGdldFVzZXJNZWRpYSgpICBcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1N0ZXJlbyAtIENhbiBiZSB0cnVlIHRvIGluZGljYXRlIHRoYXQgdGhlIHN0cmVhbSBpcyBzdGVyZW8uXG4gICAqIFRoZSBkZWZhdWx0IGlzIGZhbHNlLlxuICAgKi9cbiAgc2V0SW5wdXRBdWRpbyhzdHJlYW06IE1lZGlhU3RyZWFtLCBpc1N0ZXJlbyA9IGZhbHNlKSB7XG4gICAgdGhpcy5faW5wdXRBdWRpb1N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9pc1N0ZXJlbyA9IGlzU3RlcmVvO1xuICAgIGlmICh0aGlzLl9vbklucHV0QXVkaW9DaGFuZ2VkKSB0aGlzLl9vbklucHV0QXVkaW9DaGFuZ2VkKHN0cmVhbSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBpbnB1dCBhdWRpbyBzdHJlYW0gaXMgY2hhbmdlZFxuICAgKiB2aWEgc2V0SW5wdXRBdWRpbygpIFxuICAgKiBAY2FsbGJhY2sgUmF2aVN0cmVhbUNvbnRyb2xsZXJ+aW5wdXRBdWRpb0NoYW5nZUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW0gVGhlIG5ldyBzdHJlYW1cbiAgICovXG4gIC8qKlxuICAgKiBBc3NpZ24gYSBjYWxsYmFjayBoYW5kbGVyIGZvciB3aGVuIHRoZSBpbnB1dCBhdWRpbyBzdHJlYW0gZ2V0cyBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7UmF2aVN0cmVhbUNvbnRyb2xsZXJ+aW5wdXRBdWRpb0NoYW5nZUNhbGxiYWNrfSBvbmlucHV0YXVkaW9jaGFuZ2VkIENhbGxiYWNrIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgaW5wdXQgYXVkaW8gY2hhbmdlc1xuICAgKi9cbiAgc2V0SW5wdXRBdWRpb0NoYW5nZUhhbmRsZXIob25pbnB1dGF1ZGlvY2hhbmdlZDogRnVuY3Rpb24pIHtcbiAgICBpZiAob25pbnB1dGF1ZGlvY2hhbmdlZCkge1xuICAgICAgdGhpcy5fb25JbnB1dEF1ZGlvQ2hhbmdlZCA9IG9uaW5wdXRhdWRpb2NoYW5nZWQ7XG4gICAgfSBcbiAgfVxuICBcblxuICBzZXRJbnB1dFZpZGVvKHN0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICB0aGlzLl9pbnB1dFZpZGVvU3RyZWFtID0gc3RyZWFtO1xuICAgIGlmICh0aGlzLl9vbklucHV0VmlkZW9DaGFuZ2VkKSB0aGlzLl9vbklucHV0VmlkZW9DaGFuZ2VkKHN0cmVhbSk7XG4gIH1cblxuICBzZXRJbnB1dFZpZGVvQ2hhbmdlSGFuZGxlcihvbmlucHV0dmlkZW9jaGFuZ2VkOiBGdW5jdGlvbikge1xuICAgIGlmIChvbmlucHV0dmlkZW9jaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9vbklucHV0VmlkZW9DaGFuZ2VkID0gb25pbnB1dHZpZGVvY2hhbmdlZDtcbiAgICB9IFxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBpbmNvbWluZyBhdWRpbyBzdHJlYW0gc3VwcG9ydHMgc3RlcmVvIGlucHV0LFxuICAgKiBhcyBzcGVjaWZpZWQgYnkgc2V0SW5wdXRBdWRpby5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhpcyBpbnB1dCBhdWRpbyB0cmFjayBzdXBwb3J0cyBzdGVyZW8gaW5wdXRcbiAgICovXG4gIGlzU3RlcmVvSW5wdXQoKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgc3RhdGUgb2YgcGxheSBpcyB0aGF0IHRoZXJlIGlzIHRvbyBtdWNoIGNvbmZ1c2lvbiBpbiB0cnlpbmcgdG9cbiAgICAvLyBjb21wdXRlIHRoaXMgZnJvbSB0aGUgc3RyZWFtIHRyYWNrczpcbiAgICAvLyBUaGUgYnJvd3NlcidzIGdldFVzZXJNZWRpYSBmYWxzZWx5IHJlcG9ydHMgYSBjaGFubmVsQ291bnQgb2YgMiwgc28gd2Ugd291bGRcbiAgICAvLyBmYWxzZWx5IHJlcG9ydCBzdGVyZW8uXG4gICAgLy8gVGhlIE5vZGVKUyB3cnRjIHBhY2thZ2UgaGFzIGEgTWVkaWFTdHJlYW0gdGhhdCBkb2Vzbid0IHN1cHBvcnQgZ2V0U2V0dGluZ3NcbiAgICAvLyBhdCBhbGwsIHNvIHdlIHdvdWxkIGZhbHNlbHkgcmVwb3J0IG1vbm8uXG4gICAgcmV0dXJuIHRoaXMuX2lzU3RlcmVvO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCB0aGUgY29udmVyc2F0aW9uIGJ5IHN0b3BwaW5nIGFueSBpbmNvbWluZyB2aWRlb1xuICAgKiBhbmQgcmVtb3RlIGF1ZGlvIHN0cmVhbXMgYW5kIFxuICAgKiByZXNldCB0aGUgc291cmNlIG9iamVjdHMgb2YgdGhlaXIgY29udGFpbmVycy5cbiAgICogTm90ZSB0aGF0IHRoaXMgZG9lcyBOT1Qgc3RvcCBhbnkgbG9jYWwgYXVkaW8gc3RyZWFtcyB0aGF0XG4gICAqIG1pZ2h0IGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGVlckNvbm5lY3Rpb24gLS0gaXQgbGVhdmVzXG4gICAqIGhhbmRsaW5nIG9mIHRoYXQgbG9jYWwgYXVkaW8gc3RyZWFtIHRvIHRoZSBpbXBsZW1lbnRpbmcgY2xpZW50LlxuICAgKiBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdG9wKCkge1xuICAgIFJhdmlVdGlscy5sb2coXCJzdG9wcGluZyBzdHJlYW1zXCIsIFwiUmF2aVN0cmVhbUNvbnRyb2xsZXJcIik7XG5cbiAgICBpZiAodGhpcy5fdmlkZW9Db250YWluZXIgJiYgdGhpcy5fdmlkZW9Db250YWluZXIuc3JjT2JqZWN0KSB7XG4gICAgICBsZXQgc3JjT2JqZWN0ID0gPE1lZGlhU3RyZWFtPiB0aGlzLl92aWRlb0NvbnRhaW5lci5zcmNPYmplY3Q7XG4gICAgICBsZXQgdHJhY2tzID0gc3JjT2JqZWN0LmdldFRyYWNrcygpO1xuICAgICAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgIHRoaXMuX3ZpZGVvQ29udGFpbmVyLnNyY09iamVjdCA9IG51bGw7XG4gICAgICB0aGlzLl9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkKFwib3ZlclwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5fYXVkaW9TdHJlYW0pIHtcbiAgICAgIHRoaXMuX2F1ZGlvU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgIHRoaXMuX2F1ZGlvU3RyZWFtID0gbnVsbDtcbiAgICB9XG4gICAgXG4gIH1cblxufVxuIiwidmFyIERFQlVHID0gdHJ1ZTtcblxuLyoqIFxuICpcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBDb2xsZWN0aW9uIG9mIHN0YXRpYyB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJhdmlVdGlscyB7XG5cblxuICAvKipcbiAgICogU2ltcGxlIFVVSUQgaW1wbGVtZW50YXRpb24uXG4gICAqIFRha2VuIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA1MDc0LzUxNTU4NFxuICAgKiBTdHJpY3RseSBzcGVha2luZywgaXQncyBub3QgYSByZWFsIFVVSUQsIGJ1dCBpdCBnaXZlcyB1cyB3aGF0IHdlIG5lZWRcbiAgICogZm9yIFJBVkkgaGFuZGxpbmcuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlVVVJRCgpOiBzdHJpbmcge1xuICAgIGZ1bmN0aW9uIHM0KCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gIH1cbiAgXG4gIFxuICAvKipcbiAgICogV3JhcHMgY29uc29sZS5sb2cgc3VjaCB0aGF0IHdlIHdpbGwgb25seSBvdXRwdXQgYSBtZXNzYWdlIHRvXG4gICAqIGNvbnNvbGUubG9nIGlmIHRoZSBjb25zdGFudCBERUJVRyAoY3VycmVudGx5LCB0aGlzIGlzIHNpbXBseSBkZWZpbmVkXG4gICAqIGFzIGEgZ2xvYmFsIHZhcmlhYmxlIGluaGVyaXRlZCBieSB0aGUgcmF2aS5qcyBmaWxlLCB3aGljaCBpcyBhIGxpdHRsZVxuICAgKiBhd2Z1bCkgaXMgc2V0IHRvIGB0cnVlYC4gKERlZmF1bHRzIHRvIHRydWUuKVxuICAgKiBUaGlzIG1ldGhvZCBkaXNwYXRjaGVzIGEgXCJsb2dnZXJcIiBldmVudCBvbiB0aGUgZG9jdW1lbnQgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBkbyBzb21ldGhpbmcgZWxzZSB3aXRoIHRoZSBtZXNzYWdlLiBJdCB3aWxsIGFsd2F5c1xuICAgKiBkaXNwYXRjaCB0aGlzIGV2ZW50IHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3QgaXQncyBpbiBERUJVRyBtb2RlLFxuICAgKiBiZWNhdXNlIHByZXN1bWFibHkgaWYgeW91J3JlIGxpc3RlbmluZyBmb3IgdGhlIGV2ZW50IGl0J3MgYmVjYXVzZSB5b3VcbiAgICogd2FudCB0byBnZXQgbWVzc2FnZXMuXG4gICAqL1xuICBzdGF0aWMgbG9nKG1lc3NhZ2U6IHN0cmluZywgY2xhc3NuYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIGNsYXNzbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIG1lc3NhZ2UgPSBjbGFzc25hbWUgKyBcIjogXCIgKyBtZXNzYWdlO1xuICAgIGlmIChERUJVRykge1xuICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbG9nZ2VyJywge2RldGFpbDogbWVzc2FnZX0pKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFkZGl0aW9uYWxseSwgYW4gZXJyb3Igd2FzIGVuY291bnRlcmVkIHRyeWluZyB0byBsb2cgdGhhdC5cIilcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgY29uc29sZS5sb2cgc3VjaCB0aGF0IHdlIHdpbGwgQUxXQVlTIG91dHB1dCBhIG1lc3NhZ2UsIGFuZFxuICAgKiB0aGF0IG1lc3NhZ2Ugd2lsbCBiZSBpbiByZWQuXG4gICAqIFRoaXMgbWV0aG9kIGRpc3BhdGNoZXMgYW4gXCJlcnJsb2dnZXJcIiBldmVudCBvbiB0aGUgZG9jdW1lbnQgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBkbyBzb21ldGhpbmcgZWxzZSB3aXRoIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgc3RhdGljIGVycihtZXNzYWdlOiBzdHJpbmcsIGNsYXNzbmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBjbGFzc25hbWUgIT09ICd1bmRlZmluZWQnKSBtZXNzYWdlID0gY2xhc3NuYW1lICsgXCI6IFwiICsgbWVzc2FnZTtcbiAgICBjb25zb2xlLmxvZygnJWMgJXMnLCAnY29sb3I6ICNGQjBBMUMnLCBtZXNzYWdlKTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2VycmxvZ2dlcicsIHtkZXRhaWw6IG1lc3NhZ2V9KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC8vIFJldHVybiBKU09OLnN0cmluZ2lmeShpdGVtKSBpZiBwb3NzaWJsZSwgZWxzZSBpdGVtXG4gICAqL1xuICBzdGF0aWMgc2FmZWx5UHJpbnRhYmxlKGl0ZW06IGFueSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogRmlndXJlcyBvdXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgYSBET00gZWxlbWVudC5cbiAgICovXG4gIHN0YXRpYyBnZXRFbGVtZW50Q1NTU2l6ZShlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBpZiAoIWdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgdmFyIHcgPSBwYXJzZUludChjcy5nZXRQcm9wZXJ0eVZhbHVlKFwid2lkdGhcIiksIDEwKTtcbiAgICB2YXIgaCA9IHBhcnNlSW50KGNzLmdldFByb3BlcnR5VmFsdWUoXCJoZWlnaHRcIiksIDEwKTtcbiAgICByZXR1cm4ge3dpZHRoOiB3LCBoZWlnaHQ6IGh9XG4gIH1cbiAgXG4gIFxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBcImRlYnVnXCIgbW9kZS4gSW4gZGVidWcgbW9kZSwgbW9zdCBldmVyeXRoaW5nIGdldHNcbiAgICogcHJpbnRlZCB0byB0aGUgSlMgY29uc29sZS4gKFNlZSBhbHNvIFJhdmlVdGlscy5qcylcbiAgICogY29ubmVjdHMgdG8gdGhlIHNwZWNpZmllZCBXZWJTb2NrZXQgYWRkcmVzcy5cbiAgICogQHBhcmFtIHtib29sZWFufSBkZWJ1ZyBXaGV0aGVyIG9yIG5vdCB0byBwdXQgdGhlIGxvZ2dlciBpbnRvIGRlYnVnIG1vZGUuXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBzZXREZWJ1ZyhkZWJ1ZzogYm9vbGVhbikge1xuICAgIERFQlVHID0gZGVidWc7XG4gIH1cblxufVxuIiwiLyoqXG4gKiBUaGlzIHV0aWxpdHkgTW9kdWxlIGNvbnRhaW5zIGNvZGUgcmVsYXRlZCB0byBsb2dnaW5nIGZyb20gd2l0aGluIEFQSSBmdW5jdGlvbnMuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG4vKipcbiAqIFVzZWQgZm9yIGRldGVybWluaW5nIHdoYXQgZGF0YSB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBDbGllbnQgQVBJIHNob3VsZCBwcmludCB0byB0aGUgY29uc29sZS4gXG4gKi9cbmV4cG9ydCBlbnVtIEhpRmlMb2dMZXZlbCB7XG4gICAgTm9uZSA9IFwiTm9uZVwiLFxuICAgIEVycm9yID0gXCJFcnJvclwiLFxuICAgIFdhcm4gPSBcIldhcm5cIixcbiAgICBEZWJ1ZyA9IFwiRGVidWdcIixcbn1cblxuLyoqXG4gKiBBIHdyYXBwZXIgZm9yIEFQSS1pbnRlcm5hbCBgY29uc29sZS4qKClgIGNhbGxzLCBnYXRlZCBieSB0aGUgdXNlcidzIGN1cnJlbnQgbG9nIGxldmVsLlxuICovXG5leHBvcnQgY2xhc3MgSGlGaUxvZ2dlciB7XG4gICAgc3RhdGljIGxvZ0xldmVsOiBIaUZpTG9nTGV2ZWwgPSBIaUZpTG9nTGV2ZWwuRXJyb3I7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbG9nTGV2ZWwgVGhlIGluaXRpYWwgTG9nIExldmVsIGZvciBvdXIgTG9nZ2VyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZ0xldmVsPzogSGlGaUxvZ0xldmVsKSB7XG4gICAgICAgIGxvZ0xldmVsID0gbG9nTGV2ZWwgPyBsb2dMZXZlbCA6IEhpRmlMb2dMZXZlbC5EZWJ1ZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IEhpRmkgTG9nIExldmVsLlxuICAgICAqIEBwYXJhbSBuZXdMb2dMZXZlbCBUaGUgbmV3IExvZyBMZXZlbCBmb3Igb3VyIExvZ2dlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0SGlGaUxvZ0xldmVsKG5ld0xvZ0xldmVsOiBIaUZpTG9nTGV2ZWwpOiB2b2lkIHtcbiAgICAgICAgSGlGaUxvZ2dlci5sb2dMZXZlbCA9IG5ld0xvZ0xldmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBMb2dnZXIncyBsb2cgbGV2ZWwgaXMgYERlYnVnYCwgd2lsbCBwcmludCBhIGRlYnVnIGxvZyB0byB0aGUgbG9ncy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2cuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXNzYWdlIHdhcyBvdXRwdXQgdG8gdGhlIGNvbnNvbGU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBsb2cobWVzc2FnZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChIaUZpTG9nZ2VyLmxvZ0xldmVsID09PSBIaUZpTG9nTGV2ZWwuRGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSBzYW1lIHRoaW5nIGFzIHtAbGluayBsb2d9LlxuICAgICAqIEBwYXJhbSBtZXNzYWdlXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXNzYWdlIHdhcyBvdXRwdXQgdG8gdGhlIGNvbnNvbGU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBkZWJ1ZyhtZXNzYWdlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBMb2dnZXIncyBsb2cgbGV2ZWwgaXMgYERlYnVnYCBvciBgV2FybmAsIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGxvZyB0byB0aGUgbG9ncy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2cuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXNzYWdlIHdhcyBvdXRwdXQgdG8gdGhlIGNvbnNvbGU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyB3YXJuKG1lc3NhZ2U6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoSGlGaUxvZ2dlci5sb2dMZXZlbCA9PT0gSGlGaUxvZ0xldmVsLkRlYnVnIHx8IEhpRmlMb2dnZXIubG9nTGV2ZWwgPT09IEhpRmlMb2dMZXZlbC5XYXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBMb2dnZXIncyBsb2cgbGV2ZWwgaXMgYERlYnVnYCBvciBgV2FybmAgb3IgYEVycm9yYCwgd2lsbCBwcmludCBhbiBlcnJvciBsb2cgdG8gdGhlIGxvZ3MuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWVzc2FnZSB3YXMgb3V0cHV0IHRvIHRoZSBjb25zb2xlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZXJyb3IobWVzc2FnZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChIaUZpTG9nZ2VyLmxvZ0xldmVsID09PSBIaUZpTG9nTGV2ZWwuRGVidWcgfHwgSGlGaUxvZ2dlci5sb2dMZXZlbCA9PT0gSGlGaUxvZ0xldmVsLldhcm4gfHwgSGlGaUxvZ2dlci5sb2dMZXZlbCA9PT0gSGlGaUxvZ0xldmVsLkVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqIFRoaXMgTW9kdWxlIGNvbnRhaW5zIGEgbnVtYmVyIG9mIHVzZWZ1bCB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IEFQSSB1c2VycyBjYW4gdXNlIGluIHRoZWlyIGFwcGxpY2F0aW9ucyBpZiB0aGV5IHdpc2guXG4gKiBTb21lIG9mIHRoZW0gYXJlIGFsc28gdXNlZCBpbnRlcm5hbGx5IGluIEFQSSBjb2RlLlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cblxuaW1wb3J0IHsgSGlGaUxvZ2dlciB9IGZyb20gXCIuL0hpRmlMb2dnZXJcIjtcblxuZnVuY3Rpb24gZHluYW1pY1JlcXVpcmUobW9kOiBhbnksIHJlcXVpcmVTdHJpbmc6IHN0cmluZyk6IGFueSB7XG4gICAgcmV0dXJuIG1vZC5yZXF1aXJlKHJlcXVpcmVTdHJpbmcpO1xufVxuXG5sZXQgbm93OmFueTtcbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBub2RlIGNvbnRleHRcbiAgICB0cnkge1xuICAgICAgICBub3cgPSBkeW5hbWljUmVxdWlyZShtb2R1bGUsICdwZXJmX2hvb2tzJykucGVyZm9ybWFuY2Uubm93OyAvLyBVc2VkIHdpdGggYHByZWNpc2VJbnRlcnZhbCgpYC5cbiAgICB9IGNhdGNoIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBIaUZpVXRpbGl0aWVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTIE9iamVjdCBjb250YWluaW5nIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gcGFzc2VkIG9iamVjdHMuXG4gICAgICogXG4gICAgICogVGhpcyBmdW5jdGlvbiB3YXMgYWRhcHRlZCBmcm9tIFt0aGlzIHZlcnkgaGVscGZ1bCBkb2N1bWVudCBvbiBHb01ha2VUaGluZ3Nde0BsaW5rIGh0dHBzOi8vZ29tYWtldGhpbmdzLmNvbS9nZXR0aW5nLXRoZS1kaWZmZXJlbmNlcy1iZXR3ZWVuLXR3by1vYmplY3RzLXdpdGgtdmFuaWxsYS1qcy99LlxuICAgICAqIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAgICogXG4gICAgICogQHBhcmFtIG9iajEgXG4gICAgICogQHBhcmFtIG9iajIgXG4gICAgICovXG4gICAgc3RhdGljIHJlY3Vyc2l2ZWx5RGlmZk9iamVjdHMob2JqMTogYW55LCBvYmoyOiBhbnkpOiBhbnkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgYW4gb2JqZWN0IHRvIGNvbXBhcmUgaXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKCFvYmoyIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmoyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVmFyaWFibGVzXG4gICAgICAgIC8vXG4gICAgICAgIGxldCBkaWZmczogYW55ID0ge307XG4gICAgICAgIGxldCBrZXk7XG5cbiAgICAgICAgbGV0IGRvQXJyYXlzTWF0Y2ggPSAoYXJyMTogQXJyYXk8YW55PiwgYXJyMjogQXJyYXk8YW55PikgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFycmF5cyBhcmUgdGhlIHNhbWUgbGVuZ3RoXG4gICAgICAgICAgICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbGwgaXRlbXMgZXhpc3QgYW5kIGFyZSBpbiB0aGUgc2FtZSBvcmRlclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ29tcGFyZSB0d28gaXRlbXMgYW5kIHB1c2ggbm9uLW1hdGNoZXMgdG8gb2JqZWN0XG4gICAgICAgIGxldCBjb21wYXJlID0gKGl0ZW0xOiBhbnksIGl0ZW0yOiBhbnksIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIG9iamVjdCB0eXBlXG4gICAgICAgICAgICBsZXQgdHlwZTEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlbTEpO1xuICAgICAgICAgICAgbGV0IHR5cGUyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZW0yKTtcblxuICAgICAgICAgICAgLy8gSWYgdHlwZTIgaXMgdW5kZWZpbmVkIGl0IGhhcyBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgIGlmICh0eXBlMiA9PT0gJ1tvYmplY3QgVW5kZWZpbmVkXScpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGl0ZW1zIGFyZSBkaWZmZXJlbnQgdHlwZXNcbiAgICAgICAgICAgIGlmICh0eXBlMSAhPT0gdHlwZTIpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gaXRlbTI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhbiBvYmplY3QsIGNvbXBhcmUgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgIGlmICh0eXBlMSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JqRGlmZiA9IEhpRmlVdGlsaXRpZXMucmVjdXJzaXZlbHlEaWZmT2JqZWN0cyhpdGVtMSwgaXRlbTIpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvYmpEaWZmKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZzW2tleV0gPSBvYmpEaWZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGFuIGFycmF5LCBjb21wYXJlXG4gICAgICAgICAgICBpZiAodHlwZTEgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRvQXJyYXlzTWF0Y2goaXRlbTEsIGl0ZW0yKSkge1xuICAgICAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gaXRlbTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRWxzZSBpZiBpdCdzIGEgZnVuY3Rpb24sIGNvbnZlcnQgdG8gYSBzdHJpbmcgYW5kIGNvbXBhcmVcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwganVzdCBjb21wYXJlXG4gICAgICAgICAgICBpZiAodHlwZTEgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbTEudG9TdHJpbmcoKSAhPT0gaXRlbTIudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gaXRlbTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbTEgIT09IGl0ZW0yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZzW2tleV0gPSBpdGVtMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSBmaXJzdCBvYmplY3RcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqMSkge1xuICAgICAgICAgICAgaWYgKG9iajEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbXBhcmUob2JqMVtrZXldLCBvYmoyW2tleV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIHNlY29uZCBvYmplY3QgYW5kIGZpbmQgbWlzc2luZyBpdGVtc1xuICAgICAgICBmb3IgKGtleSBpbiBvYmoyKSB7XG4gICAgICAgICAgICBpZiAob2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmoxW2tleV0gJiYgb2JqMVtrZXldICE9PSBvYmoyW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZnNba2V5XSA9IG9iajJba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIG9iamVjdCBvZiBkaWZmZXJlbmNlc1xuICAgICAgICByZXR1cm4gZGlmZnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBcImJlc3RcIiBhdWRpbyBjb25zdHJhaW50cyBzdXBwb3J0ZWQgYnkgdGhlIGNsaWVudC4gSW4gdGhpcyBjYXNlLCBcImJlc3RcIiBpcyBkZWZpbmVkIGFzIFwidGhlIGNvbnN0cmFpbnRzIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSBoaWdoZXN0LXF1YWxpdHkgYXVkaW8uXCJcbiAgICAgKiBUaGF0IG1lYW5zIGRpc2FibGluZyBFY2hvIENhbmNlbGxhdGlvbiwgZGlzYWJsaW5nIE5vaXNlIFN1cHByZXNzaW9uLCBhbmQgZGlzYWJsaW5nIEF1dG9tYXRpYyBHYWluIENvbnRyb2wuXG4gICAgICovXG4gICAgc3RhdGljIGdldEJlc3RBdWRpb0NvbnN0cmFpbnRzKCk6IGFueSB7XG4gICAgICAgIGxldCBhdWRpb0NvbnN0cmFpbnRzOiBhbnkgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIChuYXZpZ2F0b3IpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuZWNob0NhbmNlbGxhdGlvbikge1xuICAgICAgICAgICAgYXVkaW9Db25zdHJhaW50cy5lY2hvQ2FuY2VsbGF0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIChuYXZpZ2F0b3IpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkubm9pc2VTdXBwcmVzc2lvbikge1xuICAgICAgICAgICAgYXVkaW9Db25zdHJhaW50cy5ub2lzZVN1cHByZXNzaW9uID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIChuYXZpZ2F0b3IpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuYXV0b0dhaW5Db250cm9sKSB7XG4gICAgICAgICAgICBhdWRpb0NvbnN0cmFpbnRzLmF1dG9HYWluQ29udHJvbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF1ZGlvQ29uc3RyYWludHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYHByZWNpc2VJbnRlcnZhbCgpYCBpcyBhIHZlcnNpb24gb2YgYHNldEludGVydmFsKClgIGZvciBOb2RlSlMgdGhhdCBkb2VzIG5vdCBzcGluIENQVXMgbm9yIGRyaWZ0LlxuICAgICAqIFRoZSByZXR1cm5lZCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhIGBjbGVhcigpYCBtZXRob2RzIHRoYXQgc3RvcHMgdGhlIGludGVydmFsLlxuICAgICAqIEluIHRoZSBicm93c2VyIGNvbnRleHQsIGBwcmVjaXNlSW50ZXJ2YWwoKWAgaXMgc2ltcGx5IGEgd3JhcHBlciBmb3IgYHNldEludGVydmFsKClgLlxuICAgICAqIFxuICAgICAqIFdlIGRvIHRocmVlIHRoaW5nczpcbiAgICAgKiAxLiBLZWVwIGEgcnVubmluZyBjb3VudGVyIG9mIHdoZW4gdGhlIG5leHQgY2FsbCBzaG91bGQgYmUsIHRvIGF2b2lkIGRyaWZ0LlxuICAgICAqIDIuIENvbXB1dGUgdGhlIHRpbWUgdG8gdGhlIG5leHQgY2FsbCBhbmQgZ2l2ZSB0aGF0IHRvIGBzZXRUaW1lb3V0KClgLlxuICAgICAqIDMuIE91ciBhdmVyYWdlIGVycm9yIHdpdGggdGhlIGFib3ZlIGlzIGFib3V0IDFtcyAoc28gaGFsZiB0aGUgaW50ZXJ2YWxzIGFyZSBvZmYgYnkgbW9yZSkuXG4gICAgICogU28gaW4gIzIsIHNob290IGZvciAyIG1zIGxlc3MgdGhhbiB0aGF0LCBhbmQgc3BpbiB3aXRoIHNldEltbWVkaWF0ZSAoYWxsb3dpbmcgb3RoZXIgc3R1ZmYgdG8gcnVuKSB1bnRpbCB3ZSd2ZSByZWFjaGVkIHRoZSBleHBlY3RlZCB0aW1lLlxuICAgICAqIFxuICAgICAqIEZvciBhIDEwbXMgaW50ZXJ2YWwsIHdlIG1lYXN1cmVkIGFuICoqYXZlcmFnZSoqIGVycm9yIHBlciBpbnRlcnZhbCBvZjpcbiAgICAgKiAtIGAxLjY3IG1zYCBmb3IgYHNldEludGVydmFsKClgIChzbyBTT01FVEhJTkcgaXMgdGlja2luZyBhdCA2MCBIeikuXG4gICAgICogLSBgfjEgbXNgIGZvciB0aGlzIGNvZGUgV0lUSE9VVCAjMywgdXNpbmcgYERhdGUuZ2V0VGltZSgpYFxuICAgICAqIC0gYH4xIG1zYCBmb3IgdGhpcyBjb2RlIFdJVEhPVVQgIzMsIHVzaW5nIGBwZXJmX2hvb2tzLnBlcmZvcm1hbmNlLm5vdygpYFxuICAgICAqIC0gYDAuODYgbXNgIGZvciB0aGlzIGNvZGUgdXNpbmcgYERhdGUuZ2V0VGltZSgpYFxuICAgICAqIC0gYDAuMDMgbXNgIGZvciB0aGlzIGNvZGUgdXNpbmcgYHBlcmZfaG9va3MucGVyZm9ybWFuY2Uubm93KClgXG4gICAgICogXG4gICAgICogXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgcHJlY2lzZSBpbnRlcnZhbCBleHBpcmVzLlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbE1TIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuIGVhY2ggaW50ZXJ2YWwuXG4gICAgICovXG4gICAgc3RhdGljIHByZWNpc2VJbnRlcnZhbChjYWxsYmFjazogRnVuY3Rpb24sIGludGVydmFsTVM6IG51bWJlcik6IGFueSB7XG4gICAgICAgIGlmICghbm93KSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYFxcYHByZWNpc2VJbnRlcnZhbCgpXFxgIGlzIGEgd3JhcHBlciBmb3IgXFxgc2V0SW50ZXJ2YWwoKVxcYCBpbiB0aGUgYnJvd3NlciBjb250ZXh0IWApO1xuICAgICAgICAgICAgcmV0dXJuIHNldEludGVydmFsKGNhbGxiYWNrLCBpbnRlcnZhbE1TKTsgICAgXG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgbGV0IG5leHRUaWNrID0gbm93KCk7XG4gICAgICAgIGxldCBjbGVhcjphbnkgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIGxldCB3cmFwcGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRoaXNUaWNrID0gbm93KCk7XG4gICAgICAgICAgICBpZiAodGhpc1RpY2sgPCBuZXh0VGljaykge1xuICAgICAgICAgICAgICAgIGNsZWFyID0gY2xlYXJJbW1lZGlhdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVvdXQgPSBzZXRJbW1lZGlhdGUod3JhcHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0VGljayArPSBpbnRlcnZhbE1TO1xuICAgICAgICAgICAgY2xlYXIgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCh3cmFwcGVyLCBuZXh0VGljayAtIHRoaXNUaWNrIC0gMik7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgdGltZW91dDphbnkgPSBzZXRUaW1lb3V0KHdyYXBwZXIpO1xuICAgICAgICByZXR1cm4geyBjbGVhcjogKCkgPT4gY2xlYXIodGltZW91dCkgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2hlY2tCcm93c2VyQ29tcGF0aWJpbGl0eSgpOiBCb29sZWFuIHtcbiAgICAgICAgbGV0IHJlcXVpcmVkRmVhdHVyZXM6IEFycmF5PHN0cmluZz4gPSBbXG4gICAgICAgICAgICAvLyBOYXZpZ2F0b3IgbWVkaWFEZXZpY2VzXG4gICAgICAgICAgICBcIm5hdmlnYXRvclwiLCAvLyBGb3VuZCBvbiBzb3VyY2UgY29kZSBIaUZpTWl4ZXJTZXNzaW9uLnRzLCBSYXZpU3RyZWFtQ29udHJvbGxlci50c1xuICAgICAgICAgICAgXCJuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYVwiLCAvLyBGb3VuZCBvbiBzb3VyY2UgY29kZSBIaUZpTWl4ZXJTZXNzaW9uLnRzIChsbi41OTApXG4gICAgICAgICAgICBcIm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHNcIiwgLy8gRm91bmQgb24gc291cmNlIGNvZGUgSGlGaVV0aWxpdGllcyAobG4uIDEzMCwgMTM0LCAxMzgpXG4gICAgICAgICAgICAvLyBXZWJSVENcbiAgICAgICAgICAgIFwid2luZG93Lk1lZGlhU3RyZWFtXCIsIC8vIEZvdW5kIG9uIHNvdXJjZSBjb2RlIEhpRmlDb21tdW5pY2F0b3IudHMsIEhpRmlNaXhlclNlc3Npb24udHMsIFJhdmlTZXNzaW9uLnRzLCBSYXZpU3RyZWFtQ29udHJvbGxlci50c1xuICAgICAgICAgICAgXCJ3aW5kb3cuUlRDRGF0YUNoYW5uZWxcIiwgLy8gRm91bmQgb24gc291cmNlIGNvZGUgUmF2aUNvbW1hbmRDb250cm9sbGVyLnRzIChsbi4xNTEpXG4gICAgICAgICAgICBcIndpbmRvdy5SVENQZWVyQ29ubmVjdGlvblwiLCAvLyBGb3VuZCBvbiBzb3VyY2UgY29kZSBSYXZpU2Vzc2lvbi50cyAobG4uNjAzKVxuICAgICAgICAgICAgXCJ3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uXCIgLy8gRm91bmQgb24gc291cmNlIGNvZGUgUmF2aVNlc3Npb24udHMgKGxuLjYwNClcbiAgICAgICAgXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVpcmVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGV2YWwocmVxdWlyZWRGZWF0dXJlc1tpXSkpID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihcIkhpRmkgQXVkaW8gQVBJOiBUaGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0OiBcIiArIHJlcXVpcmVkRmVhdHVyZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZEZlYXR1cmVzW2ldID09PSBcIm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihcIkhpRmkgQXVkaW8gQVBJOiBZb3VyIGJyb3dzZXIgbWF5IGJlIHByZXZlbnRpbmcgYWNjZXNzIHRvIHRoaXMgZmVhdHVyZSBpZiB5b3UgYXJlIHJ1bm5pbmcgaW4gYW4gaW5zZWN1cmUgY29udGV4dCwgaS5lLiBhbiBgaHR0cGAgc2VydmVyLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBub25hbih2OiBudW1iZXIsIGlmbmFuOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gKGlzTmFOKHYpID8gaWZuYW4gOiB2KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xhbXAodjogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICAvLyBpZiB2IGlzIE5hbiByZXR1cm5zIE5hblxuICAgICAgICByZXR1cm4gKHYgPiBtYXggPyBtYXggOiAodiA8IG1pbiA/IG1pbiA6IHYpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xhbXBOb25hbih2OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgaWZuYW46IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAodiA+IG1heCA/IG1heCA6ICh2IDwgbWluID8gbWluIDogSGlGaVV0aWxpdGllcy5ub25hbih2LCBpZm5hbikpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xhbXBOb3JtYWxpemVkKHY6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIC8vIGlmIHYgaXMgTmFuIHJldHVybnMgTmFuXG4gICAgICAgIHJldHVybiAodiA+IDEuMCA/IDEuMCA6ICh2IDwgLTEuMCA/IC0xLjAgOiB2KSk7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd3cyBkb2VzIG5vdCB3b3JrIGluIHRoZSBicm93c2VyLiBCcm93c2VyIGNsaWVudHMgbXVzdCB1c2UgdGhlIG5hdGl2ZSAnICtcbiAgICAgICdXZWJTb2NrZXQgb2JqZWN0J1xuICApO1xufTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdGlmKF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0pIHtcblx0XHRyZXR1cm4gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmhtZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlID0gT2JqZWN0LmNyZWF0ZShtb2R1bGUpO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsICdleHBvcnRzJywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0c2V0OiAoKSA9PiB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VTIE1vZHVsZXMgbWF5IG5vdCBhc3NpZ24gbW9kdWxlLmV4cG9ydHMgb3IgZXhwb3J0cy4qLCBVc2UgRVNNIGV4cG9ydCBzeW50YXgsIGluc3RlYWQ6ICcgKyBtb2R1bGUuaWQpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvLyBtb2R1bGUgZXhwb3J0cyBtdXN0IGJlIHJldHVybmVkIGZyb20gcnVudGltZSBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG5yZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2luZGV4LnRzXCIpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==