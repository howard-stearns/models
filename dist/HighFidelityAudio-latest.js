var HighFidelityAudio;HighFidelityAudio =
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../Spatial-Audio-API-Examples/examples/nodejs/testingbot/node_modules/wrtc/lib/browser.js":
/*!*************************************************************************************************!*\
  !*** ../Spatial-Audio-API-Examples/examples/nodejs/testingbot/node_modules/wrtc/lib/browser.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {



exports.MediaStream = window.MediaStream;
exports.MediaStreamTrack = window.MediaStreamTrack;
exports.RTCDataChannel = window.RTCDataChannel;
exports.RTCDataChannelEvent = window.RTCDataChannelEvent;
exports.RTCDtlsTransport = window.RTCDtlsTransport;
exports.RTCIceCandidate = window.RTCIceCandidate;
exports.RTCIceTransport = window.RTCIceTransport;
exports.RTCPeerConnection = window.RTCPeerConnection;
exports.RTCPeerConnectionIceEvent = window.RTCPeerConnectionIceEvent;
exports.RTCRtpReceiver = window.RTCRtpReceiver;
exports.RTCRtpSender = window.RTCRtpSender;
exports.RTCRtpTransceiver = window.RTCRtpTransceiver;
exports.RTCSctpTransport = window.RTCSctpTransport;
exports.RTCSessionDescription = window.RTCSessionDescription;
exports.getUserMedia = window.getUserMedia;
exports.mediaDevices = navigator.mediaDevices;


/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/***/ ((module, exports) => {



// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof global !== 'undefined') { return global; }
	throw new Error('unable to locate global object');
}

var global = getGlobal();

module.exports = exports = global.fetch;

// Needed for TypeScript and Webpack.
if (global.fetch) {
	exports.default = global.fetch.bind(global);
}

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;

/***/ }),

/***/ "./node_modules/pako/index.js":
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Top level file is just a mixin of submodules & constants


const { Deflate, deflate, deflateRaw, gzip } = __webpack_require__(/*! ./lib/deflate */ "./node_modules/pako/lib/deflate.js");

const { Inflate, inflate, inflateRaw, ungzip } = __webpack_require__(/*! ./lib/inflate */ "./node_modules/pako/lib/inflate.js");

const constants = __webpack_require__(/*! ./lib/zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

module.exports.Deflate = Deflate;
module.exports.deflate = deflate;
module.exports.deflateRaw = deflateRaw;
module.exports.gzip = gzip;
module.exports.Inflate = Inflate;
module.exports.inflate = inflate;
module.exports.inflateRaw = inflateRaw;
module.exports.ungzip = ungzip;
module.exports.constants = constants;


/***/ }),

/***/ "./node_modules/pako/lib/deflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {




const zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ "./node_modules/pako/lib/zlib/deflate.js");
const utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
const strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
const msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
const ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED
} = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  let status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = zlib_deflate.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    this.result = utils.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  const deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


module.exports.Deflate = Deflate;
module.exports.deflate = deflate;
module.exports.deflateRaw = deflateRaw;
module.exports.gzip = gzip;
module.exports.constants = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");


/***/ }),

/***/ "./node_modules/pako/lib/inflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {




const zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ "./node_modules/pako/lib/zlib/inflate.js");
const utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
const strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
const msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
const ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");
const GZheader     = __webpack_require__(/*! ./zlib/gzheader */ "./node_modules/pako/lib/zlib/gzheader.js");

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  this.options = utils.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  let status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = zlib_inflate.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      zlib_inflate.inflateReset(strm);
      status = zlib_inflate.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  const inflator = new Inflate(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || msg[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


module.exports.Inflate = Inflate;
module.exports.inflate = inflate;
module.exports.inflateRaw = inflateRaw;
module.exports.ungzip = inflate;
module.exports.constants = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");


/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/***/ ((module) => {




const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

module.exports.assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
module.exports.flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};


/***/ }),

/***/ "./node_modules/pako/lib/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/***/ ((module) => {

// String encode/decode helpers



// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
module.exports.string2buf = (str) => {
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
module.exports.buf2string = (buf, max) => {
  let i, out;
  const len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
module.exports.utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/***/ ((module) => {



// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


module.exports = adler32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/***/ ((module) => {



// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


module.exports = crc32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = __webpack_require__(/*! ./trees */ "./node_modules/pako/lib/zlib/trees.js");
const adler32 = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
const crc32   = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
const msg     = __webpack_require__(/*! ./messages */ "./node_modules/pako/lib/zlib/messages.js");

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK,
  Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,
  Z_DEFAULT_COMPRESSION,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY,
  Z_UNKNOWN,
  Z_DEFLATED
} = __webpack_require__(/*! ./constants */ "./node_modules/pako/lib/zlib/constants.js");

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = msg[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};


/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
const deflate_stored = (s, flush) => {

  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  let max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    const max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
};

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


const deflateResetKeep = (strm) => {

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  _tr_init(s);
  return Z_OK;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
};


const deflate = (strm, flush) => {

  let beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  const s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      let header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      let level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
};


const deflateEnd = (strm) => {

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  const status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
};


module.exports.deflateInit = deflateInit;
module.exports.deflateInit2 = deflateInit2;
module.exports.deflateReset = deflateReset;
module.exports.deflateResetKeep = deflateResetKeep;
module.exports.deflateSetHeader = deflateSetHeader;
module.exports.deflate = deflate;
module.exports.deflateEnd = deflateEnd;
module.exports.deflateSetDictionary = deflateSetDictionary;
module.exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/gzheader.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD = 30;       /* got a data error -- remain here until reset */
const TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32       = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
const crc32         = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
const inflate_fast  = __webpack_require__(/*! ./inffast */ "./node_modules/pako/lib/zlib/inffast.js");
const inflate_table = __webpack_require__(/*! ./inftrees */ "./node_modules/pako/lib/zlib/inftrees.js");

const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH, Z_BLOCK, Z_TREES,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Z_BUF_ERROR,
  Z_DEFLATED
} = __webpack_require__(/*! ./constants */ "./node_modules/pako/lib/zlib/constants.js");


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 1;       /* i: waiting for magic header */
const    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
const    TIME = 3;       /* i: waiting for modification time (gzip) */
const    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 5;      /* i: waiting for extra length (gzip) */
const    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
const    NAME = 7;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
const    HCRC = 9;       /* i: waiting for header crc (gzip) */
const    DICTID = 10;    /* i: waiting for dictionary check value */
const    DICT = 11;      /* waiting for inflateSetDictionary() call */
const        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 14;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 17;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 18;   /* i: waiting for code length code lengths */
const        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 20;      /* i: same as LEN below, but only first time in */
const            LEN = 21;       /* i: waiting for length/lit/eob code */
const            LENEXT = 22;    /* i: waiting for length extra bits */
const            DIST = 23;      /* i: waiting for distance code */
const            DISTEXT = 24;   /* i: waiting for distance extra bits */
const            MATCH = 25;     /* o: waiting for output space to copy string */
const            LIT = 26;       /* o: waiting for output space to write literal */
const    CHECK = 27;     /* i: waiting for 32-bit check value */
const    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 29;      /* finished check, done -- remain here until reset */
const    BAD = 30;       /* got a data error -- remain here until reset */
const    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateResetKeep = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
};


const inflateReset = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
};


module.exports.inflateReset = inflateReset;
module.exports.inflateReset2 = inflateReset2;
module.exports.inflateResetKeep = inflateResetKeep;
module.exports.inflateInit = inflateInit;
module.exports.inflateInit2 = inflateInit2;
module.exports.inflate = inflate;
module.exports.inflateEnd = inflateEnd;
module.exports.inflateGetHeader = inflateGetHeader;
module.exports.inflateSetDictionary = inflateSetDictionary;
module.exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES = 0;
const LENS = 1;
const DISTS = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
  let base_index = 0;
//  let shoextra;    /* extra bits table to use */
  let end;                    /* use base and extra for symbol > end */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;
  let extra_index = 0;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


module.exports = inflate_table;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH    = 3;
const MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS      = 256;
/* number of literal bytes 0..255 */

const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES       = 30;
/* number of distance codes */

const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

const MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) =>
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  const next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
const copy_block = (s, buf, len, header) =>
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
  s.pending += len;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) =>
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) =>
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let lx = 0;         /* running index in l_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) =>
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let black_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
const _tr_flush_block = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally = (s, dist, lc) =>
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //let out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
};

module.exports._tr_init  = _tr_init;
module.exports._tr_stored_block = _tr_stored_block;
module.exports._tr_flush_block  = _tr_flush_block;
module.exports._tr_tally = _tr_tally;
module.exports._tr_align = _tr_align;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/***/ ((module) => {



// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;


/***/ }),

/***/ "./src/classes/HiFiAudioAPIData.ts":
/*!*****************************************!*\
  !*** ./src/classes/HiFiAudioAPIData.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Point3D": () => (/* binding */ Point3D),
/* harmony export */   "OrientationQuat3D": () => (/* binding */ OrientationQuat3D),
/* harmony export */   "OrientationEuler3D": () => (/* binding */ OrientationEuler3D),
/* harmony export */   "OrientationEuler3DOrder": () => (/* binding */ OrientationEuler3DOrder),
/* harmony export */   "eulerToQuaternion": () => (/* binding */ eulerToQuaternion),
/* harmony export */   "eulerFromQuaternion": () => (/* binding */ eulerFromQuaternion),
/* harmony export */   "HiFiAudioAPIData": () => (/* binding */ HiFiAudioAPIData),
/* harmony export */   "ReceivedHiFiAudioAPIData": () => (/* binding */ ReceivedHiFiAudioAPIData)
/* harmony export */ });
/* harmony import */ var _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/HiFiUtilities */ "./src/utilities/HiFiUtilities.ts");

class Point3D {
    constructor({ x = 0, y = 0, z = 0 } = {}) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}
class OrientationQuat3D {
    constructor({ w = 1, x = 0, y = 0, z = 0 } = {}) {
        this.w = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNonan(w, -1, 1, 1);
        this.x = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNonan(x, -1, 1, 0);
        this.y = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNonan(y, -1, 1, 0);
        this.z = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNonan(z, -1, 1, 0);
    }
}
function sanitizeAngleDegrees(v) {
    if (isNaN(v) || v === Infinity) {
        return 0;
    }
    else if (v === -Infinity) {
        return -0;
    }
    else {
        return v % 360;
    }
}
class OrientationEuler3D {
    constructor({ pitchDegrees = 0, yawDegrees = 0, rollDegrees = 0 } = {}) {
        this.pitchDegrees = sanitizeAngleDegrees(pitchDegrees);
        this.yawDegrees = sanitizeAngleDegrees(yawDegrees);
        this.rollDegrees = sanitizeAngleDegrees(rollDegrees);
    }
}
var OrientationEuler3DOrder;
(function (OrientationEuler3DOrder) {
    OrientationEuler3DOrder["PitchYawRoll"] = "PitchYawRoll";
    OrientationEuler3DOrder["YawPitchRoll"] = "YawPitchRoll";
    OrientationEuler3DOrder["RollPitchYaw"] = "RollPitchYaw";
    OrientationEuler3DOrder["RollYawPitch"] = "RollYawPitch";
    OrientationEuler3DOrder["YawRollPitch"] = "YawRollPitch";
    OrientationEuler3DOrder["PitchRollYaw"] = "PitchRollYaw";
})(OrientationEuler3DOrder || (OrientationEuler3DOrder = {}));
function eulerToQuaternion(euler, order) {
    const HALF_DEG_TO_RAD = 0.5 * Math.PI / 180.0;
    let cos = { P: Math.cos(euler.pitchDegrees * HALF_DEG_TO_RAD), Y: Math.cos(euler.yawDegrees * HALF_DEG_TO_RAD), R: Math.cos(euler.rollDegrees * HALF_DEG_TO_RAD) };
    let sin = { P: Math.sin(euler.pitchDegrees * HALF_DEG_TO_RAD), Y: Math.sin(euler.yawDegrees * HALF_DEG_TO_RAD), R: Math.sin(euler.rollDegrees * HALF_DEG_TO_RAD) };
    let ax = sin.P * cos.Y * cos.R;
    let ay = cos.P * sin.Y * cos.R;
    let az = cos.P * cos.Y * sin.R;
    let aw = cos.P * cos.Y * cos.R;
    let bx = cos.P * sin.Y * sin.R;
    let by = sin.P * cos.Y * sin.R;
    let bz = sin.P * sin.Y * cos.R;
    let bw = sin.P * sin.Y * sin.R;
    switch (order) {
        case OrientationEuler3DOrder.PitchYawRoll:
            {
                return new OrientationQuat3D({
                    x: ax + bx,
                    y: ay - by,
                    z: az + bz,
                    w: aw - bw,
                });
            }
            break;
        case OrientationEuler3DOrder.YawPitchRoll:
            {
                return new OrientationQuat3D({
                    x: ax + bx,
                    y: ay - by,
                    z: az - bz,
                    w: aw + bw,
                });
            }
            break;
        case OrientationEuler3DOrder.RollPitchYaw:
            {
                return new OrientationQuat3D({
                    x: ax - bx,
                    y: ay + by,
                    z: az + bz,
                    w: aw - bw,
                });
            }
            break;
        case OrientationEuler3DOrder.RollYawPitch:
            {
                return new OrientationQuat3D({
                    x: ax - bx,
                    y: ay + by,
                    z: az - bz,
                    w: aw + bw,
                });
            }
            break;
        case OrientationEuler3DOrder.YawRollPitch:
            {
                return new OrientationQuat3D({
                    x: ax + bx,
                    y: ay + by,
                    z: az - bz,
                    w: aw - bw,
                });
            }
            break;
        case OrientationEuler3DOrder.PitchRollYaw:
            {
                return new OrientationQuat3D({
                    x: ax - bx,
                    y: ay - by,
                    z: az + bz,
                    w: aw + bw,
                });
            }
            break;
    }
}
function eulerFromQuaternion(quat, order) {
    let qx2 = quat.x * quat.x;
    let qy2 = quat.y * quat.y;
    let qz2 = quat.z * quat.z;
    let qwx = quat.w * quat.x;
    let qwy = quat.w * quat.y;
    let qwz = quat.w * quat.z;
    let qxy = quat.x * quat.y;
    let qyz = quat.y * quat.z;
    let qxz = quat.z * quat.x;
    let r00 = 1.0 - 2.0 * (qy2 + qz2);
    let r10 = 2.0 * (qxy + qwz);
    let r20 = 2.0 * (qxz - qwy);
    let r01 = 2.0 * (qxy - qwz);
    let r11 = 1.0 - 2.0 * (qx2 + qz2);
    let r21 = 2.0 * (qyz + qwx);
    let r02 = 2.0 * (qxz + qwy);
    let r12 = 2.0 * (qyz - qwx);
    let r22 = 1.0 - 2.0 * (qx2 + qy2);
    let pitch = 0;
    let yaw = 0;
    let roll = 0;
    const ONE_MINUS_EPSILON = 0.9999999;
    switch (order) {
        case OrientationEuler3DOrder.PitchYawRoll:
            {
                yaw = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(r02));
                if (Math.abs(r02) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(-r12, r22);
                    roll = Math.atan2(-r01, r00);
                }
                else {
                    pitch = Math.atan2(r21, r11);
                }
            }
            break;
        case OrientationEuler3DOrder.YawPitchRoll:
            {
                pitch = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(-r12));
                if (Math.abs(r12) < ONE_MINUS_EPSILON) {
                    yaw = Math.atan2(r02, r22);
                    roll = Math.atan2(r10, r11);
                }
                else {
                    yaw = Math.atan2(-r20, r00);
                }
            }
            break;
        case OrientationEuler3DOrder.RollPitchYaw:
            {
                pitch = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(r21));
                if (Math.abs(r21) < ONE_MINUS_EPSILON) {
                    yaw = Math.atan2(-r20, r22);
                    roll = Math.atan2(-r01, r11);
                }
                else {
                    roll = Math.atan2(r10, r00);
                }
            }
            break;
        case OrientationEuler3DOrder.RollYawPitch:
            {
                yaw = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(-r20));
                if (Math.abs(r20) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(r21, r22);
                    roll = Math.atan2(r10, r00);
                }
                else {
                    roll = Math.atan2(-r01, r11);
                }
            }
            break;
        case OrientationEuler3DOrder.YawRollPitch:
            {
                roll = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(r10));
                if (Math.abs(r10) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(-r12, r11);
                    yaw = Math.atan2(-r20, r00);
                }
                else {
                    yaw = Math.atan2(r02, r22);
                }
            }
            break;
        case OrientationEuler3DOrder.PitchRollYaw:
            {
                roll = Math.asin(_utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.clampNormalized(-r01));
                if (Math.abs(r01) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(r21, r11);
                    yaw = Math.atan2(r02, r00);
                }
                else {
                    yaw = Math.atan2(-r12, r22);
                }
            }
            break;
    }
    const RAD_TO_DEG = 180.0 / Math.PI;
    return new OrientationEuler3D({ pitchDegrees: RAD_TO_DEG * pitch, yawDegrees: RAD_TO_DEG * yaw, rollDegrees: RAD_TO_DEG * roll });
}
class HiFiAudioAPIData {
    constructor({ position = null, orientationQuat = null, orientationEuler = null, volumeThreshold = null, hiFiGain = null, userAttenuation = null, userRolloff = null } = {}) {
        this.position = position;
        this.orientationQuat = orientationQuat;
        this.orientationEuler = orientationEuler;
        this.volumeThreshold = volumeThreshold;
        this.hiFiGain = hiFiGain;
        this.userAttenuation = userAttenuation;
        this.userRolloff = userRolloff;
        this._otherUserGainQueue = {};
    }
}
class ReceivedHiFiAudioAPIData extends HiFiAudioAPIData {
    constructor(params = {}) {
        super(params);
        this.providedUserID = params.providedUserID;
        this.hashedVisitID = params.hashedVisitID;
        this.volumeDecibels = params.volumeDecibels;
        this.isStereo = params.isStereo;
    }
}


/***/ }),

/***/ "./src/classes/HiFiAxisConfiguration.ts":
/*!**********************************************!*\
  !*** ./src/classes/HiFiAxisConfiguration.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiAxes": () => (/* binding */ HiFiAxes),
/* harmony export */   "HiFiHandedness": () => (/* binding */ HiFiHandedness),
/* harmony export */   "HiFiAxisConfiguration": () => (/* binding */ HiFiAxisConfiguration),
/* harmony export */   "ourHiFiAxisConfiguration": () => (/* binding */ ourHiFiAxisConfiguration),
/* harmony export */   "HiFiAxisUtilities": () => (/* binding */ HiFiAxisUtilities)
/* harmony export */ });
/* harmony import */ var _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* harmony import */ var _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");


var HiFiAxes;
(function (HiFiAxes) {
    HiFiAxes["PositiveX"] = "Positive X";
    HiFiAxes["NegativeX"] = "Negative X";
    HiFiAxes["PositiveY"] = "Positive Y";
    HiFiAxes["NegativeY"] = "Negative Y";
    HiFiAxes["PositiveZ"] = "Positive Z";
    HiFiAxes["NegativeZ"] = "Negative Z";
})(HiFiAxes || (HiFiAxes = {}));
var HiFiHandedness;
(function (HiFiHandedness) {
    HiFiHandedness["RightHand"] = "Right Hand";
    HiFiHandedness["LeftHand"] = "Left Hand";
})(HiFiHandedness || (HiFiHandedness = {}));
class HiFiAxisConfiguration {
    constructor({ rightAxis, leftAxis, intoScreenAxis, outOfScreenAxis, upAxis, downAxis, handedness, eulerOrder }) {
        Object.assign(this, { rightAxis, leftAxis, intoScreenAxis, outOfScreenAxis, upAxis, downAxis, handedness, eulerOrder });
    }
}
let ourHiFiAxisConfiguration = new HiFiAxisConfiguration({
    rightAxis: HiFiAxes.PositiveX,
    leftAxis: HiFiAxes.NegativeX,
    intoScreenAxis: HiFiAxes.PositiveY,
    outOfScreenAxis: HiFiAxes.NegativeY,
    upAxis: HiFiAxes.PositiveZ,
    downAxis: HiFiAxes.NegativeZ,
    handedness: HiFiHandedness.RightHand,
    eulerOrder: _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationEuler3DOrder.YawPitchRoll,
});
class HiFiAxisUtilities {
    static verify(axisConfiguration) {
        let isValid = true;
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveX && axisConfiguration.leftAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.leftAxis === HiFiAxes.PositiveX && axisConfiguration.rightAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveY && axisConfiguration.leftAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.leftAxis === HiFiAxes.PositiveY && axisConfiguration.rightAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.rightAxis === HiFiAxes.PositiveZ && axisConfiguration.leftAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.leftAxis === HiFiAxes.PositiveZ && axisConfiguration.rightAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nRight Axis is ${axisConfiguration.rightAxis}, and Left Axis is ${axisConfiguration.leftAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveX && axisConfiguration.outOfScreenAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveX && axisConfiguration.intoScreenAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveY && axisConfiguration.outOfScreenAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveY && axisConfiguration.intoScreenAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.intoScreenAxis === HiFiAxes.PositiveZ && axisConfiguration.outOfScreenAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.outOfScreenAxis === HiFiAxes.PositiveZ && axisConfiguration.intoScreenAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nIntoScreen Axis is ${axisConfiguration.intoScreenAxis}, and OutOfScreen Axis is ${axisConfiguration.outOfScreenAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.upAxis === HiFiAxes.PositiveX && axisConfiguration.downAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.downAxis === HiFiAxes.PositiveX && axisConfiguration.upAxis !== HiFiAxes.NegativeX) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.upAxis === HiFiAxes.PositiveY && axisConfiguration.downAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.downAxis === HiFiAxes.PositiveY && axisConfiguration.upAxis !== HiFiAxes.NegativeY) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.upAxis === HiFiAxes.PositiveZ && axisConfiguration.downAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (axisConfiguration.downAxis === HiFiAxes.PositiveZ && axisConfiguration.upAxis !== HiFiAxes.NegativeZ) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nUp Axis is ${axisConfiguration.upAxis}, and Down Axis is ${axisConfiguration.downAxis}!`);
            isValid = false;
        }
        if (!(axisConfiguration.handedness === HiFiHandedness.RightHand || axisConfiguration.handedness === HiFiHandedness.LeftHand)) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error(`Invalid axis configuration!\nHandedness is ${axisConfiguration.handedness}!`);
            isValid = false;
        }
        return isValid;
    }
    static translatePoint3DToMixerSpace(axisConfiguration, inputPoint3D) {
        let retval = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.Point3D();
        retval = inputPoint3D;
        return retval;
    }
    static translatePoint3DFromMixerSpace(axisConfiguration, mixerPoint3D) {
        let retval = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.Point3D();
        retval = mixerPoint3D;
        return retval;
    }
    static translateOrientationQuat3DToMixerSpace(axisConfiguration, inputOrientationQuat3D) {
        let retval = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationQuat3D();
        retval = inputOrientationQuat3D;
        return retval;
    }
    static translateOrientationQuat3DFromMixerSpace(axisConfiguration, mixerOrientationQuat3D) {
        let retval = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationQuat3D();
        retval = mixerOrientationQuat3D;
        return retval;
    }
}


/***/ }),

/***/ "./src/classes/HiFiCommunicator.ts":
/*!*****************************************!*\
  !*** ./src/classes/HiFiCommunicator.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiConnectionStates": () => (/* binding */ HiFiConnectionStates),
/* harmony export */   "HiFiUserDataStreamingScopes": () => (/* binding */ HiFiUserDataStreamingScopes),
/* harmony export */   "HiFiCommunicator": () => (/* binding */ HiFiCommunicator)
/* harmony export */ });
/* harmony import */ var _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/HiFiConstants */ "./src/constants/HiFiConstants.ts");
/* harmony import */ var _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* harmony import */ var _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/HiFiUtilities */ "./src/utilities/HiFiUtilities.ts");
/* harmony import */ var _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");
/* harmony import */ var _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HiFiAxisConfiguration */ "./src/classes/HiFiAxisConfiguration.ts");
/* harmony import */ var _HiFiMixerSession__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./HiFiMixerSession */ "./src/classes/HiFiMixerSession.ts");
/* harmony import */ var _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./HiFiUserDataSubscription */ "./src/classes/HiFiUserDataSubscription.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







var HiFiConnectionStates;
(function (HiFiConnectionStates) {
    HiFiConnectionStates["Connected"] = "Connected";
    HiFiConnectionStates["Disconnected"] = "Disconnected";
    HiFiConnectionStates["Failed"] = "Failed";
    HiFiConnectionStates["Unavailable"] = "Unavailable";
})(HiFiConnectionStates || (HiFiConnectionStates = {}));
;
var HiFiUserDataStreamingScopes;
(function (HiFiUserDataStreamingScopes) {
    HiFiUserDataStreamingScopes["None"] = "none";
    HiFiUserDataStreamingScopes["Peers"] = "peers";
    HiFiUserDataStreamingScopes["All"] = "all";
})(HiFiUserDataStreamingScopes || (HiFiUserDataStreamingScopes = {}));
;
class HiFiCommunicator {
    constructor({ initialHiFiAudioAPIData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.HiFiAudioAPIData(), onConnectionStateChanged, onUsersDisconnected, transmitRateLimitTimeoutMS = _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.DEFAULT_TRANSMIT_RATE_LIMIT_TIMEOUT_MS, userDataStreamingScope = HiFiUserDataStreamingScopes.All, hiFiAxisConfiguration, webrtcSessionParams, customSTUNandTURNConfig, onMuteChanged } = {}) {
        this._timers = {
            transmitRateLimitTimeout: null,
            wantedToTransmitHiFiAudioAPIData: true
        };
        if (customSTUNandTURNConfig) {
            if (!customSTUNandTURNConfig.hasOwnProperty("stunUrls") || !Array.isArray(customSTUNandTURNConfig.stunUrls) || customSTUNandTURNConfig.stunUrls.length == 0) {
                throw new Error(`\`customSTUNandTURNConfig.stunUrls\` must be specified and must be a list containing at least one STUN server.`);
            }
            if (!customSTUNandTURNConfig.hasOwnProperty("turnUrls") || !Array.isArray(customSTUNandTURNConfig.turnUrls) || customSTUNandTURNConfig.turnUrls.length == 0) {
                throw new Error(`\`customSTUNandTURNConfig.turnUrls\` must be specified and must be a list containing at least one TURN server.`);
            }
            if (!customSTUNandTURNConfig.hasOwnProperty("turnUsername")) {
                throw new Error(`\`customSTUNandTURNConfig.turnUsername\` must be specified.`);
            }
            if (!customSTUNandTURNConfig.hasOwnProperty("turnCredential")) {
                throw new Error(`\`customSTUNandTURNConfig.turnCredential\` must be specified.`);
            }
        }
        this._customSTUNandTURNConfig = customSTUNandTURNConfig;
        if (transmitRateLimitTimeoutMS < _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`\`transmitRateLimitTimeoutMS\` must be >= ${_constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS}ms! Setting to ${_constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS}ms...`);
            transmitRateLimitTimeoutMS = _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS;
        }
        this.transmitRateLimitTimeoutMS = transmitRateLimitTimeoutMS;
        if (onUsersDisconnected) {
            this.onUsersDisconnected = onUsersDisconnected;
        }
        this._mixerSession = new _HiFiMixerSession__WEBPACK_IMPORTED_MODULE_5__.HiFiMixerSession({
            "userDataStreamingScope": userDataStreamingScope,
            "onUserDataUpdated": (data) => { this._handleUserDataUpdates(data); },
            "onUsersDisconnected": (data) => { this._onUsersDisconnected(data); },
            "onConnectionStateChanged": onConnectionStateChanged,
            "onMuteChanged": onMuteChanged
        });
        this._inputAudioMediaStream = undefined;
        this._currentHiFiAudioAPIData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.HiFiAudioAPIData();
        this._lastTransmittedHiFiAudioAPIData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.HiFiAudioAPIData();
        this._userDataSubscriptions = [];
        if (webrtcSessionParams && webrtcSessionParams.audioMinJitterBufferDuration && (webrtcSessionParams.audioMinJitterBufferDuration < 0.0 || webrtcSessionParams.audioMinJitterBufferDuration > 10.0)) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`The value of \`webrtcSessionParams.audioMinJitterBufferDuration\` (${webrtcSessionParams.audioMinJitterBufferDuration}) will be clamped to (0.0, 10.0).`);
            webrtcSessionParams.audioMinJitterBufferDuration = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_2__.HiFiUtilities.clamp(webrtcSessionParams.audioMinJitterBufferDuration, 0.0, 10.0);
        }
        if (webrtcSessionParams && webrtcSessionParams.audioMaxJitterBufferDuration && (webrtcSessionParams.audioMaxJitterBufferDuration < 0.0 || webrtcSessionParams.audioMaxJitterBufferDuration > 10.0)) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`The value of \`webrtcSessionParams.audioMaxJitterBufferDuration\` (${webrtcSessionParams.audioMaxJitterBufferDuration}) will be clamped to (0.0, 10.0).`);
            webrtcSessionParams.audioMaxJitterBufferDuration = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_2__.HiFiUtilities.clamp(webrtcSessionParams.audioMaxJitterBufferDuration, 0.0, 10.0);
        }
        this._webRTCSessionParams = webrtcSessionParams;
        if (hiFiAxisConfiguration) {
            if (_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.HiFiAxisUtilities.verify(hiFiAxisConfiguration)) {
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.rightAxis = hiFiAxisConfiguration.rightAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.leftAxis = hiFiAxisConfiguration.leftAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.intoScreenAxis = hiFiAxisConfiguration.intoScreenAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.outOfScreenAxis = hiFiAxisConfiguration.outOfScreenAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.upAxis = hiFiAxisConfiguration.upAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.downAxis = hiFiAxisConfiguration.downAxis;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.handedness = hiFiAxisConfiguration.handedness;
                _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.eulerOrder = hiFiAxisConfiguration.eulerOrder;
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`There is an error with the passed \`HiFiAxisConfiguration\`, so the new axis configuration was not set. There are more error details in the logs above.`);
            }
        }
        this._updateUserData(initialHiFiAudioAPIData);
    }
    connectToHiFiAudioAPIServer(hifiAuthJWT, signalingHostURL, signalingPort) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._mixerSession) {
                let errMsg = `\`this._mixerSession\` is falsey; try creating a new HiFiCommunicator and starting over.`;
                return Promise.reject({
                    success: false,
                    error: errMsg
                });
            }
            if (this._mixerSession.getCurrentHiFiConnectionState() === HiFiConnectionStates.Connected) {
                let msg = `Session is already connected! If you need to reset the connection, please disconnect fully using \`disconnectFromHiFiAudioAPIServer()\` and call this method again.`;
                return Promise.resolve({
                    success: true,
                    error: msg
                });
            }
            let mixerConnectionResponse;
            let signalingHostURLSafe;
            try {
                let url = new URL(signalingHostURL);
                signalingHostURLSafe = url.hostname;
                if (signalingPort == null && url.port !== "") {
                    signalingPort = Number(url.port);
                }
            }
            catch (e) {
                signalingHostURLSafe = signalingHostURL ? signalingHostURL : _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_ENDPOINT;
            }
            signalingPort = signalingPort ? signalingPort : _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_0__.HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_PORT;
            try {
                let webRTCSignalingAddress = `wss://${signalingHostURLSafe}:${signalingPort}/?token=`;
                this._mixerSession.webRTCAddress = `${webRTCSignalingAddress}${hifiAuthJWT}`;
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Using WebRTC Signaling Address:\n${webRTCSignalingAddress}<token redacted>`);
                mixerConnectionResponse = yield this._mixerSession.connectToHiFiMixer({ webRTCSessionParams: this._webRTCSessionParams, customSTUNandTURNConfig: this._customSTUNandTURNConfig });
            }
            catch (errorConnectingToMixer) {
                let errMsg = `Error when connecting to mixer!\n${errorConnectingToMixer}`;
                return Promise.reject({
                    success: false,
                    error: errMsg
                });
            }
            this._transmitHiFiAudioAPIDataToServer(true);
            return Promise.resolve({
                success: true,
                audionetInitResponse: mixerConnectionResponse.audionetInitResponse
            });
        });
    }
    setOtherUserGainForThisConnection(visitIdHash, gain) {
        return __awaiter(this, void 0, void 0, function* () {
            let otherUserGainMap = {};
            otherUserGainMap[visitIdHash] = gain;
            let result = this.setOtherUserGainsForThisConnection(otherUserGainMap);
            return Promise.resolve(result);
        });
    }
    setOtherUserGainsForThisConnection(otherUserGainMap) {
        return __awaiter(this, void 0, void 0, function* () {
            Object.assign(this._currentHiFiAudioAPIData._otherUserGainQueue, otherUserGainMap);
            let result = this._transmitHiFiAudioAPIDataToServer();
            return Promise.resolve({
                success: result.success,
                error: result.error
            });
        });
    }
    disconnectFromHiFiAudioAPIServer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._mixerSession) {
                return Promise.resolve(`No mixer session from which we can disconnect!`);
            }
            this._inputAudioMediaStream = undefined;
            this.onUsersDisconnected = undefined;
            this._userDataSubscriptions = [];
            this._currentHiFiAudioAPIData = undefined;
            this._lastTransmittedHiFiAudioAPIData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.HiFiAudioAPIData();
            return this._mixerSession.disconnectFromHiFiMixer();
        });
    }
    getOutputAudioMediaStream() {
        if (this._mixerSession) {
            return this._mixerSession.getOutputAudioMediaStream();
        }
        else {
            return null;
        }
    }
    getConnectionState() {
        if (this._mixerSession) {
            return this._mixerSession.getCurrentHiFiConnectionState();
        }
        else {
            return null;
        }
    }
    setInputAudioMediaStream(newInputAudioMediaStream, isStereo = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const retval = yield this._mixerSession.setRAVIInputAudio(newInputAudioMediaStream, isStereo);
            if (retval) {
                this._inputAudioMediaStream = newInputAudioMediaStream;
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Error trying to setRAVIInputAudio on this._mixerSession`);
            }
            return retval;
        });
    }
    setInputAudioMuted(isMuted) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._mixerSession) {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.debug(`Setting mute state to : ${isMuted}`);
                return yield this._mixerSession.setInputAudioMuted(isMuted);
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: No \`_mixerSession\`.`);
                return false;
            }
        });
    }
    getCommunicatorInfo() {
        let retval = {
            "clientInfo": {
                "inputAudioStreamSet": !!this._inputAudioMediaStream,
            }
        };
        let isBrowserContext = typeof self !== 'undefined';
        if (isBrowserContext && "string" === "string") {
            retval.clientInfo["apiVersion"] = "v1.2.2-2";
        }
        if (this._mixerSession && this._mixerSession.mixerInfo) {
            retval["serverInfo"] = this._mixerSession.mixerInfo;
        }
        return retval;
    }
    startCollectingWebRTCStats(callback) {
        if (!this._mixerSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`Couldn't start collecting WebRTC Stats: No \`_mixerSession\`!`);
        }
        this._mixerSession.startCollectingWebRTCStats(callback);
    }
    stopCollectingWebRTCStats() {
        if (!this._mixerSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`Couldn't stop collecting WebRTC Stats: No \`_mixerSession\`!`);
        }
        this._mixerSession.stopCollectingWebRTCStats();
    }
    _updateUserData({ position, orientationQuat, orientationEuler, volumeThreshold, hiFiGain, userAttenuation, userRolloff } = {}) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (position) {
            if (!this._currentHiFiAudioAPIData.position) {
                this._currentHiFiAudioAPIData.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.Point3D();
            }
            this._currentHiFiAudioAPIData.position.x = (_a = position.x) !== null && _a !== void 0 ? _a : this._currentHiFiAudioAPIData.position.x;
            this._currentHiFiAudioAPIData.position.y = (_b = position.y) !== null && _b !== void 0 ? _b : this._currentHiFiAudioAPIData.position.y;
            this._currentHiFiAudioAPIData.position.z = (_c = position.z) !== null && _c !== void 0 ? _c : this._currentHiFiAudioAPIData.position.z;
        }
        if (orientationQuat) {
            if (!this._currentHiFiAudioAPIData.orientationQuat) {
                this._currentHiFiAudioAPIData.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.OrientationQuat3D();
            }
            this._currentHiFiAudioAPIData.orientationQuat.w = (_d = orientationQuat.w) !== null && _d !== void 0 ? _d : this._currentHiFiAudioAPIData.orientationQuat.w;
            this._currentHiFiAudioAPIData.orientationQuat.x = (_e = orientationQuat.x) !== null && _e !== void 0 ? _e : this._currentHiFiAudioAPIData.orientationQuat.x;
            this._currentHiFiAudioAPIData.orientationQuat.y = (_f = orientationQuat.y) !== null && _f !== void 0 ? _f : this._currentHiFiAudioAPIData.orientationQuat.y;
            this._currentHiFiAudioAPIData.orientationQuat.z = (_g = orientationQuat.z) !== null && _g !== void 0 ? _g : this._currentHiFiAudioAPIData.orientationQuat.z;
        }
        else if (orientationEuler) {
            let checkedEuler = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.OrientationEuler3D(orientationEuler);
            this._currentHiFiAudioAPIData.orientationQuat = (0,_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.eulerToQuaternion)(checkedEuler, _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.eulerOrder);
        }
        if (typeof (volumeThreshold) === "number") {
            this._currentHiFiAudioAPIData.volumeThreshold = volumeThreshold;
        }
        if (typeof (hiFiGain) === "number") {
            this._currentHiFiAudioAPIData.hiFiGain = Math.max(0, hiFiGain);
        }
        if (typeof (userAttenuation) === "number") {
            this._currentHiFiAudioAPIData.userAttenuation = userAttenuation;
        }
        if (typeof (userRolloff) === "number") {
            this._currentHiFiAudioAPIData.userRolloff = Math.max(0, userRolloff);
        }
    }
    _maybeClearRateLimitTimeout() {
        if (this._timers.transmitRateLimitTimeout) {
            clearTimeout(this._timers.transmitRateLimitTimeout);
        }
        this._timers.transmitRateLimitTimeout = null;
    }
    _updateLastTransmittedHiFiAudioAPIData(dataJustTransmitted) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (dataJustTransmitted.position) {
            if (!this._lastTransmittedHiFiAudioAPIData.position) {
                this._lastTransmittedHiFiAudioAPIData.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.Point3D();
            }
            this._lastTransmittedHiFiAudioAPIData.position.x = (_a = dataJustTransmitted.position.x) !== null && _a !== void 0 ? _a : this._lastTransmittedHiFiAudioAPIData.position.x;
            this._lastTransmittedHiFiAudioAPIData.position.y = (_b = dataJustTransmitted.position.y) !== null && _b !== void 0 ? _b : this._lastTransmittedHiFiAudioAPIData.position.y;
            this._lastTransmittedHiFiAudioAPIData.position.z = (_c = dataJustTransmitted.position.z) !== null && _c !== void 0 ? _c : this._lastTransmittedHiFiAudioAPIData.position.z;
        }
        if (dataJustTransmitted.orientationQuat) {
            if (!this._lastTransmittedHiFiAudioAPIData.orientationQuat) {
                this._lastTransmittedHiFiAudioAPIData.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.OrientationQuat3D();
            }
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.w = (_d = dataJustTransmitted.orientationQuat.w) !== null && _d !== void 0 ? _d : this._lastTransmittedHiFiAudioAPIData.orientationQuat.w;
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.x = (_e = dataJustTransmitted.orientationQuat.x) !== null && _e !== void 0 ? _e : this._lastTransmittedHiFiAudioAPIData.orientationQuat.x;
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.y = (_f = dataJustTransmitted.orientationQuat.y) !== null && _f !== void 0 ? _f : this._lastTransmittedHiFiAudioAPIData.orientationQuat.y;
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.z = (_g = dataJustTransmitted.orientationQuat.z) !== null && _g !== void 0 ? _g : this._lastTransmittedHiFiAudioAPIData.orientationQuat.z;
        }
        if (typeof (dataJustTransmitted.volumeThreshold) === "number") {
            this._lastTransmittedHiFiAudioAPIData["volumeThreshold"] = dataJustTransmitted.volumeThreshold;
        }
        if (typeof (dataJustTransmitted.hiFiGain) === "number") {
            this._lastTransmittedHiFiAudioAPIData["hiFiGain"] = dataJustTransmitted.hiFiGain;
        }
        if (typeof (dataJustTransmitted.userAttenuation) === "number") {
            this._lastTransmittedHiFiAudioAPIData["userAttenuation"] = dataJustTransmitted.userAttenuation;
        }
        if (typeof (dataJustTransmitted.userRolloff) === "number") {
            this._lastTransmittedHiFiAudioAPIData["userRolloff"] = dataJustTransmitted.userRolloff;
        }
        if (typeof (dataJustTransmitted._otherUserGainQueue) === "object") {
            if (typeof (this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue) !== "object") {
                this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue = {};
            }
            for (const idToGain of Object.entries(dataJustTransmitted._otherUserGainQueue)) {
                this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue[idToGain[0]] = idToGain[1];
            }
        }
    }
    _transmitHiFiAudioAPIDataToServer(forceTransmit) {
        if (this._mixerSession && (!this._timers.transmitRateLimitTimeout || forceTransmit)) {
            this._timers.wantedToTransmitHiFiAudioAPIData = false;
            this._maybeClearRateLimitTimeout();
            if (!forceTransmit) {
                this._timers.transmitRateLimitTimeout = setTimeout(() => {
                    this._maybeClearRateLimitTimeout();
                    if (this._timers.wantedToTransmitHiFiAudioAPIData) {
                        this._transmitHiFiAudioAPIDataToServer(true);
                    }
                }, this.transmitRateLimitTimeoutMS);
            }
            let transmitRetval = this._mixerSession._transmitHiFiAudioAPIDataToServer(this._currentHiFiAudioAPIData, this._lastTransmittedHiFiAudioAPIData);
            if (transmitRetval.success) {
                this._updateLastTransmittedHiFiAudioAPIData(this._currentHiFiAudioAPIData);
                this._cleanUpHiFiAudioAPIDataHistory();
                return {
                    success: true,
                    rawDataTransmitted: transmitRetval.stringifiedDataForMixer
                };
            }
            else {
                return {
                    success: false,
                    error: transmitRetval.error
                };
            }
        }
        else if (this._mixerSession && this._timers.transmitRateLimitTimeout && !forceTransmit) {
            this._timers.wantedToTransmitHiFiAudioAPIData = true;
            return {
                success: true,
                error: `Transfer is rate limited. Transfer will occur shortly automatically.`
            };
        }
        else if (!this._mixerSession) {
            return {
                success: false,
                error: `No server connection yet; can't transmit user data.`
            };
        }
    }
    _cleanUpHiFiAudioAPIDataHistory() {
        this._currentHiFiAudioAPIData._otherUserGainQueue = {};
        let maxCachedOtherUserGains = 1000;
        if (Object.keys(this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue).length > maxCachedOtherUserGains) {
            this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue = {};
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Stored \`_lastTransmittedHiFiAudioAPIData._otherUserGainQueue\` was too large and was cleared to save space.`);
        }
    }
    updateUserDataAndTransmit(newUserData) {
        this._updateUserData(newUserData);
        return this._transmitHiFiAudioAPIDataToServer();
    }
    _handleUserDataUpdates(newUserDataFromServer) {
        if (this._userDataSubscriptions.length === 0) {
            return;
        }
        for (let subItr = 0; subItr < this._userDataSubscriptions.length; subItr++) {
            let currentSubscription = this._userDataSubscriptions[subItr];
            if (!currentSubscription.callback) {
                continue;
            }
            let currentSubscriptionCallbackData = [];
            for (let dataItr = 0; dataItr < newUserDataFromServer.length; dataItr++) {
                let currentDataFromServer = newUserDataFromServer[dataItr];
                if (currentSubscription.providedUserID && currentDataFromServer.providedUserID !== currentSubscription.providedUserID) {
                    continue;
                }
                let newCallbackData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.ReceivedHiFiAudioAPIData();
                if (typeof (currentDataFromServer.providedUserID) === "string") {
                    newCallbackData.providedUserID = currentDataFromServer.providedUserID;
                }
                if (typeof (currentDataFromServer.hashedVisitID) === "string") {
                    newCallbackData.hashedVisitID = currentDataFromServer.hashedVisitID;
                }
                let shouldPushNewCallbackData = false;
                for (let componentItr = 0; componentItr < currentSubscription.components.length; componentItr++) {
                    let currentComponent = currentSubscription.components[componentItr];
                    switch (currentComponent) {
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.Position:
                            if (currentDataFromServer.position) {
                                newCallbackData.position = currentDataFromServer.position;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.OrientationQuat:
                            if (currentDataFromServer.orientationQuat) {
                                newCallbackData.orientationQuat = currentDataFromServer.orientationQuat;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.OrientationEuler:
                            if (currentDataFromServer.orientationQuat) {
                                newCallbackData.orientationEuler = (0,_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_3__.eulerFromQuaternion)(currentDataFromServer.orientationQuat, _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_4__.ourHiFiAxisConfiguration.eulerOrder);
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.VolumeDecibels:
                            if (typeof (currentDataFromServer.volumeDecibels) === "number") {
                                newCallbackData.volumeDecibels = currentDataFromServer.volumeDecibels;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case _HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_6__.AvailableUserDataSubscriptionComponents.IsStereo:
                            if (typeof (currentDataFromServer.isStereo) === "boolean") {
                                newCallbackData.isStereo = currentDataFromServer.isStereo;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                    }
                }
                if (shouldPushNewCallbackData) {
                    currentSubscriptionCallbackData.push(newCallbackData);
                }
            }
            if (currentSubscription.callback && currentSubscriptionCallbackData.length > 0) {
                currentSubscription.callback(currentSubscriptionCallbackData);
            }
        }
    }
    _onUsersDisconnected(usersDisconnected) {
        if (this.onUsersDisconnected) {
            this.onUsersDisconnected(usersDisconnected);
        }
    }
    addUserDataSubscription(newSubscription) {
        if (!this._mixerSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`No \`_mixerSession\`! Data subscription not added.`);
            return;
        }
        if (this._mixerSession.userDataStreamingScope === HiFiUserDataStreamingScopes.None) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`During \`HiFiCommunicator\` construction, the server was set up to **not** send user data! Data subscription not added.`);
            return;
        }
        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Adding new User Data Subscription:\n${JSON.stringify(newSubscription)}`);
        this._userDataSubscriptions.push(newSubscription);
    }
}


/***/ }),

/***/ "./src/classes/HiFiMixerSession.ts":
/*!*****************************************!*\
  !*** ./src/classes/HiFiMixerSession.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MuteReason": () => (/* binding */ MuteReason),
/* harmony export */   "MuteChangedEvent": () => (/* binding */ MuteChangedEvent),
/* harmony export */   "HiFiMixerSession": () => (/* binding */ HiFiMixerSession)
/* harmony export */ });
/* harmony import */ var _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");
/* harmony import */ var _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* harmony import */ var _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HiFiCommunicator */ "./src/classes/HiFiCommunicator.ts");
/* harmony import */ var _libravi_RaviUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../libravi/RaviUtils */ "./src/libravi/RaviUtils.ts");
/* harmony import */ var _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../libravi/RaviSession */ "./src/libravi/RaviSession.ts");
/* harmony import */ var _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../libravi/RaviSignalingConnection */ "./src/libravi/RaviSignalingConnection.ts");
/* harmony import */ var _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./HiFiAxisConfiguration */ "./src/classes/HiFiAxisConfiguration.ts");
/* harmony import */ var _diagnostics_diagnostics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../diagnostics/diagnostics */ "./src/diagnostics/diagnostics.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








const pako = __webpack_require__(/*! pako */ "./node_modules/pako/index.js");
const INIT_TIMEOUT_MS = 5000;
const PERSONAL_VOLUME_ADJUST_TIMEOUT_MS = 5000;
var MuteReason;
(function (MuteReason) {
    MuteReason["CLIENT"] = "client";
    MuteReason["ADMIN"] = "admin";
    MuteReason["INTERNAL"] = "internal";
})(MuteReason || (MuteReason = {}));
class MuteChangedEvent {
    constructor({ success, targetInputAudioMutedValue, currentInputAudioMutedValue, adminPreventsInputAudioUnmuting, muteReason }) {
        this.success = success;
        this.targetInputAudioMutedValue = targetInputAudioMutedValue;
        this.currentInputAudioMutedValue = currentInputAudioMutedValue;
        this.adminPreventsInputAudioUnmuting = adminPreventsInputAudioUnmuting;
        this.muteReason = muteReason;
    }
}
class HiFiMixerSession {
    constructor({ userDataStreamingScope = _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiUserDataStreamingScopes.All, onUserDataUpdated, onUsersDisconnected, onConnectionStateChanged, onMuteChanged }) {
        this.concurrency = 0;
        this.webRTCAddress = undefined;
        this.userDataStreamingScope = userDataStreamingScope;
        this.onUserDataUpdated = onUserDataUpdated;
        this.onUsersDisconnected = onUsersDisconnected;
        this._mixerPeerKeyToStateCacheDict = {};
        this._lastSuccessfulInputAudioMutedValue = false;
        this.onMuteChanged = onMuteChanged;
        _libravi_RaviUtils__WEBPACK_IMPORTED_MODULE_3__.RaviUtils.setDebug(false);
        this._raviSignalingConnection = new _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingConnection();
        this._raviSignalingConnection.addStateChangeHandler((event) => {
            this.onRAVISignalingStateChanged(event);
        });
        this._raviSession = new _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSession();
        this._raviSession.addStateChangeHandler((event) => {
            this.onRAVISessionStateChanged(event);
        });
        this.onConnectionStateChanged = onConnectionStateChanged;
        this._resetMixerInfo();
        this._raviDiagnostics = new _diagnostics_diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics({ label: 'ravi', session: this, ravi: this._raviSession });
        this._hifiDiagnostics = new _diagnostics_diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics({ label: 'app', session: this, ravi: this._raviSession,
            fireOn: ['visibilitychange', 'pagehide', 'beforeunload'] });
    }
    promiseToRunAudioInit() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let initData = {
                    primary: true,
                    visit_id: this._raviSession.getUUID(),
                    session: this._raviSession.getUUID(),
                    streaming_scope: this.userDataStreamingScope,
                    is_input_stream_stereo: this._inputAudioMediaStreamIsStereo
                };
                let commandController = this._raviSession.getCommandController();
                if (!commandController) {
                    return Promise.reject({
                        success: false,
                        error: `Couldn't connect to mixer: no \`commandController\`!`
                    });
                }
                let initTimeout = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    let errMsg = `Couldn't connect to mixer: Call to \`init\` timed out!`;
                    try {
                        yield this._disconnectFromHiFiMixer();
                    }
                    catch (errorClosing) {
                        errMsg += `\nAdditionally, there was an error trying to close the failed connection. Error:\n${errorClosing}`;
                    }
                    return Promise.reject({
                        success: false,
                        error: errMsg
                    });
                }), INIT_TIMEOUT_MS);
                commandController.queueCommand("audionet.init", initData, (response) => __awaiter(this, void 0, void 0, function* () {
                    clearTimeout(initTimeout);
                    let parsedResponse;
                    try {
                        parsedResponse = JSON.parse(response);
                        this.mixerInfo["connected"] = true;
                        this.mixerInfo["build_number"] = parsedResponse.build_number;
                        this.mixerInfo["build_type"] = parsedResponse.build_type;
                        this.mixerInfo["build_version"] = parsedResponse.build_version;
                        this.mixerInfo["visit_id_hash"] = parsedResponse.visit_id_hash;
                        this._raviDiagnostics.prime(this.mixerInfo.visit_id_hash);
                        this._hifiDiagnostics.prime(this.mixerInfo.visit_id_hash);
                        resolve({
                            success: true,
                            audionetInitResponse: parsedResponse
                        });
                    }
                    catch (e) {
                        reject({
                            success: false,
                            error: `Couldn't parse init response! Parse error:\n${e}`
                        });
                    }
                }));
            });
        });
    }
    handleRAVISessionBinaryData(data) {
        let unGZippedData = pako.ungzip(data, { to: 'string' });
        let jsonData = JSON.parse(unGZippedData);
        if (jsonData.deleted_visit_ids) {
            let allDeletedUserData = [];
            let deletedVisitIDs = jsonData.deleted_visit_ids;
            for (const deletedVisitID of deletedVisitIDs) {
                let hashedVisitID = deletedVisitID;
                let deletedUserData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.ReceivedHiFiAudioAPIData({
                    hashedVisitID: hashedVisitID
                });
                let mixerPeerKeys = Object.keys(this._mixerPeerKeyToStateCacheDict);
                for (const mixerPeerKey of mixerPeerKeys) {
                    if (this._mixerPeerKeyToStateCacheDict[mixerPeerKey].hashedVisitID === hashedVisitID) {
                        if (this._mixerPeerKeyToStateCacheDict[mixerPeerKey].providedUserID) {
                            deletedUserData.providedUserID = this._mixerPeerKeyToStateCacheDict[mixerPeerKey].providedUserID;
                        }
                        break;
                    }
                }
                allDeletedUserData.push(deletedUserData);
            }
            this.concurrency -= allDeletedUserData.length;
            if (this.onUsersDisconnected && allDeletedUserData.length > 0) {
                this.onUsersDisconnected(allDeletedUserData);
            }
        }
        if (jsonData.peers) {
            let allNewUserData = [];
            let peerKeys = Object.keys(jsonData.peers);
            for (let itr = 0; itr < peerKeys.length; itr++) {
                let peerDataFromMixer = jsonData.peers[peerKeys[itr]];
                let userDataCache;
                if (this._mixerPeerKeyToStateCacheDict[peerKeys[itr]]) {
                    userDataCache = this._mixerPeerKeyToStateCacheDict[peerKeys[itr]];
                }
                else {
                    userDataCache = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.ReceivedHiFiAudioAPIData();
                    this._mixerPeerKeyToStateCacheDict[peerKeys[itr]] = userDataCache;
                    this.concurrency += 1;
                }
                let newUserData = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.ReceivedHiFiAudioAPIData();
                if (userDataCache.providedUserID) {
                    newUserData.providedUserID = userDataCache.providedUserID;
                }
                else if (typeof (peerDataFromMixer.J) === "string") {
                    userDataCache.providedUserID = peerDataFromMixer.J;
                    newUserData.providedUserID = peerDataFromMixer.J;
                }
                if (userDataCache.hashedVisitID) {
                    newUserData.hashedVisitID = userDataCache.hashedVisitID;
                }
                else if (typeof (peerDataFromMixer.e) === "string") {
                    userDataCache.hashedVisitID = peerDataFromMixer.e;
                    newUserData.hashedVisitID = peerDataFromMixer.e;
                }
                let serverSentNewUserData = false;
                let serverSentNewPosition = false;
                if (typeof (peerDataFromMixer.x) === "number") {
                    if (!userDataCache.position) {
                        userDataCache.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.Point3D();
                    }
                    userDataCache.position.x = peerDataFromMixer.x / 1000;
                    serverSentNewPosition = true;
                }
                if (typeof (peerDataFromMixer.y) === "number") {
                    if (!userDataCache.position) {
                        userDataCache.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.Point3D();
                    }
                    userDataCache.position.y = peerDataFromMixer.y / 1000;
                    serverSentNewPosition = true;
                }
                if (typeof (peerDataFromMixer.z) === "number") {
                    if (!userDataCache.position) {
                        userDataCache.position = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.Point3D();
                    }
                    userDataCache.position.z = peerDataFromMixer.z / 1000;
                    serverSentNewPosition = true;
                }
                if (serverSentNewPosition) {
                    newUserData.position = _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisUtilities.translatePoint3DFromMixerSpace(_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.ourHiFiAxisConfiguration, userDataCache.position);
                    serverSentNewUserData = true;
                }
                let serverSentNewOrientation = false;
                if (typeof (peerDataFromMixer.W) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.w = peerDataFromMixer.W / 1000;
                    serverSentNewOrientation = true;
                }
                if (typeof (peerDataFromMixer.X) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.x = peerDataFromMixer.X / 1000;
                    serverSentNewOrientation = true;
                }
                if (typeof (peerDataFromMixer.Y) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.y = peerDataFromMixer.Y / 1000;
                    serverSentNewOrientation = true;
                }
                if (typeof (peerDataFromMixer.Z) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new _HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_0__.OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.z = peerDataFromMixer.Z / 1000;
                    serverSentNewOrientation = true;
                }
                if (serverSentNewOrientation) {
                    newUserData.orientationQuat = _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisUtilities.translateOrientationQuat3DFromMixerSpace(_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.ourHiFiAxisConfiguration, userDataCache.orientationQuat);
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.v) === "number") {
                    userDataCache.volumeDecibels = peerDataFromMixer.v;
                    newUserData.volumeDecibels = peerDataFromMixer.v;
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.s) === "boolean") {
                    userDataCache.isStereo = peerDataFromMixer.s;
                    newUserData.isStereo = peerDataFromMixer.s;
                    serverSentNewUserData = true;
                }
                if (serverSentNewUserData) {
                    allNewUserData.push(newUserData);
                }
            }
            if (this.onUserDataUpdated && allNewUserData.length > 0) {
                this.onUserDataUpdated(allNewUserData);
            }
        }
        if (jsonData.instructions) {
            for (const instruction of jsonData.instructions) {
                if (!Array.isArray(instruction) || !instruction.length) {
                    continue;
                }
                let instructionName = instruction[0];
                let instructionArguments = instruction.slice(1);
                if (instructionName === "mute") {
                    let shouldBeMuted;
                    if (instructionArguments.length >= 1) {
                        if (typeof (instructionArguments[0]) === "boolean") {
                            shouldBeMuted = instructionArguments[0];
                        }
                    }
                    if (shouldBeMuted !== undefined) {
                        this._setMutedByAdmin(shouldBeMuted, MuteReason.ADMIN);
                    }
                }
            }
        }
    }
    connectToHiFiMixer({ webRTCSessionParams, customSTUNandTURNConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._currentHiFiConnectionState === _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Connected && this.mixerInfo["connected"]) {
                let msg = `Already connected! If a reconnect is needed, please hang up and try again.`;
                return Promise.resolve(msg);
            }
            if (!this.webRTCAddress) {
                let errMsg = `Couldn't connect: \`this.webRTCAddress\` is falsey!`;
                try {
                    yield this._disconnectFromHiFiMixer();
                }
                catch (errorClosing) {
                    errMsg += `\nAdditionally, there was an error trying to close the failed connection. Error:\n${errorClosing}`;
                }
                return Promise.reject(errMsg);
            }
            this._currentHiFiConnectionState = undefined;
            let mixerIsUnavailable = false;
            const tempUnavailableStateHandler = (event) => {
                if (event && event.state === _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingStates.UNAVAILABLE) {
                    mixerIsUnavailable = true;
                    this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                    this._raviSession.closeRAVISession();
                }
            };
            this._raviSignalingConnection.addStateChangeHandler(tempUnavailableStateHandler);
            try {
                yield this._raviSignalingConnection.openRAVISignalingConnection(this.webRTCAddress);
            }
            catch (errorOpeningSignalingConnection) {
                let errMsg = `Couldn't open signaling connection to \`${this.webRTCAddress.slice(0, this.webRTCAddress.indexOf("token="))}<token redacted>\`! Error:\n${errorOpeningSignalingConnection}`;
                try {
                    yield this._disconnectFromHiFiMixer();
                }
                catch (errorClosing) {
                    errMsg += `\nAdditionally, there was an error trying to close the failed connection. Error:\n${errorClosing}`;
                }
                this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                return Promise.reject(errMsg);
            }
            try {
                yield this._raviSession.openRAVISession({ signalingConnection: this._raviSignalingConnection, params: webRTCSessionParams, customStunAndTurn: customSTUNandTURNConfig });
            }
            catch (errorOpeningRAVISession) {
                let errMsg = `Couldn't open RAVI session associated with \`${this.webRTCAddress.slice(0, this.webRTCAddress.indexOf("token="))}<token redacted>\`! Error:\n${errorOpeningRAVISession}`;
                if (mixerIsUnavailable) {
                    errMsg = `High Fidelity server is at capacity; service is unavailable.`;
                }
                try {
                    yield this._disconnectFromHiFiMixer();
                }
                catch (errorClosing) {
                    errMsg += `\nAdditionally, there was an error trying to close the connection. Error:\n${errorClosing}`;
                }
                this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                return Promise.reject(errMsg);
            }
            let audionetInitResponse;
            try {
                audionetInitResponse = yield this.promiseToRunAudioInit();
            }
            catch (initError) {
                let errMsg = `\`audionet.init\` command failed! Error:\n${initError.error}`;
                try {
                    yield this._disconnectFromHiFiMixer();
                }
                catch (errorClosing) {
                    errMsg += `\nAdditionally, there was an error trying to close the failed connection. Error:\n${errorClosing}`;
                }
                this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                return Promise.reject(errMsg);
            }
            this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
            this.concurrency = 0;
            this._raviSession.getCommandController().addBinaryHandler((data) => { this.handleRAVISessionBinaryData(data); }, true);
            return Promise.resolve(audionetInitResponse);
        });
    }
    disconnectFromHiFiMixer() {
        return __awaiter(this, void 0, void 0, function* () {
            this._raviDiagnostics.noteExplicitApplicationClose();
            this._hifiDiagnostics.noteExplicitApplicationClose();
            return this._disconnectFromHiFiMixer();
        });
    }
    _disconnectFromHiFiMixer() {
        return __awaiter(this, void 0, void 0, function* () {
            function close(thingToClose, nameOfThingToClose, closedState) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (thingToClose) {
                        let state = thingToClose.getState();
                        if (!thingToClose || state === closedState) {
                            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`The RAVI ${nameOfThingToClose} was already closed.`);
                        }
                        else {
                            try {
                                if (thingToClose instanceof _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingConnection) {
                                    yield thingToClose.closeRAVISignalingConnection();
                                }
                                else if (thingToClose instanceof _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSession) {
                                    yield thingToClose.closeRAVISession();
                                }
                                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`The RAVI ${nameOfThingToClose} closed successfully from state ${state}.`);
                            }
                            catch (e) {
                                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`The RAVI ${nameOfThingToClose} didn't close successfully from state ${state}! Error:\n${e}`);
                            }
                        }
                    }
                    else {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`The RAVI ${nameOfThingToClose} was missing.`);
                    }
                    thingToClose = null;
                });
            }
            yield close(this._raviSignalingConnection, "Signaling Connection", _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingStates.CLOSED);
            yield close(this._raviSession, "Session", _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.CLOSED);
            this._resetMixerInfo();
            yield this._setMutedByAdmin(false, MuteReason.INTERNAL);
            return Promise.resolve(`Successfully disconnected.`);
        });
    }
    setRAVIInputAudio(inputAudioMediaStream, isStereo = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let retval = false;
            if (this._raviSession) {
                let streamController = this._raviSession.getStreamController();
                if (!streamController) {
                    _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set input audio on _raviSession.streamController: No \`streamController\`!`);
                    retval = false;
                }
                else {
                    streamController.setInputAudio(inputAudioMediaStream, isStereo);
                    _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set input audio on _raviSession.streamController!`);
                    retval = true;
                }
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set input audio on _raviSession.streamController: No \`_raviSession\`!`);
                retval = false;
            }
            if (retval) {
                if (this._inputAudioMediaStreamIsStereo != isStereo) {
                    if (this._raviSession.getState() === _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.CONNECTED) {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Stereo status has changed from ${this._inputAudioMediaStreamIsStereo} to ${isStereo}; attempting to re-initialize with the mixer`);
                        let audionetInitResponse;
                        try {
                            this._inputAudioMediaStreamIsStereo = isStereo;
                            audionetInitResponse = yield this.promiseToRunAudioInit();
                        }
                        catch (initError) {
                            let errMsg = `Attempt to call \`audionet.init\` for change in stereo status failed! Error:\n${initError.error}`;
                            return Promise.reject(errMsg);
                        }
                    }
                    else {
                        this._inputAudioMediaStreamIsStereo = isStereo;
                    }
                }
            }
            return retval;
        });
    }
    setInputAudioMuted(newMutedValue, tryToStopMicStream = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._setMuted(newMutedValue, tryToStopMicStream, MuteReason.CLIENT);
        });
    }
    _setMutedByAdmin(mutedByAdmin, muteReason) {
        return __awaiter(this, void 0, void 0, function* () {
            this._adminPreventsInputAudioUnmuting = mutedByAdmin;
            return yield this._setMuted(mutedByAdmin || this._lastSuccessfulInputAudioMutedValue, false, muteReason);
        });
    }
    _setMuted(newMutedValue, tryToStopMicStream, muteReason) {
        return __awaiter(this, void 0, void 0, function* () {
            let success = true;
            if (muteReason == MuteReason.CLIENT) {
                if (this._adminPreventsInputAudioUnmuting && !newMutedValue) {
                    _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: Muted by admin.`);
                    success = false;
                }
            }
            if (success) {
                success = yield this._trySetInputAudioMuted(newMutedValue, tryToStopMicStream);
            }
            if (success) {
                this._lastSuccessfulInputAudioMutedValue = newMutedValue;
            }
            if (this.onMuteChanged) {
                this.onMuteChanged(new MuteChangedEvent({
                    success: success,
                    targetInputAudioMutedValue: newMutedValue,
                    currentInputAudioMutedValue: this._lastSuccessfulInputAudioMutedValue,
                    adminPreventsInputAudioUnmuting: this._adminPreventsInputAudioUnmuting,
                    muteReason: muteReason
                }));
            }
            return success;
        });
    }
    _trySetInputAudioMuted(newMutedValue, tryToStopMicStream) {
        return __awaiter(this, void 0, void 0, function* () {
            let streamController = this._raviSession.getStreamController();
            if (this._raviSession && streamController) {
                let hasMicPermission = false;
                if (typeof (navigator) !== "undefined" && navigator.permissions && navigator.permissions.query) {
                    let result;
                    try {
                        result = yield navigator.permissions.query({ name: 'microphone' });
                    }
                    catch (_a) { }
                    if (result && result.state === "granted") {
                        hasMicPermission = true;
                    }
                }
                if (!tryToStopMicStream || !hasMicPermission || typeof self === 'undefined') {
                    let raviAudioStream = streamController._inputAudioStream;
                    if (raviAudioStream) {
                        raviAudioStream.getTracks().forEach((track) => {
                            track.enabled = !newMutedValue;
                        });
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set mute state to ${newMutedValue} on _raviSession.streamController._inputAudioStream`);
                        return true;
                    }
                    else {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: No \`_inputAudioStream\` on \`_raviSession.streamController\`.`);
                    }
                }
                else {
                    let raviAudioStream = streamController._inputAudioStream;
                    if (raviAudioStream && newMutedValue) {
                        raviAudioStream.getTracks().forEach((track) => {
                            this._cachedMediaTrackConstraints = track.getConstraints();
                            track.stop();
                        });
                        streamController.setInputAudio(null);
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set mute state to \`true\` by stopping all input media tracks!`);
                        return true;
                    }
                    else if (!raviAudioStream && !newMutedValue) {
                        let newMediaStream = yield navigator.mediaDevices.getUserMedia({ audio: this._cachedMediaTrackConstraints, video: false });
                        streamController.setInputAudio(newMediaStream);
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set mute state to \`false\` by getting new input media stream!`);
                        return true;
                    }
                    else if (raviAudioStream && !newMutedValue) {
                        raviAudioStream.getTracks().forEach((track) => {
                            track.enabled = true;
                        });
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Successfully set mute state to \`false\` by enabling all tracks on \`_raviSession.streamController._inputAudioStream\`!`);
                        return true;
                    }
                    else {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: No \`_inputAudioStream\` on \`_raviSession.streamController\`.`);
                    }
                }
            }
            else {
                _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.warn(`Couldn't set mute state: No \`_raviSession\`, or \`_raviSession.getStreamController()\` returned null.`);
                return false;
            }
        });
    }
    getOutputAudioMediaStream() {
        if (!this._raviSession) {
            return null;
        }
        let streamController = this._raviSession.getStreamController();
        if (!streamController) {
            return null;
        }
        return streamController.getAudioStream();
    }
    _setCurrentHiFiConnectionState(state) {
        if (this._currentHiFiConnectionState !== state) {
            this._currentHiFiConnectionState = state;
            if (this.onConnectionStateChanged) {
                this.onConnectionStateChanged(this._currentHiFiConnectionState);
            }
            this._hifiDiagnostics.fire();
        }
    }
    getCurrentHiFiConnectionState() {
        return this._currentHiFiConnectionState;
    }
    onRAVISignalingStateChanged(event) {
        return __awaiter(this, void 0, void 0, function* () {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`New RAVI signaling state: \`${event.state}\``);
            switch (event.state) {
                case _libravi_RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_5__.RaviSignalingStates.UNAVAILABLE:
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Unavailable);
                    try {
                        yield this._disconnectFromHiFiMixer();
                    }
                    catch (errorClosing) {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Error encountered while trying to close the connection. Error:\n${errorClosing}`);
                    }
                    break;
            }
        });
    }
    onRAVISessionStateChanged(event) {
        return __awaiter(this, void 0, void 0, function* () {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`New RAVI session state: \`${event.state}\``);
            this._raviDiagnostics.fire();
            switch (event.state) {
                case _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.CONNECTED:
                    this._mixerPeerKeyToStateCacheDict = {};
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Connected);
                    break;
                case _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.DISCONNECTED:
                    if (this._currentHiFiConnectionState === _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Unavailable) {
                        break;
                    }
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Disconnected);
                    try {
                        yield this._disconnectFromHiFiMixer();
                    }
                    catch (errorClosing) {
                        _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.log(`Error encountered while trying to close the connection. Error:\n${errorClosing}`);
                    }
                    break;
                case _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.FAILED:
                    if (this._currentHiFiConnectionState === _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Unavailable) {
                        break;
                    }
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Failed);
                    break;
                case _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_4__.RaviSessionStates.CLOSED:
                    if (this._currentHiFiConnectionState === _HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Unavailable) {
                        break;
                    }
                    this._setCurrentHiFiConnectionState(_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates.Disconnected);
                    break;
            }
        });
    }
    startCollectingWebRTCStats(callback) {
        if (!this._raviSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`Couldn't start collecting WebRTC stats: No \`_raviSession\`!`);
            return;
        }
        if (this._statsObserverCallback) {
            this.stopCollectingWebRTCStats();
        }
        this._statsObserverCallback = callback;
        this._raviSession.addStatsObserver(this._statsObserverCallback);
    }
    stopCollectingWebRTCStats() {
        if (!this._raviSession) {
            _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_1__.HiFiLogger.error(`Couldn't stop collecting WebRTC stats: No \`_raviSession\`!`);
            return;
        }
        this._raviSession.removeStatsObserver(this._statsObserverCallback);
        this._statsObserverCallback = undefined;
    }
    _transmitHiFiAudioAPIDataToServer(currentHifiAudioAPIData, previousHifiAudioAPIData) {
        if (!this.mixerInfo["connected"] || !this._raviSession) {
            return {
                success: false,
                error: `Can't transmit data to mixer; not connected to mixer.`
            };
        }
        let dataForMixer = {};
        if (currentHifiAudioAPIData.position && (typeof (currentHifiAudioAPIData.position.x) === "number")
            && (typeof (currentHifiAudioAPIData.position.y) === "number")
            && (typeof (currentHifiAudioAPIData.position.z) === "number")) {
            let changedComponents = { x: false, y: false, z: false, changed: false };
            if (previousHifiAudioAPIData && previousHifiAudioAPIData.position) {
                if (currentHifiAudioAPIData.position.x !== previousHifiAudioAPIData.position.x) {
                    changedComponents.x = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.position.y !== previousHifiAudioAPIData.position.y) {
                    changedComponents.y = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.position.z !== previousHifiAudioAPIData.position.z) {
                    changedComponents.z = true;
                    changedComponents.changed = true;
                }
            }
            else {
                changedComponents.x = true;
                changedComponents.y = true;
                changedComponents.z = true;
                changedComponents.changed = true;
            }
            if (changedComponents.changed) {
                let translatedPosition = _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisUtilities.translatePoint3DToMixerSpace(_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.ourHiFiAxisConfiguration, currentHifiAudioAPIData.position);
                if (changedComponents.x) {
                    dataForMixer["x"] = Math.round(translatedPosition.x * 1000);
                }
                if (changedComponents.y) {
                    dataForMixer["y"] = Math.round(translatedPosition.y * 1000);
                }
                if (changedComponents.z) {
                    dataForMixer["z"] = Math.round(translatedPosition.z * 1000);
                }
            }
        }
        if (currentHifiAudioAPIData.orientationQuat && (typeof (currentHifiAudioAPIData.orientationQuat.w) === "number")
            && (typeof (currentHifiAudioAPIData.orientationQuat.x) === "number")
            && (typeof (currentHifiAudioAPIData.orientationQuat.y) === "number")
            && (typeof (currentHifiAudioAPIData.orientationQuat.z) === "number")) {
            let changedComponents = { w: false, x: false, y: false, z: false, changed: false };
            if (previousHifiAudioAPIData && previousHifiAudioAPIData.orientationQuat) {
                if (currentHifiAudioAPIData.orientationQuat.w !== previousHifiAudioAPIData.orientationQuat.w) {
                    changedComponents.w = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.orientationQuat.x !== previousHifiAudioAPIData.orientationQuat.x) {
                    changedComponents.x = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.orientationQuat.y !== previousHifiAudioAPIData.orientationQuat.y) {
                    changedComponents.y = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.orientationQuat.z !== previousHifiAudioAPIData.orientationQuat.z) {
                    changedComponents.z = true;
                    changedComponents.changed = true;
                }
            }
            else {
                changedComponents.w = true;
                changedComponents.x = true;
                changedComponents.y = true;
                changedComponents.z = true;
                changedComponents.changed = true;
            }
            if (changedComponents.changed) {
                let translatedOrientation = _HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisUtilities.translateOrientationQuat3DToMixerSpace(_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.ourHiFiAxisConfiguration, currentHifiAudioAPIData.orientationQuat);
                if (changedComponents.w) {
                    dataForMixer["W"] = translatedOrientation.w * 1000;
                }
                if (changedComponents.x) {
                    dataForMixer["X"] = translatedOrientation.x * 1000;
                }
                if (changedComponents.y) {
                    dataForMixer["Y"] = translatedOrientation.y * 1000;
                }
                dataForMixer["Z"] = translatedOrientation.z * 1000;
            }
        }
        if (typeof (currentHifiAudioAPIData.volumeThreshold) === "number") {
            dataForMixer["T"] = currentHifiAudioAPIData.volumeThreshold;
        }
        if (typeof (currentHifiAudioAPIData.hiFiGain) === "number") {
            dataForMixer["g"] = Math.max(0, currentHifiAudioAPIData.hiFiGain);
        }
        if (typeof (currentHifiAudioAPIData.userAttenuation) === "number") {
            dataForMixer["a"] = currentHifiAudioAPIData.userAttenuation;
        }
        if (typeof (currentHifiAudioAPIData.userRolloff) === "number") {
            dataForMixer["r"] = Math.max(0, currentHifiAudioAPIData.userRolloff);
        }
        if (typeof (currentHifiAudioAPIData._otherUserGainQueue) == "object") {
            let changedUserGains = {};
            let idToGains = Object.entries(currentHifiAudioAPIData._otherUserGainQueue);
            let previousOtherUserGains = previousHifiAudioAPIData ? previousHifiAudioAPIData._otherUserGainQueue : undefined;
            for (const idToGain of idToGains) {
                let hashedVisitId = idToGain[0];
                let gain = idToGain[1];
                if (!(typeof (gain) == "number")) {
                    continue;
                }
                if (previousOtherUserGains && previousOtherUserGains[hashedVisitId] === gain) {
                    continue;
                }
                changedUserGains[hashedVisitId] = gain;
            }
            if (Object.entries(changedUserGains).length) {
                dataForMixer["V"] = changedUserGains;
            }
        }
        if (Object.keys(dataForMixer).length === 0) {
            return {
                success: true,
                stringifiedDataForMixer: JSON.stringify({})
            };
        }
        else {
            let commandController = this._raviSession.getCommandController();
            if (commandController) {
                let stringifiedDataForMixer = JSON.stringify(dataForMixer);
                commandController.sendInput(stringifiedDataForMixer);
                return {
                    success: true,
                    stringifiedDataForMixer: stringifiedDataForMixer
                };
            }
            else {
                return {
                    success: false,
                    error: `Can't transmit data to mixer; no \`commandController\`!.`
                };
            }
        }
    }
    _resetMixerInfo() {
        this.mixerInfo = {
            "connected": false,
        };
    }
}


/***/ }),

/***/ "./src/classes/HiFiUserDataSubscription.ts":
/*!*************************************************!*\
  !*** ./src/classes/HiFiUserDataSubscription.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AvailableUserDataSubscriptionComponents": () => (/* binding */ AvailableUserDataSubscriptionComponents),
/* harmony export */   "UserDataSubscription": () => (/* binding */ UserDataSubscription)
/* harmony export */ });
var AvailableUserDataSubscriptionComponents;
(function (AvailableUserDataSubscriptionComponents) {
    AvailableUserDataSubscriptionComponents["Position"] = "Position";
    AvailableUserDataSubscriptionComponents["OrientationEuler"] = "Orientation (Euler)";
    AvailableUserDataSubscriptionComponents["OrientationQuat"] = "Orientation (Quaternion)";
    AvailableUserDataSubscriptionComponents["VolumeDecibels"] = "Volume (Decibels)";
    AvailableUserDataSubscriptionComponents["IsStereo"] = "IsStereo";
})(AvailableUserDataSubscriptionComponents || (AvailableUserDataSubscriptionComponents = {}));
class UserDataSubscription {
    constructor({ providedUserID = null, components, callback }) {
        this.providedUserID = providedUserID;
        this.components = components;
        this.callback = callback;
    }
}


/***/ }),

/***/ "./src/constants/HiFiConstants.ts":
/*!****************************************!*\
  !*** ./src/constants/HiFiConstants.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiConstants": () => (/* binding */ HiFiConstants)
/* harmony export */ });
class HiFiConstants {
    constructor() { }
}
HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS = 10;
HiFiConstants.DEFAULT_TRANSMIT_RATE_LIMIT_TIMEOUT_MS = 50;
HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_ENDPOINT = "api.highfidelity.com";
HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_PORT = 443;
;


/***/ }),

/***/ "./src/diagnostics/diagnostics.ts":
/*!****************************************!*\
  !*** ./src/diagnostics/diagnostics.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Diagnostics": () => (/* binding */ Diagnostics)
/* harmony export */ });
/* harmony import */ var _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libravi/RaviSession */ "./src/libravi/RaviSession.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const isBrowser = typeof window !== 'undefined';
const noop = (_) => undefined;
const xStorage = isBrowser ? window.localStorage : { getItem: noop, setItem: noop, removeItem: noop };
const xAddEventListener = isBrowser ? window.addEventListener : noop;
const xRemoveEventListener = isBrowser ? window.removeEventListener : noop;
const xDocument = isBrowser ? window.document : { visibilityState: true, addEventListener: noop, removeEventListener: noop };
const xNavigator = isBrowser ? window.navigator : { onLine: true, userAgent: `NodeJS ${process.report.getReport().header.nodejsVersion}` };
let xfetch = isBrowser && window.fetch;
if (!isBrowser) {
    try {
        xfetch = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
    }
    catch (e) {
        ;
    }
}
const nonOperative = "non-operative";
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('remote-inbound-rtp', _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.get('remote-inbound-rtp').concat(['packetsLost', 'totalRoundTripTime']));
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('inbound-rtp', _libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.get('inbound-rtp').concat(['packetsLost', 'packetsReceived', 'jitter']));
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('outbound-rtp', ['type', 'retransmittedPacketsSent', 'packetsSent']);
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('candidate-pair', ['writable', 'state', 'nominated', 'localCandidateId', 'remoteCandidateId']);
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('remote-candidate', ['id', 'address', 'ip', 'candidateType', 'protocol']);
_libravi_RaviSession__WEBPACK_IMPORTED_MODULE_0__.STATS_WATCHER_FILTER.set('local-candidate', ['id', 'address', 'ip', 'candidateType', 'protocol']);
let nStatsClients = 0;
let browserStats = {};
let remoteStats = {};
let reports;
const useDebugPrefixes = false;
class Diagnostics {
    constructor({ url = "https://webrtc-diag.highfidelity.com/api/v1/logs/post_logs", label, session, ravi, fireOn = [] }) {
        Object.assign(this, { url, label, session, ravi, fireOn });
        this.checkPersisted();
        this.reset();
        this.fireListener = () => this.fire();
        this.onlineListener = () => this.checkPersisted();
    }
    prime(identifier) {
        if (this.isPrimed())
            return;
        this.checkPersisted();
        this.identifier = identifier;
        this.grabRTCInternals();
        Diagnostics.startStats(this.session);
        this.fireOn.forEach(event => xDocument.addEventListener(event, this.fireListener));
    }
    fire() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isPrimed())
                return;
            const reportString = this.toString();
            if (!(yield this.report(reportString))) {
                this.persist(reportString);
            }
            this.reset();
        });
    }
    noteExplicitApplicationClose() {
        this.explicitApplicationClose = true;
    }
    reset() {
        Diagnostics.stopStats(this.session);
        this.identifier = nonOperative;
        this.explicitApplicationClose = false;
        this.webSocket = this.rtc = {};
        this.fireOn.forEach(event => xDocument.removeEventListener(event, this.fireListener));
        reports = {
            'outbound-rtp': {},
            'inbound-rtp': {},
            'remote-inbound-rtp': {}
        };
    }
    isPrimed() {
        return this.identifier !== nonOperative;
    }
    toString() {
        return `${new Date().toISOString()} ${this.identifier} applogReason_sessionEND` +
            this.connectionStats('browserStats') +
            this.connectionStats('mixerStats') +
            this.rtpStats() +
            this.rtcStates() +
            this.s('NUM_CONNECTED', this.session.concurrency, '\n') +
            this.s('APPSTATE', this.session.getCurrentHiFiConnectionState(), '\n') +
            this.s('RAVISTATE', this.ravi.getState()) +
            this.s('ONLINE', xNavigator.onLine ? 'yes' : 'no') +
            this.s('XPLICITCLOSED', this.explicitApplicationClose ? 'yes' : 'no') +
            this.visibilityInfo() +
            this.connectionInfo() +
            (useDebugPrefixes ? '\n' : '') +
            ` [${xNavigator.userAgent}]`;
    }
    s(name, value, debugPrefix = '') {
        let separator = isNaN(value) ? '_' : ':';
        return `${useDebugPrefixes ? debugPrefix : ''} ${this.label}${name}${separator}${value}`;
    }
    connectionInfo() {
        const info = xNavigator.connection || xNavigator.mozConnection || xNavigator.webkitConnection || {};
        return this.s('DEVICE', info.type, '\n') +
            this.s('RATING', info.effectiveType) +
            this.s('DL', info.downlink) +
            this.s('RTT', info.rtt);
    }
    visibilityInfo() {
        return this.s('VISIBLITY', xDocument.visibilityState);
    }
    grabRTCInternals() {
        let ravi = this.ravi, raviRTC = ravi._raviImplementation, signaling = raviRTC._signalingConnection._signalingImplementation;
        this.webSocket = signaling._webSocket;
        this.rtc = raviRTC._rtcConnection;
    }
    rtcStates() {
        let collector = {}, safelyGet = (property, source = this.rtc) => {
            try {
                collector[property] = source[property];
            }
            catch (e) {
                collector[property] = e.name;
            }
        };
        safelyGet('readyState', this.webSocket);
        ['connectionState', 'signalingState', 'iceConnctionState', 'iceGatheringState'].forEach(p => safelyGet(p));
        return this.s('WebSocket', collector.readyState, '\n') +
            this.s('RTC', collector.connectionState) +
            this.s('SIGNALING', collector.signalingState) +
            this.s('ICE', collector.iceConnectionState) +
            this.s('GATHERING', collector.iceGatheringState);
    }
    connectionStats(kind) {
        let report = kind === 'browserStats' ? browserStats : remoteStats;
        return this.s(kind + 'IP', report.ip || report.address, '\n') +
            this.s(kind + 'TYPE', report.candidateType) +
            this.s(kind + 'PROTOCOL', report.protocol);
    }
    rtpStats() {
        let s = '';
        Object.keys(reports).forEach(reportName => {
            let report = reports[reportName], first = true;
            Object.keys(report).forEach(propertyName => {
                s += this.s(`${reportName}_${propertyName}`, report[propertyName], first ? '\n' : '');
                first = false;
            });
        });
        return s;
    }
    report(reportString) {
        if (!xNavigator.onLine)
            return false;
        if (!xfetch)
            return false;
        return xfetch(this.url, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: reportString
        }).then((response) => response.ok, (x) => false);
    }
    persist(reportString) {
        let existing = xStorage.getItem(this.label) || "";
        if (existing)
            existing += "\n";
        xStorage.setItem(this.label, existing + reportString);
        xAddEventListener('online', this.onlineListener);
    }
    checkPersisted() {
        return __awaiter(this, void 0, void 0, function* () {
            xRemoveEventListener('online', this.onlineListener);
            let existing = xStorage.getItem(this.label);
            if (!existing)
                return;
            if (!(yield this.report(existing)))
                return;
            xStorage.removeItem(this.label);
        });
    }
    static startStats(session) {
        if (nStatsClients++ > 0)
            return;
        session.startCollectingWebRTCStats((next, previous) => {
            let selected = next.find((report) => report.writable || report.nominated), localReport = next.find((report) => report.id === selected.localCandidateId), remoteReport = next.find((report) => report.id === selected.remoteCandidateId);
            if (localReport)
                browserStats = localReport;
            if (remoteReport)
                remoteStats = remoteReport;
            function note(type, deltaProperties, absoluteProperties = []) {
                function findReport(list) {
                    return list.find((report) => {
                        return report.type == type;
                    });
                }
                let previousReport = findReport(previous), nextReport = findReport(next);
                deltaProperties.forEach(property => reports[type][property] =
                    nextReport && (nextReport[property] - (previousReport ? previousReport[property] : 0)));
                absoluteProperties.forEach(property => reports[type][property] =
                    nextReport && nextReport[property]);
            }
            note('outbound-rtp', ['retransmittedPacketsSent', 'packetsSent']);
            note('inbound-rtp', ['packetsLost', 'packetsReceived'], ['jitter']);
            note('remote-inbound-rtp', ['packetsLost'], ['roundTripTime', 'totalRoundTripTime', 'jitter']);
        });
    }
    static stopStats(session) {
        if (!nStatsClients)
            return;
        if (--nStatsClients > 0)
            return;
        session.stopCollectingWebRTCStats();
        browserStats = remoteStats = {};
    }
}


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiUtilities": () => (/* reexport safe */ _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities),
/* harmony export */   "hiFiAPIVersion": () => (/* binding */ apiVersion),
/* harmony export */   "apiVersion": () => (/* binding */ apiVersion),
/* harmony export */   "HiFiAudioAPIData": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.HiFiAudioAPIData),
/* harmony export */   "ReceivedHiFiAudioAPIData": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.ReceivedHiFiAudioAPIData),
/* harmony export */   "OrientationEuler3D": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationEuler3D),
/* harmony export */   "OrientationQuat3D": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.OrientationQuat3D),
/* harmony export */   "Point3D": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.Point3D),
/* harmony export */   "eulerToQuaternion": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.eulerToQuaternion),
/* harmony export */   "eulerFromQuaternion": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.eulerFromQuaternion),
/* harmony export */   "HiFiCommunicator": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiCommunicator),
/* harmony export */   "HiFiConnectionStates": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates),
/* harmony export */   "HiFiUserDataStreamingScopes": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiUserDataStreamingScopes),
/* harmony export */   "AvailableUserDataSubscriptionComponents": () => (/* reexport safe */ _classes_HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_3__.AvailableUserDataSubscriptionComponents),
/* harmony export */   "UserDataSubscription": () => (/* reexport safe */ _classes_HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_3__.UserDataSubscription),
/* harmony export */   "HiFiLogLevel": () => (/* reexport safe */ _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__.HiFiLogLevel),
/* harmony export */   "HiFiLogger": () => (/* reexport safe */ _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__.HiFiLogger),
/* harmony export */   "HiFiConstants": () => (/* reexport safe */ _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_5__.HiFiConstants),
/* harmony export */   "HiFiAxes": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxes),
/* harmony export */   "HiFiHandedness": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiHandedness),
/* harmony export */   "HiFiAxisConfiguration": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisConfiguration),
/* harmony export */   "getBestAudioConstraints": () => (/* binding */ getBestAudioConstraints),
/* harmony export */   "preciseInterval": () => (/* binding */ preciseInterval),
/* harmony export */   "Communicator": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiCommunicator),
/* harmony export */   "ConnectionStates": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiConnectionStates),
/* harmony export */   "UserDataStreamingScopes": () => (/* reexport safe */ _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__.HiFiUserDataStreamingScopes),
/* harmony export */   "ReceivedAudioAPIData": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.ReceivedHiFiAudioAPIData),
/* harmony export */   "AudioAPIData": () => (/* reexport safe */ _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__.HiFiAudioAPIData),
/* harmony export */   "Logger": () => (/* reexport safe */ _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__.HiFiLogger),
/* harmony export */   "LogLevel": () => (/* reexport safe */ _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__.HiFiLogLevel),
/* harmony export */   "Utilities": () => (/* reexport safe */ _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities),
/* harmony export */   "Constants": () => (/* reexport safe */ _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_5__.HiFiConstants),
/* harmony export */   "Axes": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxes),
/* harmony export */   "Handedness": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiHandedness),
/* harmony export */   "AxisConfiguration": () => (/* reexport safe */ _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__.HiFiAxisConfiguration)
/* harmony export */ });
/* harmony import */ var _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities/HiFiUtilities */ "./src/utilities/HiFiUtilities.ts");
/* harmony import */ var _classes_HiFiAudioAPIData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/HiFiAudioAPIData */ "./src/classes/HiFiAudioAPIData.ts");
/* harmony import */ var _classes_HiFiCommunicator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/HiFiCommunicator */ "./src/classes/HiFiCommunicator.ts");
/* harmony import */ var _classes_HiFiUserDataSubscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classes/HiFiUserDataSubscription */ "./src/classes/HiFiUserDataSubscription.ts");
/* harmony import */ var _utilities_HiFiLogger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utilities/HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* harmony import */ var _constants_HiFiConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants/HiFiConstants */ "./src/constants/HiFiConstants.ts");
/* harmony import */ var _classes_HiFiAxisConfiguration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./classes/HiFiAxisConfiguration */ "./src/classes/HiFiAxisConfiguration.ts");


let isBrowserContext = typeof self !== 'undefined';
if (isBrowserContext) {
    _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.checkBrowserCompatibility();
}
let apiVersion =  true ? "v1.2.2-2" : 0;








let getBestAudioConstraints = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.getBestAudioConstraints;

let preciseInterval = _utilities_HiFiUtilities__WEBPACK_IMPORTED_MODULE_0__.HiFiUtilities.preciseInterval;









/***/ }),

/***/ "./src/libravi/RaviCommandController.ts":
/*!**********************************************!*\
  !*** ./src/libravi/RaviCommandController.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviCommandController": () => (/* binding */ RaviCommandController)
/* harmony export */ });
/* harmony import */ var _RaviUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");

const _BINARY_COMMAND_KEY = "_BINARY";
const _MOUSE_STATE_BUFFER_SIZE = 28;
var _KEY_CODE_TABLE;
(function (_KEY_CODE_TABLE) {
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ControlLeft"] = 0] = "ControlLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["AltLeft"] = 1] = "AltLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["OSLeft"] = 2] = "OSLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Space"] = 3] = "Space";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["OSRight"] = 4] = "OSRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["AltRight"] = 5] = "AltRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ControlRight"] = 6] = "ControlRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ShiftLeft"] = 7] = "ShiftLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ShiftRight"] = 8] = "ShiftRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Comma"] = 9] = "Comma";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Period"] = 10] = "Period";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Slash"] = 11] = "Slash";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["CapsLock"] = 12] = "CapsLock";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Enter"] = 13] = "Enter";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Semicolon"] = 14] = "Semicolon";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Quote"] = 15] = "Quote";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Tab"] = 16] = "Tab";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["BracketLeft"] = 17] = "BracketLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["BracketRight"] = 18] = "BracketRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Backslash"] = 19] = "Backslash";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Backquote"] = 20] = "Backquote";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Minus"] = 21] = "Minus";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Equal"] = 22] = "Equal";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit0"] = 23] = "Digit0";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit1"] = 24] = "Digit1";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit2"] = 25] = "Digit2";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit3"] = 26] = "Digit3";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit4"] = 27] = "Digit4";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit5"] = 28] = "Digit5";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit6"] = 29] = "Digit6";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit7"] = 30] = "Digit7";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit8"] = 31] = "Digit8";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Digit9"] = 32] = "Digit9";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Backspace"] = 33] = "Backspace";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Escape"] = 34] = "Escape";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowLeft"] = 35] = "ArrowLeft";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowRight"] = 36] = "ArrowRight";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowDown"] = 37] = "ArrowDown";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["ArrowUp"] = 38] = "ArrowUp";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["PageDown"] = 39] = "PageDown";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["PageUp"] = 40] = "PageUp";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["End"] = 41] = "End";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Home"] = 42] = "Home";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Delete"] = 43] = "Delete";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Insert"] = 44] = "Insert";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad0"] = 45] = "Numpad0";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad1"] = 46] = "Numpad1";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad2"] = 47] = "Numpad2";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad3"] = 48] = "Numpad3";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad4"] = 49] = "Numpad4";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad5"] = 50] = "Numpad5";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad6"] = 51] = "Numpad6";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad7"] = 52] = "Numpad7";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad8"] = 53] = "Numpad8";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["Numpad9"] = 54] = "Numpad9";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadDecimal"] = 55] = "NumpadDecimal";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadEnter"] = 56] = "NumpadEnter";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadAdd"] = 57] = "NumpadAdd";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadSubtract"] = 58] = "NumpadSubtract";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumLock"] = 59] = "NumLock";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadEqual"] = 60] = "NumpadEqual";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadMultiply"] = 61] = "NumpadMultiply";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["NumpadDivide"] = 62] = "NumpadDivide";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyA"] = 63] = "KeyA";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyB"] = 64] = "KeyB";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyC"] = 65] = "KeyC";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyD"] = 66] = "KeyD";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyE"] = 67] = "KeyE";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyF"] = 68] = "KeyF";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyG"] = 69] = "KeyG";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyH"] = 70] = "KeyH";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyI"] = 71] = "KeyI";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyJ"] = 72] = "KeyJ";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyK"] = 73] = "KeyK";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyL"] = 74] = "KeyL";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyM"] = 75] = "KeyM";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyN"] = 76] = "KeyN";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyO"] = 77] = "KeyO";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyP"] = 78] = "KeyP";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyQ"] = 79] = "KeyQ";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyR"] = 80] = "KeyR";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyS"] = 81] = "KeyS";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyT"] = 82] = "KeyT";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyU"] = 83] = "KeyU";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyV"] = 84] = "KeyV";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyW"] = 85] = "KeyW";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyX"] = 86] = "KeyX";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyY"] = 87] = "KeyY";
    _KEY_CODE_TABLE[_KEY_CODE_TABLE["KeyZ"] = 88] = "KeyZ";
})(_KEY_CODE_TABLE || (_KEY_CODE_TABLE = {}));
;
const _KEYBOARD_STATE_BUFFER_SIZE = 12;
class RaviCommandController {
    constructor() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviCommandController");
        this._commandQueueMap = new Map();
        this._numQueuedCommands = 0;
        this._commandQueueInterval = 1000;
        this._commandPumpTimer = null;
        this._inputTarget;
        this._keyboardTarget;
        this._mouseStateBuffer = new ArrayBuffer(_MOUSE_STATE_BUFFER_SIZE + 4);
        this._mouseStateUint8 = new Uint8Array(this._mouseStateBuffer);
        this._mouseStateUint8[0] = 0x4D;
        this._mouseStateFloat = new Float32Array(this._mouseStateBuffer, 4);
        this._mouseStateFloat[0] = -1.0;
        this._mouseStateFloat[1] = -1.0;
        this._mouseStateFloat[2] = -1.0;
        this._mouseStateFloat[3] = -1.0;
        this._keyboardStateBuffer = new ArrayBuffer(_KEYBOARD_STATE_BUFFER_SIZE + 1);
        this._keyboardState = new Uint8Array(this._keyboardStateBuffer);
        this._keyboardState[0] = 0x4B;
    }
    setCommandQueueInterval(queueInterval) {
        this._commandQueueInterval = queueInterval;
        if (this._commandPumpTimer) {
            this.stopMonitoringQueues();
            this.monitorQueues();
        }
    }
    queueCommand(command, param, handler) {
        var commandQueue = this._commandQueueMap.get(command);
        if (!commandQueue) {
            commandQueue = { toSend: [], listener: [] };
            this._commandQueueMap.set(command, commandQueue);
        }
        var handlerInstance = null;
        if (handler) {
            handlerInstance = new RaviCommandHandlerInstance(handler, false, true);
        }
        commandQueue.toSend.push(new RaviCommandInstance(command, param, handlerInstance));
        this._numQueuedCommands++;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Added command " + command, "RaviCommandController");
    }
    queueBinaryCommand(message) {
        let command = _BINARY_COMMAND_KEY;
        var commandQueue = this._commandQueueMap.get(command);
        if (!commandQueue) {
            commandQueue = { toSend: [], listener: [] };
            this._commandQueueMap.set(command, commandQueue);
        }
        commandQueue.toSend.push(new RaviCommandInstance(message, null, null));
        this._numQueuedCommands++;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Added binary command", "RaviCommandController");
    }
    addMessageHandler(expectedMessage, handler, isSticky) {
        var messageEntry = this._commandQueueMap.get(expectedMessage);
        if (!messageEntry) {
            messageEntry = { toSend: [], listener: [] };
            this._commandQueueMap.set(expectedMessage, messageEntry);
        }
        var handlerInstance = new RaviCommandHandlerInstance(handler, isSticky, false);
        messageEntry.listener.push(handlerInstance);
    }
    addBinaryHandler(handler, isSticky) {
        this.addMessageHandler(_BINARY_COMMAND_KEY, handler, isSticky);
    }
    sendInput(inputEvent) {
        if (this._inputDataChannel && this._inputDataChannel.readyState === 'open') {
            this._inputDataChannel.send(inputEvent);
        }
    }
    monitorQueues() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Begin monitoring for queued commands", "RaviCommandController");
        this._commandPumpTimer = setInterval(this._processSendingQueuedCommands.bind(this), this._commandQueueInterval);
    }
    stopMonitoringQueues() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Stop monitoring for queued commands", "RaviCommandController");
        clearInterval(this._commandPumpTimer);
        this._commandPumpTimer = null;
    }
    _processSendingQueuedCommands() {
        if (this._numQueuedCommands <= 0) {
            return;
        }
        this._commandQueueMap.forEach(function (value, key, map) {
            if (value.toSend.length) {
                var commandInstance = value.toSend.shift();
                if (commandInstance._handler) {
                    value.listener.push(commandInstance._handler);
                }
                if (this._sendCommandInstance(commandInstance)) {
                    this._numQueuedCommands--;
                }
                else {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Send failed. CommandDataChannel may have been disconnected. Will not retry.", "RaviCommandController");
                }
            }
        }.bind(this));
    }
    _serializeJsonCommandMessageToSend(command, payload) {
        return JSON.stringify({ "c": command, "p": payload });
    }
    _unserializeJsonCommandMessageFromReceived(message) {
        let commandMessage;
        try {
            commandMessage = JSON.parse(message);
        }
        catch (e) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err(`Couldn't parse command message! Error:\n${e}\n Full message contents:\n${message}`, "RaviCommandController");
            return;
        }
        if (commandMessage && commandMessage.c && commandMessage.p) {
            return { 'command': commandMessage.c, 'payload': commandMessage.p };
        }
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Message cannot be unserialized into a CommandMessage: " + message, "RaviCommandController");
        return null;
    }
    _sendCommandInstance(commandInstance) {
        try {
            let message = commandInstance._command;
            if (typeof message === "string") {
                message = this._serializeJsonCommandMessageToSend(commandInstance._command, commandInstance._param);
                _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Sending command " + message, "RaviCommandController");
            }
            else {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Sending binary command", "RaviCommandController");
            }
            this._commandDataChannel.send(message);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Received error while sending: " + err.message, "RaviCommandController");
            return false;
        }
    }
    _processListeningCommand(fromServerMessage) {
        let serverData = fromServerMessage.data;
        let commandMessage = null;
        if (serverData) {
            if (typeof serverData === 'string') {
                commandMessage = this._unserializeJsonCommandMessageFromReceived(serverData);
                this._continueProcessingListeningCommand(commandMessage);
            }
            else if (serverData instanceof ArrayBuffer) {
                commandMessage = { 'command': _BINARY_COMMAND_KEY, 'payload': new Uint8Array(serverData) };
                this._continueProcessingListeningCommand(commandMessage);
            }
            else if (serverData instanceof Blob) {
                serverData.arrayBuffer()
                    .then((processedArrayBuffer) => {
                    commandMessage = { 'command': _BINARY_COMMAND_KEY, 'payload': new Uint8Array(processedArrayBuffer) };
                    this._continueProcessingListeningCommand(commandMessage);
                });
            }
        }
    }
    _continueProcessingListeningCommand(commandMessage) {
        if (!commandMessage) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Received invalid command message, ignoring: " + JSON.stringify(commandMessage), "RaviCommandController");
            return;
        }
        var foundCommandInstance = this._commandQueueMap.get(commandMessage.command);
        if (foundCommandInstance) {
            var length = foundCommandInstance.listener.length;
            if (length > 0) {
                if (foundCommandInstance.listener[0] && foundCommandInstance.listener[0]._hasMatchingSentCommand) {
                    var commandInstance = foundCommandInstance.listener.shift();
                    if (commandInstance && commandInstance._handler) {
                        commandInstance._handler(commandMessage.payload);
                        return;
                    }
                    else {
                        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Undefined command handler: " + commandMessage, "RaviCommandController");
                    }
                }
                else {
                    var newListeners = [];
                    for (var i = 0; i < length; i++) {
                        var listener = foundCommandInstance.listener[i];
                        if (listener && listener._handler) {
                            listener._handler(commandMessage.payload);
                        }
                        else {
                            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Undefined message handler: " + commandMessage, "RaviCommandController");
                        }
                        if (listener && listener._isSticky) {
                            newListeners.push(listener);
                        }
                    }
                    foundCommandInstance.listener = newListeners;
                }
            }
        }
    }
    _setInputDataChannel(inputDataChannel) {
        this._inputDataChannel = inputDataChannel;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Received new input data channel with id " + this._inputDataChannel.id, "RaviCommandController");
        this._inputDataChannel.onopen = function () {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_inputDataChannel onopen, state is " + this._inputDataChannel.readyState, "RaviCommandController");
        }.bind(this);
        this._inputDataChannel.onclose = function () {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_inputDataChannel onclose, state is " + this._inputDataChannel.readyState, "RaviCommandController");
        }.bind(this);
        this._inputDataChannel.onmessage = function (message) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_inputDataChannel got message: " + (message.data), "RaviCommandController");
        }.bind(this);
    }
    _setCommandDataChannel(commandDataChannel) {
        this._commandDataChannel = commandDataChannel;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Received new data channel with id " + this._commandDataChannel.id, "RaviCommandController");
        this._commandDataChannel.onopen = function () {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_commandDataChannel ononpen, state is " + this._commandDataChannel.readyState, "RaviCommandController");
            this.monitorQueues();
        }.bind(this);
        this._commandDataChannel.onclose = function () {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_commandDataChannel onclose, state is " + this._commandDataChannel.readyState, "RaviCommandController");
            this.stopMonitoringQueues();
        }.bind(this);
        this._commandDataChannel.onmessage = function (message) {
            this._processListeningCommand(message);
        }.bind(this);
    }
    setInputTarget(inputTargetElement) {
        if (this._inputTarget) {
            this._inputTarget.onmousemove = null;
            this._inputTarget.onmouseenter = null;
            this._inputTarget.onmouseleave = null;
            this._inputTarget.onmousedown = null;
            this._inputTarget.onmouseup = null;
            this._inputTarget.onwheel = null;
        }
        this._inputTarget = inputTargetElement;
        if (this._inputTarget) {
            var that = this;
            this._inputTarget.onmousemove = function (event) { that._trackMouse(event); };
            this._inputTarget.onmouseenter = null;
            this._inputTarget.onmouseleave = null;
            this._inputTarget.onmousedown = function (event) { that._captureMouseDown(event); };
            this._inputTarget.onmouseup = function (event) { that._resetMouseDown(event); };
            this._inputTarget.onwheel = function (event) { that._wheelMouse(event); };
        }
    }
    setKeyboardTarget(inputTargetElement) {
        if (this._keyboardTarget) {
            this._keyboardTarget.onkeydown = null;
            this._keyboardTarget.onkeyup = null;
        }
        this._keyboardTarget = inputTargetElement;
        if (this._keyboardTarget) {
            var that = this;
            this._keyboardTarget.onkeydown = function (event) { that._onKeyboardDown(event); };
            this._keyboardTarget.onkeyup = function (event) { that._onKeyboardUp(event); };
        }
    }
    _captureMouseDown(e) {
        this._mouseStateFloat[0] = e.offsetX;
        this._mouseStateFloat[1] = e.offsetY;
        this._mouseStateFloat[2] = e.offsetX;
        this._mouseStateFloat[3] = e.offsetY;
        this._mouseStateUint8[1] = e.buttons;
        this._sendMouseState();
    }
    _resetMouseDown(e) {
        this._mouseStateFloat[0] = -1.0;
        this._mouseStateFloat[1] = -1.0;
        this._mouseStateFloat[2] = -1.0;
        this._mouseStateFloat[3] = -1.0;
        this._mouseStateUint8[1] = e.buttons;
        this._sendMouseState();
    }
    _trackMouse(e) {
        this._mouseStateFloat[0] = e.offsetX;
        this._mouseStateFloat[1] = e.offsetY;
        this._mouseStateFloat[4] = this._inputTarget.offsetWidth;
        this._mouseStateFloat[5] = this._inputTarget.offsetHeight;
        this._mouseStateUint8[1] = e.buttons;
        this._sendMouseState();
    }
    _wheelMouse(e) {
        this._mouseStateFloat[6] = e.deltaY;
        this._sendMouseState();
        this._mouseStateFloat[6] = 0;
    }
    _sendMouseState() {
        this.sendInput(this._mouseStateBuffer);
    }
    _keyByteNum(c) {
        return c >> 3;
    }
    _keyBitMask(c) {
        return (1 << (c % 8));
    }
    _onKeyboardDown(e) {
        let c = _KEY_CODE_TABLE[e.code];
        let keyByteNum = 1 + this._keyByteNum(c);
        let keyByteMask = this._keyBitMask(c);
        if ((this._keyboardState[keyByteNum] & keyByteMask) === 0) {
            this._keyboardState[keyByteNum] |= keyByteMask;
            this._sendKeyboardState();
        }
    }
    _onKeyboardUp(e) {
        let c = _KEY_CODE_TABLE[e.code];
        let keyByteNum = 1 + this._keyByteNum(c);
        let keyByteMask = this._keyBitMask(c);
        if ((this._keyboardState[keyByteNum] & keyByteMask) !== 0) {
            this._keyboardState[keyByteNum] ^= keyByteMask;
            this._sendKeyboardState();
        }
    }
    _sendKeyboardState() {
        this.sendInput(this._keyboardStateBuffer);
    }
}
class RaviCommandInstance {
    constructor(command, param, handler) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviCommandInstance");
        this._command = command;
        this._param = param;
        this._handler = handler;
    }
}
class RaviCommandHandlerInstance {
    constructor(handler, isSticky, hasMatchingSentCommand) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviCommandHandlerInstance");
        this._handler = handler;
        this._isSticky = isSticky;
        this._hasMatchingSentCommand = hasMatchingSentCommand;
    }
}


/***/ }),

/***/ "./src/libravi/RaviSession.ts":
/*!************************************!*\
  !*** ./src/libravi/RaviSession.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviSessionStates": () => (/* binding */ RaviSessionStates),
/* harmony export */   "RaviSession": () => (/* binding */ RaviSession),
/* harmony export */   "STATS_WATCHER_FILTER": () => (/* binding */ STATS_WATCHER_FILTER)
/* harmony export */ });
/* harmony import */ var _RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RaviSignalingConnection */ "./src/libravi/RaviSignalingConnection.ts");
/* harmony import */ var _RaviStreamController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RaviStreamController */ "./src/libravi/RaviStreamController.ts");
/* harmony import */ var _RaviUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");
/* harmony import */ var _RaviCommandController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RaviCommandController */ "./src/libravi/RaviCommandController.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




;
var RaviSessionStates;
(function (RaviSessionStates) {
    RaviSessionStates["NEW"] = "new";
    RaviSessionStates["CONNECTING"] = "checking";
    RaviSessionStates["CONNECTED"] = "connected";
    RaviSessionStates["COMPLETED"] = "completed";
    RaviSessionStates["DISCONNECTED"] = "disconnected";
    RaviSessionStates["FAILED"] = "failed";
    RaviSessionStates["CLOSED"] = "closed";
})(RaviSessionStates || (RaviSessionStates = {}));
;
class RaviSession {
    constructor() {
        this._stateChangeHandlers = new Set();
        this._uuid = _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.createUUID();
        this._commandController = new _RaviCommandController__WEBPACK_IMPORTED_MODULE_3__.RaviCommandController();
        this._streamController = new _RaviStreamController__WEBPACK_IMPORTED_MODULE_1__.RaviStreamController(this._commandController);
        this._state = RaviSessionStates.CLOSED;
        this._raviImplementation = new RaviWebRTCImplementation(this);
        const raviImpl = this._raviImplementation;
        this._streamController.setInputAudioChangeHandler(raviImpl._addAudioInputStream.bind(raviImpl));
        this._streamController.setInputVideoChangeHandler(raviImpl._addVideoInputStream.bind(raviImpl));
    }
    getState() {
        return this._state;
    }
    getUUID() {
        return this._uuid;
    }
    addStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.add(changeHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error adding a state change handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    removeStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.delete(changeHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error removing a state change handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    getCommandController() {
        return this._commandController;
    }
    getStreamController() {
        return this._streamController;
    }
    openRAVISession({ signalingConnection, timeout = 5000, params = null, customStunAndTurn = null }) {
        if (this._state === RaviSessionStates.CONNECTED || this._state === RaviSessionStates.COMPLETED) {
            return Promise.resolve("There is already an open RAVI session. To reconnect, first close the existing connection, and then attempt to open again.");
        }
        var raviSession = this;
        this._raviImplementation._assignSignalingConnection(signalingConnection);
        this._openingTimeout = setTimeout(() => {
            let errorMessage = "RaviSession.open timed out after " + timeout + " ms";
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log(errorMessage, "RaviSession");
            raviSession._fulfillPromises({ message: errorMessage }, RaviSessionStates.FAILED);
            raviSession.closeRAVISession();
        }, timeout);
        return new Promise((resolve, reject) => {
            raviSession._resolveOpen = resolve;
            raviSession._rejectOpen = reject;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Opening RAVI session", "RaviSession");
            this._state = RaviSessionStates.NEW;
            raviSession._raviImplementation._open(params, customStunAndTurn);
        });
    }
    closeRAVISession() {
        var raviSession = this;
        if (this._state === RaviSessionStates.CLOSED)
            return Promise.resolve("RAVI session is already closed.");
        this._streamController._stop();
        this._commandController.stopMonitoringQueues();
        return new Promise((resolve, reject) => {
            raviSession._resolveClose = resolve;
            raviSession._rejectClose = reject;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Closing RAVI session", "RaviSession");
            raviSession._raviImplementation._close();
        });
    }
    _fulfillPromises(event = {}, state) {
        let errorMessage = event.reason || event.message || state;
        switch (state) {
            case RaviSessionStates.CONNECTED:
            case RaviSessionStates.COMPLETED:
                if (this._openingTimeout) {
                    clearTimeout(this._openingTimeout);
                    this._openingTimeout = null;
                }
                if (this._resolveOpen)
                    this._resolveOpen();
                if (this._rejectClose)
                    this._rejectClose(errorMessage);
                break;
            case RaviSessionStates.DISCONNECTED:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("_fulfillPromises: Possible transitory state DISCONNECTED; leaving promises pending", "RaviSession");
                break;
            case RaviSessionStates.FAILED:
                if (this._openingTimeout) {
                    clearTimeout(this._openingTimeout);
                    this._openingTimeout = null;
                }
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._rejectClose)
                    this._rejectClose(errorMessage);
                let raviSession = this;
                const closeTimer = setTimeout(() => {
                    raviSession._raviImplementation._close();
                }, 0);
                break;
            case RaviSessionStates.CLOSED:
                if (this._openingTimeout) {
                    clearTimeout(this._openingTimeout);
                    this._openingTimeout = null;
                }
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._resolveClose)
                    this._resolveClose();
                break;
            default:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("_fulfillPromises: Skipping in-progress state " + state, "RaviSession");
        }
    }
    _doOntrack(event) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received new track: ", "RaviSession");
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log(event, "RaviSession");
        if (event && event.track && event.track.kind === "video") {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Adding remote video track to stream controller", "RaviSession");
            this._streamController._setVideoStream(event.streams[0]);
            this._streamController._onVideoStreamStateChanged("ready");
        }
        if (event && event.track && event.track.kind === "audio") {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Adding remote audio track to stream controller", "RaviSession");
            this._streamController._setAudioStream(event.streams[0]);
        }
    }
    _doOndatachannel(event) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received new channel: ", "RaviSession");
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log(event, "RaviSession");
        switch (event.channel.label) {
            case "ravi.input":
                this._commandController._setInputDataChannel(event.channel);
                break;
            case "ravi.command":
                this._commandController._setCommandDataChannel(event.channel);
                break;
            default:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received unknown data channel named " + event.channel.label, "RaviSession");
                break;
        }
    }
    _handleStateChange(event = {}, state) {
        event["state"] = state;
        this._fulfillPromises(event, state);
        if (state !== this._state) {
            this._state = state;
            event["state"] = state;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("_handleStateChange: " + _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.safelyPrintable(event), "RaviSession");
            this._stateChangeHandlers.forEach(function (handler) {
                if (handler) {
                    handler(event);
                }
            });
        }
    }
    addStatsObserver(observer) {
        return this._raviImplementation._addStatsObserver(observer);
    }
    removeStatsObserver(observer) {
        return this._raviImplementation._removeStatsObserver(observer);
    }
}
const STATS_WATCHER_FILTER = new Map([
    ["remote-inbound-rtp", ["id", "type", "timestamp", "roundTripTime", "jitter"]],
    ["inbound-rtp", ["id", "type", "timestamp", "jitterBufferDelay", "jitterBufferEmittedCount", "bytesReceived"]]
]);
class RaviWebRTCStatsWatcher {
    constructor(webRTCImplementation) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("constructor", "RaviStatsWatcher");
        this._raviImplementation = webRTCImplementation;
        this._observers = new Set();
        this._filter = STATS_WATCHER_FILTER;
        this._interval = 0;
        this._prevStats = [];
    }
    stop() {
        if (this._interval) {
            clearInterval(this._interval);
            this._interval = 0;
        }
    }
    addObserver(observer) {
        try {
            this._observers.add(observer);
            this._onObserverChange();
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error adding a stats observer: " +
                err.message, "RaviStatsWatcher");
            return false;
        }
        return false;
    }
    removeObserver(observer) {
        try {
            this._observers.delete(observer);
            this._onObserverChange();
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error removing a stats observer handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    _onObserverChange() {
        const INTERVAL = 1000;
        this._prevStats = [];
        if (this._observers.size > 0) {
            if (!this._interval) {
                setInterval((handler, timeout) => __awaiter(this, void 0, void 0, function* () {
                    const stats = yield this._raviImplementation._getStats();
                    let filteredStats = [];
                    if (stats) {
                        stats.forEach((report) => {
                            if (this._filter.has(report.type)) {
                                let selectedFields = this._filter.get(report.type);
                                let filteredReport = {};
                                selectedFields.forEach(key => {
                                    filteredReport[key] = report[key];
                                });
                                filteredStats.push(filteredReport);
                            }
                        });
                    }
                    if (filteredStats.length) {
                        this._observers.forEach((observer) => {
                            observer(filteredStats, this._prevStats);
                        });
                    }
                    this._prevStats = filteredStats;
                }), INTERVAL);
            }
        }
        else {
            if (this._interval) {
                clearInterval(this._interval);
                this._interval = 0;
            }
        }
    }
}
let crossPlatformRTCPeerConnection = null;
let crossPlatformRTCSessionDescription = null;
if (typeof self === 'undefined') {
    crossPlatformRTCPeerConnection = __webpack_require__(/*! wrtc */ "../Spatial-Audio-API-Examples/examples/nodejs/testingbot/node_modules/wrtc/lib/browser.js").RTCPeerConnection;
    crossPlatformRTCSessionDescription = __webpack_require__(/*! wrtc */ "../Spatial-Audio-API-Examples/examples/nodejs/testingbot/node_modules/wrtc/lib/browser.js").RTCSessionDescription;
}
else {
    crossPlatformRTCPeerConnection = RTCPeerConnection;
    crossPlatformRTCSessionDescription = RTCSessionDescription;
}
const DEFAULT_STUN_CONFIG = {
    'urls': ['stun:stun.l.google.com:19302']
};
const LEGACY_TURN_CONFIG = {
    'urls': ['turn:turn.highfidelity.com:3478'],
    'username': 'clouduser',
    'credential': 'chariot-travesty-hook'
};
let peerConnectionConfig = {
    'iceServers': [
        DEFAULT_STUN_CONFIG,
        LEGACY_TURN_CONFIG
    ]
};
class RaviWebRTCImplementation {
    constructor(raviSession) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("constructor", "RaviWebRTCImplementation");
        this._raviSession = raviSession;
        this._negotiator = this._setupConnection.bind(this);
        this._statsWatcher = new RaviWebRTCStatsWatcher(this);
        this._raviAudioSenders = [];
        this._raviVideoSenders = [];
    }
    _initRtcConnection() {
        const raviSession = this._raviSession;
        const sessionImplementation = this;
        this._rtcConnection = new crossPlatformRTCPeerConnection(peerConnectionConfig);
        const rtcConnection = this._rtcConnection;
        let senders = rtcConnection.getSenders();
        senders.forEach((sender) => {
            sender.replaceTrack(null);
        });
        this._raviAudioSenders = [];
        this._raviVideoSenders = [];
        rtcConnection.addEventListener('iceconnectionstatechange', function (event) {
            if (rtcConnection.iceConnectionState === "connected" || rtcConnection.iceConnectionState == "completed") {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Session has fully connected; removing short-circuit handler", "RaviWebRTCImplementation");
                sessionImplementation._signalingConnection.removeStateChangeHandler(sessionImplementation._shortCircuitHandler);
            }
            raviSession._handleStateChange(event, rtcConnection.iceConnectionState);
        });
        rtcConnection.addEventListener('datachannel', function (event) { raviSession._doOndatachannel(event); });
        rtcConnection.addEventListener('track', function (event) { raviSession._doOntrack(event); });
        rtcConnection.addEventListener('icecandidate', function (event) { sessionImplementation._doOnicecandidate(event); });
        rtcConnection.addEventListener('negotiationneeded', function (event) { sessionImplementation._doOnnegotiationneeded(event); });
        rtcConnection.addEventListener("signalingstatechange", function (event) { sessionImplementation._doOnsignalingstatechanged(event); });
    }
    _assignSignalingConnection(signalingConnection) {
        this._signalingConnection = signalingConnection;
    }
    _addAudioInputStream(stream) {
        const rtcConnection = this._rtcConnection;
        const sessionImplementation = this;
        var retval = false;
        if (stream) {
            this._audioInputStream = stream;
            if (!rtcConnection) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting audio input stream without available RTC connection; will store it until ready", "RaviWebRTCImplementation");
                return true;
            }
            const currentSenders = this._raviAudioSenders;
            const newAudioTracks = stream.getAudioTracks();
            const numNewTracks = newAudioTracks.length;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                if (i < numNewTracks) {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Replacing audio track #" + i + "  in rtcConnection", "RaviWebRTCImplementation");
                    currentSenders[i].replaceTrack(newAudioTracks[i]);
                }
                else {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting audio sender #" + i + " to null", "RaviWebRTCImplementation");
                    currentSenders[i].replaceTrack(null);
                }
            }
            for (i; i < numNewTracks; i++) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Adding local audio track #" + i + " to rtcConnection", "RaviWebRTCImplementation");
                currentSenders.push(rtcConnection.addTrack(newAudioTracks[i], stream));
            }
        }
        else {
            const currentSenders = this._raviAudioSenders;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting audio sender #" + i + " to null", "RaviWebRTCImplementation");
                currentSenders[i].replaceTrack(null);
            }
        }
        return retval;
    }
    _addVideoInputStream(stream) {
        const rtcConnection = this._rtcConnection;
        const that = this;
        var retval = false;
        if (stream) {
            this._videoInputStream = stream;
            if (!rtcConnection) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting video input stream without available RTC connection; will store it until ready", "RaviWebRTCImplementation");
                return true;
            }
            const currentSenders = this._raviVideoSenders;
            const newVideoTracks = stream.getVideoTracks();
            const numNewTracks = newVideoTracks.length;
            if (numNewTracks > 0) {
                if (currentSenders.length > 0) {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Replacing video track #0 in rtcConnection", "RaviWebRTCImplementation");
                    currentSenders[0].replaceTrack(newVideoTracks[0]);
                }
                else {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Adding video track #0 to rtcConnection", "RaviWebRTCImplementation");
                    currentSenders.push(rtcConnection.addTrack(newVideoTracks[0]));
                }
                retval = true;
            }
            else {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Assigned video stream doesn't contain vidoe track", "RaviWebRTCImplementation");
            }
        }
        else {
            const currentSenders = this._raviVideoSenders;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Setting video sender #" + i + " to null", "RaviWebRTCImplementation");
                currentSenders[i].replaceTrack(null);
            }
        }
        return retval;
    }
    _open(params, customStunAndTurn) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Attempting to open connection...", "RaviWebRTCImplementation");
        this._customStunAndTurn = customStunAndTurn;
        if (this._rtcConnection
            && (this._rtcConnection.connectionState == 'connecting'
                || this._rtcConnection.connectionState == 'connected')) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("We already have a connection in progress. Will not attempt a new one.", "RaviWebRTCImplementation");
            this._raviSession._handleStateChange({ "state": this._rtcConnection.connectionState }, this._rtcConnection.connectionState);
            return;
        }
        if (this._signalingConnection) {
            this._signalingConnection.addMessageHandler(this._negotiator);
            this._shortCircuitHandler = this._cancelOpeningProcessOnSignalingDisconnect.bind(this);
            this._signalingConnection.addStateChangeHandler(this._shortCircuitHandler);
            let message = {};
            if (params) {
                message = params;
                message["sessionID"] = this._raviSession.getUUID();
            }
            else {
                message = this._raviSession.getUUID();
            }
            this._signalingConnection.send(JSON.stringify({ 'request': message }));
        }
    }
    _cancelOpeningProcessOnSignalingDisconnect(event) {
        let state = event.state || "unknown";
        const raviSession = this._raviSession;
        switch (state) {
            case _RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_0__.RaviSignalingStates.CLOSED:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Signaling state closed before session was established; closing RaviSession", "RaviWebRTCImplementation");
                raviSession._handleStateChange(event, RaviSessionStates.CLOSED);
                this._close();
                break;
            case _RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_0__.RaviSignalingStates.ERROR:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Signaling state errored out before session was established; closing RaviSession", "RaviWebRTCImplementation");
                raviSession._handleStateChange(event, RaviSessionStates.FAILED);
                this._close();
                break;
            case _RaviSignalingConnection__WEBPACK_IMPORTED_MODULE_0__.RaviSignalingStates.UNAVAILABLE:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Signaling state reached 'unavailable' before session was established; closing RaviSession", "RaviWebRTCImplementation");
                raviSession._handleStateChange(event, RaviSessionStates.FAILED);
                this._close();
                break;
            default:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Signaling state has changed during opening of RAVI session, but is an OK change. New state: " + state, "RaviWebRTCImplementation");
        }
    }
    _close() {
        this._statsWatcher.stop();
        const raviSession = this._raviSession;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("closing", "RaviWebRTCImplementation");
        if (this._rtcConnection) {
            this._rtcConnection.close();
        }
        this._signalingConnection.removeMessageHandler(this._negotiator);
        this._signalingConnection.removeStateChangeHandler(this._shortCircuitHandler);
        this._rtcConnection = null;
        raviSession._handleStateChange({}, RaviSessionStates.CLOSED);
    }
    _doOnicecandidate(event) {
        if (event.candidate && event.candidate != "") {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Sending local ICE candidate: " + JSON.stringify(event.candidate), "RaviWebRTCImplementation");
            this._signalingConnection.send(JSON.stringify({ 'ice': event.candidate, 'uuid': this._raviSession.getUUID() }));
        }
        else {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("End of local ICE candidates", "RaviSession");
        }
    }
    _doOnnegotiationneeded(event) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("need renegotiation please", "RaviWebRTCImplementation");
        const msg = {
            renegotiate: "please",
            uuid: this._raviSession.getUUID()
        };
        const desc = JSON.stringify(msg);
        if (this._signalingConnection && this._rtcConnection && this._rtcConnection.signalingState === "stable") {
            this._signalingConnection.send(desc);
        }
    }
    _doOnsignalingstatechanged(event) {
        if (this._rtcConnection) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("SignalingState changed: " + this._rtcConnection.signalingState, "RaviWebRTCImplementation");
        }
    }
    _forceBitrateUp(sdp) {
        const localAudioIsStereo = this._raviSession._streamController.isStereoInput();
        const bitrate = localAudioIsStereo ? 128000 : 64000;
        return sdp.replace(/a=fmtp:111 /g, 'a=fmtp:111 maxaveragebitrate=' + bitrate + ';');
    }
    _forceStereoDown(sdp) {
        return sdp.replace(/a=fmtp:111 /g, 'a=fmtp:111 maxaveragebitrate=128000;sprop-stereo=1;stereo=1;');
    }
    _setupConnection(event) {
        let fullMessage = "";
        let signal = "";
        const raviSession = this._raviSession;
        const signalingConnection = this._signalingConnection;
        const sessionImplementation = this;
        if (!raviSession || !signalingConnection) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Missing one of raviSession or signalingConnection! Can't set up connection.", "RaviWebRTCImplementation");
            return;
        }
        if (event && event.data) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log('Message from server: ' + event.data, "RaviWebRTCImplementation");
            fullMessage = JSON.parse(event.data);
        }
        else {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log('No message received by onMessage handler', "RaviWebRTCImplementation");
            return;
        }
        signal = fullMessage[raviSession.getUUID()];
        if (!signal)
            return;
        if (signal.sdp) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received sdp type=" + signal.type, "RaviWebRTCImplementation");
            if (sessionImplementation._customStunAndTurn) {
                const CUSTOM_TURN_CONFIG = {
                    'urls': sessionImplementation._customStunAndTurn.turnUrls,
                    'username': sessionImplementation._customStunAndTurn.turnUsername,
                    'credential': sessionImplementation._customStunAndTurn.turnCredential
                };
                const CUSTOM_STUN_CONFIG = {
                    'urls': sessionImplementation._customStunAndTurn.stunUrls
                };
                peerConnectionConfig = {
                    'iceServers': [
                        CUSTOM_STUN_CONFIG,
                        CUSTOM_TURN_CONFIG
                    ]
                };
            }
            else if (signal.turn && signal.turn.urls && signal.turn.username && signal.turn.credential) {
                const DYNAMIC_TURN_CONFIG = {
                    'urls': signal.turn.urls,
                    'username': signal.turn.username,
                    'credential': signal.turn.credential
                };
                peerConnectionConfig = {
                    'iceServers': [
                        DEFAULT_STUN_CONFIG,
                        DYNAMIC_TURN_CONFIG
                    ]
                };
            }
            if (!this._rtcConnection) {
                this._initRtcConnection();
                if (this._audioInputStream) {
                    this._addAudioInputStream(this._audioInputStream);
                }
                if (this._videoInputStream) {
                    this._addVideoInputStream(this._videoInputStream);
                }
            }
            let rtcConnection = this._rtcConnection;
            signal.sdp = sessionImplementation._forceBitrateUp(signal.sdp);
            const desc = new crossPlatformRTCSessionDescription(signal);
            rtcConnection.setRemoteDescription(desc)
                .then(function () {
                return rtcConnection.createAnswer();
            })
                .then(function (answer) {
                answer.sdp = sessionImplementation._forceStereoDown(answer.sdp);
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Answer:", "RaviWebRTCImplementation");
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log(answer, "RaviWebRTCImplementation");
                return rtcConnection.setLocalDescription(answer);
            })
                .then(function () {
                const msg = {
                    type: "answer",
                    sdp: rtcConnection.localDescription,
                    uuid: raviSession.getUUID()
                };
                const desc = JSON.stringify(msg);
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Sending answer to server", "RaviWebRTCImplementation");
                signalingConnection.send(desc);
            });
        }
        else if (signal.ice) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Received remote ICE candidate: " + JSON.stringify(signal.ice), "RaviWebRTCImplementation");
            if (this._rtcConnection) {
                this._rtcConnection.addIceCandidate(signal.ice)
                    .then(function () {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Added remote candidate", "RaviWebRTCImplementation");
                })
                    .catch(function (e) {
                    _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.err("Error attempting to add remote ICE candidate: " + e.message, "RaviWebRTCImplementation");
                });
            }
            else {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Ignore ice candidate until we have an rtcConnection, ice='" + JSON.stringify(signal) + "'", "RaviWebRTCImplementation");
            }
        }
        else {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_2__.RaviUtils.log("Unknown message " + JSON.stringify(signal), "RaviWebRTCImplementation");
        }
    }
    _addStatsObserver(observer) {
        return this._statsWatcher.addObserver(observer);
    }
    _removeStatsObserver(observer) {
        return this._statsWatcher.removeObserver(observer);
    }
    _getStats(selector = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._rtcConnection) {
                return this._rtcConnection.getStats(selector);
            }
            else {
                return [];
            }
        });
    }
}


/***/ }),

/***/ "./src/libravi/RaviSignalingConnection.ts":
/*!************************************************!*\
  !*** ./src/libravi/RaviSignalingConnection.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviSignalingStates": () => (/* binding */ RaviSignalingStates),
/* harmony export */   "RaviSignalingConnection": () => (/* binding */ RaviSignalingConnection)
/* harmony export */ });
/* harmony import */ var _RaviUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");

var RaviSignalingStates;
(function (RaviSignalingStates) {
    RaviSignalingStates["CONNECTING"] = "connecting";
    RaviSignalingStates["OPEN"] = "open";
    RaviSignalingStates["ERROR"] = "error";
    RaviSignalingStates["CLOSING"] = "closing";
    RaviSignalingStates["CLOSED"] = "closed";
    RaviSignalingStates["UNAVAILABLE"] = "unavailable";
})(RaviSignalingStates || (RaviSignalingStates = {}));
;
class RaviSignalingConnection {
    constructor() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Constructor", "RaviSignalingConnection");
        this._stateChangeHandlers = new Set();
        this._messageHandlers = new Set();
        this._state = RaviSignalingStates.CLOSED;
        this._signalingImplementation = new RaviSignalingWebSocketImplementation(this);
    }
    getState() {
        return this._state;
    }
    addStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.add(changeHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Error adding a state change handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    removeStateChangeHandler(changeHandler) {
        try {
            const retval = this._stateChangeHandlers.delete(changeHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Error removing a state change handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    addMessageHandler(messageHandler) {
        try {
            this._messageHandlers.add(messageHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Error adding a message handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    removeMessageHandler(messageHandler) {
        try {
            this._messageHandlers.delete(messageHandler);
            return true;
        }
        catch (err) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("Error removing a state change handler: " +
                err.message, "RaviSignalingConnection");
            return false;
        }
        return false;
    }
    openRAVISignalingConnection(URL) {
        var signalingConnection = this;
        if (this._state === RaviSignalingStates.OPEN)
            return Promise.resolve("There is already an open WebSocket connection. To reconnect, first close the existing WebSocket and then attempt to open again.");
        return new Promise((resolve, reject) => {
            signalingConnection._resolveOpen = resolve;
            signalingConnection._rejectOpen = reject;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Opening signaling connection to " + URL, "RaviSignalingController");
            let event = { "state": RaviSignalingStates.CONNECTING };
            this._handleStateChange(event, RaviSignalingStates.CONNECTING);
            this._signalingImplementation._open(URL);
        });
    }
    send(message) {
        this._signalingImplementation._send(message);
    }
    closeRAVISignalingConnection() {
        var signalingConnection = this;
        if (this._state === RaviSignalingStates.CLOSED)
            return Promise.resolve("Signaling connection is already closed.");
        return new Promise((resolve, reject) => {
            signalingConnection._resolveClose = resolve;
            signalingConnection._rejectClose = reject;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Closing signaling connection", "RaviSignalingController");
            let event = { "state": RaviSignalingStates.CLOSING };
            this._handleStateChange(event, RaviSignalingStates.CLOSING);
            this._signalingImplementation._close();
        });
    }
    _handleStateChange(event = {}, state) {
        this._fulfillPromises(event, state);
        if (state !== this._state) {
            this._state = state;
            event["state"] = state;
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_handleStateChange: " + _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.safelyPrintable(event), "RaviSignalingConnection");
            this._stateChangeHandlers.forEach(function (handler) {
                if (handler) {
                    handler(event);
                }
            });
        }
    }
    _fulfillPromises(event = {}, state) {
        let errorMessage = event.reason || event.message || state;
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_fulfillPromises: Handling state " + state, "RaviSignalingConnection");
        switch (state) {
            case RaviSignalingStates.OPEN:
                if (this._resolveOpen)
                    this._resolveOpen();
                if (this._rejectClose)
                    this._rejectClose(errorMessage);
                break;
            case RaviSignalingStates.CLOSED:
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._resolveClose)
                    this._resolveClose();
                break;
            case RaviSignalingStates.ERROR:
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._rejectClose)
                    this._rejectClose(errorMessage);
                break;
            case RaviSignalingStates.UNAVAILABLE:
                if (this._rejectOpen)
                    this._rejectOpen(errorMessage);
                if (this._resolveClose)
                    this._resolveClose();
                break;
            default:
                _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_fulfillPromises: Skipping in-progress state " + state, "RaviSignalingConnection");
        }
    }
    _handleMessage(message) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("_doOnmessage: " + _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.safelyPrintable(message), "RaviSignalingConnection");
        if (message.data) {
            try {
                let messageData = JSON.parse(message.data);
                if (messageData.error && messageData.error === "service-unavailable") {
                    this._handleStateChange({}, RaviSignalingStates.UNAVAILABLE);
                }
            }
            catch (err) {
            }
        }
        this._messageHandlers.forEach(function (handler) {
            if (handler) {
                handler(message);
            }
        });
    }
}
let crossPlatformWebSocket = null;
if (typeof self === 'undefined') {
    crossPlatformWebSocket = __webpack_require__(/*! ws */ "./node_modules/ws/browser.js");
}
else {
    crossPlatformWebSocket = WebSocket;
}
class RaviSignalingWebSocketImplementation {
    constructor(raviSignalingConnection) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviSignalingWebSocketImplementation");
        this._raviSignalingConnection = raviSignalingConnection;
    }
    _open(socketAddress) {
        var signalingConnection = this._raviSignalingConnection;
        if (this._webSocket && this._webSocket.readyState === crossPlatformWebSocket.OPEN) {
            signalingConnection._handleStateChange({}, RaviSignalingStates.OPEN);
            return;
        }
        this._webSocket = new crossPlatformWebSocket(socketAddress);
        this._webSocket.addEventListener('open', function (event) { signalingConnection._handleStateChange(event, RaviSignalingStates.OPEN); });
        this._webSocket.addEventListener('error', function (event) { signalingConnection._handleStateChange(event, RaviSignalingStates.ERROR); });
        this._webSocket.addEventListener('close', function (event) {
            if (event && event.code && event.code > 4000) {
                _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.err("_handleStateChange: signaling error code " + event.code + ":  " + event.reason, "RaviSignalingConnection");
                signalingConnection._handleStateChange(event, RaviSignalingStates.ERROR);
            }
            else {
                signalingConnection._handleStateChange(event, RaviSignalingStates.CLOSED);
            }
        });
        this._webSocket.addEventListener('message', function (event) { signalingConnection._handleMessage(event); });
    }
    _send(message) {
        if (this._webSocket && this._webSocket.readyState === crossPlatformWebSocket.OPEN) {
            _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("Sending message to server: " + message, "RaviSignalingWebSocketImplementation");
            this._webSocket.send(message);
        }
    }
    _close() {
        var signalingConnection = this._raviSignalingConnection;
        if (!this._webSocket || this._webSocket.readyState === crossPlatformWebSocket.CLOSED) {
            signalingConnection._handleStateChange({}, RaviSignalingStates.CLOSED);
            return;
        }
        this._webSocket.close();
        this._webSocket = null;
    }
}


/***/ }),

/***/ "./src/libravi/RaviStreamController.ts":
/*!*********************************************!*\
  !*** ./src/libravi/RaviStreamController.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviStreamController": () => (/* binding */ RaviStreamController)
/* harmony export */ });
/* harmony import */ var _RaviUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RaviUtils */ "./src/libravi/RaviUtils.ts");

class RaviStreamController {
    constructor(raviCommandController) {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("constructor", "RaviStreamController");
        this._commandController = raviCommandController;
        this._audioStream = null;
        this._videoStream = null;
        this._onVideoStreamStateChanged = function (state) { _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("onvideostreamstatechanged " + state, "RaviStreamController"); };
        this._onInputAudioChanged = null;
        this._onInputVideoChanged = null;
    }
    getVideoStream() {
        return this._videoStream;
    }
    _setVideoStream(videoStream) {
        this._videoStream = videoStream;
        if (this._videoContainer) {
            this._videoContainer.srcObject = this._videoStream;
        }
    }
    setVideoContainer(videoElement, onvideostreamstatechanged) {
        this._videoContainer = videoElement;
        if (this._videoStream) {
            this._videoContainer.srcObject = this._videoStream;
        }
        this.setVideoStateChangeHandler(onvideostreamstatechanged);
    }
    setVideoStateChangeHandler(onvideostreamstatechanged) {
        if (onvideostreamstatechanged) {
            this._onVideoStreamStateChanged = onvideostreamstatechanged;
        }
    }
    showVideoDashboard(enabled) {
        this._commandController.queueCommand("video.showDashboard", { "enabled": enabled }, null);
    }
    showVideoCursor(enabled) {
        this._commandController.queueCommand("video.showCursor", { "enabled": enabled }, null);
    }
    getAudioStream() {
        return this._audioStream;
    }
    _setAudioStream(audioStream) {
        this._audioStream = audioStream;
        if (this._audioContainer) {
            this._audioContainer.srcObject = this._audioStream;
        }
    }
    setAudioContainer(audioElement) {
        this._audioContainer = audioElement;
        if (this._audioStream) {
            this._audioContainer.srcObject = this._audioStream;
        }
    }
    setInputAudio(stream, isStereo = false) {
        this._inputAudioStream = stream;
        this._isStereo = isStereo;
        if (this._onInputAudioChanged)
            this._onInputAudioChanged(stream);
    }
    setInputAudioChangeHandler(oninputaudiochanged) {
        if (oninputaudiochanged) {
            this._onInputAudioChanged = oninputaudiochanged;
        }
    }
    setInputVideo(stream) {
        this._inputVideoStream = stream;
        if (this._onInputVideoChanged)
            this._onInputVideoChanged(stream);
    }
    setInputVideoChangeHandler(oninputvideochanged) {
        if (oninputvideochanged) {
            this._onInputVideoChanged = oninputvideochanged;
        }
    }
    isStereoInput() {
        return this._isStereo;
    }
    _stop() {
        _RaviUtils__WEBPACK_IMPORTED_MODULE_0__.RaviUtils.log("stopping streams", "RaviStreamController");
        if (this._videoContainer && this._videoContainer.srcObject) {
            let srcObject = this._videoContainer.srcObject;
            let tracks = srcObject.getTracks();
            tracks.forEach(track => track.stop());
            this._videoContainer.srcObject = null;
            this._onVideoStreamStateChanged("over");
        }
        if (this._audioStream) {
            this._audioStream.getTracks().forEach(track => track.stop());
            this._audioStream = null;
        }
    }
}


/***/ }),

/***/ "./src/libravi/RaviUtils.ts":
/*!**********************************!*\
  !*** ./src/libravi/RaviUtils.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RaviUtils": () => (/* binding */ RaviUtils)
/* harmony export */ });
var DEBUG = true;
class RaviUtils {
    static createUUID() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }
    static log(message, classname) {
        if (typeof classname !== 'undefined')
            message = classname + ": " + message;
        if (DEBUG) {
            console.log(message);
        }
        if (typeof document !== 'undefined' && DEBUG) {
            try {
                document.dispatchEvent(new CustomEvent('logger', { detail: message }));
            }
            catch (err) {
                console.log(message);
                console.log("Additionally, an error was encountered trying to log that.");
                console.log(err);
            }
        }
    }
    static err(message, classname) {
        if (typeof classname !== 'undefined')
            message = classname + ": " + message;
        console.log('%c %s', 'color: #FB0A1C', message);
        if (typeof document !== 'undefined') {
            document.dispatchEvent(new CustomEvent('errlogger', { detail: message }));
        }
    }
    static safelyPrintable(item) {
        try {
            return JSON.stringify(item);
        }
        catch (e) {
            return item;
        }
    }
    static getElementCSSSize(el) {
        if (!getComputedStyle) {
            return;
        }
        var cs = getComputedStyle(el);
        var w = parseInt(cs.getPropertyValue("width"), 10);
        var h = parseInt(cs.getPropertyValue("height"), 10);
        return { width: w, height: h };
    }
    static setDebug(debug) {
        DEBUG = debug;
    }
}


/***/ }),

/***/ "./src/utilities/HiFiLogger.ts":
/*!*************************************!*\
  !*** ./src/utilities/HiFiLogger.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiLogLevel": () => (/* binding */ HiFiLogLevel),
/* harmony export */   "HiFiLogger": () => (/* binding */ HiFiLogger)
/* harmony export */ });
var HiFiLogLevel;
(function (HiFiLogLevel) {
    HiFiLogLevel["None"] = "None";
    HiFiLogLevel["Error"] = "Error";
    HiFiLogLevel["Warn"] = "Warn";
    HiFiLogLevel["Debug"] = "Debug";
})(HiFiLogLevel || (HiFiLogLevel = {}));
class HiFiLogger {
    constructor(logLevel) {
        logLevel = logLevel ? logLevel : HiFiLogLevel.Debug;
    }
    static setHiFiLogLevel(newLogLevel) {
        HiFiLogger.logLevel = newLogLevel;
    }
    static log(message) {
        if (HiFiLogger.logLevel === HiFiLogLevel.Debug) {
            console.log(message);
            return true;
        }
        else {
            return false;
        }
    }
    static debug(message) {
        return this.log(message);
    }
    static warn(message) {
        if (HiFiLogger.logLevel === HiFiLogLevel.Debug || HiFiLogger.logLevel === HiFiLogLevel.Warn) {
            console.warn(message);
            return true;
        }
        else {
            return false;
        }
    }
    static error(message) {
        if (HiFiLogger.logLevel === HiFiLogLevel.Debug || HiFiLogger.logLevel === HiFiLogLevel.Warn || HiFiLogger.logLevel === HiFiLogLevel.Error) {
            console.error(message);
            return true;
        }
        else {
            return false;
        }
    }
}
HiFiLogger.logLevel = HiFiLogLevel.Error;


/***/ }),

/***/ "./src/utilities/HiFiUtilities.ts":
/*!****************************************!*\
  !*** ./src/utilities/HiFiUtilities.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HiFiUtilities": () => (/* binding */ HiFiUtilities)
/* harmony export */ });
/* harmony import */ var _HiFiLogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HiFiLogger */ "./src/utilities/HiFiLogger.ts");
/* module decorator */ module = __webpack_require__.hmd(module);

function dynamicRequire(mod, requireString) {
    return mod.require(requireString);
}
let now;
if (typeof self === 'undefined') {
    try {
        now = dynamicRequire(module, 'perf_hooks').performance.now;
    }
    catch (_a) { }
}
class HiFiUtilities {
    constructor() { }
    static recursivelyDiffObjects(obj1, obj2) {
        if (!obj2 || Object.prototype.toString.call(obj2) !== '[object Object]') {
            return obj1;
        }
        let diffs = {};
        let key;
        let doArraysMatch = (arr1, arr2) => {
            if (arr1.length !== arr2.length) {
                return false;
            }
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i]) {
                    return false;
                }
            }
            return true;
        };
        let compare = (item1, item2, key) => {
            let type1 = Object.prototype.toString.call(item1);
            let type2 = Object.prototype.toString.call(item2);
            if (type2 === '[object Undefined]') {
                diffs[key] = null;
                return;
            }
            if (type1 !== type2) {
                diffs[key] = item2;
                return;
            }
            if (type1 === '[object Object]') {
                let objDiff = HiFiUtilities.recursivelyDiffObjects(item1, item2);
                if (Object.keys(objDiff).length > 0) {
                    diffs[key] = objDiff;
                }
                return;
            }
            if (type1 === '[object Array]') {
                if (!doArraysMatch(item1, item2)) {
                    diffs[key] = item2;
                }
                return;
            }
            if (type1 === '[object Function]') {
                if (item1.toString() !== item2.toString()) {
                    diffs[key] = item2;
                }
            }
            else {
                if (item1 !== item2) {
                    diffs[key] = item2;
                }
            }
        };
        for (key in obj1) {
            if (obj1.hasOwnProperty(key)) {
                compare(obj1[key], obj2[key], key);
            }
        }
        for (key in obj2) {
            if (obj2.hasOwnProperty(key)) {
                if (!obj1[key] && obj1[key] !== obj2[key]) {
                    diffs[key] = obj2[key];
                }
            }
        }
        return diffs;
    }
    ;
    static getBestAudioConstraints() {
        let audioConstraints = {};
        if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().echoCancellation) {
            audioConstraints.echoCancellation = false;
        }
        if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().noiseSuppression) {
            audioConstraints.noiseSuppression = false;
        }
        if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().autoGainControl) {
            audioConstraints.autoGainControl = false;
        }
        return audioConstraints;
    }
    static preciseInterval(callback, intervalMS) {
        if (!now) {
            _HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.warn(`\`preciseInterval()\` is a wrapper for \`setInterval()\` in the browser context!`);
            return setInterval(callback, intervalMS);
        }
        let nextTick = now();
        let clear = clearTimeout;
        let wrapper = () => {
            let thisTick = now();
            if (thisTick < nextTick) {
                clear = clearImmediate;
                return timeout = setImmediate(wrapper);
            }
            nextTick += intervalMS;
            clear = clearTimeout;
            timeout = setTimeout(wrapper, nextTick - thisTick - 2);
            callback();
        };
        let timeout = setTimeout(wrapper);
        return { clear: () => clear(timeout) };
    }
    static checkBrowserCompatibility() {
        let requiredFeatures = [
            "navigator",
            "navigator.mediaDevices.getUserMedia",
            "navigator.mediaDevices.getSupportedConstraints",
            "window.MediaStream",
            "window.RTCDataChannel",
            "window.RTCPeerConnection",
            "window.RTCSessionDescription"
        ];
        for (let i = 0; i < requiredFeatures.length; i++) {
            if (typeof (eval(requiredFeatures[i])) === "undefined") {
                _HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error("HiFi Audio API: The browser does not support: " + requiredFeatures[i]);
                if (requiredFeatures[i] === "navigator.mediaDevices.getUserMedia") {
                    _HiFiLogger__WEBPACK_IMPORTED_MODULE_0__.HiFiLogger.error("HiFi Audio API: Your browser may be preventing access to this feature if you are running in an insecure context, i.e. an `http` server.");
                }
                return false;
            }
        }
        return true;
    }
    static nonan(v, ifnan) {
        return (isNaN(v) ? ifnan : v);
    }
    static clamp(v, min, max) {
        return (v > max ? max : (v < min ? min : v));
    }
    static clampNonan(v, min, max, ifnan) {
        return (v > max ? max : (v < min ? min : HiFiUtilities.nonan(v, ifnan)));
    }
    static clampNormalized(v) {
        return (v > 1.0 ? 1.0 : (v < -1.0 ? -1.0 : v));
    }
}


/***/ }),

/***/ "./node_modules/ws/browser.js":
/*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
/***/ ((module) => {



module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/index.ts");
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi4vU3BhdGlhbC1BdWRpby1BUEktRXhhbXBsZXMvZXhhbXBsZXMvbm9kZWpzL3Rlc3Rpbmdib3Qvbm9kZV9tb2R1bGVzL3dydGMvbGliL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2NsYXNzZXMvSGlGaUF1ZGlvQVBJRGF0YS50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvY2xhc3Nlcy9IaUZpQXhpc0NvbmZpZ3VyYXRpb24udHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2NsYXNzZXMvSGlGaUNvbW11bmljYXRvci50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvY2xhc3Nlcy9IaUZpTWl4ZXJTZXNzaW9uLnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy9jbGFzc2VzL0hpRmlVc2VyRGF0YVN1YnNjcmlwdGlvbi50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvY29uc3RhbnRzL0hpRmlDb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2RpYWdub3N0aWNzL2RpYWdub3N0aWNzLnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvbGlicmF2aS9SYXZpQ29tbWFuZENvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2xpYnJhdmkvUmF2aVNlc3Npb24udHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2xpYnJhdmkvUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24udHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2xpYnJhdmkvUmF2aVN0cmVhbUNvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vc3JjL2xpYnJhdmkvUmF2aVV0aWxzLnRzIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS8uL3NyYy91dGlsaXRpZXMvSGlGaUxvZ2dlci50cyIsIndlYnBhY2s6Ly9IaWdoRmlkZWxpdHlbbmFtZV0vLi9zcmMvdXRpbGl0aWVzL0hpRmlVdGlsaXRpZXMudHMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdLy4vbm9kZV9tb2R1bGVzL3dzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL0hpZ2hGaWRlbGl0eVtuYW1lXS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdL3dlYnBhY2svcnVudGltZS9oYXJtb255IG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vSGlnaEZpZGVsaXR5W25hbWVdL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8v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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIseUNBQXlDOztBQUU5RDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7Ozs7Ozs7Ozs7QUNsRGE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkVhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qjs7O0FBR0E7Ozs7Ozs7Ozs7O0FDMURhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUIsMkJBQTJCLGFBQWE7QUFDeEMsb0JBQW9CLHFCQUFxQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LEVBQUMsQ0FBQztJQUNsSyxJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxZQUFZLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxlQUFlLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsV0FBVyxHQUFHLGVBQWUsQ0FBQyxFQUFDLENBQUM7SUFRbEssSUFBSSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDL0IsSUFBSSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDL0IsSUFBSSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDL0IsSUFBSSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFFL0IsSUFBSSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDL0IsSUFBSSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDL0IsSUFBSSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDL0IsSUFBSSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFFL0IsUUFBUSxLQUFL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LEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDMUIsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBSTFCLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDbEMsSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQzVCLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUU1QixJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDNUIsSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNsQyxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFFNUIsSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQzVCLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUM1QixJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBSWxDLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNkLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNaLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztJQUNiLE1BQU0saUJBQWlCLEdBQUcsU0FBUyxDQUFDO0lBQ3BDLFFBQVEsS0FBSyxFQUFFO1FBQ2YsS0FBSyx1QkFBdUIsQ0FBQyxZQUFZO1lBQUU7Z0JBQ3ZDLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxD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SUFBSSxDQUFDLGdDQUFnQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUMsbUNBQUksSUFBSSxDQUFDLGdDQUFnQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDdEksSUFBSSxDQUFDLGdDQUFnQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUMsbUNBQUksSUFBSSxDQUFDLGdDQUFnQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7U0FDekk7UUFFRCxJQUFJLG1CQUFtQixDQUFDLGVBQWUsRUFBRTtZQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdDQUFnQyxDQUFDLGVBQWUsRUFBRTtnQkFDeEQsSUFBSSxDQUFDLGdDQUFnQyxDQUFDLGVBQWUsR0FBRyxJQUFJLGdFQUFpQixFQUFFLENBQUM7YUFDbkY7WUFFRCxJQUFJLENBQUMsZ0NBQWdDLENBQUMsZUFBZSxDQUFDLENBQUMsU0FBRyxtQkFBbUIsQ0FBQyxlQUFlLENBQUMsQ0FBQyxtQ0FBSSxJQUFJLENBQUMsZ0NBQWdDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztZQUMzSixJQUFJLENBQUMsZ0NBQWdDLENBQUMsZUFBZSxDQUFDLENBQUMsU0FBRyxtQkFBbUIsQ0FBQyxlQUFlLENBQUMsQ0FBQyxtQ0FBSSxJQUFJLENBQUMsZ0NBQWdDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztZQUMzSixJQUFJLENBQUMsZ0NBQWdDLENBQUMsZUFBZSxDQUFDLENBQUMsU0FBRyxtQkFBbUIsQ0FBQyxlQUFlLENBQUMsQ0FBQyxtQ0FBSSxJQUFJLENBQUMsZ0NBQWdDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztZQUMzSixJQUFJLENBQUMsZ0NBQWdDLENBQUMsZUFBZSxDQUFDLENBQUMsU0FBRyxtQkFBbUIsQ0FBQyxlQUFlLENBQUMsQ0FBQyxtQ0FBSSxJQUFJLENBQUMsZ0NBQWdDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztTQUM5SjtRQUVELElBQUksT0FBTyxDQUFDLG1CQUFtQixDQUFDLGVBQWUsQ0FBQyxLQUFLLFFBQVEsRUFBRTtZQUMzRCxJQUFJLENBQUMsZ0NBQWdDLENBQUMsaUJBQWlCLENBQUMsR0FBRyxtQkFBbUIsQ0FBQyxlQUFlLENBQUM7U0FDbEc7UUFFRCxJQUFJLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsS0FBSyxRQUFRLEVBQUU7WUFDcEQsSUFBSSxDQUFDLGdDQUFnQyxDQUFDLFVBQVUsQ0FBQyxHQUFHLG1CQUFtQixDQUFDLFFBQVEsQ0FBQztTQUNwRjtRQUNELElBQUksT0FBTyxDQUFDLG1CQUFtQixDQUFDLGVBQWUsQ0FBQyxLQUFLLFFBQVEsRUFBRTtZQUMzRCxJQUFJLENBQUMsZ0NBQWdDLENBQUMsaUJBQWlCLENBQUMsR0FBRyxtQkFBbUIsQ0FBQyxlQUFlLENBQUM7U0FDbEc7UUFDRCxJQUFJLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsS0FBSyxRQUFRLEVBQUU7WUFDdkQsSUFBSSxDQUFDLGdDQUFnQyxDQUFDLGFBQWEsQ0FBQyxHQUFHLG1CQUFtQixDQUFDLFdBQVcsQ0FBQztTQUMxRjtRQUNELElBQUksT0FBTyxDQUFDLG1CQUFtQixDQUFDLG1CQUFtQixDQUFDLEtBQUssUUFBUSxFQUFFO1lBQy9ELElBQUksT0FBTSxDQUFDLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLFFBQVEsRUFBRTtnQkFDaEYsSUFBSSxDQUFDLGdDQUFnQyxDQUFDLG1CQUFtQixHQUFHLEVBQUUsQ0FBQzthQUNsRTtZQUNELEtBQUssTUFBTSxRQUFRLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO2dCQUM1RSxJQUFJLENBQUMsZ0NBQWdDLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3hGO1NBQ0o7SUFDTCxDQUFDO0lBV08saUNBQWlDLENBQUMsYUFBdUI7UUFFN0QsSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLHdCQUF3QixJQUFJLGFBQWEsQ0FBQyxFQUFFO1lBQ2pGLElBQUksQ0FBQyxPQUFPLENBQUMsZ0NBQWdDLEdBQUcsS0FBSyxDQUFDO1lBQ3RELElBQUksQ0FBQywyQkFBMkIsRUFBRSxDQUFDO1lBQ25DLElBQUksQ0FBQyxhQUFhLEVBQUU7Z0JBQ2hCLElBQUksQ0FBQyxPQUFPLENBQUMsd0JBQXdCLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRTtvQkFDcEQsSUFBSSxDQUFDLDJCQUEyQixFQUFFLENBQUM7b0JBRW5DLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQ0FBZ0MsRUFBRTt3QkFDL0MsSUFBSSxDQUFDLGlDQUFpQyxDQUFDLElBQUksQ0FBQyxDQUFDO3FCQUNoRDtnQkFDTCxDQUFDLEVBQUUsSUFBSSxDQUFDLDBCQUEwQixDQUFDLENBQUM7YUFDdkM7WUFPRCxJQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLGlDQUFpQyxDQUFDLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxJQUFJLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztZQUNoSixJQUFJLGNBQWMsQ0FBQyxPQUFPLEVBQUU7Z0JBR3hCLElBQUksQ0FBQyxzQ0FBc0MsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsQ0FBQztnQkFHM0UsSUFBSSxDQUFDLCtCQUErQixFQUFFLENBQUM7Z0JBRXZDLE9BQU87b0JBQ0gsT0FBTyxFQUFFLElBQUk7b0JBQ2Isa0JBQWtCLEVBQUUsY0FBYyxDQUFDLHVCQUF1QjtpQkFDN0QsQ0FBQzthQUNMO2lCQUFNO2dCQUNILE9BQU87b0JBQ0gsT0FBTyxFQUFFLEtBQUs7b0JBQ2QsS0FBSyxFQUFFLGNBQWMsQ0FBQyxLQUFLO2lCQUM5QixDQUFDO2FBQ0w7U0FDSjthQUFNLElBQUksSUFBSSxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLHdCQUF3QixJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3RGLElBQUksQ0FBQyxPQUFPLENBQUMsZ0NBQWdDLEdBQUcsSUFBSSxDQUFDO1lBQ3JELE9BQU87Z0JBQ0gsT0FBTyxFQUFFLElBQUk7Z0JBQ2IsS0FBSyxFQUFFLHNFQUFzRTthQUNoRixDQUFDO1NBQ0w7YUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUM1QixPQUFPO2dCQUNILE9BQU8sRUFBRSxLQUFLO2dCQUNkLEtBQUssRUFBRSxxREFBcUQ7YUFDL0QsQ0FBQztTQUNMO0lBQ0wsQ0FBQztJQVFPLCtCQUErQjtRQUVuQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsbUJBQW1CLEdBQUcsRUFBRSxDQUFDO1FBRXZELElBQUksdUJBQXVCLEdBQUcsSUFBSSxDQUFDO1FBQ25DLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZ0NBQWdDLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxNQUFNLEdBQUcsdUJBQXVCLEVBQUU7WUFDekcsSUFBSSxDQUFDLGdDQUFnQyxDQUFDLG1CQUFtQixHQUFHLEVBQUUsQ0FBQztZQUMvRCxrRUFBZSxDQUFDLDhHQUE4RyxDQUFDLENBQUM7U0FDbkk7SUFDTCxDQUFDO0lBWUQseUJBQXlCLENBQUMsV0FBZ0I7UUFDdEMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUVsQyxPQUFPLElBQUksQ0FBQyxpQ0FBaUMsRUFBRSxDQUFDO0lBQ3BELENBQUM7SUFRTyxzQkFBc0IsQ0FBQyxxQkFBc0Q7UUFDakYsSUFBSSxJQUFJLENBQUMsc0JBQXNCLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMxQyxPQUFPO1NBQ1Y7UUFFRCxLQUFLLElBQUksTUFBTSxHQUFHLENBQUMsRUFBRSxNQUFNLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsRUFBRTtZQUN4RSxJQUFJLG1CQUFtQixHQUFHLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUk5RCxJQUFJLENBQUMsbUJBQW1CLENBQUMsUUFBUSxFQUFFO2dCQUMvQixTQUFTO2FBQ1o7WUFFRCxJQUFJLCtCQUErQixHQUFvQyxFQUFFLENBQUM7WUFFMUUsS0FBSyxJQUFJLE9BQU8sR0FBRyxDQUFDLEVBQUUsT0FBTyxHQUFHLHFCQUFxQixDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsRUFBRTtnQkFDckUsSUFBSSxxQkFBcUIsR0FBRyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFFM0QsSUFBSSxtQkFBbUIsQ0FBQyxjQUFjLElBQUkscUJBQXFCLENBQUMsY0FBYyxLQUFLLG1CQUFtQixDQUFDLGNBQWMsRUFBRTtvQkFDbkgsU0FBUztpQkFDWjtnQkFFRCxJQUFJLGVBQWUsR0FBRyxJQUFJLHVFQUF3QixFQUFFLENBQUM7Z0JBRXJELElBQUksT0FBTyxDQUFDLHFCQUFxQixDQUFDLGNBQWMsQ0FBQyxLQUFLLFFBQVEsRUFBRTtvQkFDNUQsZUFBZSxDQUFDLGNBQWMsR0FBRyxxQkFBcUIsQ0FBQyxjQUFjLENBQUM7aUJBQ3pFO2dCQUVELElBQUksT0FBTyxDQUFDLHFCQUFxQixDQUFDLGFBQWEsQ0FBQyxLQUFLLFFBQVEsRUFBRTtvQkFDM0QsZUFBZSxDQUFDLGFBQWEsR0FBRyxxQkFBcUIsQ0FBQyxhQUFhLENBQUM7aUJBQ3ZFO2dCQUVELElBQUkseUJBQXlCLEdBQUcsS0FBSyxDQUFDO2dCQUV0QyxLQUFLLElBQUksWUFBWSxHQUFHLENBQUMsRUFBRSxZQUFZLEdBQUcsbUJBQW1CLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUUsRUFBRTtvQkFDN0YsSUFBSSxnQkFBZ0IsR0FBRyxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7b0JBRXBFLFFBQVEsZ0JBQWdCLEVBQUU7d0JBQ3RCLEtBQUssdUdBQWdEOzRCQUNqRCxJQUFJLHFCQUFxQixDQUFDLFFBQVEsRUFBRTtnQ0FDaEMsZUFBZSxDQUFDLFFBQVEsR0FBRyxxQkFBcUIsQ0FBQyxRQUFRLENBQUM7Z0NBQzFELHlCQUF5QixHQUFHLElBQUksQ0FBQzs2QkFDcEM7NEJBQ0QsTUFBTTt3QkFFVixLQUFLLDhHQUF1RDs0QkFDeEQsSUFBSSxxQkFBcUIsQ0FBQyxlQUFlLEVBQUU7Z0NBQ3ZDLGVBQWUsQ0FBQyxlQUFlLEdBQUcscUJBQXFCLENBQUMsZUFBZSxDQUFDO2dDQUN4RSx5QkFBeUIsR0FBRyxJQUFJLENBQUM7NkJBQ3BDOzRCQUNELE1BQU07d0JBQ1YsS0FBSywrR0FBd0Q7NEJBRXpELElBQUkscUJBQXFCLENBQUMsZUFBZSxFQUFFO2dDQUN2QyxlQUFlLENBQUMsZ0JBQWdCLEdBQUcsc0VBQW1CLENBQUMscUJBQXFCLENBQUMsZUFBZSxFQUFFLHVGQUFtQyxDQUFDLENBQUM7Z0NBQ25JLHlCQUF5QixHQUFHLElBQUksQ0FBQzs2QkFDcEM7NEJBQ0QsTUFBTTt3QkFFVixLQUFLLDZHQUFzRDs0QkFDdkQsSUFBSSxPQUFPLENBQUMscUJBQXFCLENBQUMsY0FBYyxDQUFDLEtBQUssUUFBUSxFQUFFO2dDQUM1RCxlQUFlLENBQUMsY0FBYyxHQUFHLHFCQUFxQixDQUFDLGNBQWMsQ0FBQztnQ0FDdEUseUJBQXlCLEdBQUcsSUFBSSxDQUFDOzZCQUNwQzs0QkFDRCxNQUFNO3dCQUVWLEtBQUssdUdBQWdEOzRCQUNqRCxJQUFJLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsS0FBSyxTQUFTLEVBQUU7Z0NBQ3ZELGVBQWUsQ0FBQyxRQUFRLEdBQUcscUJBQXFCLENBQUMsUUFBUSxDQUFDO2dDQUMxRCx5QkFBeUIsR0FBRyxJQUFJLENBQUM7NkJBQ3BDOzRCQUNELE1BQU07cUJBQ2I7aUJBQ0o7Z0JBRUQsSUFBSSx5QkFBeUIsRUFBRTtvQkFDM0IsK0JBQStCLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO2lCQUN6RDthQUNKO1lBRUQsSUFBSSxtQkFBbUIsQ0FBQyxRQUFRLElBQUksK0JBQStCLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDNUUsbUJBQW1CLENBQUMsUUFBUSxDQUFDLCtCQUErQixDQUFDLENBQUM7YUFDakU7U0FDSjtJQUNMLENBQUM7SUFTTyxvQkFBb0IsQ0FBQyxpQkFBa0Q7UUFDM0UsSUFBSSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7WUFDMUIsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGlCQUFpQixDQUFDLENBQUM7U0FDL0M7SUFDTCxDQUFDO0lBWUQsdUJBQXVCLENBQUMsZUFBcUM7UUFDekQsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDckIsbUVBQWdCLENBQUMsb0RBQW9ELENBQUMsQ0FBQztZQUN2RSxPQUFPO1NBQ1Y7UUFFRCxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsc0JBQXNCLEtBQUssMkJBQTJCLENBQUMsSUFBSSxFQUFFO1lBQ2hGLG1FQUFnQixDQUFDLHlIQUF5SCxDQUFDLENBQUM7WUFDNUksT0FBTztTQUNWO1FBRUQsaUVBQWMsQ0FBQyx1Q0FBdUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDekYsSUFBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUN0RCxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuMUI2SDtBQUN6RTtBQUNrQztBQUV0QztBQUNxRTtBQUNwQjtBQUNaO0FBQzdCO0FBQ3pELE1BQU0sSUFBSSxHQUFHLG1CQUFPLENBQUMsMENBQU0sQ0FBQyxDQUFDO0FBRTdCLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQztBQUM3QixNQUFNLGlDQUFpQyxHQUFHLElBQUksQ0FBQztBQXlCL0MsSUFBWSxVQUlYO0FBSkQsV0FBWSxVQUFVO0lBQ2xCLCtCQUFpQjtJQUNqQiw2QkFBZTtJQUNmLG1DQUFxQjtBQUN6QixDQUFDLEVBSlcsVUFBVSxLQUFWLFVBQVUsUUFJckI7QUFLTSxNQUFNLGdCQUFnQjtJQXlCekIsWUFBWSxFQUFFLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSwyQkFBMkIsRUFBRSwrQkFBK0IsRUFBRSxVQUFVLEVBQXFLO1FBQzVSLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksQ0FBQywwQkFBMEIsR0FBRywwQkFBMEIsQ0FBQztRQUM3RCxJQUFJLENBQUMsMkJBQTJCLEdBQUcsMkJBQTJCLENBQUM7UUFDL0QsSUFBSSxDQUFDLCtCQUErQixHQUFHLCtCQUErQixDQUFDO1FBQ3ZFLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO0lBQ2pDLENBQUM7Q0FDSjtBQW1CTSxNQUFNLGdCQUFnQjtJQTJHekIsWUFBWSxFQUFFLHNCQUFzQixHQUFHLDhFQUErQixFQUFFLGlCQUFpQixFQUFFLG1CQUFtQixFQUFFLHdCQUF3QixFQUFFLGFBQWEsRUFBc007UUFqRHRWLGdCQUFXLEdBQVUsQ0FBQyxDQUFDO1FBa0QxQixJQUFJLENBQUMsYUFBYSxHQUFHLFNBQVMsQ0FBQztRQUMvQixJQUFJLENBQUMsc0JBQXNCLEdBQUcsc0JBQXNCLENBQUM7UUFDckQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLGlCQUFpQixDQUFDO1FBQzNDLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQztRQUMvQyxJQUFJLENBQUMsNkJBQTZCLEdBQUcsRUFBRSxDQUFDO1FBQ3hDLElBQUksQ0FBQyxtQ0FBbUMsR0FBRyxLQUFLLENBQUM7UUFDakQsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7UUFFbkMsa0VBQWtCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFMUIsSUFBSSxDQUFDLHdCQUF3QixHQUFHLElBQUkscUZBQXVCLEVBQUUsQ0FBQztRQUM5RCxJQUFJLENBQUMsd0JBQXdCLENBQUMscUJBQXFCLENBQUMsQ0FBQyxLQUFVLEVBQUUsRUFBRTtZQUMvRCxJQUFJLENBQUMsMkJBQTJCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUMsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksNkRBQVcsRUFBRSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxZQUFZLENBQUMscUJBQXFCLENBQUMsQ0FBQyxLQUFVLEVBQUUsRUFBRTtZQUNuRCxJQUFJLENBQUMseUJBQXlCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDMUMsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsd0JBQXdCLEdBQUcsd0JBQXdCLENBQUM7UUFFekQsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLGlFQUFXLENBQUMsRUFBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUMsQ0FBQyxDQUFDO1FBQ2pHLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLGlFQUFXLENBQUMsRUFBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxZQUFZO1lBR3BELE1BQU0sRUFBRSxDQUFDLGtCQUFrQixFQUFFLFVBQVUsRUFBRSxjQUFjLENBQUMsRUFBQyxDQUFDLENBQUM7SUFDeEcsQ0FBQztJQVFLLHFCQUFxQjs7WUFDdkIsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtnQkFDbkMsSUFBSSxRQUFRLEdBQUc7b0JBQ1gsT0FBTyxFQUFFLElBQUk7b0JBRWIsUUFBUSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFO29CQUNyQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUU7b0JBQ3BDLGVBQWUsRUFBRSxJQUFJLENBQUMsc0JBQXNCO29CQUM1QyxzQkFBc0IsRUFBRSxJQUFJLENBQUMsOEJBQThCO2lCQUM5RCxDQUFDO2dCQUNGLElBQUksaUJBQWlCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO2dCQUNqRSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7b0JBQ3BCLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQzt3QkFDbEIsT0FBTyxFQUFFLEtBQUs7d0JBQ2QsS0FBSyxFQUFFLHNEQUFzRDtxQkFDaEUsQ0FBQyxDQUFDO2lCQUNOO2dCQUVELElBQUksV0FBVyxHQUFHLFVBQVUsQ0FBQyxHQUFTLEVBQUU7b0JBQ3BDLElBQUksTUFBTSxHQUFHLHdEQUF3RDtvQkFDckUsSUFBSTt3QkFDQSxNQUFNLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxDQUFDO3FCQUN6QztvQkFBQyxPQUFPLFlBQVksRUFBRTt3QkFDbkIsTUFBTSxJQUFJLHFGQUFxRixZQUFZLEVBQUUsQ0FBQztxQkFDakg7b0JBQ0QsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDO3dCQUNsQixPQUFPLEVBQUUsS0FBSzt3QkFDZCxLQUFLLEVBQUUsTUFBTTtxQkFDaEIsQ0FBQyxDQUFDO2dCQUNQLENBQUMsR0FBRSxlQUFlLENBQUMsQ0FBQztnQkFFcEIsaUJBQWlCLENBQUMsWUFBWSxDQUFDLGVBQWUsRUFBRSxRQUFRLEVBQUUsQ0FBTyxRQUFnQixFQUFFLEVBQUU7b0JBQ2pGLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztvQkFDMUIsSUFBSSxjQUFtQixDQUFDO29CQUN4QixJQUFJO3dCQUNBLGNBQWMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO3dCQUN0QyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQzt3QkFDbkMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsR0FBRyxjQUFjLENBQUMsWUFBWSxDQUFDO3dCQUM3RCxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxHQUFHLGNBQWMsQ0FBQyxVQUFVLENBQUM7d0JBQ3pELElBQUksQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLEdBQUcsY0FBYyxDQUFDLGFBQWEsQ0FBQzt3QkFDL0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxlQUFlLENBQUMsR0FBRyxjQUFjLENBQUMsYUFBYSxDQUFDO3dCQUMvRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUM7d0JBQzFELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsQ0FBQzt3QkFDMUQsT0FBTyxDQUFDOzRCQUNKLE9BQU8sRUFBRSxJQUFJOzRCQUNiLG9CQUFvQixFQUFFLGNBQWM7eUJBQ3ZDLENBQUMsQ0FBQztxQkFDTjtvQkFBQyxPQUFPLENBQUMsRUFBRTt3QkFDUixNQUFNLENBQUM7NEJBQ0gsT0FBTyxFQUFFLEtBQUs7NEJBQ2QsS0FBSyxFQUFFLCtDQUErQyxDQUFDLEVBQUU7eUJBQzVELENBQUMsQ0FBQztxQkFDTjtnQkFDTCxDQUFDLEVBQUMsQ0FBQztZQUNQLENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQztLQUFBO0lBTUQsMkJBQTJCLENBQUMsSUFBUztRQUNqQyxJQUFJLGFBQWEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ3hELElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFekMsSUFBSSxRQUFRLENBQUMsaUJBQWlCLEVBQUU7WUFDNUIsSUFBSSxrQkFBa0IsR0FBb0MsRUFBRSxDQUFDO1lBRTdELElBQUksZUFBZSxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQztZQUNqRCxLQUFLLE1BQU0sY0FBYyxJQUFJLGVBQWUsRUFBRTtnQkFDMUMsSUFBSSxhQUFhLEdBQUcsY0FBYyxDQUFDO2dCQUVuQyxJQUFJLGVBQWUsR0FBRyxJQUFJLHVFQUF3QixDQUFDO29CQUMvQyxhQUFhLEVBQUUsYUFBYTtpQkFDL0IsQ0FBQyxDQUFDO2dCQUVILElBQUksYUFBYSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLDZCQUE2QixDQUFDLENBQUM7Z0JBQ3BFLEtBQUssTUFBTSxZQUFZLElBQUksYUFBYSxFQUFFO29CQUN0QyxJQUFJLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxZQUFZLENBQUMsQ0FBQyxhQUFhLEtBQUssYUFBYSxFQUFFO3dCQUNsRixJQUFJLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxZQUFZLENBQUMsQ0FBQyxjQUFjLEVBQUU7NEJBQ2pFLGVBQWUsQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLDZCQUE2QixDQUFDLFlBQVksQ0FBQyxDQUFDLGNBQWMsQ0FBQzt5QkFDcEc7d0JBQ0QsTUFBTTtxQkFDVDtpQkFDSjtnQkFFRCxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7YUFDNUM7WUFHRCxJQUFJLENBQUMsV0FBVyxJQUFJLGtCQUFrQixDQUFDLE1BQU0sQ0FBQztZQUM5QyxJQUFJLElBQUksQ0FBQyxtQkFBbUIsSUFBSSxrQkFBa0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUMzRCxJQUFJLENBQUMsbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsQ0FBQzthQUNoRDtTQUNKO1FBRUQsSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFFO1lBQ2hCLElBQUksY0FBYyxHQUFvQyxFQUFFLENBQUM7WUFFekQsSUFBSSxRQUFRLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDM0MsS0FBSyxJQUFJLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLEVBQUU7Z0JBQzVDLElBQUksaUJBQWlCLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFHdEQsSUFBSSxhQUF1QyxDQUFDO2dCQUU1QyxJQUFJLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtvQkFDbkQsYUFBYSxHQUFHLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQTZCLENBQUM7aUJBQ2pHO3FCQUVJO29CQUNELGFBQWEsR0FBRyxJQUFJLHVFQUF3QixFQUFFLENBQUM7b0JBQy9DLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxhQUFhLENBQUM7b0JBQ2xFLElBQUksQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDO2lCQUN6QjtnQkFJRCxJQUFJLFdBQVcsR0FBRyxJQUFJLHVFQUF3QixFQUFFLENBQUM7Z0JBR2pELElBQUksYUFBYSxDQUFDLGNBQWMsRUFBRTtvQkFFOUIsV0FBVyxDQUFDLGNBQWMsR0FBRyxhQUFhLENBQUMsY0FBYyxDQUFDO2lCQUM3RDtxQkFBTSxJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLEVBQUU7b0JBQ2xELGFBQWEsQ0FBQyxjQUFjLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO29CQUNuRCxXQUFXLENBQUMsY0FBYyxHQUFHLGlCQUFpQixDQUFDLENBQUMsQ0FBQztpQkFDcEQ7Z0JBS0QsSUFBSSxhQUFhLENBQUMsYUFBYSxFQUFFO29CQUU3QixXQUFXLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQyxhQUFhLENBQUM7aUJBQzNEO3FCQUFNLElBQUksT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVEsRUFBRTtvQkFDbEQsYUFBYSxDQUFDLGFBQWEsR0FBRyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7b0JBQ2xELFdBQVcsQ0FBQyxhQUFhLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO2lCQUNuRDtnQkFFRCxJQUFJLHFCQUFxQixHQUFHLEtBQUssQ0FBQztnQkFHbEMsSUFBSSxxQkFBcUIsR0FBRyxLQUFLLENBQUM7Z0JBQ2xDLElBQUksT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVEsRUFBRTtvQkFDM0MsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUU7d0JBQ3pCLGFBQWEsQ0FBQyxRQUFRLEdBQUcsSUFBSSxzREFBTyxFQUFFLENBQUM7cUJBQzFDO29CQUVELGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLGlCQUFpQixDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7b0JBQ3RELHFCQUFxQixHQUFHLElBQUksQ0FBQztpQkFDaEM7Z0JBQ0QsSUFBSSxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxFQUFFO29CQUMzQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRTt3QkFDekIsYUFBYSxDQUFDLFFBQVEsR0FBRyxJQUFJLHNEQUFPLEVBQUUsQ0FBQztxQkFDMUM7b0JBRUQsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztvQkFDdEQscUJBQXFCLEdBQUcsSUFBSSxDQUFDO2lCQUNoQztnQkFDRCxJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLEVBQUU7b0JBQzNDLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFO3dCQUN6QixhQUFhLENBQUMsUUFBUSxHQUFHLElBQUksc0RBQU8sRUFBRSxDQUFDO3FCQUMxQztvQkFFRCxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO29CQUN0RCxxQkFBcUIsR0FBRyxJQUFJLENBQUM7aUJBQ2hDO2dCQUdELElBQUkscUJBQXFCLEVBQUU7b0JBR3ZCLFdBQVcsQ0FBQyxRQUFRLEdBQUcsb0dBQWdELENBQUMsNEVBQXdCLEVBQUUsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUMxSCxxQkFBcUIsR0FBRyxJQUFJLENBQUM7aUJBQ2hDO2dCQUdELElBQUksd0JBQXdCLEdBQUcsS0FBSyxDQUFDO2dCQUNyQyxJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLEVBQUU7b0JBQzNDLElBQUksQ0FBQyxhQUFhLENBQUMsZUFBZSxFQUFFO3dCQUNoQyxhQUFhLENBQUMsZUFBZSxHQUFHLElBQUksZ0VBQWlCLEVBQUUsQ0FBQztxQkFDM0Q7b0JBQ0QsYUFBYSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztvQkFDN0Qsd0JBQXdCLEdBQUcsSUFBSSxDQUFDO2lCQUNuQztnQkFDRCxJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLEVBQUU7b0JBQzNDLElBQUksQ0FBQyxhQUFhLENBQUMsZUFBZSxFQUFFO3dCQUNoQyxhQUFhLENBQUMsZUFBZSxHQUFHLElBQUksZ0VBQWlCLEVBQUUsQ0FBQztxQkFDM0Q7b0JBQ0QsYUFBYSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztvQkFDN0Qsd0JBQXdCLEdBQUcsSUFBSSxDQUFDO2lCQUNuQztnQkFDRCxJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLEVBQUU7b0JBQzNDLElBQUksQ0FBQyxhQUFhLENBQUMsZUFBZSxFQUFFO3dCQUNoQyxhQUFhLENBQUMsZUFBZSxHQUFHLElBQUksZ0VBQWlCLEVBQUUsQ0FBQztxQkFDM0Q7b0JBQ0QsYUFBYSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztvQkFDN0Qsd0JBQXdCLEdBQUcsSUFBSSxDQUFDO2lCQUNuQztnQkFDRCxJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLEVBQUU7b0JBQzNDLElBQUksQ0FBQyxhQUFhLENBQUMsZUFBZSxFQUFFO3dCQUNoQyxhQUFhLENBQUMsZUFBZSxHQUFHLElBQUksZ0VBQWlCLEVBQUUsQ0FBQztxQkFDM0Q7b0JBQ0QsYUFBYSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztvQkFDN0Qsd0JBQXdCLEdBQUcsSUFBSSxDQUFDO2lCQUNuQztnQkFHRCxJQUFJLHdCQUF3QixFQUFFO29CQUcxQixXQUFXLENBQUMsZUFBZSxHQUFHLDhHQUEwRCxDQUFDLDRFQUF3QixFQUFFLGFBQWEsQ0FBQyxlQUFlLENBQUMsQ0FBQztvQkFDbEoscUJBQXFCLEdBQUcsSUFBSSxDQUFDO2lCQUNoQztnQkFHRCxJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLEVBQUU7b0JBQzNDLGFBQWEsQ0FBQyxjQUFjLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO29CQUNuRCxXQUFXLENBQUMsY0FBYyxHQUFHLGlCQUFpQixDQUFDLENBQUMsQ0FBQztvQkFDakQscUJBQXFCLEdBQUcsSUFBSSxDQUFDO2lCQUNoQztnQkFHRCxJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLEVBQUU7b0JBQzVDLGFBQWEsQ0FBQyxRQUFRLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO29CQUM3QyxXQUFXLENBQUMsUUFBUSxHQUFHLGlCQUFpQixDQUFDLENBQUMsQ0FBQztvQkFDM0MscUJBQXFCLEdBQUcsSUFBSSxDQUFDO2lCQUNoQztnQkFJRCxJQUFJLHFCQUFxQixFQUFFO29CQUN2QixjQUFjLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2lCQUNwQzthQUNKO1lBRUQsSUFBSSxJQUFJLENBQUMsaUJBQWlCLElBQUksY0FBYyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQ3JELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxjQUFjLENBQUMsQ0FBQzthQUMxQztTQUNKO1FBRUQsSUFBSSxRQUFRLENBQUMsWUFBWSxFQUFFO1lBQ3ZCLEtBQUssTUFBTSxXQUFXLElBQUksUUFBUSxDQUFDLFlBQVksRUFBRTtnQkFDN0MsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFO29CQUNwRCxTQUFTO2lCQUNaO2dCQUVELElBQUksZUFBZSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDckMsSUFBSSxvQkFBb0IsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNoRCxJQUFJLGVBQWUsS0FBSyxNQUFNLEVBQUU7b0JBQzVCLElBQUksYUFBc0IsQ0FBQztvQkFDM0IsSUFBSSxvQkFBb0IsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO3dCQUNsQyxJQUFJLE9BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLFNBQVMsRUFBRTs0QkFDL0MsYUFBYSxHQUFHLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDO3lCQUMzQztxQkFDSjtvQkFDRCxJQUFJLGFBQWEsS0FBSyxTQUFTLEVBQUU7d0JBQzdCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLEVBQUUsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO3FCQUMxRDtpQkFDSjthQUNKO1NBQ0o7SUFDTCxDQUFDO0lBU0ssa0JBQWtCLENBQUMsRUFBRSxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBb0c7O1lBRXZLLElBQUksSUFBSSxDQUFDLDJCQUEyQixLQUFLLDZFQUE4QixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLEVBQUU7Z0JBQ3BHLElBQUksR0FBRyxHQUFHLDRFQUE0RSxDQUFDO2dCQUN2RixPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDL0I7WUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRTtnQkFDckIsSUFBSSxNQUFNLEdBQUcscURBQXFELENBQUM7Z0JBQ25FLElBQUk7b0JBQ0EsTUFBTSxJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztpQkFDekM7Z0JBQUMsT0FBTyxZQUFZLEVBQUU7b0JBQ25CLE1BQU0sSUFBSSxxRkFBcUYsWUFBWSxFQUFFLENBQUM7aUJBQ2pIO2dCQUNELE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUNqQztZQUVELElBQUksQ0FBQywyQkFBMkIsR0FBRyxTQUFTLENBQUM7WUFFN0MsSUFBSSxrQkFBa0IsR0FBRyxLQUFLLENBQUM7WUFDL0IsTUFBTSwyQkFBMkIsR0FBRyxDQUFDLEtBQVUsRUFBRSxFQUFFO2dCQUMvQyxJQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsS0FBSyxLQUFLLDZGQUErQixFQUFFO29CQUMxRCxrQkFBa0IsR0FBRyxJQUFJLENBQUM7b0JBQzFCLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyx3QkFBd0IsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO29CQUNwRixJQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixFQUFFLENBQUM7aUJBQ3hDO1lBQ0wsQ0FBQztZQUNELElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxxQkFBcUIsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1lBRWpGLElBQUk7Z0JBQ0EsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsMkJBQTJCLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQzthQUN0RjtZQUFDLE9BQU8sK0JBQStCLEVBQUU7Z0JBQ3RDLElBQUksTUFBTSxHQUFHLDJDQUEyQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsK0JBQStCLCtCQUErQixFQUFFLENBQUM7Z0JBQzFMLElBQUk7b0JBQ0EsTUFBTSxJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztpQkFDekM7Z0JBQUMsT0FBTyxZQUFZLEVBQUU7b0JBQ25CLE1BQU0sSUFBSSxxRkFBcUYsWUFBWSxFQUFFLENBQUM7aUJBQ2pIO2dCQUNELElBQUksQ0FBQyx3QkFBd0IsQ0FBQyx3QkFBd0IsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO2dCQUNwRixPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDakM7WUFFRCxJQUFJO2dCQUNBLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxlQUFlLENBQUMsRUFBRSxtQkFBbUIsRUFBRSxJQUFJLENBQUMsd0JBQXdCLEVBQUUsTUFBTSxFQUFFLG1CQUFtQixFQUFFLGlCQUFpQixFQUFFLHVCQUF1QixFQUFFLENBQUMsQ0FBQzthQUM1SztZQUFDLE9BQU8sdUJBQXVCLEVBQUU7Z0JBQzlCLElBQUksTUFBTSxHQUFHLGdEQUFnRCxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsK0JBQStCLHVCQUF1QixFQUFFLENBQUM7Z0JBQ3ZMLElBQUksa0JBQWtCLEVBQUU7b0JBQ3BCLE1BQU0sR0FBRyw4REFBOEQsQ0FBQztpQkFDM0U7Z0JBQ0QsSUFBSTtvQkFDQSxNQUFNLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxDQUFDO2lCQUN6QztnQkFBQyxPQUFPLFlBQVksRUFBRTtvQkFDbkIsTUFBTSxJQUFJLDhFQUE4RSxZQUFZLEVBQUUsQ0FBQztpQkFDMUc7Z0JBQ0QsSUFBSSxDQUFDLHdCQUF3QixDQUFDLHdCQUF3QixDQUFDLDJCQUEyQixDQUFDLENBQUM7Z0JBQ3BGLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUNqQztZQUVELElBQUksb0JBQW9CLENBQUM7WUFDekIsSUFBSTtnQkFDQSxvQkFBb0IsR0FBRyxNQUFNLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO2FBQzdEO1lBQUMsT0FBTyxTQUFTLEVBQUU7Z0JBQ2hCLElBQUksTUFBTSxHQUFHLDZDQUE2QyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQzVFLElBQUk7b0JBQ0EsTUFBTSxJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztpQkFDekM7Z0JBQUMsT0FBTyxZQUFZLEVBQUU7b0JBQ25CLE1BQU0sSUFBSSxxRkFBcUYsWUFBWSxFQUFFLENBQUM7aUJBQ2pIO2dCQUNELElBQUksQ0FBQyx3QkFBd0IsQ0FBQyx3QkFBd0IsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO2dCQUNwRixPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDakM7WUFFRCxJQUFJLENBQUMsd0JBQXdCLENBQUMsd0JBQXdCLENBQUMsMkJBQTJCLENBQUMsQ0FBQztZQUVwRixJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQztZQUNyQixJQUFJLENBQUMsWUFBWSxDQUFDLG9CQUFvQixFQUFFLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxJQUFTLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxJQUFJLENBQUMsRUFBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFFM0gsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFDakQsQ0FBQztLQUFBO0lBTUssdUJBQXVCOztZQUN6QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsNEJBQTRCLEVBQUUsQ0FBQztZQUNyRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsNEJBQTRCLEVBQUUsQ0FBQztZQUNyRCxPQUFPLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxDQUFDO1FBQzNDLENBQUM7S0FBQTtJQUNLLHdCQUF3Qjs7WUFDMUIsU0FBZSxLQUFLLENBQUMsWUFBcUQsRUFBRSxrQkFBMEIsRUFBRSxXQUFtQjs7b0JBQ3ZILElBQUksWUFBWSxFQUFFO3dCQUNkLElBQUksS0FBSyxHQUFHLFlBQVksQ0FBQyxRQUFRLEVBQUUsQ0FBQzt3QkFDcEMsSUFBSSxDQUFDLFlBQVksSUFBSSxLQUFLLEtBQUssV0FBVyxFQUFFOzRCQUN4QyxpRUFBYyxDQUFDLFlBQVksa0JBQWtCLHNCQUFzQixDQUFDLENBQUM7eUJBQ3hFOzZCQUFNOzRCQUNILElBQUk7Z0NBQ0EsSUFBSSxZQUFZLFlBQVkscUZBQXVCLEVBQUU7b0NBQ2pELE1BQU0sWUFBWSxDQUFDLDRCQUE0QixFQUFFLENBQUM7aUNBQ3JEO3FDQUFNLElBQUksWUFBWSxZQUFZLDZEQUFXLEVBQUU7b0NBQzVDLE1BQU0sWUFBWSxDQUFDLGdCQUFnQixFQUFFLENBQUM7aUNBQ3pDO2dDQUNELGlFQUFjLENBQUMsWUFBWSxrQkFBa0IsbUNBQW1DLEtBQUssR0FBRyxDQUFDLENBQUM7NkJBQzdGOzRCQUFDLE9BQU8sQ0FBQyxFQUFFO2dDQUNSLGtFQUFlLENBQUMsWUFBWSxrQkFBa0IseUNBQXlDLEtBQUssYUFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDOzZCQUNqSDt5QkFDSjtxQkFDSjt5QkFBTTt3QkFDSCxrRUFBZSxDQUFDLFlBQVksa0JBQWtCLGVBQWUsQ0FBQyxDQUFDO3FCQUNsRTtvQkFFRCxZQUFZLEdBQUcsSUFBSSxDQUFDO2dCQUN4QixDQUFDO2FBQUE7WUFFRCxNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEVBQUUsc0JBQXNCLEVBQUUsd0ZBQTBCLENBQUMsQ0FBQztZQUMvRixNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLFNBQVMsRUFBRSwwRUFBd0IsQ0FBQyxDQUFDO1lBRXBFLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUV2QixNQUFNLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXhELE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1FBQ3pELENBQUM7S0FBQTtJQVFLLGlCQUFpQixDQUFDLHFCQUFrQyxFQUFFLFdBQW9CLEtBQUs7O1lBRWpGLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQztZQUNuQixJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ25CLElBQUksZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO2dCQUMvRCxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7b0JBQ25CLGtFQUFlLENBQUMscUZBQXFGLENBQUMsQ0FBQztvQkFDdkcsTUFBTSxHQUFHLEtBQUssQ0FBQztpQkFDbEI7cUJBQU07b0JBQ0gsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLFFBQVEsQ0FBQyxDQUFDO29CQUNoRSxpRUFBYyxDQUFDLGdFQUFnRSxDQUFDLENBQUM7b0JBQ2pGLE1BQU0sR0FBRyxJQUFJLENBQUM7aUJBQ2pCO2FBQ0o7aUJBQU07Z0JBQ0gsa0VBQWUsQ0FBQyxpRkFBaUYsQ0FBQyxDQUFDO2dCQUNuRyxNQUFNLEdBQUcsS0FBSyxDQUFDO2FBQ2xCO1lBRUQsSUFBSSxNQUFNLEVBQUU7Z0JBQ1IsSUFBSSxJQUFJLENBQUMsOEJBQThCLElBQUksUUFBUSxFQUFFO29CQUNqRCxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLEtBQUssNkVBQTJCLEVBQUU7d0JBRTlELGtFQUFlLENBQUMsa0NBQWtDLElBQUksQ0FBQyw4QkFBOEIsT0FBTyxRQUFRLDhDQUE4QyxDQUFDLENBQUM7d0JBQ3BKLElBQUksb0JBQW9CLENBQUM7d0JBQ3pCLElBQUk7NEJBQ0EsSUFBSSxDQUFDLDhCQUE4QixHQUFHLFFBQVEsQ0FBQzs0QkFDL0Msb0JBQW9CLEdBQUcsTUFBTSxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQzt5QkFDN0Q7d0JBQUMsT0FBTyxTQUFTLEVBQUU7NEJBS2hCLElBQUksTUFBTSxHQUFHLGlGQUFpRixTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7NEJBQ2hILE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQzt5QkFDakM7cUJBQ0o7eUJBQU07d0JBR0gsSUFBSSxDQUFDLDhCQUE4QixHQUFHLFFBQVEsQ0FBQztxQkFDbEQ7aUJBQ0o7YUFDSjtZQUNELE9BQU8sTUFBTSxDQUFDO1FBQ2xCLENBQUM7S0FBQTtJQWlDSyxrQkFBa0IsQ0FBQyxhQUFzQixFQUFFLHFCQUE4QixLQUFLOztZQUNoRixPQUFPLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLEVBQUUsa0JBQWtCLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RGLENBQUM7S0FBQTtJQUVLLGdCQUFnQixDQUFDLFlBQXFCLEVBQUUsVUFBc0I7O1lBS2hFLElBQUksQ0FBQyxnQ0FBZ0MsR0FBRyxZQUFZLENBQUM7WUFDckQsT0FBTyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxtQ0FBbUMsRUFBRSxLQUFLLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDN0csQ0FBQztLQUFBO0lBRUssU0FBUyxDQUFDLGFBQXNCLEVBQUUsa0JBQTJCLEVBQUUsVUFBc0I7O1lBQ3ZGLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQztZQUNuQixJQUFJLFVBQVUsSUFBSSxVQUFVLENBQUMsTUFBTSxFQUFFO2dCQUNqQyxJQUFJLElBQUksQ0FBQyxnQ0FBZ0MsSUFBSSxDQUFDLGFBQWEsRUFBRTtvQkFDekQsa0VBQWUsQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO29CQUM1RCxPQUFPLEdBQUcsS0FBSyxDQUFDO2lCQUNuQjthQUNKO1lBQ0QsSUFBSSxPQUFPLEVBQUU7Z0JBQ1QsT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLHNCQUFzQixDQUFDLGFBQWEsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO2FBQ2xGO1lBQ0QsSUFBSSxPQUFPLEVBQUU7Z0JBQ1QsSUFBSSxDQUFDLG1DQUFtQyxHQUFHLGFBQWEsQ0FBQzthQUM1RDtZQUVELElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtnQkFDcEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLGdCQUFnQixDQUFDO29CQUNwQyxPQUFPLEVBQUUsT0FBTztvQkFDaEIsMEJBQTBCLEVBQUUsYUFBYTtvQkFDekMsMkJBQTJCLEVBQUUsSUFBSSxDQUFDLG1DQUFtQztvQkFDckUsK0JBQStCLEVBQUUsSUFBSSxDQUFDLGdDQUFnQztvQkFDdEUsVUFBVSxFQUFFLFVBQVU7aUJBQ3pCLENBQUMsQ0FBQyxDQUFDO2FBQ1A7WUFDRCxPQUFPLE9BQU8sQ0FBQztRQUNuQixDQUFDO0tBQUE7SUFFSyxzQkFBc0IsQ0FBQyxhQUFzQixFQUFFLGtCQUEyQjs7WUFDNUUsSUFBSSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLG1CQUFtQixFQUFFLENBQUM7WUFDL0QsSUFBSSxJQUFJLENBQUMsWUFBWSxJQUFJLGdCQUFnQixFQUFFO2dCQUN2QyxJQUFJLGdCQUFnQixHQUFHLEtBQUssQ0FBQztnQkFFN0IsSUFBSSxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssV0FBVyxJQUFJLFNBQVMsQ0FBQyxXQUFXLElBQUksU0FBUyxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUU7b0JBQzVGLElBQUksTUFBd0IsQ0FBQztvQkFDN0IsSUFBSTt3QkFDQSxNQUFNLEdBQUcsTUFBTSxTQUFTLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsQ0FBQyxDQUFDO3FCQUN0RTtvQkFBQyxXQUFNLEdBQUc7b0JBQ1gsSUFBSSxNQUFNLElBQUksTUFBTSxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUU7d0JBQ3RDLGdCQUFnQixHQUFHLElBQUksQ0FBQztxQkFDM0I7aUJBQ0o7Z0JBRUQsSUFBSSxDQUFDLGtCQUFrQixJQUFJLENBQUMsZ0JBQWdCLElBQUksT0FBTyxJQUFJLEtBQUssV0FBVyxFQUFFO29CQUt6RSxJQUFJLGVBQWUsR0FBRyxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQztvQkFFekQsSUFBSSxlQUFlLEVBQUU7d0JBQ2pCLGVBQWUsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUF1QixFQUFFLEVBQUU7NEJBQzVELEtBQUssQ0FBQyxPQUFPLEdBQUcsQ0FBQyxhQUFhLENBQUM7d0JBQ25DLENBQUMsQ0FBQyxDQUFDO3dCQUNILGlFQUFjLENBQUMsa0NBQWtDLGFBQWEscURBQXFELENBQUMsQ0FBQzt3QkFDckgsT0FBTyxJQUFJLENBQUM7cUJBQ2Y7eUJBQU07d0JBQ0gsa0VBQWUsQ0FBQyx5RkFBeUYsQ0FBQyxDQUFDO3FCQUM5RztpQkFDSjtxQkFBTTtvQkFPSCxJQUFJLGVBQWUsR0FBRyxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQztvQkFDekQsSUFBSSxlQUFlLElBQUksYUFBYSxFQUFFO3dCQUNsQyxlQUFlLENBQUMsU0FBUyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBdUIsRUFBRSxFQUFFOzRCQUk1RCxJQUFJLENBQUMsNEJBQTRCLEdBQUcsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDOzRCQUMzRCxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7d0JBQ2pCLENBQUMsQ0FBQyxDQUFDO3dCQUNILGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDckMsaUVBQWMsQ0FBQyw2RUFBNkUsQ0FBQyxDQUFDO3dCQUM5RixPQUFPLElBQUksQ0FBQztxQkFDZjt5QkFBTSxJQUFJLENBQUMsZUFBZSxJQUFJLENBQUMsYUFBYSxFQUFFO3dCQUMzQyxJQUFJLGNBQWMsR0FBRyxNQUFNLFNBQVMsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyw0QkFBNEIsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQzt3QkFDM0gsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxDQUFDO3dCQUMvQyxpRUFBYyxDQUFDLDZFQUE2RSxDQUFDLENBQUM7d0JBQzlGLE9BQU8sSUFBSSxDQUFDO3FCQUNmO3lCQUFNLElBQUksZUFBZSxJQUFJLENBQUMsYUFBYSxFQUFFO3dCQUMxQyxlQUFlLENBQUMsU0FBUyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBdUIsRUFBRSxFQUFFOzRCQUM1RCxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQzt3QkFDekIsQ0FBQyxDQUFDLENBQUM7d0JBQ0gsaUVBQWMsQ0FBQyx5SEFBeUgsQ0FBQyxDQUFDO3dCQUMxSSxPQUFPLElBQUksQ0FBQztxQkFDZjt5QkFBTTt3QkFDSCxrRUFBZSxDQUFDLHlGQUF5RixDQUFDLENBQUM7cUJBQzlHO2lCQUNKO2FBQ0o7aUJBQU07Z0JBQ0gsa0VBQWUsQ0FBQyx3R0FBd0csQ0FBQyxDQUFDO2dCQUMxSCxPQUFPLEtBQUssQ0FBQzthQUNoQjtRQUNMLENBQUM7S0FBQTtJQU9ELHlCQUF5QjtRQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNwQixPQUFPLElBQUksQ0FBQztTQUNmO1FBRUQsSUFBSSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFFL0QsSUFBSSxDQUFDLGdCQUFnQixFQUFFO1lBQ25CLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFFRCxPQUFPLGdCQUFnQixDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQzdDLENBQUM7SUFPRCw4QkFBOEIsQ0FBQyxLQUEyQjtRQUN0RCxJQUFJLElBQUksQ0FBQywyQkFBMkIsS0FBSyxLQUFLLEVBQUU7WUFDNUMsSUFBSSxDQUFDLDJCQUEyQixHQUFHLEtBQUssQ0FBQztZQUN6QyxJQUFJLElBQUksQ0FBQyx3QkFBd0IsRUFBRTtnQkFDL0IsSUFBSSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO2FBQ25FO1lBQ0QsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxDQUFDO1NBQ2hDO0lBQ0wsQ0FBQztJQUtELDZCQUE2QjtRQUN6QixPQUFPLElBQUksQ0FBQywyQkFBMkIsQ0FBQztJQUM1QyxDQUFDO0lBTUssMkJBQTJCLENBQUMsS0FBVTs7WUFDeEMsaUVBQWMsQ0FBQywrQkFBK0IsS0FBSyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUM7WUFDL0QsUUFBUSxLQUFLLENBQUMsS0FBSyxFQUFFO2dCQUNqQixLQUFLLDZGQUErQjtvQkFDaEMsSUFBSSxDQUFDLDhCQUE4QixDQUFDLCtFQUFnQyxDQUFDLENBQUM7b0JBQ3RFLElBQUk7d0JBQ0EsTUFBTSxJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztxQkFDekM7b0JBQUMsT0FBTyxZQUFZLEVBQUU7d0JBQ25CLGlFQUFjLENBQUMsbUVBQW1FLFlBQVksRUFBRSxDQUFDLENBQUM7cUJBQ3JHO29CQUNELE1BQU07YUFDYjtRQUNMLENBQUM7S0FBQTtJQU1LLHlCQUF5QixDQUFDLEtBQVU7O1lBQ3RDLGlFQUFjLENBQUMsNkJBQTZCLEtBQUssQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDO1lBQzdELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUM3QixRQUFRLEtBQUssQ0FBQyxLQUFLLEVBQUU7Z0JBQ2pCLEtBQUssNkVBQTJCO29CQUM1QixJQUFJLENBQUMsNkJBQTZCLEdBQUcsRUFBRSxDQUFDO29CQUN4QyxJQUFJLENBQUMsOEJBQThCLENBQUMsNkVBQThCLENBQUMsQ0FBQztvQkFDcEUsTUFBTTtnQkFDVixLQUFLLGdGQUE4QjtvQkFDL0IsSUFBSSxJQUFJLENBQUMsMkJBQTJCLEtBQUssK0VBQWdDLEVBQUU7d0JBQ3ZFLE1BQU07cUJBQ1Q7b0JBQ0QsSUFBSSxDQUFDLDhCQUE4QixDQUFDLGdGQUFpQyxDQUFDLENBQUM7b0JBQ3ZFLElBQUk7d0JBQ0EsTUFBTSxJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztxQkFDekM7b0JBQUMsT0FBTyxZQUFZLEVBQUU7d0JBQ25CLGlFQUFjLENBQUMsbUVBQW1FLFlBQVksRUFBRSxDQUFDLENBQUM7cUJBQ3JHO29CQUNELE1BQU07Z0JBQ1YsS0FBSywwRUFBd0I7b0JBQ3pCLElBQUksSUFBSSxDQUFDLDJCQUEyQixLQUFLLCtFQUFnQyxFQUFFO3dCQUN2RSxNQUFNO3FCQUNUO29CQUNELElBQUksQ0FBQyw4QkFBOEIsQ0FBQywwRUFBMkIsQ0FBQyxDQUFDO29CQUNqRSxNQUFNO2dCQUNWLEtBQUssMEVBQXdCO29CQUd6QixJQUFJLElBQUksQ0FBQywyQkFBMkIsS0FBSywrRUFBZ0MsRUFBRTt3QkFDdkUsTUFBTTtxQkFDVDtvQkFDRCxJQUFJLENBQUMsOEJBQThCLENBQUMsZ0ZBQWlDLENBQUMsQ0FBQztvQkFDdkUsTUFBTTthQUNiO1FBQ0wsQ0FBQztLQUFBO0lBRUQsMEJBQTBCLENBQUMsUUFBa0I7UUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDcEIsbUVBQWdCLENBQUMsOERBQThELENBQUMsQ0FBQztZQUNqRixPQUFPO1NBQ1Y7UUFFRCxJQUFJLElBQUksQ0FBQyxzQkFBc0IsRUFBRTtZQUM3QixJQUFJLENBQUMseUJBQXlCLEVBQUUsQ0FBQztTQUNwQztRQUVELElBQUksQ0FBQyxzQkFBc0IsR0FBRyxRQUFRLENBQUM7UUFFdkMsSUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBRUQseUJBQXlCO1FBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3BCLG1FQUFnQixDQUFDLDZEQUE2RCxDQUFDLENBQUM7WUFDaEYsT0FBTztTQUNWO1FBRUQsSUFBSSxDQUFDLFlBQVksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQztRQUVuRSxJQUFJLENBQUMsc0JBQXNCLEdBQUcsU0FBUyxDQUFDO0lBQzVDLENBQUM7SUFPRCxpQ0FBaUMsQ0FBQyx1QkFBeUMsRUFBRSx3QkFBMkM7UUFDcEgsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3BELE9BQU87Z0JBQ0gsT0FBTyxFQUFFLEtBQUs7Z0JBQ2QsS0FBSyxFQUFFLHVEQUF1RDthQUNqRSxDQUFDO1NBQ0w7UUFFRCxJQUFJLFlBQVksR0FBUSxFQUFFLENBQUM7UUFHM0IsSUFBSSx1QkFBdUIsQ0FBQyxRQUFRLElBQUksQ0FBQyxPQUFPLENBQUMsdUJBQXVCLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVEsQ0FBQztlQUMzRixDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxDQUFDO2VBQzFELENBQUMsT0FBTyxDQUFDLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLENBQUMsRUFBRTtZQUUvRCxJQUFJLGlCQUFpQixHQUE2RCxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQztZQUNuSSxJQUFJLHdCQUF3QixJQUFJLHdCQUF3QixDQUFDLFFBQVEsRUFBRTtnQkFDL0QsSUFBSSx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLHdCQUF3QixDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUU7b0JBQzVFLGlCQUFpQixDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7b0JBQzNCLGlCQUFpQixDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7aUJBQ3BDO2dCQUNELElBQUksdUJBQXVCLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFO29CQUM1RSxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO29CQUMzQixpQkFBaUIsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO2lCQUNwQztnQkFDRCxJQUFJLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssd0JBQXdCLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRTtvQkFDNUUsaUJBQWlCLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztvQkFDM0IsaUJBQWlCLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztpQkFDcEM7YUFDSjtpQkFBTTtnQkFDSCxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO2dCQUMzQixpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO2dCQUMzQixpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO2dCQUMzQixpQkFBaUIsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO2FBQ3BDO1lBR0QsSUFBSSxpQkFBaUIsQ0FBQyxPQUFPLEVBQUU7Z0JBQzNCLElBQUksa0JBQWtCLEdBQUcsa0dBQThDLENBQUMsNEVBQXdCLEVBQUUsdUJBQXVCLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBR3BJLElBQUksaUJBQWlCLENBQUMsQ0FBQyxFQUFFO29CQUNyQixZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7aUJBQy9EO2dCQUNELElBQUksaUJBQWlCLENBQUMsQ0FBQyxFQUFFO29CQUNyQixZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7aUJBQy9EO2dCQUNELElBQUksaUJBQWlCLENBQUMsQ0FBQyxFQUFFO29CQUNyQixZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7aUJBQy9EO2FBQ0o7U0FDSjtRQUdELElBQUksdUJBQXVCLENBQUMsZUFBZSxJQUFJLENBQUMsT0FBTyxDQUFDLHVCQUF1QixDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLENBQUM7ZUFDekcsQ0FBQyxPQUFPLENBQUMsdUJBQXVCLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVEsQ0FBQztlQUNqRSxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxDQUFDO2VBQ2pFLENBQUMsT0FBTyxDQUFDLHVCQUF1QixDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLENBQUMsRUFBRTtZQUV0RSxJQUFJLGlCQUFpQixHQUF5RSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFDO1lBQ3pKLElBQUksd0JBQXdCLElBQUksd0JBQXdCLENBQUMsZUFBZSxFQUFFO2dCQUN0RSxJQUFJLHVCQUF1QixDQUFDLGVBQWUsQ0FBQyxDQUFDLEtBQUssd0JBQXdCLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRTtvQkFDMUYsaUJBQWlCLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztvQkFDM0IsaUJBQWlCLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztpQkFDcEM7Z0JBQ0QsSUFBSSx1QkFBdUIsQ0FBQyxlQUFlLENBQUMsQ0FBQyxLQUFLLHdCQUF3QixDQUFDLGVBQWUsQ0FBQyxDQUFDLEVBQUU7b0JBQzFGLGlCQUFpQixDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7b0JBQzNCLGlCQUFpQixDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7aUJBQ3BDO2dCQUNELElBQUksdUJBQXVCLENBQUMsZUFBZSxDQUFDLENBQUMsS0FBSyx3QkFBd0IsQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUFFO29CQUMxRixpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO29CQUMzQixpQkFBaUIsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO2lCQUNwQztnQkFDRCxJQUFJLHVCQUF1QixDQUFDLGVBQWUsQ0FBQyxDQUFDLEtBQUssd0JBQXdCLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRTtvQkFDMUYsaUJBQWlCLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztvQkFDM0IsaUJBQWlCLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztpQkFDcEM7YUFDSjtpQkFBTTtnQkFDSCxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO2dCQUMzQixpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO2dCQUMzQixpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO2dCQUMzQixpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO2dCQUMzQixpQkFBaUIsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO2FBQ3BDO1lBR0QsSUFBSSxpQkFBaUIsQ0FBQyxPQUFPLEVBQUU7Z0JBRTNCLElBQUkscUJBQXFCLEdBQUcsNEdBQXdELENBQUMsNEVBQXdCLEVBQUUsdUJBQXVCLENBQUMsZUFBZSxDQUFDLENBQUM7Z0JBRXhKLElBQUksaUJBQWlCLENBQUMsQ0FBQyxFQUFFO29CQUNyQixZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcscUJBQXFCLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztpQkFDdEQ7Z0JBQ0QsSUFBSSxpQkFBaUIsQ0FBQyxDQUFDLEVBQUU7b0JBQ3JCLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxxQkFBcUIsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO2lCQUN0RDtnQkFDRCxJQUFJLGlCQUFpQixDQUFDLENBQUMsRUFBRTtvQkFDckIsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLHFCQUFxQixDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7aUJBQ3REO2dCQUdELFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxxQkFBcUIsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO2FBRXREO1NBQ0o7UUFFRCxJQUFJLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxlQUFlLENBQUMsS0FBSyxRQUFRLEVBQUU7WUFDL0QsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLHVCQUF1QixDQUFDLGVBQWUsQ0FBQztTQUMvRDtRQUVELElBQUksT0FBTyxDQUFDLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxLQUFLLFFBQVEsRUFBRTtZQUN4RCxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsdUJBQXVCLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDckU7UUFFRCxJQUFJLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxlQUFlLENBQUMsS0FBSyxRQUFRLEVBQUU7WUFDL0QsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLHVCQUF1QixDQUFDLGVBQWUsQ0FBQztTQUMvRDtRQUVELElBQUksT0FBTyxDQUFDLHVCQUF1QixDQUFDLFdBQVcsQ0FBQyxLQUFLLFFBQVEsRUFBRTtZQUMzRCxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsdUJBQXVCLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDeEU7UUFFRCxJQUFJLE9BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLFFBQVEsRUFBRTtZQUNqRSxJQUFJLGdCQUFnQixHQUFxQixFQUFFLENBQUM7WUFDNUMsSUFBSSxTQUFTLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1lBQzVFLElBQUksc0JBQXNCLEdBQUcsd0JBQXdCLENBQUMsQ0FBQyxDQUFDLHdCQUF3QixDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7WUFDakgsS0FBSyxNQUFNLFFBQVEsSUFBSSxTQUFTLEVBQUU7Z0JBQzlCLElBQUksYUFBYSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDaEMsSUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN2QixJQUFJLENBQUMsQ0FBQyxPQUFNLENBQUMsSUFBSSxDQUFDLElBQUksUUFBUSxDQUFDLEVBQUU7b0JBQzdCLFNBQVM7aUJBQ1o7Z0JBQ0QsSUFBSSxzQkFBc0IsSUFBSSxzQkFBc0IsQ0FBQyxhQUFhLENBQUMsS0FBSyxJQUFJLEVBQUU7b0JBQzFFLFNBQVM7aUJBQ1o7Z0JBQ0QsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLEdBQUcsSUFBSSxDQUFDO2FBQzFDO1lBRUQsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUMsTUFBTSxFQUFFO2dCQUN6QyxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsZ0JBQWdCLENBQUM7YUFDeEM7U0FDSjtRQUVELElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBRXhDLE9BQU87Z0JBQ0gsT0FBTyxFQUFFLElBQUk7Z0JBQ2IsdUJBQXVCLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUM7YUFDOUMsQ0FBQztTQUNMO2FBQU07WUFDSCxJQUFJLGlCQUFpQixHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztZQUVqRSxJQUFJLGlCQUFpQixFQUFFO2dCQUNuQixJQUFJLHVCQUF1QixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQzNELGlCQUFpQixDQUFDLFNBQVMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO2dCQUNyRCxPQUFPO29CQUNILE9BQU8sRUFBRSxJQUFJO29CQUNiLHVCQUF1QixFQUFFLHVCQUF1QjtpQkFDbkQsQ0FBQzthQUNMO2lCQUFNO2dCQUNILE9BQU87b0JBQ0gsT0FBTyxFQUFFLEtBQUs7b0JBQ2QsS0FBSyxFQUFFLDBEQUEwRDtpQkFDcEUsQ0FBQzthQUNMO1NBQ0o7SUFDTCxDQUFDO0lBS08sZUFBZTtRQUNuQixJQUFJLENBQUMsU0FBUyxHQUFHO1lBQ2IsV0FBVyxFQUFFLEtBQUs7U0FDckIsQ0FBQztJQUNOLENBQUM7Q0FDSjs7Ozs7Ozs7Ozs7Ozs7OztBQzVtQ0QsSUFBWSx1Q0FNWDtBQU5ELFdBQVksdUNBQXVDO0lBQy9DLGdFQUFxQjtJQUNyQixtRkFBd0M7SUFDeEMsdUZBQTRDO0lBQzVDLCtFQUFvQztJQUNwQyxnRUFBcUI7QUFDekIsQ0FBQyxFQU5XLHVDQUF1QyxLQUF2Qyx1Q0FBdUMsUUFNbEQ7QUFNTSxNQUFNLG9CQUFvQjtJQWdCN0IsWUFBWSxFQUFFLGNBQWMsR0FBRyxJQUFJLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBK0c7UUFDcEssSUFBSSxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7UUFDckMsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7UUFDN0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDN0IsQ0FBQztDQUNKOzs7Ozs7Ozs7Ozs7Ozs7QUNuQ00sTUFBTSxhQUFhO0lBb0J0QixnQkFBZSxDQUFDOztBQWZULGdEQUFrQyxHQUFXLEVBQUUsQ0FBQztBQUtoRCxvREFBc0MsR0FBVyxFQUFFLENBQUM7QUFJcEQsaURBQW1DLEdBQVcsc0JBQXNCLENBQUM7QUFJckUsNkNBQStCLEdBQVcsR0FBRyxDQUFDO0FBR3hELENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QnlFO0FBRTNFLE1BQU0sU0FBUyxHQUFHLE9BQU8sTUFBTSxLQUFLLFdBQVcsQ0FBQztBQUNoRCxNQUFNLElBQUksR0FBRyxDQUFDLENBQUssRUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDO0FBQ3RDLE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBQyxDQUFDO0FBQ3BHLE1BQU0saUJBQWlCLEdBQU8sU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUN6RSxNQUFNLG9CQUFvQixHQUFPLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDL0UsTUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFDLGVBQWUsRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLG1CQUFtQixFQUFFLElBQUksRUFBQyxDQUFDO0FBQzNILE1BQU0sVUFBVSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxVQUFXLE9BQU8sQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFVLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxFQUFDLENBQUM7QUFDbEosSUFBSSxNQUFNLEdBQUcsU0FBUyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUM7QUFDdkMsSUFBSSxDQUFDLFNBQVMsRUFBRTtJQUNaLElBQUk7UUFDQSxNQUFNLEdBQUcsbUJBQU8sQ0FBQyx3REFBWSxDQUFDLENBQUM7S0FDbEM7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNSLENBQUM7S0FDSjtDQUNKO0FBRUQsTUFBTSxZQUFZLEdBQUcsZUFBZSxDQUFDO0FBRXJDLDBFQUF3QixDQUFDLG9CQUFvQixFQUNwQiwwRUFBd0IsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLGFBQWEsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2SCwwRUFBd0IsQ0FBQyxhQUFhLEVBQ2IsMEVBQXdCLENBQUMsYUFBYSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsYUFBYSxFQUFFLGlCQUFpQixFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2SCwwRUFBd0IsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxNQUFNLEVBQUUsMEJBQTBCLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQztBQUU5RiwwRUFBd0IsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLFVBQVUsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLGtCQUFrQixFQUFFLG1CQUFtQixDQUFDLENBQUMsQ0FBQztBQUN4SCwwRUFBd0IsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLGVBQWUsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO0FBQ25HLDBFQUF3QixDQUFDLGlCQUFpQixFQUFFLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsZUFBZSxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7QUFRbEcsSUFBSSxhQUFhLEdBQUcsQ0FBQyxDQUFDO0FBQ3RCLElBQUksWUFBWSxHQUFvQixFQUFFLENBQUM7QUFDdkMsSUFBSSxXQUFXLEdBQW9CLEVBQUUsQ0FBQztBQUN0QyxJQUFJLE9BQVcsQ0FBQztBQUNoQixNQUFNLGdCQUFnQixHQUFHLEtBQUssQ0FBQztBQVV4QixNQUFNLFdBQVc7SUFhcEIsWUFBWSxFQUFDLEdBQUcsR0FBRyw0REFBNEQsRUFDbEUsS0FBSyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxHQUFHLEVBQUUsRUFBZ0c7UUFDMUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFDLENBQUMsQ0FBQztRQUN6RCxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdEIsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLFlBQVksR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDdEMsSUFBSSxDQUFDLGNBQWMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDdEQsQ0FBQztJQUlELEtBQUssQ0FBQyxVQUFpQjtRQUNuQixJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFBRSxPQUFPO1FBQzVCLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN4QixXQUFXLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNyQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFFLFNBQWlCLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ2hHLENBQUM7SUFJSyxJQUFJOztZQUNOLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUFFLE9BQU87WUFDN0IsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3JDLElBQUksQ0FBRSxPQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQUU7Z0JBQ25DLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDOUI7WUFDRCxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDYixDQUFDO0tBQUE7SUFDTCw0QkFBNEI7UUFDeEIsSUFBSSxDQUFDLHdCQUF3QixHQUFHLElBQUksQ0FBQztJQUN6QyxDQUFDO0lBT0QsS0FBSztRQUNELFdBQVcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxVQUFVLEdBQUcsWUFBWSxDQUFDO1FBQy9CLElBQUksQ0FBQyx3QkFBd0IsR0FBRyxLQUFLLENBQUM7UUFDdEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQztRQUUvQixJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFFLFNBQWlCLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBQy9GLE9BQU8sR0FBRztZQUNOLGNBQWMsRUFBRSxFQUFFO1lBQ2xCLGFBQWEsRUFBRSxFQUFFO1lBQ2pCLG9CQUFvQixFQUFFLEVBQUU7U0FDM0I7SUFDTCxDQUFDO0lBQ0QsUUFBUTtRQUNKLE9BQU8sSUFBSSxDQUFDLFVBQVUsS0FBSyxZQUFZLENBQUM7SUFDNUMsQ0FBQztJQUtELFFBQVE7UUFDSixPQUFPLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUUsSUFBSSxJQUFJLENBQUMsVUFBVSwwQkFBMEI7WUFDM0UsSUFBSSxDQUFDLGVBQWUsQ0FBQyxjQUFjLENBQUM7WUFDcEMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUM7WUFDbEMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNmLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDaEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDO1lBQ3ZELElBQUksQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsNkJBQTZCLEVBQUUsRUFBRSxJQUFJLENBQUM7WUFDdEUsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUN6QyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUNsRCxJQUFJLENBQUMsQ0FBQyxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsd0JBQXdCLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ3JFLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDckIsSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUNyQixDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUM5QixLQUFLLFVBQVUsQ0FBQyxTQUFTLEdBQUcsQ0FBQztJQUNyQyxDQUFDO0lBQ0QsQ0FBQyxDQUFDLElBQVcsRUFBRSxLQUFTLEVBQUUsV0FBVyxHQUFHLEVBQUU7UUFDdEMsSUFBSSxTQUFTLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUN6QyxPQUFPLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxHQUFHLFNBQVMsR0FBRyxLQUFLLEVBQUUsQ0FBQztJQUM3RixDQUFDO0lBQ0QsY0FBYztRQUNWLE1BQU0sSUFBSSxHQUFRLFVBQWtCLENBQUMsVUFBVSxJQUFLLFVBQWtCLENBQUMsYUFBYSxJQUFLLFVBQWtCLENBQUMsZ0JBQWdCLElBQUksRUFBRSxDQUFDO1FBQ25JLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7WUFDcEMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQztZQUNwQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDO1lBQzNCLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBQ0QsY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsU0FBUyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFNRCxnQkFBZ0I7UUFDWixJQUFJLElBQUksR0FBTyxJQUFJLENBQUMsSUFBSSxFQUNwQixPQUFPLEdBQU8sSUFBSSxDQUFDLG1CQUFtQixFQUN0QyxTQUFTLEdBQU8sT0FBTyxDQUFDLG9CQUFvQixDQUFDLHdCQUF3QixDQUFDO1FBQzFFLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDLFVBQVUsQ0FBQztRQUN0QyxJQUFJLENBQUMsR0FBRyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUM7SUFDdEMsQ0FBQztJQUNELFNBQVM7UUFHTCxJQUFJLFNBQVMsR0FBTyxFQUFFLEVBQ2xCLFNBQVMsR0FBRyxDQUFDLFFBQWUsRUFBRSxTQUFhLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUNuRCxJQUFJO2dCQUNBLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDMUM7WUFBQyxPQUFPLENBQUMsRUFBRTtnQkFDUixTQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQzthQUNoQztRQUNMLENBQUMsQ0FBQztRQUNOLFNBQVMsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3hDLENBQUMsaUJBQWlCLEVBQUUsZ0JBQWdCLEVBQUUsbUJBQW1CLEVBQUMsbUJBQW1CLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxRyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDO1lBQ2xELElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxlQUFlLENBQUM7WUFDeEMsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsU0FBUyxDQUFDLGNBQWMsQ0FBQztZQUM3QyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsa0JBQWtCLENBQUM7WUFDM0MsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsU0FBUyxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDekQsQ0FBQztJQUNELGVBQWUsQ0FBQyxJQUFXO1FBQ3ZCLElBQUksTUFBTSxHQUFHLElBQUksS0FBSyxjQUFjLENBQUMsQ0FBQyxDQUFFLFlBQVksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDO1FBQ25FLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFLElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUM7WUFDdkQsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxhQUFhLENBQUM7WUFDekMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBQ0QsUUFBUTtRQUNKLElBQUksQ0FBQyxHQUFVLEVBQUUsQ0FBQztRQUNsQixNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUN0QyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQzVCLEtBQUssR0FBRyxJQUFJLENBQUM7WUFDakIsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEVBQUU7Z0JBQ3ZDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxJQUFJLFlBQVksRUFBRSxFQUFFLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ3RGLEtBQUssR0FBRyxLQUFLLENBQUM7WUFDbEIsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sQ0FBQyxDQUFDO0lBQ2IsQ0FBQztJQU1ELE1BQU0sQ0FBQyxZQUFtQjtRQUN0QixJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU07WUFBRSxPQUFPLEtBQUssQ0FBQztRQUNyQyxJQUFJLENBQUMsTUFBTTtZQUFFLE9BQU8sS0FBSyxDQUFDO1FBTTFCLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDcEIsTUFBTSxFQUFFLE1BQU07WUFDZCxPQUFPLEVBQUUsRUFBRSxjQUFjLEVBQUUsWUFBWSxFQUFFO1lBQ3pDLElBQUksRUFBRSxZQUFZO1NBQ3JCLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFpQixFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBSUQsT0FBTyxDQUFDLFlBQW1CO1FBQ3ZCLElBQUksUUFBUSxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUtsRCxJQUFJLFFBQVE7WUFBRSxRQUFRLElBQUksSUFBSSxDQUFDO1FBQy9CLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLEdBQUcsWUFBWSxDQUFDLENBQUM7UUFFdEQsaUJBQWlCLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBSUssY0FBYzs7WUFDaEIsb0JBQW9CLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUNwRCxJQUFJLFFBQVEsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM1QyxJQUFJLENBQUMsUUFBUTtnQkFBRSxPQUFPO1lBQ3RCLElBQUksQ0FBRSxPQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO2dCQUFFLE9BQU87WUFDMUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEMsQ0FBQztLQUFBO0lBSUQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUF3QjtRQUN0QyxJQUFJLGFBQWEsRUFBRSxHQUFHLENBQUM7WUFBRSxPQUFPO1FBQ2hDLE9BQU8sQ0FBQywwQkFBMEIsQ0FBQyxDQUFDLElBQVEsRUFBRSxRQUFZLEVBQUUsRUFBRTtZQUMxRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBVSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFDekUsV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFVLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssUUFBUSxDQUFDLGdCQUFnQixDQUFDLEVBQ2hGLFlBQVksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBVSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxLQUFLLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1lBQ3ZGLElBQUksV0FBVztnQkFBRyxZQUFZLEdBQUcsV0FBVyxDQUFDO1lBQzdDLElBQUksWUFBWTtnQkFBRSxXQUFXLEdBQUcsWUFBWSxDQUFDO1lBQzdDLFNBQVMsSUFBSSxDQUFDLElBQVcsRUFBRSxlQUE2QixFQUFFLHFCQUFtQyxFQUFFO2dCQUMzRixTQUFTLFVBQVUsQ0FBQyxJQUFRO29CQUN4QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFVLEVBQUUsRUFBRTt3QkFDNUIsT0FBTyxNQUFNLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQztvQkFDL0IsQ0FBQyxDQUFDLENBQUM7Z0JBQ1AsQ0FBQztnQkFDRCxJQUFJLGNBQWMsR0FBRyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQ3JDLFVBQVUsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ2xDLGVBQWUsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDO29CQUNuQyxVQUFVLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNoSCxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDO29CQUNuQyxVQUFVLElBQUksVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDbkUsQ0FBQztZQUNELElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQywwQkFBMEIsRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ2xFLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDcEUsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxlQUFlLEVBQUUsb0JBQW9CLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNuRyxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFDRCxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQXdCO1FBQ3JDLElBQUksQ0FBQyxhQUFhO1lBQUUsT0FBTztRQUMzQixJQUFJLEVBQUUsYUFBYSxHQUFHLENBQUM7WUFBRSxPQUFPO1FBQ2hDLE9BQU8sQ0FBQyx5QkFBeUIsRUFBRSxDQUFDO1FBQ3BDLFlBQVksR0FBRyxXQUFXLEdBQUcsRUFBRSxDQUFDO0lBQ3BDLENBQUM7Q0FDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyUnlEO0FBQ2pDO0FBQ3pCLElBQUksZ0JBQWdCLEdBQUcsT0FBTyxJQUFJLEtBQUssV0FBVyxDQUFDO0FBQ25ELElBQUksZ0JBQWdCLEVBQUU7SUFDbEIsNkZBQXVDLEVBQUUsQ0FBQztDQUM3QztBQUNELElBQUksVUFBVSxHQUFHLEtBQXNDLENBQUMsQ0FBQyxDQUFDLFVBQWdCLENBQUMsQ0FBQyxDQUFDLENBQVMsQ0FBQztBQUMvQztBQUNsQjtBQVV5SjtBQUM5RDtBQUVFO0FBQ2pEO0FBQ1I7QUFDd0M7QUFHbEcsSUFBSSx1QkFBdUIsR0FBRywyRkFBcUMsQ0FBQztBQUNqQztBQUNuQyxJQUFJLGVBQWUsR0FBRyxtRkFBNkIsQ0FBQztBQUN6QjtBQUtxSjtBQUNoRDtBQUN4QztBQUNqQjtBQUNBO0FBQ3NFOzs7Ozs7Ozs7Ozs7Ozs7O0FDM0NyRztBQU14QyxNQUFNLG1CQUFtQixHQUFHLFNBQVMsQ0FBQztBQU10QyxNQUFNLHdCQUF3QixHQUFHLEVBQUUsQ0FBQztBQUVwQyxJQUFLLGVBcUdKO0FBckdELFdBQUssZUFBZTtJQUNsQixtRUFBaUI7SUFDakIsMkRBQWE7SUFDYix5REFBWTtJQUNaLHVEQUFXO0lBQ1gsMkRBQWE7SUFDYiw2REFBYztJQUNkLHFFQUFrQjtJQUVsQiwrREFBZTtJQUNmLGlFQUFnQjtJQUNoQix1REFBVztJQUNYLDBEQUFhO0lBQ2Isd0RBQVk7SUFFWiw4REFBZTtJQUNmLHdEQUFZO0lBQ1osZ0VBQWdCO0lBQ2hCLHdEQUFZO0lBRVosb0RBQVU7SUFDVixvRUFBa0I7SUFDbEIsc0VBQW1CO0lBQ25CLGdFQUFnQjtJQUVoQixnRUFBZ0I7SUFDaEIsd0RBQVk7SUFDWix3REFBWTtJQUVaLDBEQUFhO0lBQ2IsMERBQWE7SUFDYiwwREFBYTtJQUNiLDBEQUFhO0lBQ2IsMERBQWE7SUFDYiwwREFBYTtJQUNiLDBEQUFhO0lBQ2IsMERBQWE7SUFDYiwwREFBYTtJQUNiLDBEQUFhO0lBRWIsZ0VBQWdCO0lBRWhCLDBEQUFhO0lBRWIsZ0VBQWdCO0lBQ2hCLGtFQUFpQjtJQUNqQixnRUFBZ0I7SUFDaEIsNERBQWM7SUFDZCw4REFBZTtJQUNmLDBEQUFhO0lBQ2Isb0RBQVU7SUFDVixzREFBVztJQUNYLDBEQUFhO0lBQ2IsMERBQWE7SUFFYiw0REFBYztJQUNkLDREQUFjO0lBQ2QsNERBQWM7SUFDZCw0REFBYztJQUNkLDREQUFjO0lBQ2QsNERBQWM7SUFDZCw0REFBYztJQUNkLDREQUFjO0lBQ2QsNERBQWM7SUFDZCw0REFBYztJQUVkLHdFQUFvQjtJQUNwQixvRUFBa0I7SUFDbEIsZ0VBQWdCO0lBQ2hCLDBFQUFxQjtJQUNyQiw0REFBYztJQUNkLG9FQUFrQjtJQUNsQiwwRUFBcUI7SUFDckIsc0VBQW1CO0lBRW5CLHNEQUFXO0lBQ1gsc0RBQVc7SUFDWCxzREFBVztJQUNYLHNEQUFXO0lBQ1gsc0RBQVc7SUFDWCxzREFBVztJQUNYLHNEQUFXO0lBQ1gsc0RBQVc7SUFDWCxzREFBVztJQUNYLHNEQUFXO0lBQ1gsc0RBQVc7SUFDWCxzREFBVztJQUNYLHNEQUFXO0lBQ1gsc0RBQVc7SUFDWCxzREFBVztJQUNYLHNEQUFXO0lBQ1gsc0RBQVc7SUFDWCxzREFBVztJQUNYLHNEQUFXO0lBQ1gsc0RBQVc7SUFDWCxzREFBVztJQUNYLHNEQUFXO0lBQ1gsc0RBQVc7SUFDWCxzREFBVztJQUNYLHNEQUFXO0lBQ1gsc0RBQVc7QUFDYixDQUFDLEVBckdJLGVBQWUsS0FBZixlQUFlLFFBcUduQjtBQUFBLENBQUM7QUFDRixNQUFNLDJCQUEyQixHQUFHLEVBQUUsQ0FBQztBQWtCaEMsTUFBTSxxQkFBcUI7SUEwQ2hDO1FBQ0UscURBQWEsQ0FBQyxhQUFhLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztRQUV0RCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNsQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLENBQUM7UUFDbEMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQztRQUU5QixJQUFJLENBQUMsWUFBWSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxlQUFlLENBQUM7UUFHckIsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksV0FBVyxDQUFDLHdCQUF3QixHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRXZFLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUMvRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSTtRQUUvQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUMsQ0FBRSxDQUFDO1FBQ3JFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztRQUNoQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7UUFDaEMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztRQUdoQyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxXQUFXLENBQUMsMkJBQTJCLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDN0UsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUNoRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBU0QsdUJBQXVCLENBQUMsYUFBcUI7UUFDM0MsSUFBSSxDQUFDLHFCQUFxQixHQUFHLGFBQWEsQ0FBQztRQUczQyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtZQUMxQixJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztZQUM1QixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7U0FDdEI7SUFDSCxDQUFDO0lBb0NELFlBQVksQ0FBQyxPQUFlLEVBQUUsS0FBVSxFQUFFLE9BQWlCO1FBR3pELElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdEQsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNqQixZQUFZLEdBQUcsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUUsQ0FBQztZQUM1QyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztTQUNsRDtRQUVELElBQUksZUFBZSxHQUFHLElBQUksQ0FBQztRQUMzQixJQUFJLE9BQU8sRUFBRTtZQUlYLGVBQWUsR0FBRyxJQUFJLDBCQUEwQixDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDeEU7UUFDRCxZQUFZLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBRSxJQUFJLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsZUFBZSxDQUFDLENBQUUsQ0FBQztRQUlyRixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUUxQixxREFBYSxDQUFDLGdCQUFnQixHQUFHLE9BQU8sRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFzQkQsa0JBQWtCLENBQUMsT0FBb0I7UUFFckMsSUFBSSxPQUFPLEdBQUcsbUJBQW1CLENBQUM7UUFDbEMsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN0RCxJQUFJLENBQUUsWUFBWSxFQUFFO1lBQ2xCLFlBQVksR0FBRyxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRSxDQUFDO1lBQzVDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDO1NBQ2xEO1FBRUQsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUUsSUFBSSxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFFLENBQUM7UUFJekUsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFFMUIscURBQWEsQ0FBQyxzQkFBc0IsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFnQkQsaUJBQWlCLENBQUMsZUFBdUIsRUFBRSxPQUFpQixFQUFFLFFBQWlCO1FBSTdFLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDOUQsSUFBSSxDQUFFLFlBQVksRUFBRTtZQUNsQixZQUFZLEdBQUcsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUUsQ0FBQztZQUM1QyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLGVBQWUsRUFBRSxZQUFZLENBQUMsQ0FBQztTQUMxRDtRQUlELElBQUksZUFBZSxHQUFHLElBQUksMEJBQTBCLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMvRSxZQUFZLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUU5QyxDQUFDO0lBd0JELGdCQUFnQixDQUFDLE9BQWlCLEVBQUUsUUFBaUI7UUFHbkQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLG1CQUFtQixFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztJQUlqRSxDQUFDO0lBaUJELFNBQVMsQ0FBQyxVQUFlO1FBQ3ZCLElBQUksSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLEtBQUssTUFBTSxFQUFFO1lBSTFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDekM7SUFDSCxDQUFDO0lBYUQsYUFBYTtRQUNYLHFEQUFhLENBQUMsc0NBQXNDLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztRQUMvRSxJQUFJLENBQUMsaUJBQWlCLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDbEgsQ0FBQztJQVFELG9CQUFvQjtRQUNsQixxREFBYSxDQUFDLHFDQUFxQyxFQUFFLHVCQUF1QixDQUFDLENBQUM7UUFDOUUsYUFBYSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQVNELDZCQUE2QjtRQUMzQixJQUFJLElBQUksQ0FBQyxrQkFBa0IsSUFBSSxDQUFDLEVBQUU7WUFDaEMsT0FBTztTQUNSO1FBR0QsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxVQUFTLEtBQVUsRUFBRSxHQUFRLEVBQUUsR0FBUTtZQUVuRSxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFO2dCQUV2QixJQUFJLGVBQWUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUczQyxJQUFJLGVBQWUsQ0FBQyxRQUFRLEVBQUU7b0JBRTVCLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDL0M7Z0JBR0QsSUFBSyxJQUFJLENBQUMsb0JBQW9CLENBQUMsZUFBZSxDQUFDLEVBQUc7b0JBQ2hELElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO2lCQUMzQjtxQkFBTTtvQkFDTCxxREFBYSxDQUFDLDZFQUE2RSxFQUFFLHVCQUF1QixDQUFDLENBQUM7aUJBR3ZIO2FBQ0Y7UUFDSCxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDaEIsQ0FBQztJQVVELGtDQUFrQyxDQUFDLE9BQWUsRUFBRSxPQUFlO1FBQ2pFLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFDLEdBQUcsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBQyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQWNELDBDQUEwQyxDQUFDLE9BQWU7UUFDeEQsSUFBSSxjQUFjLENBQUM7UUFDbkIsSUFBSTtZQUNGLGNBQWMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ3RDO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixxREFBYSxDQUFDLDJDQUEyQyxDQUFDLDhCQUE4QixPQUFPLEVBQUUsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO1lBQzVILE9BQU87U0FDUjtRQUtELElBQUksY0FBYyxJQUFJLGNBQWMsQ0FBQyxDQUFDLElBQUksY0FBYyxDQUFDLENBQUMsRUFBRTtZQUMxRCxPQUFPLEVBQUMsU0FBUyxFQUFFLGNBQWMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLGNBQWMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztTQUNwRTtRQUNELHFEQUFhLENBQUMsd0RBQXdELEdBQUcsT0FBTyxFQUFFLHVCQUF1QixDQUFDLENBQUM7UUFFM0csT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBWUQsb0JBQW9CLENBQUMsZUFBb0M7UUFHdkQsSUFBSTtZQUNGLElBQUksT0FBTyxHQUFHLGVBQWUsQ0FBQyxRQUFRLENBQUM7WUFDdkMsSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRLEVBQUU7Z0JBQy9CLE9BQU8sR0FBRyxJQUFJLENBQUMsa0NBQWtDLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRSxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3BHLHFEQUFhLENBQUMsa0JBQWtCLEdBQUcsT0FBTyxFQUFFLHVCQUF1QixDQUFDLENBQUM7YUFDdEU7aUJBQU07Z0JBQ0wscURBQWEsQ0FBQyx3QkFBd0IsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO2FBQ2xFO1lBQ0QsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUV2QyxPQUFPLElBQUksQ0FBQztTQUNiO1FBQUMsT0FBTyxHQUFHLEVBQUU7WUFDWixxREFBYSxDQUFDLGdDQUFnQyxHQUFHLEdBQUcsQ0FBQyxPQUFPLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztZQUN2RixPQUFPLEtBQUssQ0FBQztTQUNkO0lBQ0gsQ0FBQztJQVlELHdCQUF3QixDQUFDLGlCQUFzQjtRQUU3QyxJQUFJLFVBQVUsR0FBRyxpQkFBaUIsQ0FBQyxJQUFJLENBQUM7UUFDeEMsSUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDO1FBTzFCLElBQUksVUFBVSxFQUFFO1lBQ2QsSUFBSSxPQUFPLFVBQVUsS0FBSyxRQUFRLEVBQUU7Z0JBRWxDLGNBQWMsR0FBRyxJQUFJLENBQUMsMENBQTBDLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQzdFLElBQUksQ0FBQyxtQ0FBbUMsQ0FBQyxjQUFjLENBQUMsQ0FBQzthQUMxRDtpQkFBTSxJQUFJLFVBQVUsWUFBWSxXQUFXLEVBQUM7Z0JBSzNDLGNBQWMsR0FBRyxFQUFFLFNBQVMsRUFBRyxtQkFBbUIsRUFBRSxTQUFTLEVBQUcsSUFBSSxVQUFVLENBQUMsVUFBVSxDQUFDLEVBQUMsQ0FBQztnQkFJNUYsSUFBSSxDQUFDLG1DQUFtQyxDQUFDLGNBQWMsQ0FBQyxDQUFDO2FBQzFEO2lCQUFNLElBQUksVUFBVSxZQUFZLElBQUksRUFBRTtnQkFDckMsVUFBVSxDQUFDLFdBQVcsRUFBRTtxQkFDckIsSUFBSSxDQUFDLENBQUMsb0JBQW9CLEVBQUUsRUFBRTtvQkFDN0IsY0FBYyxHQUFHLEVBQUUsU0FBUyxFQUFHLG1CQUFtQixFQUFFLFNBQVMsRUFBRyxJQUFJLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFDLENBQUM7b0JBQ3RHLElBQUksQ0FBQyxtQ0FBbUMsQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDM0QsQ0FBQyxDQUFDLENBQUM7YUFDTjtTQUNGO0lBQ0gsQ0FBQztJQUVELG1DQUFtQyxDQUFDLGNBQW1CO1FBQ3JELElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDbkIscURBQWEsQ0FBQyw4Q0FBOEMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxFQUFFLHVCQUF1QixDQUFDLENBQUM7WUFDeEgsT0FBTztTQUNSO1FBR0QsSUFBSSxvQkFBb0IsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM3RSxJQUFJLG9CQUFvQixFQUFFO1lBRXhCLElBQUksTUFBTSxHQUFHLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7WUFDbEQsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQXdCZCxJQUFJLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsdUJBQXVCLEVBQUU7b0JBSWhHLElBQUksZUFBZSxHQUFHLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztvQkFDNUQsSUFBSSxlQUFlLElBQUksZUFBZSxDQUFDLFFBQVEsRUFBRTt3QkFDL0MsZUFBZSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7d0JBQ2pELE9BQU87cUJBQ1I7eUJBQU07d0JBQ0wscURBQWEsQ0FBQyw2QkFBNkIsR0FBRyxjQUFjLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztxQkFDeEY7aUJBRUY7cUJBQU07b0JBQ0wsSUFBSSxZQUFZLEdBQUcsRUFBRSxDQUFDO29CQUN0QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO3dCQUMvQixJQUFJLFFBQVEsR0FBRyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ2hELElBQUksUUFBUSxJQUFJLFFBQVEsQ0FBQyxRQUFRLEVBQUU7NEJBRWpDLFFBQVEsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO3lCQUMzQzs2QkFBTTs0QkFDTCxxREFBYSxDQUFDLDZCQUE2QixHQUFHLGNBQWMsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO3lCQUN4Rjt3QkFFRCxJQUFJLFFBQVEsSUFBSSxRQUFRLENBQUMsU0FBUyxFQUFFOzRCQUNsQyxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO3lCQUM3QjtxQkFDRjtvQkFFRCxvQkFBb0IsQ0FBQyxRQUFRLEdBQUcsWUFBWSxDQUFDO2lCQUM5QzthQUNGO1NBRUY7SUFDSCxDQUFDO0lBWUQsb0JBQW9CLENBQUMsZ0JBQWdDO1FBQ25ELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxnQkFBZ0IsQ0FBQztRQUMxQyxxREFBYSxDQUFDLDBDQUEwQyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztRQUUvRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxHQUFHO1lBQzlCLHFEQUFhLENBQUMscUNBQXFDLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO1FBQ3BILENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFYixJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxHQUFHO1lBQy9CLHFEQUFhLENBQUMsc0NBQXNDLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO1FBQ3JILENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFYixJQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxHQUFHLFVBQVUsT0FBWTtZQUN2RCxxREFBYSxDQUFDLGlDQUFpQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLHVCQUF1QixDQUFDLENBQUM7UUFDN0YsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNmLENBQUM7SUFZRCxzQkFBc0IsQ0FBQyxrQkFBa0M7UUFDdkQsSUFBSSxDQUFDLG1CQUFtQixHQUFHLGtCQUFrQixDQUFDO1FBQzlDLHFEQUFhLENBQUMsb0NBQW9DLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEVBQUUsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO1FBRTNHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEdBQUc7WUFDaEMscURBQWEsQ0FBQyx3Q0FBd0MsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsVUFBVSxFQUFFLHVCQUF1QixDQUFDLENBQUM7WUFFdkgsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3ZCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFYixJQUFJLENBQUMsbUJBQW1CLENBQUMsT0FBTyxHQUFHO1lBQ2pDLHFEQUFhLENBQUMsd0NBQXdDLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFVBQVUsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO1lBRXZILElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1FBQzlCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFYixJQUFJLENBQUMsbUJBQW1CLENBQUMsU0FBUyxHQUFHLFVBQVUsT0FBWTtZQUN6RCxJQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDekMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNmLENBQUM7SUFRRCxjQUFjLENBQUMsa0JBQStCO1FBQzVDLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNyQixJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7WUFDckMsSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO1lBQ3RDLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztZQUN0QyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7WUFDckMsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1lBQ25DLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztTQUNsQztRQUVELElBQUksQ0FBQyxZQUFZLEdBQUcsa0JBQWtCLENBQUM7UUFFdkMsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3JCLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztZQUVoQixJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsR0FBSSxVQUFTLEtBQUssSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzlFLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztZQUN0QyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7WUFDdEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEdBQUcsVUFBUyxLQUFLLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25GLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxHQUFHLFVBQVMsS0FBSyxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0UsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEdBQUksVUFBUyxLQUFLLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMzRTtJQUNILENBQUM7SUFFRixpQkFBaUIsQ0FBQyxrQkFBK0I7UUFDOUMsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztZQUN0QyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7U0FDckM7UUFFRCxJQUFJLENBQUMsZUFBZSxHQUFHLGtCQUFrQixDQUFDO1FBRTFDLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN4QixJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7WUFFaEIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEdBQUcsVUFBUyxLQUFLLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRixJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sR0FBRyxVQUFTLEtBQUssSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQy9FO0lBQ0gsQ0FBQztJQU9ELGlCQUFpQixDQUFDLENBQWE7UUFDN0IsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFDckMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFDckMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFDckMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFFckMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFHckMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFLRCxlQUFlLENBQUMsQ0FBYTtRQUMzQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7UUFDaEMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztRQUNoQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7UUFFaEMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFHckMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFLRCxXQUFXLENBQUMsQ0FBYTtRQUV2QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQztRQUNyQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQztRQUVyQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUM7UUFDekQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDO1FBRTFELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDO1FBR3JDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBTUQsV0FBVyxDQUFDLENBQWE7UUFDdkIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDcEMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVELGVBQWU7UUFDYixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFRCxXQUFXLENBQUMsQ0FBTTtRQUNoQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEIsQ0FBQztJQUNELFdBQVcsQ0FBQyxDQUFNO1FBQ2hCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBS0QsZUFBZSxDQUFDLENBQWdCO1FBQzlCLElBQUksQ0FBQyxHQUFHLGVBQWUsQ0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEMsSUFBSSxVQUFVLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekMsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDdkQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsSUFBSSxXQUFXLENBQUM7WUFDL0MsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7U0FDN0I7SUFDSCxDQUFDO0lBS0QsYUFBYSxDQUFDLENBQWdCO1FBQzVCLElBQUksQ0FBQyxHQUFHLGVBQWUsQ0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEMsSUFBSSxVQUFVLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekMsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDdkQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsSUFBSSxXQUFXLENBQUM7WUFDL0MsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7U0FDN0I7SUFDSCxDQUFDO0lBRUQsa0JBQWtCO1FBQ2hCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7SUFDNUMsQ0FBQztDQUVGO0FBcUJELE1BQU0sbUJBQW1CO0lBZXZCLFlBQVksT0FBWSxFQUFFLEtBQVUsRUFBRSxPQUFZO1FBQ2hELHFEQUFhLENBQUMsYUFBYSxFQUFFLHFCQUFxQixDQUFDLENBQUM7UUFDcEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7UUFDeEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDcEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7SUFDMUIsQ0FBQztDQUNGO0FBd0JELE1BQU0sMEJBQTBCO0lBYzlCLFlBQVksT0FBWSxFQUFFLFFBQWlCLEVBQUUsc0JBQStCO1FBQzFFLHFEQUFhLENBQUMsYUFBYSxFQUFFLDRCQUE0QixDQUFDLENBQUM7UUFDM0QsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7UUFDeEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUM7UUFDMUIsSUFBSSxDQUFDLHVCQUF1QixHQUFHLHNCQUFzQixDQUFDO0lBQ3hELENBQUM7Q0FDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcDdCd0Y7QUFDM0I7QUFDdEI7QUFDd0I7QUFvRC9ELENBQUM7QUFVRixJQUFZLGlCQVFYO0FBUkQsV0FBWSxpQkFBaUI7SUFDM0IsZ0NBQVc7SUFDWCw0Q0FBdUI7SUFDdkIsNENBQXVCO0lBQ3ZCLDRDQUF1QjtJQUN2QixrREFBNkI7SUFDN0Isc0NBQWlCO0lBQ2pCLHNDQUFpQjtBQUNuQixDQUFDLEVBUlcsaUJBQWlCLEtBQWpCLGlCQUFpQixRQVE1QjtBQUFBLENBQUM7QUFVSyxNQUFNLFdBQVc7SUF1Q3RCO1FBRUUsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7UUFDdEMsSUFBSSxDQUFDLEtBQUssR0FBRyw0REFBb0IsRUFBRSxDQUFDO1FBR3BDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLHlFQUFxQixFQUFFLENBQUM7UUFDdEQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksdUVBQW9CLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFHM0UsSUFBSSxDQUFDLE1BQU0sR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLENBQUM7UUFNdkMsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksd0JBQXdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFHOUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDO1FBQzFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQywwQkFBMEIsQ0FBQyxRQUFRLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDaEcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLDBCQUEwQixDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUNsRyxDQUFDO0lBT0QsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNyQixDQUFDO0lBT0QsT0FBTztRQUNMLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUNwQixDQUFDO0lBa0JELHFCQUFxQixDQUFDLGFBQXVCO1FBQzNDLElBQUk7WUFDRixJQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQzdDLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNaLHFEQUFhLENBQUMsdUNBQXVDO2dCQUNuRCxHQUFHLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBQzlCLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFVRCx3QkFBd0IsQ0FBQyxhQUF1QjtRQUM5QyxJQUFJO1lBQ0YsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNoRCxPQUFPLElBQUksQ0FBQztTQUNiO1FBQUMsT0FBTyxHQUFHLEVBQUU7WUFDWixxREFBYSxDQUFDLHlDQUF5QztnQkFDckQsR0FBRyxDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUMsQ0FBQztZQUM5QixPQUFPLEtBQUssQ0FBQztTQUNkO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBUUQsb0JBQW9CO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDO0lBQ2pDLENBQUM7SUFRRCxtQkFBbUI7UUFDakIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUM7SUFDaEMsQ0FBQztJQWNELGVBQWUsQ0FBQyxFQUFDLG1CQUFtQixFQUFFLE9BQU8sR0FBRyxJQUFJLEVBQUUsTUFBTSxHQUFHLElBQUksRUFBRSxpQkFBaUIsR0FBRyxJQUFJLEVBQStJO1FBRTFPLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxpQkFBaUIsQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxpQkFBaUIsQ0FBQyxTQUFTLEVBQUU7WUFFNUYsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUNsQiwySEFBMkgsQ0FDOUgsQ0FBQztTQUNMO1FBRUQsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDO1FBSXZCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQywwQkFBMEIsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBR3pFLElBQUksQ0FBQyxlQUFlLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUNuQyxJQUFJLFlBQVksR0FBRyxtQ0FBbUMsR0FBRyxPQUFPLEdBQUcsS0FBSyxDQUFDO1lBQ3pFLHFEQUFhLENBQUMsWUFBWSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBQzNDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsRUFBRSxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUVsRixXQUFXLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUNuQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFFWixPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQ3JDLFdBQVcsQ0FBQyxZQUFZLEdBQUcsT0FBTyxDQUFDO1lBQ25DLFdBQVcsQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDO1lBR2pDLHFEQUFhLENBQUMsc0JBQXNCLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFDckQsSUFBSSxDQUFDLE1BQU0sR0FBRyxpQkFBaUIsQ0FBQyxHQUFHLENBQUM7WUFDcEMsV0FBVyxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUNuRSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFXRCxnQkFBZ0I7UUFDZCxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUM7UUFDdkIsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLGlCQUFpQixDQUFDLE1BQU07WUFBRSxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQ2hFLGlDQUFpQyxDQUNwQyxDQUFDO1FBSUYsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssRUFBRSxDQUFDO1FBQy9CLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1FBRS9DLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFDckMsV0FBVyxDQUFDLGFBQWEsR0FBRyxPQUFPLENBQUM7WUFDcEMsV0FBVyxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUM7WUFFbEMscURBQWEsQ0FBQyxzQkFBc0IsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUNyRCxXQUFXLENBQUMsbUJBQW1CLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDM0MsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBVUQsZ0JBQWdCLENBQUMsUUFBYSxFQUFFLEVBQUUsS0FBd0I7UUFDeEQsSUFBSSxZQUFZLEdBQUcsS0FBSyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxJQUFJLEtBQUssQ0FBQztRQUMxRCxRQUFPLEtBQUssRUFBRTtZQUNaLEtBQUssaUJBQWlCLENBQUMsU0FBUyxDQUFDO1lBQ2pDLEtBQUssaUJBQWlCLENBQUMsU0FBUztnQkFDOUIsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO29CQUN0QixZQUFZLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO29CQUNuQyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztpQkFDL0I7Z0JBQ0QsSUFBSSxJQUFJLENBQUMsWUFBWTtvQkFBRSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7Z0JBQzNDLElBQUksSUFBSSxDQUFDLFlBQVk7b0JBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDdkQsTUFBTTtZQUNSLEtBQUssaUJBQWlCLENBQUMsWUFBWTtnQkFJakMscURBQWEsQ0FBQyxvRkFBb0YsRUFBRSxhQUFhLENBQUMsQ0FBQztnQkFDbkgsTUFBTTtZQUNSLEtBQUssaUJBQWlCLENBQUMsTUFBTTtnQkFDM0IsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO29CQUN0QixZQUFZLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO29CQUNuQyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztpQkFDL0I7Z0JBQ0QsSUFBSSxJQUFJLENBQUMsV0FBVztvQkFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUNyRCxJQUFJLElBQUksQ0FBQyxZQUFZO29CQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBT3ZELElBQUksV0FBVyxHQUFHLElBQUksQ0FBQztnQkFDdkIsTUFBTSxVQUFVLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRTtvQkFDL0IsV0FBVyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUM3QyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ04sTUFBTTtZQUNSLEtBQUssaUJBQWlCLENBQUMsTUFBTTtnQkFDM0IsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO29CQUN0QixZQUFZLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO29CQUNuQyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztpQkFDL0I7Z0JBQ0QsSUFBSSxJQUFJLENBQUMsV0FBVztvQkFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUNyRCxJQUFJLElBQUksQ0FBQyxhQUFhO29CQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztnQkFDN0MsTUFBTTtZQUNSO2dCQUVFLHFEQUFhLENBQUMsK0NBQStDLEdBQUcsS0FBSyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1NBQ3pGO0lBQ0gsQ0FBQztJQVVELFVBQVUsQ0FBQyxLQUFVO1FBR25CLHFEQUFhLENBQUMsc0JBQXNCLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDckQscURBQWEsQ0FBQyxLQUFLLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFFcEMsSUFBSSxLQUFLLElBQUksS0FBSyxDQUFDLEtBQUssSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxPQUFPLEVBQUU7WUFDeEQscURBQWEsQ0FBQyxnREFBZ0QsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUMvRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN6RCxJQUFJLENBQUMsaUJBQWlCLENBQUMsMEJBQTBCLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDNUQ7UUFFRCxJQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTtZQUN4RCxxREFBYSxDQUFDLGdEQUFnRCxFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBQy9FLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzFEO0lBQ0gsQ0FBQztJQU9ELGdCQUFnQixDQUFDLEtBQVU7UUFDekIscURBQWEsQ0FBQyx3QkFBd0IsRUFBRSxhQUFhLENBQUMsQ0FBQztRQUN2RCxxREFBYSxDQUFDLEtBQUssRUFBRSxhQUFhLENBQUMsQ0FBQztRQUVwQyxRQUFRLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFO1lBQzNCLEtBQUssWUFBWTtnQkFDZixJQUFJLENBQUMsa0JBQWtCLENBQUMsb0JBQW9CLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUM1RCxNQUFNO1lBQ1IsS0FBSyxjQUFjO2dCQUNqQixJQUFJLENBQUMsa0JBQWtCLENBQUMsc0JBQXNCLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUM5RCxNQUFNO1lBQ1I7Z0JBQ0UscURBQWEsQ0FBQyxzQ0FBc0MsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxhQUFhLENBQUMsQ0FBQztnQkFDM0YsTUFBTTtTQUNUO0lBQ0gsQ0FBQztJQU1ELGtCQUFrQixDQUFDLFFBQWEsRUFBRSxFQUFFLEtBQXdCO1FBQzFELEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxLQUFLLENBQUM7UUFHdkIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUdwQyxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1lBQ3BCLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxLQUFLLENBQUM7WUFDdkIscURBQWEsQ0FBQyxzQkFBc0IsR0FBRyxpRUFBeUIsQ0FBQyxLQUFLLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUN4RixJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLFVBQVMsT0FBTztnQkFDaEQsSUFBSSxPQUFPLEVBQUU7b0JBQ1gsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO2lCQUNoQjtZQUNILENBQUMsQ0FBQyxDQUFDO1NBQ047SUFDSCxDQUFDO0lBZ0JELGdCQUFnQixDQUFDLFFBQWtCO1FBQ2pDLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFTRCxtQkFBbUIsQ0FBQyxRQUFrQjtRQUNwQyxPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNqRSxDQUFDO0NBRUY7QUFPTSxNQUFNLG9CQUFvQixHQUFHLElBQUksR0FBRyxDQUFDO0lBQzFDLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxlQUFlLEVBQUUsUUFBUSxDQUFDLENBQUU7SUFDL0UsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxtQkFBbUIsRUFBRSwwQkFBMEIsRUFBRSxlQUFlLENBQUMsQ0FBQztDQUMvRyxDQUFDLENBQUM7QUFjSCxNQUFNLHNCQUFzQjtJQW1CMUIsWUFBWSxvQkFBOEM7UUFDeEQscURBQWEsQ0FBQyxhQUFhLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsbUJBQW1CLEdBQUcsb0JBQW9CLENBQUM7UUFDaEQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQzVCLElBQUksQ0FBQyxPQUFPLEdBQUcsb0JBQW9CLENBQUM7UUFDcEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7UUFDbkIsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUtELElBQUk7UUFDRixJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbEIsYUFBYSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztTQUNwQjtJQUNILENBQUM7SUFlRCxXQUFXLENBQUMsUUFBa0I7UUFDNUIsSUFBSTtZQUNGLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzlCLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1lBQ3pCLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNaLHFEQUFhLENBQUMsaUNBQWlDO2dCQUM3QyxHQUFHLENBQUMsT0FBTyxFQUFFLGtCQUFrQixDQUFDLENBQUM7WUFDbkMsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQVNELGNBQWMsQ0FBQyxRQUFrQjtRQUMvQixJQUFJO1lBQ0YsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDakMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFDekIsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUFDLE9BQU8sR0FBRyxFQUFFO1lBQ1oscURBQWEsQ0FBQywyQ0FBMkM7Z0JBQ3ZELEdBQUcsQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFDOUIsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQU1ELGlCQUFpQjtRQUNmLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQztRQUV0QixJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztRQUVyQixJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRTtZQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTtnQkFDbkIsV0FBVyxDQUFDLENBQU8sT0FBWSxFQUFFLE9BQVksRUFBRSxFQUFFO29CQUMvQyxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxTQUFTLEVBQUUsQ0FBQztvQkFFekQsSUFBSSxhQUFhLEdBQU8sRUFBRSxDQUFDO29CQUMzQixJQUFJLEtBQUssRUFBRTt3QkFDVCxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBVyxFQUFFLEVBQUU7NEJBRTVCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFO2dDQUVqQyxJQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7Z0NBR25ELElBQUksY0FBYyxHQUFRLEVBQUUsQ0FBQztnQ0FDN0IsY0FBYyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtvQ0FDekIsY0FBYyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztnQ0FDdEMsQ0FBQyxDQUFDLENBQUM7Z0NBR0gsYUFBYSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQzs2QkFDcEM7d0JBQ0gsQ0FBQyxDQUFDLENBQUM7cUJBQ0o7b0JBR0QsSUFBSSxhQUFhLENBQUMsTUFBTSxFQUFFO3dCQUN4QixJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBRSxDQUFDLFFBQVEsRUFBQyxFQUFFOzRCQUNuQyxRQUFRLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzt3QkFDM0MsQ0FBQyxDQUFDLENBQUM7cUJBQ0o7b0JBR0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxhQUFhLENBQUM7Z0JBQ2xDLENBQUMsR0FBRSxRQUFRLENBQUUsQ0FBQzthQUNmO1NBQ0Y7YUFBTTtZQUVMLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtnQkFDbEIsYUFBYSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDOUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7YUFDcEI7U0FDRjtJQUNILENBQUM7Q0FFRjtBQTJCRCxJQUFJLDhCQUE4QixHQUFPLElBQUksQ0FBQztBQUM5QyxJQUFJLGtDQUFrQyxHQUFPLElBQUksQ0FBQztBQUNsRCxJQUFJLE9BQU8sSUFBSSxLQUFLLFdBQVcsRUFBRTtJQUUvQiw4QkFBOEIsR0FBRyw4SUFBaUMsQ0FBQztJQUNuRSxrQ0FBa0MsR0FBRyxrSkFBcUMsQ0FBQztDQUM1RTtLQUFNO0lBRUwsOEJBQThCLEdBQUcsaUJBQWlCLENBQUM7SUFDbkQsa0NBQWtDLEdBQUcscUJBQXFCLENBQUM7Q0FDNUQ7QUFNRCxNQUFNLG1CQUFtQixHQUFHO0lBQzFCLE1BQU0sRUFBRSxDQUFDLDhCQUE4QixDQUFDO0NBQ3pDLENBQUM7QUFDRixNQUFNLGtCQUFrQixHQUFHO0lBQ3pCLE1BQU0sRUFBRSxDQUFDLGlDQUFpQyxDQUFDO0lBQzNDLFVBQVUsRUFBRSxXQUFXO0lBQ3ZCLFlBQVksRUFBRSx1QkFBdUI7Q0FDdEMsQ0FBQztBQUNGLElBQUksb0JBQW9CLEdBQUc7SUFDekIsWUFBWSxFQUFFO1FBQ1osbUJBQW1CO1FBQ25CLGtCQUFrQjtLQUNuQjtDQUNGLENBQUM7QUFPRixNQUFNLHdCQUF3QjtJQTZCNUIsWUFBWSxXQUF3QjtRQUNsQyxxREFBYSxDQUFDLGFBQWEsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO1FBQ3pELElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwRCxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksc0JBQXNCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztRQUM1QixJQUFJLENBQUMsaUJBQWlCLEdBQUcsRUFBRSxDQUFDO0lBQzlCLENBQUM7SUFTRCxrQkFBa0I7UUFDaEIsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztRQUN0QyxNQUFNLHFCQUFxQixHQUFHLElBQUksQ0FBQztRQUduQyxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksOEJBQThCLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUMvRSxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDO1FBRzFDLElBQUksT0FBTyxHQUFHLGFBQWEsQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN6QyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBVyxFQUFFLEVBQUU7WUFDOUIsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QixDQUFDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLENBQUM7UUFDNUIsSUFBSSxDQUFDLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztRQVU1QixhQUFhLENBQUMsZ0JBQWdCLENBQUMsMEJBQTBCLEVBQUUsVUFBUyxLQUFVO1lBQzVFLElBQUksYUFBYSxDQUFDLGtCQUFrQixLQUFLLFdBQVcsSUFBSSxhQUFhLENBQUMsa0JBQWtCLElBQUksV0FBVyxFQUFFO2dCQUN2RyxxREFBYSxDQUFDLDZEQUE2RCxFQUFFLDBCQUEwQixDQUFDLENBQUM7Z0JBQ3pHLHFCQUFxQixDQUFDLG9CQUFvQixDQUFDLHdCQUF3QixDQUFDLHFCQUFxQixDQUFDLG9CQUFvQixDQUFDLENBQUM7YUFDakg7WUFDRCxXQUFXLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLGFBQWEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQzFFLENBQUMsQ0FBQyxDQUFDO1FBR0gsYUFBYSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxVQUFTLEtBQVUsSUFBSSxXQUFXLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3RyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQVMsS0FBVSxJQUFJLFdBQVcsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUlqRyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxFQUFFLFVBQVMsS0FBVSxJQUFJLHFCQUFxQixDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFJekgsYUFBYSxDQUFDLGdCQUFnQixDQUFDLG1CQUFtQixFQUFFLFVBQVMsS0FBVSxJQUFJLHFCQUFxQixDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFHbkksYUFBYSxDQUFDLGdCQUFnQixDQUFDLHNCQUFzQixFQUFFLFVBQVMsS0FBVSxJQUFJLHFCQUFxQixDQUFDLDBCQUEwQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFNUksQ0FBQztJQVFELDBCQUEwQixDQUFDLG1CQUE0QztRQUNyRSxJQUFJLENBQUMsb0JBQW9CLEdBQUcsbUJBQW1CLENBQUM7SUFDbEQsQ0FBQztJQVVELG9CQUFvQixDQUFDLE1BQW1CO1FBQ3RDLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7UUFDMUMsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLENBQUM7UUFDbkMsSUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBRW5CLElBQUksTUFBTSxFQUFFO1lBQ1YsSUFBSSxDQUFDLGlCQUFpQixHQUFHLE1BQU0sQ0FBQztZQUNoQyxJQUFJLENBQUUsYUFBYSxFQUFFO2dCQUNuQixxREFBYSxDQUFDLHdGQUF3RixFQUFFLDBCQUEwQixDQUFDLENBQUM7Z0JBQ3BJLE9BQU8sSUFBSSxDQUFDO2FBQ2I7WUFNRCxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUM7WUFHOUMsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQy9DLE1BQU0sWUFBWSxHQUFHLGNBQWMsQ0FBQyxNQUFNLENBQUM7WUFFM0MsSUFBSSxDQUFDLEdBQUMsQ0FBQyxDQUFDO1lBQ1IsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBTXRDLElBQUksQ0FBQyxHQUFHLFlBQVksRUFBRTtvQkFDcEIscURBQWEsQ0FBQyx5QkFBeUIsR0FBRyxDQUFDLEdBQUcsb0JBQW9CLEVBQUUsMEJBQTBCLENBQUMsQ0FBQztvQkFDaEcsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDbkQ7cUJBQU07b0JBR0wscURBQWEsQ0FBQyx3QkFBd0IsR0FBRyxDQUFDLEdBQUcsVUFBVSxFQUFFLDBCQUEwQixDQUFDLENBQUM7b0JBQ3JGLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ3RDO2FBQ0Y7WUFJRCxLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUM3QixxREFBYSxDQUFDLDRCQUE0QixHQUFHLENBQUMsR0FBRyxtQkFBbUIsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO2dCQUNsRyxjQUFjLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7YUFFeEU7U0FDRjthQUFNO1lBRUgsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDO1lBRzlDLElBQUksQ0FBQyxHQUFDLENBQUMsQ0FBQztZQUNSLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN0QyxxREFBYSxDQUFDLHdCQUF3QixHQUFHLENBQUMsR0FBRyxVQUFVLEVBQUUsMEJBQTBCLENBQUMsQ0FBQztnQkFDckYsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN0QztTQUNKO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVELG9CQUFvQixDQUFDLE1BQW1CO1FBQ3RDLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7UUFDMUMsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQztRQUVuQixJQUFJLE1BQU0sRUFBRTtZQUNWLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxNQUFNLENBQUM7WUFDaEMsSUFBSSxDQUFFLGFBQWEsRUFBRTtnQkFDbkIscURBQWEsQ0FBQyx3RkFBd0YsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO2dCQUNwSSxPQUFPLElBQUksQ0FBQzthQUNiO1lBTUQsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDO1lBRzlDLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUMvQyxNQUFNLFlBQVksR0FBRyxjQUFjLENBQUMsTUFBTSxDQUFDO1lBRzNDLElBQUksWUFBWSxHQUFHLENBQUMsRUFBRTtnQkFFcEIsSUFBSSxjQUFjLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDN0IscURBQWEsQ0FBQywyQ0FBMkMsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO29CQUN2RixjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNuRDtxQkFBTTtvQkFFTCxxREFBYSxDQUFDLHdDQUF3QyxFQUFFLDBCQUEwQixDQUFDLENBQUM7b0JBQ3BGLGNBQWMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUVoRTtnQkFDRCxNQUFNLEdBQUcsSUFBSSxDQUFDO2FBQ2Y7aUJBQU07Z0JBQ0wscURBQWEsQ0FBQyxtREFBbUQsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO2FBQ2hHO1NBQ0Y7YUFBTTtZQUVMLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztZQUc5QyxJQUFJLENBQUMsR0FBQyxDQUFDLENBQUM7WUFDUixLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUcsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDdEMscURBQWEsQ0FBQyx3QkFBd0IsR0FBRyxDQUFDLEdBQUcsVUFBVSxFQUFFLDBCQUEwQixDQUFDLENBQUM7Z0JBQ3JGLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDdEM7U0FDRjtRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFVRCxLQUFLLENBQUMsTUFBMkIsRUFBRSxpQkFBMEM7UUFDM0UscURBQWEsQ0FBQyxrQ0FBa0MsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO1FBQzlFLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxpQkFBaUIsQ0FBQztRQUM1QyxJQUFJLElBQUksQ0FBQyxjQUFjO2VBQ2hCLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLElBQUksWUFBWTttQkFDaEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLElBQUksV0FBVyxDQUFDLEVBQzlEO1lBQ0UscURBQWEsQ0FBQyx1RUFBdUUsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO1lBR25ILElBQUksQ0FBQyxZQUFZLENBQUMsa0JBQWtCLENBQUMsRUFBQyxPQUFPLEVBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLEVBQUMsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQ3pILE9BQU87U0FDUjtRQUVELElBQUksSUFBSSxDQUFDLG9CQUFvQixFQUFFO1lBSTdCLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFROUQsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksQ0FBQywwQ0FBMEMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdkYsSUFBSSxDQUFDLG9CQUFvQixDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1lBSTNFLElBQUksT0FBTyxHQUFRLEVBQUUsQ0FBQztZQUN0QixJQUFJLE1BQU0sRUFBRTtnQkFDUixPQUFPLEdBQUcsTUFBTSxDQUFDO2dCQUNqQixPQUFPLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQzthQUN0RDtpQkFBTTtnQkFDSCxPQUFPLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQzthQUN6QztZQUVELElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEU7SUFDSCxDQUFDO0lBYUQsMENBQTBDLENBQUUsS0FBVTtRQUNwRCxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxJQUFJLFNBQVMsQ0FBQztRQUNyQyxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO1FBQ3RDLFFBQU8sS0FBSyxFQUFFO1lBQ1osS0FBSyxnRkFBMEI7Z0JBQzdCLHFEQUFhLENBQUMsNEVBQTRFLEVBQUUsMEJBQTBCLENBQUMsQ0FBQztnQkFDeEgsV0FBVyxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFFaEUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNkLE1BQU07WUFDUixLQUFLLCtFQUF5QjtnQkFDNUIscURBQWEsQ0FBQyxpRkFBaUYsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO2dCQUM3SCxXQUFXLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUNoRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ2QsTUFBTTtZQUNSLEtBQUsscUZBQStCO2dCQUNsQyxxREFBYSxDQUFDLDJGQUEyRixFQUFFLDBCQUEwQixDQUFDLENBQUM7Z0JBQ3ZJLFdBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ2hFLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDZCxNQUFNO1lBQ1I7Z0JBQ0UscURBQWEsQ0FBQyw4RkFBOEYsR0FBRyxLQUFLLEVBQUUsMEJBQTBCLENBQUMsQ0FBQztTQUNySjtJQUNILENBQUM7SUFjRCxNQUFNO1FBQ0osSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUMxQixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO1FBQ3RDLHFEQUFhLENBQUMsU0FBUyxFQUFFLDBCQUEwQixDQUFDLENBQUM7UUFFckQsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDN0I7UUFHRCxJQUFJLENBQUMsb0JBQW9CLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBS2pFLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUk5RSxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQztRQUczQixXQUFXLENBQUMsa0JBQWtCLENBQUMsRUFBRSxFQUFFLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQy9ELENBQUM7SUFPRCxpQkFBaUIsQ0FBQyxLQUFVO1FBQzFCLElBQUksS0FBSyxDQUFDLFNBQVMsSUFBSSxLQUFLLENBQUMsU0FBUyxJQUFJLEVBQUUsRUFBRTtZQUM1QyxxREFBYSxDQUFDLCtCQUErQixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxFQUFFLDBCQUEwQixDQUFDLENBQUM7WUFDN0csSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxTQUFTLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLEVBQUMsQ0FBQyxDQUFDLENBQUM7U0FDL0c7YUFBTTtZQUNMLHFEQUFhLENBQUMsNkJBQTZCLEVBQUUsYUFBYSxDQUFDLENBQUM7U0FDN0Q7SUFDSCxDQUFDO0lBT0Qsc0JBQXNCLENBQUMsS0FBVTtRQUMvQixxREFBYSxDQUFDLDJCQUEyQixFQUFFLDBCQUEwQixDQUFDLENBQUM7UUFDdkUsTUFBTSxHQUFHLEdBQUc7WUFDVixXQUFXLEVBQUUsUUFBUTtZQUNyQixJQUFJLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUU7U0FDbEMsQ0FBQztRQUNGLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7UUFHakMsSUFBSSxJQUFJLENBQUMsb0JBQW9CLElBQUksSUFBSSxDQUFDLGNBQWMsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsS0FBSyxRQUFRLEVBQUU7WUFDdkcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN0QztJQUNILENBQUM7SUFPRCwwQkFBMEIsQ0FBQyxLQUFVO1FBQ25DLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUV2QixxREFBYSxDQUFDLDBCQUEwQixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxFQUFFLDBCQUEwQixDQUFDLENBQUM7U0FDNUc7SUFDSCxDQUFDO0lBS0QsZUFBZSxDQUFDLEdBQVc7UUFHekIsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsRUFBRSxDQUFDO1FBRS9FLE1BQU0sT0FBTyxHQUFHLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUdwRCxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLCtCQUErQixHQUFDLE9BQU8sR0FBQyxHQUFHLENBQUMsQ0FBQztJQUNsRixDQUFDO0lBS0QsZ0JBQWdCLENBQUMsR0FBVztRQUUxQixPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLDhEQUE4RCxDQUFDLENBQUM7SUFDckcsQ0FBQztJQVFELGdCQUFnQixDQUFDLEtBQVU7UUFDekIsSUFBSSxXQUFXLEdBQU8sRUFBRSxDQUFDO1FBQ3pCLElBQUksTUFBTSxHQUFPLEVBQUUsQ0FBQztRQUlwQixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO1FBQ3RDLE1BQU0sbUJBQW1CLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDO1FBQ3RELE1BQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDO1FBR25DLElBQUksQ0FBQyxXQUFXLElBQUksQ0FBQyxtQkFBbUIsRUFBRTtZQUN4QyxxREFBYSxDQUFDLDZFQUE2RSxFQUFFLDBCQUEwQixDQUFDLENBQUM7WUFDekgsT0FBTztTQUNSO1FBR0QsSUFBSSxLQUFLLElBQUksS0FBSyxDQUFDLElBQUksRUFBRTtZQUN2QixxREFBYSxDQUFDLHVCQUF1QixHQUFHLEtBQUssQ0FBQyxJQUFJLEVBQUUsMEJBQTBCLENBQUMsQ0FBQztZQUNoRixXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDdEM7YUFBTTtZQUNMLHFEQUFhLENBQUMsMENBQTBDLEVBQUUsMEJBQTBCLENBQUMsQ0FBQztZQUN0RixPQUFPO1NBQ1I7UUFDRCxNQUFNLEdBQUcsV0FBVyxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQzVDLElBQUksQ0FBQyxNQUFNO1lBQUUsT0FBTztRQUdwQixJQUFJLE1BQU0sQ0FBQyxHQUFHLEVBQUU7WUFDZCxxREFBYSxDQUFDLG9CQUFvQixHQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUUsMEJBQTBCLENBQUMsQ0FBQztZQUc5RSxJQUFJLHFCQUFxQixDQUFDLGtCQUFrQixFQUFFO2dCQUM1QyxNQUFNLGtCQUFrQixHQUFHO29CQUN6QixNQUFNLEVBQUUscUJBQXFCLENBQUMsa0JBQWtCLENBQUMsUUFBUTtvQkFDekQsVUFBVSxFQUFFLHFCQUFxQixDQUFDLGtCQUFrQixDQUFDLFlBQVk7b0JBQ2pFLFlBQVksRUFBRSxxQkFBcUIsQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjO2lCQUN0RSxDQUFDO2dCQUNGLE1BQU0sa0JBQWtCLEdBQUc7b0JBQ3pCLE1BQU0sRUFBRSxxQkFBcUIsQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRO2lCQUMxRCxDQUFDO2dCQUNGLG9CQUFvQixHQUFHO29CQUNyQixZQUFZLEVBQUU7d0JBQ1osa0JBQWtCO3dCQUNsQixrQkFBa0I7cUJBQ25CO2lCQUNGLENBQUM7YUFFSDtpQkFBTSxJQUFJLE1BQU0sQ0FBQyxJQUFJLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBRzVGLE1BQU0sbUJBQW1CLEdBQUc7b0JBQzFCLE1BQU0sRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUk7b0JBQ3hCLFVBQVUsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVE7b0JBQ2hDLFlBQVksRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVU7aUJBQ3JDLENBQUM7Z0JBQ0Ysb0JBQW9CLEdBQUc7b0JBQ3JCLFlBQVksRUFBRTt3QkFDWixtQkFBbUI7d0JBQ25CLG1CQUFtQjtxQkFDcEI7aUJBQ0YsQ0FBQzthQUNIO1lBTUQsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO2dCQUcxQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtvQkFDMUIsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO2lCQUNuRDtnQkFDRCxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtvQkFDMUIsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO2lCQUNuRDthQUNGO1lBQ0QsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQztZQUd4QyxNQUFNLENBQUMsR0FBRyxHQUFHLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDL0QsTUFBTSxJQUFJLEdBQUcsSUFBSSxrQ0FBa0MsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUc1RCxhQUFhLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDO2lCQUN2QyxJQUFJLENBQUM7Z0JBRUwsT0FBTyxhQUFhLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDckMsQ0FBQyxDQUFDO2lCQUNELElBQUksQ0FBQyxVQUFTLE1BQVc7Z0JBRXhCLE1BQU0sQ0FBQyxHQUFHLEdBQUcscUJBQXFCLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNoRSxxREFBYSxDQUFDLFNBQVMsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO2dCQUNyRCxxREFBYSxDQUFDLE1BQU0sRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO2dCQUVsRCxPQUFPLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNuRCxDQUFDLENBQUM7aUJBQ0QsSUFBSSxDQUFDO2dCQUNKLE1BQU0sR0FBRyxHQUFHO29CQUNWLElBQUksRUFBRSxRQUFRO29CQUNkLEdBQUcsRUFBRSxhQUFhLENBQUMsZ0JBQWdCO29CQUNuQyxJQUFJLEVBQUUsV0FBVyxDQUFDLE9BQU8sRUFBRTtpQkFDNUIsQ0FBQztnQkFDRixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNqQyxxREFBYSxDQUFDLDBCQUEwQixFQUFFLDBCQUEwQixDQUFDLENBQUM7Z0JBRXRFLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNqQyxDQUFDLENBQUMsQ0FBQztTQUVKO2FBQU0sSUFBSSxNQUFNLENBQUMsR0FBRyxFQUFFO1lBQ3JCLHFEQUFhLENBQUMsaUNBQWlDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsMEJBQTBCLENBQUMsQ0FBQztZQUMxRyxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7Z0JBQ3ZCLElBQUksQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUM7cUJBQzlDLElBQUksQ0FBQztvQkFDSixxREFBYSxDQUFDLHdCQUF3QixFQUFFLDBCQUEwQixDQUFDLENBQUM7Z0JBQ3RFLENBQUMsQ0FBQztxQkFDRCxLQUFLLENBQUMsVUFBUyxDQUFNO29CQUNwQixxREFBYSxDQUFDLGdEQUFnRCxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsMEJBQTBCLENBQUMsQ0FBQztnQkFDMUcsQ0FBQyxDQUFDLENBQUM7YUFDSjtpQkFBTTtnQkFFTCxxREFBYSxDQUFDLDREQUE0RCxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxFQUFFLDBCQUEwQixDQUFDLENBQUM7YUFDeEk7U0FDRjthQUFNO1lBRUwscURBQWEsQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLDBCQUEwQixDQUFDLENBQUM7U0FDeEY7SUFDSCxDQUFDO0lBV0QsaUJBQWlCLENBQUMsUUFBa0I7UUFDbEMsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBVUQsb0JBQW9CLENBQUMsUUFBa0I7UUFDckMsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBTUssU0FBUyxDQUFDLFdBQWdCLElBQUk7O1lBQ2xDLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDdkIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUMvQztpQkFBTTtnQkFDTCxPQUFPLEVBQUUsQ0FBQzthQUNYO1FBQ0gsQ0FBQztLQUFBO0NBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDandDdUM7QUFheEMsSUFBWSxtQkFPWDtBQVBELFdBQVksbUJBQW1CO0lBQzdCLGdEQUF5QjtJQUN6QixvQ0FBYTtJQUNiLHNDQUFlO0lBQ2YsMENBQW1CO0lBQ25CLHdDQUFpQjtJQUNqQixrREFBMkI7QUFDN0IsQ0FBQyxFQVBXLG1CQUFtQixLQUFuQixtQkFBbUIsUUFPOUI7QUFBQSxDQUFDO0FBWUssTUFBTSx1QkFBdUI7SUE2QmxDO1FBQ0UscURBQWEsQ0FBQyxhQUFhLEVBQUUseUJBQXlCLENBQUMsQ0FBQztRQUd4RCxJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUN0QyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUdsQyxJQUFJLENBQUMsTUFBTSxHQUFHLG1CQUFtQixDQUFDLE1BQU0sQ0FBQztRQU16QyxJQUFJLENBQUMsd0JBQXdCLEdBQUcsSUFBSSxvQ0FBb0MsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUVqRixDQUFDO0lBT0QsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNyQixDQUFDO0lBbUJELHFCQUFxQixDQUFDLGFBQXVCO1FBQzNDLElBQUk7WUFDRixJQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQzdDLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNaLHFEQUFhLENBQUMsdUNBQXVDO2dCQUNuRCxHQUFHLENBQUMsT0FBTyxFQUFFLHlCQUF5QixDQUFDLENBQUM7WUFDMUMsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQVNELHdCQUF3QixDQUFDLGFBQXVCO1FBQzlDLElBQUk7WUFDRixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQy9ELE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNaLHFEQUFhLENBQUMseUNBQXlDO2dCQUNyRCxHQUFHLENBQUMsT0FBTyxFQUFFLHlCQUF5QixDQUFDLENBQUM7WUFDMUMsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQWlCRCxpQkFBaUIsQ0FBQyxjQUF3QjtRQUN4QyxJQUFJO1lBQ0YsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUMxQyxPQUFPLElBQUksQ0FBQztTQUNiO1FBQUMsT0FBTyxHQUFHLEVBQUU7WUFDWixxREFBYSxDQUFDLGtDQUFrQztnQkFDOUMsR0FBRyxDQUFDLE9BQU8sRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO1lBQzFDLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFTRCxvQkFBb0IsQ0FBQyxjQUF3QjtRQUMzQyxJQUFJO1lBQ0YsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUM3QyxPQUFPLElBQUksQ0FBQztTQUNiO1FBQUMsT0FBTyxHQUFHLEVBQUU7WUFDWixxREFBYSxDQUFDLHlDQUF5QztnQkFDckQsR0FBRyxDQUFDLE9BQU8sRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO1lBQzFDLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFTRCwyQkFBMkIsQ0FBQyxHQUFXO1FBQ3JDLElBQUksbUJBQW1CLEdBQUcsSUFBSSxDQUFDO1FBQy9CLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxtQkFBbUIsQ0FBQyxJQUFJO1lBQUUsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUNoRSxpSUFBaUksQ0FDcEksQ0FBQztRQUVGLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFDckMsbUJBQW1CLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQztZQUMzQyxtQkFBbUIsQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDO1lBRXpDLHFEQUFhLENBQUMsa0NBQWtDLEdBQUcsR0FBRyxFQUFFLHlCQUF5QixDQUFDLENBQUM7WUFDbkYsSUFBSSxLQUFLLEdBQUcsRUFBQyxPQUFPLEVBQUMsbUJBQW1CLENBQUMsVUFBVSxFQUFDLENBQUM7WUFDckQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUcvRCxJQUFJLENBQUMsd0JBQXdCLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzNDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQU9ELElBQUksQ0FBQyxPQUFlO1FBQ2xCLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQVFELDRCQUE0QjtRQUMxQixJQUFJLG1CQUFtQixHQUFHLElBQUksQ0FBQztRQUMvQixJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssbUJBQW1CLENBQUMsTUFBTTtZQUFFLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FDbEUseUNBQXlDLENBQzVDLENBQUM7UUFFRixPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQ3JDLG1CQUFtQixDQUFDLGFBQWEsR0FBRyxPQUFPLENBQUM7WUFDNUMsbUJBQW1CLENBQUMsWUFBWSxHQUFHLE1BQU0sQ0FBQztZQUUxQyxxREFBYSxDQUFDLDhCQUE4QixFQUFFLHlCQUF5QixDQUFDLENBQUM7WUFDekUsSUFBSSxLQUFLLEdBQUcsRUFBQyxPQUFPLEVBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFDLENBQUM7WUFDbEQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUc1RCxJQUFJLENBQUMsd0JBQXdCLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDekMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBT0Qsa0JBQWtCLENBQUMsUUFBYSxFQUFFLEVBQUUsS0FBMEI7UUFFNUQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUdwQyxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1lBQ3BCLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxLQUFLLENBQUM7WUFDdkIscURBQWEsQ0FBQyxzQkFBc0IsR0FBRyxpRUFBeUIsQ0FBQyxLQUFLLENBQUMsRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO1lBQ3BHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsVUFBUyxPQUFPO2dCQUNoRCxJQUFJLE9BQU8sRUFBRTtvQkFDWCxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQ2hCO1lBQ0gsQ0FBQyxDQUFDLENBQUM7U0FDTjtJQUNILENBQUM7SUFTRCxnQkFBZ0IsQ0FBQyxRQUFhLEVBQUUsRUFBRSxLQUEwQjtRQUMxRCxJQUFJLFlBQVksR0FBRyxLQUFLLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLElBQUksS0FBSyxDQUFDO1FBQzFELHFEQUFhLENBQUMsbUNBQW1DLEdBQUcsS0FBSyxFQUFFLHlCQUF5QixDQUFDLENBQUM7UUFDdEYsUUFBTyxLQUFLLEVBQUU7WUFDWixLQUFLLG1CQUFtQixDQUFDLElBQUk7Z0JBQzNCLElBQUksSUFBSSxDQUFDLFlBQVk7b0JBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO2dCQUMzQyxJQUFJLElBQUksQ0FBQyxZQUFZO29CQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQ3ZELE1BQU07WUFDUixLQUFLLG1CQUFtQixDQUFDLE1BQU07Z0JBQzdCLElBQUksSUFBSSxDQUFDLFdBQVc7b0JBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDckQsSUFBSSxJQUFJLENBQUMsYUFBYTtvQkFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7Z0JBQzdDLE1BQU07WUFDUixLQUFLLG1CQUFtQixDQUFDLEtBQUs7Z0JBQzVCLElBQUksSUFBSSxDQUFDLFdBQVc7b0JBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDckQsSUFBSSxJQUFJLENBQUMsWUFBWTtvQkFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUN2RCxNQUFNO1lBQ1IsS0FBSyxtQkFBbUIsQ0FBQyxXQUFXO2dCQUNsQyxJQUFJLElBQUksQ0FBQyxXQUFXO29CQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQ3JELElBQUksSUFBSSxDQUFDLGFBQWE7b0JBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO2dCQUM3QyxNQUFNO1lBQ1I7Z0JBRUUscURBQWEsQ0FBQywrQ0FBK0MsR0FBRyxLQUFLLEVBQUUseUJBQXlCLENBQUMsQ0FBQztTQUNyRztJQUNILENBQUM7SUFLRCxjQUFjLENBQUMsT0FBWTtRQUN6QixxREFBYSxDQUFDLGdCQUFnQixHQUFHLGlFQUF5QixDQUFDLE9BQU8sQ0FBQyxFQUFFLHlCQUF5QixDQUFDLENBQUM7UUFNaEcsSUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFO1lBQ2QsSUFBSTtnQkFDQSxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDM0MsSUFBSSxXQUFXLENBQUMsS0FBSyxJQUFJLFdBQVcsQ0FBQyxLQUFLLEtBQUsscUJBQXFCLEVBQUU7b0JBQ2xFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLEVBQUUsbUJBQW1CLENBQUMsV0FBVyxDQUFDLENBQUM7aUJBQ2hFO2FBQ0o7WUFBQyxPQUFNLEdBQUcsRUFBRTthQUlaO1NBQ0o7UUFDRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLFVBQVMsT0FBTztZQUM1QyxJQUFJLE9BQU8sRUFBRTtnQkFDWCxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDbEI7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FFRjtBQW9CRCxJQUFJLHNCQUFzQixHQUFPLElBQUksQ0FBQztBQUN0QyxJQUFJLE9BQU8sSUFBSSxLQUFLLFdBQVcsRUFBRTtJQUUvQixzQkFBc0IsR0FBRyxtQkFBTyxDQUFDLHdDQUFJLENBQUMsQ0FBQztDQUN4QztLQUFNO0lBRUwsc0JBQXNCLEdBQUcsU0FBUyxDQUFDO0NBQ3BDO0FBTUQsTUFBTSxvQ0FBb0M7SUFleEMsWUFBWSx1QkFBZ0Q7UUFDMUQscURBQWEsQ0FBQyxhQUFhLEVBQUUsc0NBQXNDLENBQUMsQ0FBQztRQUNyRSxJQUFJLENBQUMsd0JBQXdCLEdBQUcsdUJBQXVCLENBQUM7SUFDMUQsQ0FBQztJQUtELEtBQUssQ0FBQyxhQUFxQjtRQUN6QixJQUFJLG1CQUFtQixHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQztRQUd4RCxJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEtBQUssc0JBQXNCLENBQUMsSUFBSSxFQUFFO1lBQy9FLG1CQUFtQixDQUFDLGtCQUFrQixDQUFDLEVBQUUsRUFBRSxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNyRSxPQUFPO1NBQ1Y7UUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksc0JBQXNCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFPNUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsVUFBUyxLQUFVLElBQUksbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBUyxLQUFVLElBQUksbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDOUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBUyxLQUFVO1lBQ3pELElBQUksS0FBSyxJQUFJLEtBQUssQ0FBQyxJQUFJLElBQUksS0FBSyxDQUFDLElBQUksR0FBRyxJQUFJLEVBQUU7Z0JBRzFDLHFEQUFhLENBQUMsMkNBQTJDLEdBQUcsS0FBSyxDQUFDLElBQUksR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO2dCQUMxSCxtQkFBbUIsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLEVBQUUsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDNUU7aUJBQU07Z0JBQ0gsbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQzdFO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFJSCxJQUFJLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxVQUFTLEtBQVUsSUFBSSxtQkFBbUIsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuSCxDQUFDO0lBS0QsS0FBSyxDQUFDLE9BQVk7UUFDaEIsSUFBSSxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxLQUFLLHNCQUFzQixDQUFDLElBQUksRUFBRTtZQUMvRSxxREFBYSxDQUFDLDZCQUE2QixHQUFHLE9BQU8sRUFBRSxzQ0FBc0MsQ0FBQyxDQUFDO1lBQy9GLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ2pDO0lBQ0gsQ0FBQztJQUtELE1BQU07UUFDSixJQUFJLG1CQUFtQixHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQztRQUV4RCxJQUFJLENBQUUsSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsS0FBSyxzQkFBc0IsQ0FBQyxNQUFNLEVBQUU7WUFDbkYsbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsRUFBRSxFQUFFLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3ZFLE9BQU87U0FDVjtRQUNELElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDeEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7SUFDekIsQ0FBQztDQUNGOzs7Ozs7Ozs7Ozs7Ozs7O0FDdGJ1QztBQWVqQyxNQUFNLG9CQUFvQjtJQWtCL0IsWUFBWSxxQkFBNEM7UUFDdEQscURBQWEsQ0FBQyxhQUFhLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztRQUNyRCxJQUFJLENBQUMsa0JBQWtCLEdBQUcscUJBQXFCLENBQUM7UUFJaEQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFDekIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFHekIsSUFBSSxDQUFDLDBCQUEwQixHQUFHLFVBQVUsS0FBVSxJQUFJLHFEQUFhLENBQUMsNEJBQTRCLEdBQUcsS0FBSyxFQUFFLHNCQUFzQixDQUFDLENBQUMsRUFBQztRQUV2SSxJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUM7SUFDbkMsQ0FBQztJQU9ELGNBQWM7UUFDWixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDM0IsQ0FBQztJQU9ELGVBQWUsQ0FBQyxXQUF3QjtRQUN0QyxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztRQUNoQyxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDeEIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztTQUNwRDtJQUNILENBQUM7SUFrQkQsaUJBQWlCLENBQUMsWUFBOEIsRUFBRSx5QkFBbUM7UUFDbkYsSUFBSSxDQUFDLGVBQWUsR0FBRyxZQUFZLENBQUM7UUFFcEMsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3JCLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7U0FDcEQ7UUFDRCxJQUFJLENBQUMsMEJBQTBCLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBTUQsMEJBQTBCLENBQUMseUJBQW1DO1FBQzVELElBQUkseUJBQXlCLEVBQUU7WUFDN0IsSUFBSSxDQUFDLDBCQUEwQixHQUFHLHlCQUF5QixDQUFDO1NBQzdEO0lBQ0gsQ0FBQztJQU9ELGtCQUFrQixDQUFDLE9BQWdCO1FBQ2pDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLENBQUMscUJBQXFCLEVBQUUsRUFBQyxTQUFTLEVBQUUsT0FBTyxFQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDMUYsQ0FBQztJQU1ELGVBQWUsQ0FBQyxPQUFnQjtRQUM5QixJQUFJLENBQUMsa0JBQWtCLENBQUMsWUFBWSxDQUFDLGtCQUFrQixFQUFFLEVBQUMsU0FBUyxFQUFFLE9BQU8sRUFBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3ZGLENBQUM7SUFPRCxjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQzNCLENBQUM7SUFPRCxlQUFlLENBQUMsV0FBd0I7UUFDdEMsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7UUFDaEMsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7U0FDcEQ7SUFDSCxDQUFDO0lBU0QsaUJBQWlCLENBQUMsWUFBOEI7UUFDOUMsSUFBSSxDQUFDLGVBQWUsR0FBRyxZQUFZLENBQUM7UUFFcEMsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3JCLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7U0FDcEQ7SUFDSCxDQUFDO0lBdUJELGFBQWEsQ0FBQyxNQUFtQixFQUFFLFFBQVEsR0FBRyxLQUFLO1FBQ2pELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxNQUFNLENBQUM7UUFDaEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUM7UUFDMUIsSUFBSSxJQUFJLENBQUMsb0JBQW9CO1lBQUUsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFZRCwwQkFBMEIsQ0FBQyxtQkFBNkI7UUFDdEQsSUFBSSxtQkFBbUIsRUFBRTtZQUN2QixJQUFJLENBQUMsb0JBQW9CLEdBQUcsbUJBQW1CLENBQUM7U0FDakQ7SUFDSCxDQUFDO0lBR0QsYUFBYSxDQUFDLE1BQW1CO1FBQy9CLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxNQUFNLENBQUM7UUFDaEMsSUFBSSxJQUFJLENBQUMsb0JBQW9CO1lBQUUsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRCwwQkFBMEIsQ0FBQyxtQkFBNkI7UUFDdEQsSUFBSSxtQkFBbUIsRUFBRTtZQUN2QixJQUFJLENBQUMsb0JBQW9CLEdBQUcsbUJBQW1CLENBQUM7U0FDakQ7SUFDSCxDQUFDO0lBUUQsYUFBYTtRQU9YLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUN4QixDQUFDO0lBWUQsS0FBSztRQUNILHFEQUFhLENBQUMsa0JBQWtCLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztRQUUxRCxJQUFJLElBQUksQ0FBQyxlQUFlLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEVBQUU7WUFDMUQsSUFBSSxTQUFTLEdBQWlCLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDO1lBQzdELElBQUksTUFBTSxHQUFHLFNBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNuQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7WUFDdEMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1lBQ3RDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxNQUFNLENBQUM7U0FDeEM7UUFDRCxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDckIsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUM3RCxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztTQUMxQjtJQUVILENBQUM7Q0FFRjs7Ozs7Ozs7Ozs7Ozs7O0FDalFELElBQUksS0FBSyxHQUFHLElBQUksQ0FBQztBQU9WLE1BQU0sU0FBUztJQVNwQixNQUFNLENBQUMsVUFBVTtRQUNmLFNBQVMsRUFBRTtZQUNULE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdFLENBQUM7UUFFRCxPQUFPLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQztJQUN2RixDQUFDO0lBY0QsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFlLEVBQUUsU0FBaUI7UUFDM0MsSUFBSSxPQUFPLFNBQVMsS0FBSyxXQUFXO1lBQUUsT0FBTyxHQUFHLFNBQVMsR0FBRyxJQUFJLEdBQUcsT0FBTyxDQUFDO1FBQzNFLElBQUksS0FBSyxFQUFFO1lBQ1QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN0QjtRQUNELElBQUksT0FBTyxRQUFRLEtBQUssV0FBVyxJQUFJLEtBQUssRUFBRTtZQUM1QyxJQUFJO2dCQUNGLFFBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxXQUFXLENBQUMsUUFBUSxFQUFFLEVBQUMsTUFBTSxFQUFFLE9BQU8sRUFBQyxDQUFDLENBQUMsQ0FBQzthQUN0RTtZQUFDLE9BQU0sR0FBRyxFQUFFO2dCQUNYLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3JCLE9BQU8sQ0FBQyxHQUFHLENBQUMsNERBQTRELENBQUM7Z0JBQ3pFLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDbEI7U0FDRjtJQUNILENBQUM7SUFRRCxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQWUsRUFBRSxTQUFpQjtRQUMzQyxJQUFJLE9BQU8sU0FBUyxLQUFLLFdBQVc7WUFBRSxPQUFPLEdBQUcsU0FBUyxHQUFHLElBQUksR0FBRyxPQUFPLENBQUM7UUFDM0UsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDaEQsSUFBSSxPQUFPLFFBQVEsS0FBSyxXQUFXLEVBQUU7WUFDbkMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxXQUFXLEVBQUUsRUFBQyxNQUFNLEVBQUUsT0FBTyxFQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3pFO0lBQ0gsQ0FBQztJQUtELE1BQU0sQ0FBQyxlQUFlLENBQUMsSUFBUztRQUM5QixJQUFJO1lBQ0YsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzdCO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixPQUFPLElBQUksQ0FBQztTQUNiO0lBQ0gsQ0FBQztJQUtELE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxFQUFlO1FBQ3RDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUNyQixPQUFPO1NBQ1I7UUFDRCxJQUFJLEVBQUUsR0FBRyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUM5QixJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ25ELElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDcEQsT0FBTyxFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBQztJQUM5QixDQUFDO0lBVUQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFjO1FBQzVCLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDaEIsQ0FBQztDQUVGOzs7Ozs7Ozs7Ozs7Ozs7O0FDOUZELElBQVksWUFLWDtBQUxELFdBQVksWUFBWTtJQUNwQiw2QkFBYTtJQUNiLCtCQUFlO0lBQ2YsNkJBQWE7SUFDYiwrQkFBZTtBQUNuQixDQUFDLEVBTFcsWUFBWSxLQUFaLFlBQVksUUFLdkI7QUFLTSxNQUFNLFVBQVU7SUFNbkIsWUFBWSxRQUF1QjtRQUMvQixRQUFRLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUM7SUFDeEQsQ0FBQztJQU1ELE1BQU0sQ0FBQyxlQUFlLENBQUMsV0FBeUI7UUFDNUMsVUFBVSxDQUFDLFFBQVEsR0FBRyxXQUFXLENBQUM7SUFDdEMsQ0FBQztJQU9ELE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBZTtRQUN0QixJQUFJLFVBQVUsQ0FBQyxRQUFRLEtBQUssWUFBWSxDQUFDLEtBQUssRUFBRTtZQUM1QyxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3JCLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7YUFBTTtZQUNILE9BQU8sS0FBSyxDQUFDO1NBQ2hCO0lBQ0wsQ0FBQztJQU9ELE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBZTtRQUN4QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQU9ELE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBZTtRQUN2QixJQUFJLFVBQVUsQ0FBQyxRQUFRLEtBQUssWUFBWSxDQUFDLEtBQUssSUFBSSxVQUFVLENBQUMsUUFBUSxLQUFLLFlBQVksQ0FBQyxJQUFJLEVBQUU7WUFDekYsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN0QixPQUFPLElBQUksQ0FBQztTQUNmO2FBQU07WUFDSCxPQUFPLEtBQUssQ0FBQztTQUNoQjtJQUNMLENBQUM7SUFPRCxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQWU7UUFDeEIsSUFBSSxVQUFVLENBQUMsUUFBUSxLQUFLLFlBQVksQ0FBQyxLQUFLLElBQUksVUFBVSxDQUFDLFFBQVEsS0FBSyxZQUFZLENBQUMsSUFBSSxJQUFJLFVBQVUsQ0FBQyxRQUFRLEtBQUssWUFBWSxDQUFDLEtBQUssRUFBRTtZQUN2SSxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3ZCLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7YUFBTTtZQUNILE9BQU8sS0FBSyxDQUFDO1NBQ2hCO0lBQ0wsQ0FBQzs7QUFsRU0sbUJBQVEsR0FBaUIsWUFBWSxDQUFDLEtBQUssQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNiYjtBQUUxQyxTQUFTLGNBQWMsQ0FBQyxHQUFRLEVBQUUsYUFBcUI7SUFDbkQsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3RDLENBQUM7QUFFRCxJQUFJLEdBQU8sQ0FBQztBQUNaLElBQUksT0FBTyxJQUFJLEtBQUssV0FBVyxFQUFFO0lBRTdCLElBQUk7UUFDQSxHQUFHLEdBQUcsY0FBYyxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDO0tBQzlEO0lBQUMsV0FBTSxHQUFFO0NBQ2I7QUFFTSxNQUFNLGFBQWE7SUFDdEIsZ0JBQWdCLENBQUM7SUFXakIsTUFBTSxDQUFDLHNCQUFzQixDQUFDLElBQVMsRUFBRSxJQUFTO1FBRTlDLElBQUksQ0FBQyxJQUFJLElBQUksTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLGlCQUFpQixFQUFFO1lBQ3JFLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFLRCxJQUFJLEtBQUssR0FBUSxFQUFFLENBQUM7UUFDcEIsSUFBSSxHQUFHLENBQUM7UUFFUixJQUFJLGFBQWEsR0FBRyxDQUFDLElBQWdCLEVBQUUsSUFBZ0IsRUFBRSxFQUFFO1lBRXZELElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUM3QixPQUFPLEtBQUssQ0FBQzthQUNoQjtZQUdELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUNsQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUU7b0JBQ3JCLE9BQU8sS0FBSyxDQUFDO2lCQUNoQjthQUNKO1lBR0QsT0FBTyxJQUFJLENBQUM7UUFDaEIsQ0FBQyxDQUFDO1FBR0YsSUFBSSxPQUFPLEdBQUcsQ0FBQyxLQUFVLEVBQUUsS0FBVSxFQUFFLEdBQVcsRUFBRSxFQUFFO1lBRWxELElBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNsRCxJQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFHbEQsSUFBSSxLQUFLLEtBQUssb0JBQW9CLEVBQUU7Z0JBQ2hDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM7Z0JBQ2xCLE9BQU87YUFDVjtZQUdELElBQUksS0FBSyxLQUFLLEtBQUssRUFBRTtnQkFDakIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztnQkFDbkIsT0FBTzthQUNWO1lBR0QsSUFBSSxLQUFLLEtBQUssaUJBQWlCLEVBQUU7Z0JBQzdCLElBQUksT0FBTyxHQUFHLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ2pFLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO29CQUNqQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDO2lCQUN4QjtnQkFDRCxPQUFPO2FBQ1Y7WUFHRCxJQUFJLEtBQUssS0FBSyxnQkFBZ0IsRUFBRTtnQkFDNUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUU7b0JBQzlCLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7aUJBQ3RCO2dCQUNELE9BQU87YUFDVjtZQUlELElBQUksS0FBSyxLQUFLLG1CQUFtQixFQUFFO2dCQUMvQixJQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUUsS0FBSyxLQUFLLENBQUMsUUFBUSxFQUFFLEVBQUU7b0JBQ3ZDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7aUJBQ3RCO2FBQ0o7aUJBQU07Z0JBQ0gsSUFBSSxLQUFLLEtBQUssS0FBSyxFQUFFO29CQUNqQixLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO2lCQUN0QjthQUNKO1FBQ0wsQ0FBQyxDQUFDO1FBR0YsS0FBSyxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ2QsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUMxQixPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQzthQUN0QztTQUNKO1FBR0QsS0FBSyxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ2QsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQ3ZDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQzFCO2FBQ0o7U0FDSjtRQUdELE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFBQSxDQUFDO0lBTUYsTUFBTSxDQUFDLHVCQUF1QjtRQUMxQixJQUFJLGdCQUFnQixHQUFRLEVBQUUsQ0FBQztRQUUvQixJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxXQUFXLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsS0FBSyxXQUFXLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsdUJBQXVCLENBQUMsS0FBSyxXQUFXLElBQUksU0FBUyxDQUFDLFlBQVksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDLGdCQUFnQixFQUFFO1lBQ3ZPLGdCQUFnQixDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQztTQUM3QztRQUVELElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLLFdBQVcsSUFBSSxPQUFPLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxLQUFLLFdBQVcsSUFBSSxPQUFPLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLFdBQVcsSUFBSSxTQUFTLENBQUMsWUFBWSxDQUFDLHVCQUF1QixFQUFFLENBQUMsZ0JBQWdCLEVBQUU7WUFDdk8sZ0JBQWdCLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO1NBQzdDO1FBRUQsSUFBSSxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssV0FBVyxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLEtBQUssV0FBVyxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLHVCQUF1QixDQUFDLEtBQUssV0FBVyxJQUFJLFNBQVMsQ0FBQyxZQUFZLENBQUMsdUJBQXVCLEVBQUUsQ0FBQyxlQUFlLEVBQUU7WUFDdE8sZ0JBQWdCLENBQUMsZUFBZSxHQUFHLEtBQUssQ0FBQztTQUM1QztRQUVELE9BQU8sZ0JBQWdCLENBQUM7SUFDNUIsQ0FBQztJQXdCRCxNQUFNLENBQUMsZUFBZSxDQUFDLFFBQWtCLEVBQUUsVUFBa0I7UUFDekQsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNOLHdEQUFlLENBQUMsa0ZBQWtGLENBQUMsQ0FBQztZQUNwRyxPQUFPLFdBQVcsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7U0FDNUM7UUFFRCxJQUFJLFFBQVEsR0FBRyxHQUFHLEVBQUUsQ0FBQztRQUNyQixJQUFJLEtBQUssR0FBTyxZQUFZLENBQUM7UUFDN0IsSUFBSSxPQUFPLEdBQUcsR0FBRyxFQUFFO1lBQ2YsSUFBSSxRQUFRLEdBQUcsR0FBRyxFQUFFLENBQUM7WUFDckIsSUFBSSxRQUFRLEdBQUcsUUFBUSxFQUFFO2dCQUNyQixLQUFLLEdBQUcsY0FBYyxDQUFDO2dCQUN2QixPQUFPLE9BQU8sR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDMUM7WUFDRCxRQUFRLElBQUksVUFBVSxDQUFDO1lBQ3ZCLEtBQUssR0FBRyxZQUFZLENBQUM7WUFDckIsT0FBTyxHQUFHLFVBQVUsQ0FBQyxPQUFPLEVBQUUsUUFBUSxHQUFHLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN2RCxRQUFRLEVBQUUsQ0FBQztRQUNmLENBQUMsQ0FBQztRQUNGLElBQUksT0FBTyxHQUFPLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN0QyxPQUFPLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO0lBQzNDLENBQUM7SUFFRCxNQUFNLENBQUMseUJBQXlCO1FBQzVCLElBQUksZ0JBQWdCLEdBQWtCO1lBRWxDLFdBQVc7WUFDWCxxQ0FBcUM7WUFDckMsZ0RBQWdEO1lBRWhELG9CQUFvQjtZQUNwQix1QkFBdUI7WUFDdkIsMEJBQTBCO1lBQzFCLDhCQUE4QjtTQUNqQztRQUNELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDOUMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxXQUFXLEVBQUU7Z0JBQ3BELHlEQUFnQixDQUFDLGdEQUFnRCxHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pGLElBQUksZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEtBQUsscUNBQXFDLEVBQUU7b0JBQy9ELHlEQUFnQixDQUFDLHlJQUF5SSxDQUFDLENBQUM7aUJBQy9KO2dCQUNELE9BQU8sS0FBSyxDQUFDO2FBQ2hCO1NBQ0o7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFTLEVBQUUsS0FBYTtRQUNqQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxNQUFNLENBQUMsS0FBSyxDQUFDLENBQVMsRUFBRSxHQUFXLEVBQUUsR0FBVztRQUU1QyxPQUFPLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFTLEVBQUUsR0FBVyxFQUFFLEdBQVcsRUFBRSxLQUFhO1FBQ2hFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0UsQ0FBQztJQUVELE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBUztRQUU1QixPQUFPLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkQsQ0FBQztDQUNKOzs7Ozs7Ozs7OztBQzdPWTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7VUNQQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3hCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHdDQUF3Qyx5Q0FBeUM7V0FDakY7V0FDQTtXQUNBLEU7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBLEU7Ozs7O1dDVkEsd0Y7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7VUNOQTtVQUNBO1VBQ0E7VUFDQSIsImZpbGUiOiJIaWdoRmlkZWxpdHlBdWRpby1sYXRlc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuTWVkaWFTdHJlYW0gPSB3aW5kb3cuTWVkaWFTdHJlYW07XG5leHBvcnRzLk1lZGlhU3RyZWFtVHJhY2sgPSB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaztcbmV4cG9ydHMuUlRDRGF0YUNoYW5uZWwgPSB3aW5kb3cuUlRDRGF0YUNoYW5uZWw7XG5leHBvcnRzLlJUQ0RhdGFDaGFubmVsRXZlbnQgPSB3aW5kb3cuUlRDRGF0YUNoYW5uZWxFdmVudDtcbmV4cG9ydHMuUlRDRHRsc1RyYW5zcG9ydCA9IHdpbmRvdy5SVENEdGxzVHJhbnNwb3J0O1xuZXhwb3J0cy5SVENJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlO1xuZXhwb3J0cy5SVENJY2VUcmFuc3BvcnQgPSB3aW5kb3cuUlRDSWNlVHJhbnNwb3J0O1xuZXhwb3J0cy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbjtcbmV4cG9ydHMuUlRDUGVlckNvbm5lY3Rpb25JY2VFdmVudCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbkljZUV2ZW50O1xuZXhwb3J0cy5SVENSdHBSZWNlaXZlciA9IHdpbmRvdy5SVENSdHBSZWNlaXZlcjtcbmV4cG9ydHMuUlRDUnRwU2VuZGVyID0gd2luZG93LlJUQ1J0cFNlbmRlcjtcbmV4cG9ydHMuUlRDUnRwVHJhbnNjZWl2ZXIgPSB3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXI7XG5leHBvcnRzLlJUQ1NjdHBUcmFuc3BvcnQgPSB3aW5kb3cuUlRDU2N0cFRyYW5zcG9ydDtcbmV4cG9ydHMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID0gd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbjtcbmV4cG9ydHMuZ2V0VXNlck1lZGlhID0gd2luZG93LmdldFVzZXJNZWRpYTtcbmV4cG9ydHMubWVkaWFEZXZpY2VzID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gdGhlIG9ubHkgcmVsaWFibGUgbWVhbnMgdG8gZ2V0IHRoZSBnbG9iYWwgb2JqZWN0IGlzXG5cdC8vIGBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpYFxuXHQvLyBIb3dldmVyLCB0aGlzIGNhdXNlcyBDU1AgdmlvbGF0aW9ucyBpbiBDaHJvbWUgYXBwcy5cblx0aWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gc2VsZjsgfVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHdpbmRvdzsgfVxuXHRpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGdsb2JhbDsgfVxuXHR0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdCcpO1xufVxuXG52YXIgZ2xvYmFsID0gZ2V0R2xvYmFsKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGdsb2JhbC5mZXRjaDtcblxuLy8gTmVlZGVkIGZvciBUeXBlU2NyaXB0IGFuZCBXZWJwYWNrLlxuaWYgKGdsb2JhbC5mZXRjaCkge1xuXHRleHBvcnRzLmRlZmF1bHQgPSBnbG9iYWwuZmV0Y2guYmluZChnbG9iYWwpO1xufVxuXG5leHBvcnRzLkhlYWRlcnMgPSBnbG9iYWwuSGVhZGVycztcbmV4cG9ydHMuUmVxdWVzdCA9IGdsb2JhbC5SZXF1ZXN0O1xuZXhwb3J0cy5SZXNwb25zZSA9IGdsb2JhbC5SZXNwb25zZTsiLCIvLyBUb3AgbGV2ZWwgZmlsZSBpcyBqdXN0IGEgbWl4aW4gb2Ygc3VibW9kdWxlcyAmIGNvbnN0YW50c1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IERlZmxhdGUsIGRlZmxhdGUsIGRlZmxhdGVSYXcsIGd6aXAgfSA9IHJlcXVpcmUoJy4vbGliL2RlZmxhdGUnKTtcblxuY29uc3QgeyBJbmZsYXRlLCBpbmZsYXRlLCBpbmZsYXRlUmF3LCB1bmd6aXAgfSA9IHJlcXVpcmUoJy4vbGliL2luZmxhdGUnKTtcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9saWIvemxpYi9jb25zdGFudHMnKTtcblxubW9kdWxlLmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVSYXcgPSBkZWZsYXRlUmF3O1xubW9kdWxlLmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG5tb2R1bGUuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5tb2R1bGUuZXhwb3J0cy51bmd6aXAgPSB1bmd6aXA7XG5tb2R1bGUuZXhwb3J0cy5jb25zdGFudHMgPSBjb25zdGFudHM7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuY29uc3QgemxpYl9kZWZsYXRlID0gcmVxdWlyZSgnLi96bGliL2RlZmxhdGUnKTtcbmNvbnN0IHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG5jb25zdCBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbmNvbnN0IG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xuY29uc3QgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcblxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX05PX0ZMVVNILCBaX1NZTkNfRkxVU0gsIFpfRlVMTF9GTFVTSCwgWl9GSU5JU0gsXG4gIFpfT0ssIFpfU1RSRUFNX0VORCxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICBaX0RFRkFVTFRfU1RSQVRFR1ksXG4gIFpfREVGTEFURURcbn0gPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBEZWZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbZGVmbGF0ZV1dLFxuICogW1tkZWZsYXRlUmF3XV0gYW5kIFtbZ3ppcF1dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogRGVmbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbRGVmbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5XG4gKlxuICogQ29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbRGVmbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbRGVmbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgZGVmbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFlvdSB3aWxsIG5vdCBuZWVkIGl0IGluIHJlYWwgbGlmZSwgYmVjYXVzZSBkZWZsYXRlIGVycm9yc1xuICogYXJlIHBvc3NpYmxlIG9ubHkgb24gd3Jvbmcgb3B0aW9ucyBvciBiYWQgYG9uRGF0YWAgLyBgb25FbmRgXG4gKiBjdXN0b20gaGFuZGxlcnMuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tEZWZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBEZWZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGRlZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgbGV2ZWxgXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgbWVtTGV2ZWxgXG4gKiAtIGBzdHJhdGVneWBcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGRlZmxhdGVcbiAqIC0gYGd6aXBgIChCb29sZWFuKSAtIGNyZWF0ZSBnemlwIHdyYXBwZXJcbiAqIC0gYGhlYWRlcmAgKE9iamVjdCkgLSBjdXN0b20gaGVhZGVyIGZvciBnemlwXG4gKiAgIC0gYHRleHRgIChCb29sZWFuKSAtIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHRcbiAqICAgLSBgdGltZWAgKE51bWJlcikgLSBtb2RpZmljYXRpb24gdGltZSwgdW5peCB0aW1lc3RhbXBcbiAqICAgLSBgb3NgIChOdW1iZXIpIC0gb3BlcmF0aW9uIHN5c3RlbSBjb2RlXG4gKiAgIC0gYGV4dHJhYCAoQXJyYXkpIC0gYXJyYXkgb2YgYnl0ZXMgd2l0aCBleHRyYSBkYXRhIChtYXggNjU1MzYpXG4gKiAgIC0gYG5hbWVgIChTdHJpbmcpIC0gZmlsZSBuYW1lIChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBjb21tZW50YCAoU3RyaW5nKSAtIGNvbW1lbnQgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGhjcmNgIChCb29sZWFuKSAtIHRydWUgaWYgaGVhZGVyIGNyYyBzaG91bGQgYmUgYWRkZWRcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IG5ldyBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIGNvbnN0IGRlZmxhdGUgPSBuZXcgcGFrby5EZWZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBkZWZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBkZWZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChkZWZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoZGVmbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coZGVmbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBsZXZlbDogWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgIG1ldGhvZDogWl9ERUZMQVRFRCxcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIG1lbUxldmVsOiA4LFxuICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1lcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgbGV0IG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICBsZXQgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgbGV0IGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIGZsdXNoX21vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIGZsdXNoX21vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0XG4gKiBoYXZlIGBmbHVzaF9tb2RlYCBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmdcbiAqIGJ1ZmZlcnMgYW5kIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0uXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmx1c2hfbW9kZSkge1xuICBjb25zdCBzdHJtID0gdGhpcy5zdHJtO1xuICBjb25zdCBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICBsZXQgc3RhdHVzLCBfZmx1c2hfbW9kZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoZmx1c2hfbW9kZSA9PT0gfn5mbHVzaF9tb2RlKSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGU7XG4gIGVsc2UgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlID09PSB0cnVlID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGZvciAoOzspIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIGF2YWlsX291dCA+IDYgdG8gYXZvaWQgcmVwZWF0aW5nIG1hcmtlcnNcbiAgICBpZiAoKF9mbHVzaF9tb2RlID09PSBaX1NZTkNfRkxVU0ggfHwgX2ZsdXNoX21vZGUgPT09IFpfRlVMTF9GTFVTSCkgJiYgc3RybS5hdmFpbF9vdXQgPD0gNikge1xuICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuXG4gICAgLy8gRW5kZWQgPT4gZmx1c2ggYW5kIGZpbmlzaFxuICAgIGlmIChzdGF0dXMgPT09IFpfU1RSRUFNX0VORCkge1xuICAgICAgaWYgKHN0cm0ubmV4dF9vdXQgPiAwKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggaWYgb3V0IGJ1ZmZlciBmdWxsXG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBGbHVzaCBpZiByZXF1ZXN0ZWQgYW5kIGhhcyBkYXRhXG4gICAgaWYgKF9mbHVzaF9tb2RlID4gMCAmJiBzdHJtLm5leHRfb3V0ID4gMCkge1xuICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDApIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXkpOiBvdXRwdXQgZGF0YS5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGRlZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIG9uY2UgYWZ0ZXIgeW91IHRlbGwgZGVmbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogZGVmbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXlcbiAqIC0gZGF0YSAoVWludDhBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwYWtvLmRlZmxhdGUoZGF0YSkpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXlcbiAqIC0gZGF0YSAoVWludDhBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBnemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheVxuICogLSBkYXRhIChVaW50OEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkIG9mXG4gKiBkZWZsYXRlIG9uZS5cbiAqKi9cbmZ1bmN0aW9uIGd6aXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuZ3ppcCA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7XG5tb2R1bGUuZXhwb3J0cy5nemlwID0gZ3ppcDtcbm1vZHVsZS5leHBvcnRzLmNvbnN0YW50cyA9IHJlcXVpcmUoJy4vemxpYi9jb25zdGFudHMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5jb25zdCB6bGliX2luZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvaW5mbGF0ZScpO1xuY29uc3QgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbmNvbnN0IHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xuY29uc3QgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG5jb25zdCBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuY29uc3QgR1poZWFkZXIgICAgID0gcmVxdWlyZSgnLi96bGliL2d6aGVhZGVyJyk7XG5cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9OT19GTFVTSCwgWl9GSU5JU0gsXG4gIFpfT0ssIFpfU1RSRUFNX0VORCwgWl9ORUVEX0RJQ1QsIFpfU1RSRUFNX0VSUk9SLCBaX0RBVEFfRVJST1IsIFpfTUVNX0VSUk9SXG59ID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgSW5mbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXVxuICogYW5kIFtbaW5mbGF0ZVJhd11dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fFN0cmluZ1xuICpcbiAqIFVuY29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbSW5mbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbSW5mbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbSW5mbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgSW5mbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBpbmZsYXRlXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gbm8gb3B0aW9ucyBzZXQsIGF1dG9kZXRlY3QgZGVmbGF0ZS9nemlwIGRhdGEgZm9ybWF0IHZpYVxuICogd3JhcHBlciBoZWFkZXIuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiBjb25zdCBjaHVuazEgPSBuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogY29uc3QgY2h1bmsyID0gbmV3IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogY29uc3QgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTAyNCAqIDY0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICBjb25zdCBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgLy8gRm9yY2Ugd2luZG93IHNpemUgZm9yIGByYXdgIGRhdGEsIGlmIG5vdCBzZXQgZGlyZWN0bHksXG4gIC8vIGJlY2F1c2Ugd2UgaGF2ZSBubyBoZWFkZXIgZm9yIGF1dG9kZXRlY3QuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsgb3B0LndpbmRvd0JpdHMgPSAtMTU7IH1cbiAgfVxuXG4gIC8vIElmIGB3aW5kb3dCaXRzYCBub3QgZGVmaW5lZCAoYW5kIG1vZGUgbm90IHJhdykgLSBzZXQgYXV0b2RldGVjdCBmbGFnIGZvciBnemlwL2RlZmxhdGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikgJiZcbiAgICAgICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7XG4gIH1cblxuICAvLyBHemlwIGhlYWRlciBoYXMgbm8gaW5mbyBhYm91dCB3aW5kb3dzIHNpemUsIHdlIGNhbiBkbyBhdXRvZGV0ZWN0IG9ubHlcbiAgLy8gZm9yIGRlZmxhdGUuIFNvLCBpZiB3aW5kb3cgc2l6ZSBub3Qgc2V0LCBmb3JjZSBpdCB0byBtYXggd2hlbiBnemlwIHBvc3NpYmxlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPiAxNSkgJiYgKG9wdC53aW5kb3dCaXRzIDwgNDgpKSB7XG4gICAgLy8gYml0IDMgKDE2KSAtPiBnemlwcGVkIGRhdGFcbiAgICAvLyBiaXQgNCAoMzIpIC0+IGF1dG9kZXRlY3QgZ3ppcC9kZWZsYXRlXG4gICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkge1xuICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtICAgPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICBsZXQgc3RhdHVzICA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC53aW5kb3dCaXRzXG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBHWmhlYWRlcigpO1xuXG4gIHpsaWJfaW5mbGF0ZS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpO1xuXG4gIC8vIFNldHVwIGRpY3Rpb25hcnlcbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfVxuICAgIGlmIChvcHQucmF3KSB7IC8vSW4gcmF3IG1vZGUgd2UgbmVlZCB0byBzZXQgdGhlIGRpY3Rpb25hcnkgZWFybHlcbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIG9wdC5kaWN0aW9uYXJ5KTtcbiAgICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIGZsdXNoX21vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXIpOiBpbnB1dCBkYXRhXG4gKiAtIGZsdXNoX21vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUVcbiAqICAgZmx1c2ggbW9kZXMuIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILFxuICogICBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBJZiBlbmQgb2Ygc3RyZWFtIGRldGVjdGVkLFxuICogW1tJbmZsYXRlI29uRW5kXV0gd2lsbCBiZSBjYWxsZWQuXG4gKlxuICogYGZsdXNoX21vZGVgIGlzIG5vdCBuZWVkZWQgZm9yIG5vcm1hbCBvcGVyYXRpb24sIGJlY2F1c2UgZW5kIG9mIHN0cmVhbVxuICogZGV0ZWN0ZWQgYXV0b21hdGljYWxseS4gWW91IG1heSB0cnkgdG8gdXNlIGl0IGZvciBhZHZhbmNlZCB0aGluZ3MsIGJ1dFxuICogdGhpcyBmdW5jdGlvbmFsaXR5IHdhcyBub3QgdGVzdGVkLlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZsdXNoX21vZGUpIHtcbiAgY29uc3Qgc3RybSA9IHRoaXMuc3RybTtcbiAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgY29uc3QgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICBsZXQgc3RhdHVzLCBfZmx1c2hfbW9kZSwgbGFzdF9hdmFpbF9vdXQ7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHJldHVybiBmYWxzZTtcblxuICBpZiAoZmx1c2hfbW9kZSA9PT0gfn5mbHVzaF9tb2RlKSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGU7XG4gIGVsc2UgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlID09PSB0cnVlID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgVWludDhBcnJheShjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG5cbiAgICBpZiAoc3RhdHVzID09PSBaX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSk7XG5cbiAgICAgIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFpfREFUQV9FUlJPUikge1xuICAgICAgICAvLyBSZXBsYWNlIGNvZGUgd2l0aCBtb3JlIHZlcmJvc2VcbiAgICAgICAgc3RhdHVzID0gWl9ORUVEX0RJQ1Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2tpcCBzbnljIG1hcmtlcnMgaWYgbW9yZSBkYXRhIGZvbGxvd3MgYW5kIG5vdCByYXcgbW9kZVxuICAgIHdoaWxlIChzdHJtLmF2YWlsX2luID4gMCAmJlxuICAgICAgICAgICBzdGF0dXMgPT09IFpfU1RSRUFNX0VORCAmJlxuICAgICAgICAgICBzdHJtLnN0YXRlLndyYXAgPiAwICYmXG4gICAgICAgICAgIGRhdGFbc3RybS5uZXh0X2luXSAhPT0gMClcbiAgICB7XG4gICAgICB6bGliX2luZmxhdGUuaW5mbGF0ZVJlc2V0KHN0cm0pO1xuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIFpfU1RSRUFNX0VSUk9SOlxuICAgICAgY2FzZSBaX0RBVEFfRVJST1I6XG4gICAgICBjYXNlIFpfTkVFRF9ESUNUOlxuICAgICAgY2FzZSBaX01FTV9FUlJPUjpcbiAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJlbWVtYmVyIHJlYWwgYGF2YWlsX291dGAgdmFsdWUsIGJlY2F1c2Ugd2UgbWF5IHBhdGNoIG91dCBidWZmZXIgY29udGVudFxuICAgIC8vIHRvIGFsaWduIHV0Zjggc3RyaW5ncyBib3VuZGFyaWVzLlxuICAgIGxhc3RfYXZhaWxfb3V0ID0gc3RybS5hdmFpbF9vdXQ7XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgIGxldCBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTtcblxuICAgICAgICAgIGxldCB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgbGV0IHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpO1xuXG4gICAgICAgICAgLy8gbW92ZSB0YWlsICYgcmVhbGlnbiBjb3VudGVyc1xuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsO1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDtcbiAgICAgICAgICBpZiAodGFpbCkgc3RybS5vdXRwdXQuc2V0KHN0cm0ub3V0cHV0LnN1YmFycmF5KG5leHRfb3V0X3V0ZjgsIG5leHRfb3V0X3V0ZjggKyB0YWlsKSwgMCk7XG5cbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0Lmxlbmd0aCA9PT0gc3RybS5uZXh0X291dCA/IHN0cm0ub3V0cHV0IDogc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTXVzdCByZXBlYXQgaXRlcmF0aW9uIGlmIG91dCBidWZmZXIgaXMgZnVsbFxuICAgIGlmIChzdGF0dXMgPT09IFpfT0sgJiYgbGFzdF9hdmFpbF9vdXQgPT09IDApIGNvbnRpbnVlO1xuXG4gICAgLy8gRmluYWxpemUgaWYgZW5kIG9mIHN0cmVhbSByZWFjaGVkLlxuICAgIGlmIChzdGF0dXMgPT09IFpfU1RSRUFNX0VORCkge1xuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDApIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGVhY2ggY2h1bmsgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheSk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0XG4gKiBmb3JtYXQgdmlhIHdyYXBwZXIgaGVhZGVyIGJ5IGRlZmF1bHQuIFRoYXQncyB3aHkgd2UgZG9uJ3QgcHJvdmlkZVxuICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIHdpbmRvd0JpdHNcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJyk7XG4gKiBjb25zdCBpbnB1dCA9IHBha28uZGVmbGF0ZShuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKSk7XG4gKiBsZXQgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgY29uc3QgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICBpbmZsYXRvci5wdXNoKGlucHV0KTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoaW5mbGF0b3IuZXJyKSB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5KTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5KTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbm1vZHVsZS5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdztcbm1vZHVsZS5leHBvcnRzLnVuZ3ppcCA9IGluZmxhdGU7XG5tb2R1bGUuZXhwb3J0cy5jb25zdGFudHMgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuY29uc3QgX2hhcyA9IChvYmosIGtleSkgPT4ge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICBjb25zdCBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgY29uc3Qgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbm1vZHVsZS5leHBvcnRzLmZsYXR0ZW5DaHVua3MgPSAoY2h1bmtzKSA9PiB7XG4gIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICBsZXQgbGVuID0gMDtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgfVxuXG4gIC8vIGpvaW4gY2h1bmtzXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG5cbiAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGV0IGNodW5rID0gY2h1bmtzW2ldO1xuICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIFF1aWNrIGNoZWNrIGlmIHdlIGNhbiB1c2UgZmFzdCBhcnJheSB0byBiaW4gc3RyaW5nIGNvbnZlcnNpb25cbi8vXG4vLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMlxuLy8gLSBhcHBseShVaW50OEFycmF5KSBjYW4gZmFpbCBvbiBpT1MgNS4xIFNhZmFyaVxuLy9cbmxldCBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxuY29uc3QgX3V0ZjhsZW4gPSBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yIChsZXQgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbm1vZHVsZS5leHBvcnRzLnN0cmluZzJidWYgPSAoc3RyKSA9PiB7XG4gIGxldCBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyXG5jb25zdCBidWYyYmluc3RyaW5nID0gKGJ1ZiwgbGVuKSA9PiB7XG4gIC8vIE9uIENocm9tZSwgdGhlIGFyZ3VtZW50cyBpbiBhIGZ1bmN0aW9uIGNhbGwgdGhhdCBhcmUgYWxsb3dlZCBpcyBgNjU1MzRgLlxuICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaXMgc21hbGxlciB0aGFuIHRoYXQsIHdlIGNhbiB1c2UgdGhpcyBvcHRpbWl6YXRpb24sXG4gIC8vIG90aGVyd2lzZSB3ZSB3aWxsIHRha2UgYSBzbG93ZXIgcGF0aC5cbiAgaWYgKGxlbiA8IDY1NTM0KSB7XG4gICAgaWYgKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBidWYubGVuZ3RoID09PSBsZW4gPyBidWYgOiBidWYuc3ViYXJyYXkoMCwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMuYnVmMnN0cmluZyA9IChidWYsIG1heCkgPT4ge1xuICBsZXQgaSwgb3V0O1xuICBjb25zdCBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICBjb25zdCB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGxldCBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgbGV0IGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4gLSAxOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbm1vZHVsZS5leHBvcnRzLnV0Zjhib3JkZXIgPSAoYnVmLCBtYXgpID0+IHtcblxuICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICBsZXQgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgYWRsZXIzMiA9IChhZGxlciwgYnVmLCBsZW4sIHBvcykgPT4ge1xuICBsZXQgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgWl9NRU1fRVJST1I6ICAgICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmNvbnN0IG1ha2VUYWJsZSA9ICgpID0+IHtcbiAgbGV0IGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59O1xuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxuY29uc3QgY3JjVGFibGUgPSBuZXcgVWludDMyQXJyYXkobWFrZVRhYmxlKCkpO1xuXG5cbmNvbnN0IGNyYzMyID0gKGNyYywgYnVmLCBsZW4sIHBvcykgPT4ge1xuICBjb25zdCB0ID0gY3JjVGFibGU7XG4gIGNvbnN0IGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjcmMzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5jb25zdCB7IF90cl9pbml0LCBfdHJfc3RvcmVkX2Jsb2NrLCBfdHJfZmx1c2hfYmxvY2ssIF90cl90YWxseSwgX3RyX2FsaWduIH0gPSByZXF1aXJlKCcuL3RyZWVzJyk7XG5jb25zdCBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG5jb25zdCBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xuY29uc3QgbXNnICAgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9OT19GTFVTSCwgWl9QQVJUSUFMX0ZMVVNILCBaX0ZVTExfRkxVU0gsIFpfRklOSVNILCBaX0JMT0NLLFxuICBaX09LLCBaX1NUUkVBTV9FTkQsIFpfU1RSRUFNX0VSUk9SLCBaX0RBVEFfRVJST1IsIFpfQlVGX0VSUk9SLFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gIFpfRklMVEVSRUQsIFpfSFVGRk1BTl9PTkxZLCBaX1JMRSwgWl9GSVhFRCwgWl9ERUZBVUxUX1NUUkFURUdZLFxuICBaX1VOS05PV04sXG4gIFpfREVGTEFURURcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmNvbnN0IE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG5jb25zdCBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xuY29uc3QgREVGX01FTV9MRVZFTCA9IDg7XG5cblxuY29uc3QgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5jb25zdCBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5jb25zdCBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5jb25zdCBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbmNvbnN0IEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuY29uc3QgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5jb25zdCBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG5jb25zdCBNSU5fTUFUQ0ggPSAzO1xuY29uc3QgTUFYX01BVENIID0gMjU4O1xuY29uc3QgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxuY29uc3QgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG5jb25zdCBJTklUX1NUQVRFID0gNDI7XG5jb25zdCBFWFRSQV9TVEFURSA9IDY5O1xuY29uc3QgTkFNRV9TVEFURSA9IDczO1xuY29uc3QgQ09NTUVOVF9TVEFURSA9IDkxO1xuY29uc3QgSENSQ19TVEFURSA9IDEwMztcbmNvbnN0IEJVU1lfU1RBVEUgPSAxMTM7XG5jb25zdCBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbmNvbnN0IEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG5jb25zdCBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xuY29uc3QgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xuY29uc3QgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbmNvbnN0IE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5jb25zdCBlcnIgPSAoc3RybSwgZXJyb3JDb2RlKSA9PiB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59O1xuXG5jb25zdCByYW5rID0gKGYpID0+IHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn07XG5cbmNvbnN0IHplcm8gPSAoYnVmKSA9PiB7XG4gIGxldCBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH1cbn07XG5cblxuLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xubGV0IEhBU0hfWkxJQiA9IChzLCBwcmV2LCBkYXRhKSA9PiAoKHByZXYgPDwgcy5oYXNoX3NoaWZ0KSBeIGRhdGEpICYgcy5oYXNoX21hc2s7XG4vLyBUaGlzIGhhc2ggY2F1c2VzIGxlc3MgY29sbGlzaW9ucywgaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL2lzc3Vlcy8xMzVcbi8vIEJ1dCBicmVha3MgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vbGV0IEhBU0hfRkFTVCA9IChzLCBwcmV2LCBkYXRhKSA9PiAoKHByZXYgPDwgOCkgKyAocHJldiA+PiA4KSArIChkYXRhIDw8IDQpKSAmIHMuaGFzaF9tYXNrO1xubGV0IEhBU0ggPSBIQVNIX1pMSUI7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmNvbnN0IGZsdXNoX3BlbmRpbmcgPSAoc3RybSkgPT4ge1xuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICBsZXQgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHN0cm0ub3V0cHV0LnNldChzLnBlbmRpbmdfYnVmLnN1YmFycmF5KHMucGVuZGluZ19vdXQsIHMucGVuZGluZ19vdXQgKyBsZW4pLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59O1xuXG5cbmNvbnN0IGZsdXNoX2Jsb2NrX29ubHkgPSAocywgbGFzdCkgPT4ge1xuICBfdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn07XG5cblxuY29uc3QgcHV0X2J5dGUgPSAocywgYikgPT4ge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuY29uc3QgcHV0U2hvcnRNU0IgPSAocywgYikgPT4ge1xuXG4gIC8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5jb25zdCByZWFkX2J1ZiA9IChzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSA9PiB7XG5cbiAgbGV0IGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIGJ1Zi5zZXQoc3RybS5pbnB1dC5zdWJhcnJheShzdHJtLm5leHRfaW4sIHN0cm0ubmV4dF9pbiArIGxlbiksIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuY29uc3QgbG9uZ2VzdF9tYXRjaCA9IChzLCBjdXJfbWF0Y2gpID0+IHtcblxuICBsZXQgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICBsZXQgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIGxldCBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIGxldCBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgbGV0IGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICBsZXQgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICBjb25zdCBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIGNvbnN0IF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICBjb25zdCB3bWFzayA9IHMud19tYXNrO1xuICBjb25zdCBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICBjb25zdCBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICBsZXQgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIGxldCBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5jb25zdCBmaWxsX3dpbmRvdyA9IChzKSA9PiB7XG5cbiAgY29uc3QgX3dfc2l6ZSA9IHMud19zaXplO1xuICBsZXQgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICBzLndpbmRvdy5zZXQocy53aW5kb3cuc3ViYXJyYXkoX3dfc2l6ZSwgX3dfc2l6ZSArIF93X3NpemUpLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyAxXSk7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgY29uc3QgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIGxldCBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuY29uc3QgZGVmbGF0ZV9zdG9yZWQgPSAocywgZmx1c2gpID0+IHtcblxuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIGxldCBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgY29uc3QgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovXG4gICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7XG4gICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cblxuXG4gICAgfVxuICAgIC8qIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxuICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuXG4gIHMuaW5zZXJ0ID0gMDtcblxuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfTkVFRF9NT1JFO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmNvbnN0IGRlZmxhdGVfZmFzdCA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBoYXNoX2hlYWQ7ICAgICAgICAvKiBoZWFkIG9mIHRoZSBoYXNoIGNoYWluICovXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSk7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmNvbnN0IGRlZmxhdGVfc2xvdyA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICBsZXQgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgbGV0IG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSk7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmNvbnN0IGRlZmxhdGVfcmxlID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgbGV0IHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICBsZXQgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICBjb25zdCBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5jb25zdCBkZWZsYXRlX2h1ZmYgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcblxuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxuY29uc3QgY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5jb25zdCBsbV9pbml0ID0gKHMpID0+IHtcblxuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufTtcblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi9cblxuICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAgLyogbG9nMih3X3NpemUpICAoOC4uMTYpICovXG4gIHRoaXMud19tYXNrID0gMDsgIC8qIHdfc2l6ZSAtIDEgKi9cblxuICB0aGlzLndpbmRvdyA9IG51bGw7XG4gIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgKiBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxuICAgKiBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXG4gICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgKiBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICovXG5cbiAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7XG4gIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAqIGlzIGRpcmVjdGx5IHVzZWQgYXMgc2xpZGluZyB3aW5kb3cuXG4gICAqL1xuXG4gIHRoaXMucHJldiA9IG51bGw7XG4gIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXG4gICAqIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAqIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxuICAgKi9cblxuICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovXG5cbiAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovXG4gIHRoaXMuaGFzaF9zaXplID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7ICAgLyogbG9nMihoYXNoX3NpemUpICovXG4gIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqL1xuXG4gIHRoaXMuaGFzaF9zaGlmdCA9IDA7XG4gIC8qIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XG4gICAqIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxuICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICogICBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuICAgKi9cblxuICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXG4gICAqIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG4gICAqL1xuXG4gIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsgICAgICAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi9cbiAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOyAgIC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7ICAgICAgICAgIC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7ICAgICAgICAgLyogbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvdyAqL1xuXG4gIHRoaXMucHJldl9sZW5ndGggPSAwO1xuICAvKiBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXG4gICAqL1xuXG4gIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7XG4gIC8qIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXG4gICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGVcbiAgICogc3BlZWQuXG4gICAqL1xuXG4gIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwO1xuICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAqIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXG4gICAqIGxldmVscyA+PSA0LlxuICAgKi9cbiAgLy8gVGhhdCdzIGFsaWFzIHRvIG1heF9sYXp5X21hdGNoLCBkb24ndCB1c2UgZGlyZWN0bHlcbiAgLy90aGlzLm1heF9pbnNlcnRfbGVuZ3RoID0gMDtcbiAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICogZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgKiBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxuICAgKi9cblxuICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgIC8qIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nKi9cblxuICB0aGlzLmdvb2RfbWF0Y2ggPSAwO1xuICAvKiBVc2UgYSBmYXN0ZXIgc2VhcmNoIHdoZW4gdGhlIHByZXZpb3VzIG1hdGNoIGlzIGxvbmdlciB0aGFuIHRoaXMgKi9cblxuICB0aGlzLm5pY2VfbWF0Y2ggPSAwOyAvKiBTdG9wIHNlYXJjaGluZyB3aGVuIGN1cnJlbnQgbWF0Y2ggZXhjZWVkcyB0aGlzICovXG5cbiAgICAgICAgICAgICAgLyogdXNlZCBieSB0cmVlcy5jOiAqL1xuXG4gIC8qIERpZG4ndCB1c2UgY3RfZGF0YSB0eXBlZGVmIGJlbG93IHRvIHN1cHByZXNzIGNvbXBpbGVyIHdhcm5pbmcgKi9cblxuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9sdHJlZVtIRUFQX1NJWkVdOyAgIC8qIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGJsX3RyZWVbMipCTF9DT0RFUysxXTsgIC8qIEh1ZmZtYW4gdHJlZSBmb3IgYml0IGxlbmd0aHMgKi9cblxuICAvLyBVc2UgZmxhdCBhcnJheSBvZiBET1VCTEUgc2l6ZSwgd2l0aCBpbnRlcmxlYXZlZCBmYXRhLFxuICAvLyBiZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgZWZmZWN0aXZlXG4gIHRoaXMuZHluX2x0cmVlICA9IG5ldyBVaW50MTZBcnJheShIRUFQX1NJWkUgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IFVpbnQxNkFycmF5KCgyICogRF9DT0RFUyArIDEpICogMik7XG4gIHRoaXMuYmxfdHJlZSAgICA9IG5ldyBVaW50MTZBcnJheSgoMiAqIEJMX0NPREVTICsgMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgVWludDE2QXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyBVaW50MTZBcnJheSgyICogTF9DT0RFUyArIDEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IFVpbnQxNkFycmF5KDIgKiBMX0NPREVTICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyh0aGlzLmRlcHRoKTtcbiAgLyogRGVwdGggb2YgZWFjaCBzdWJ0cmVlIHVzZWQgYXMgdGllIGJyZWFrZXIgZm9yIHRyZWVzIG9mIGVxdWFsIGZyZXF1ZW5jeVxuICAgKi9cblxuICB0aGlzLmxfYnVmID0gMDsgICAgICAgICAgLyogYnVmZmVyIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMubGFzdF9saXQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cblxuICB0aGlzLmRfYnVmID0gMDtcbiAgLyogQnVmZmVyIGluZGV4IGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxuICAgKiB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xuICAgKiBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuXG4gICAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG5jb25zdCBkZWZsYXRlUmVzZXRLZWVwID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIF90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn07XG5cblxuY29uc3QgZGVmbGF0ZVJlc2V0ID0gKHN0cm0pID0+IHtcblxuICBjb25zdCByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBkZWZsYXRlU2V0SGVhZGVyID0gKHN0cm0sIGhlYWQpID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVJbml0MiA9IChzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpID0+IHtcblxuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBsZXQgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICBjb25zdCBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuXG4gIHMud3JhcCA9IHdyYXA7XG4gIHMuZ3poZWFkID0gbnVsbDtcbiAgcy53X2JpdHMgPSB3aW5kb3dCaXRzO1xuICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7XG4gIHMud19tYXNrID0gcy53X3NpemUgLSAxO1xuXG4gIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7XG4gIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxO1xuICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XG5cbiAgcy53aW5kb3cgPSBuZXcgVWludDhBcnJheShzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgVWludDE2QXJyYXkocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgVWludDE2QXJyYXkocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuXG4gIC8vb3ZlcmxheSA9ICh1c2hmICopIFpBTExPQyhzdHJtLCBzLT5saXRfYnVmc2l6ZSwgc2l6ZW9mKHVzaCkrMik7XG4gIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IFVpbnQ4QXJyYXkocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICAvLyBJdCBpcyBvZmZzZXQgZnJvbSBgcy5wZW5kaW5nX2J1ZmAgKHNpemUgaXMgYHMubGl0X2J1ZnNpemUgKiAyYClcbiAgLy9zLT5kX2J1ZiA9IG92ZXJsYXkgKyBzLT5saXRfYnVmc2l6ZS9zaXplb2YodXNoKTtcbiAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufTtcblxuY29uc3QgZGVmbGF0ZUluaXQgPSAoc3RybSwgbGV2ZWwpID0+IHtcblxuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGUgPSAoc3RybSwgZmx1c2gpID0+IHtcblxuICBsZXQgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgY29uc3Qgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIGxldCBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIGxldCBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICBsZXQgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICBfdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufTtcblxuXG5jb25zdCBkZWZsYXRlRW5kID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIGNvbnN0IHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5jb25zdCBkZWZsYXRlU2V0RGljdGlvbmFyeSA9IChzdHJtLCBkaWN0aW9uYXJ5KSA9PiB7XG5cbiAgbGV0IGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuICBjb25zdCB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgbGV0IHRtcERpY3QgPSBuZXcgVWludDhBcnJheShzLndfc2l6ZSk7XG4gICAgdG1wRGljdC5zZXQoZGljdGlvbmFyeS5zdWJhcnJheShkaWN0TGVuZ3RoIC0gcy53X3NpemUsIGRpY3RMZW5ndGgpLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgY29uc3QgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBjb25zdCBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBjb25zdCBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBsZXQgc3RyID0gcy5zdHJzdGFydDtcbiAgICBsZXQgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKTtcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0Mjtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVJbmZvID0gJ3Bha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBHWmhlYWRlcigpIHtcbiAgLyogdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dCAqL1xuICB0aGlzLnRleHQgICAgICAgPSAwO1xuICAvKiBtb2RpZmljYXRpb24gdGltZSAqL1xuICB0aGlzLnRpbWUgICAgICAgPSAwO1xuICAvKiBleHRyYSBmbGFncyAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLnhmbGFncyAgICAgPSAwO1xuICAvKiBvcGVyYXRpbmcgc3lzdGVtICovXG4gIHRoaXMub3MgICAgICAgICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi9cbiAgdGhpcy5leHRyYSAgICAgID0gbnVsbDtcbiAgLyogZXh0cmEgZmllbGQgbGVuZ3RoICh2YWxpZCBpZiBleHRyYSAhPSBaX05VTEwpICovXG4gIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLFxuICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbGVhdmUgZm9yIGZldyBjb2RlIG1vZGlmaWNhdGlvbnNcblxuICAvL1xuICAvLyBTZXR1cCBsaW1pdHMgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5XG4gIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlc1xuICAvL1xuXG4gIC8qIHNwYWNlIGF0IGV4dHJhIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuZXh0cmFfbWF4ICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi9cbiAgdGhpcy5uYW1lICAgICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IG5hbWUgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5uYW1lX21heCAgID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgY29tbWVudCBvciBaX05VTEwgKi9cbiAgdGhpcy5jb21tZW50ICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5jb21tX21heCAgID0gMDtcbiAgLyogdHJ1ZSBpZiB0aGVyZSB3YXMgb3Igd2lsbCBiZSBhIGhlYWRlciBjcmMgKi9cbiAgdGhpcy5oY3JjICAgICAgID0gMDtcbiAgLyogdHJ1ZSB3aGVuIGRvbmUgcmVhZGluZyBnemlwIGhlYWRlciAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLmRvbmUgICAgICAgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHWmhlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbmNvbnN0IEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICBsZXQgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICBsZXQgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIGxldCBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICBsZXQgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICBsZXQgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBsZXQgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICBsZXQgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIGxldCB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIGxldCB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgbGV0IHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICBsZXQgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgbGV0IGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICBsZXQgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICBsZXQgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIGxldCBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICBsZXQgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIGxldCBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIGxldCBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICBsZXQgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgbGV0IGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICBsZXQgZnJvbV9zb3VyY2U7XG5cblxuICBsZXQgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICAgICAgICBpZiAobGVuIDw9IG9wIC0gd2hhdmUpIHtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICBsZW4gLT0gb3AgLSB3aGF2ZTtcbi8vICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCA+IHdoYXZlKTtcbi8vICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbSA9IDA7IC8vIHdpbmRvdyBpbmRleFxuICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93O1xuICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh3bmV4dCA8IG9wKSB7ICAgICAgLyogd3JhcCBhcm91bmQgd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIGVuZCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgeyAgLyogc29tZSBmcm9tIHN0YXJ0IG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0O1xuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbnRpZ3VvdXMgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgICAgICAvKiBjb3B5IGRpcmVjdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgLyogbWluaW11bSBsZW5ndGggaXMgdGhyZWUgKi9cbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgLyogMm5kIGxldmVsIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICAgICAgY29udGludWUgZG9kaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICB9XG4gIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7XG5cbiAgLyogcmV0dXJuIHVudXNlZCBieXRlcyAob24gZW50cnksIGJpdHMgPCA4LCBzbyBpbiB3b24ndCBnbyB0b28gZmFyIGJhY2spICovXG4gIGxlbiA9IGJpdHMgPj4gMztcbiAgX2luIC09IGxlbjtcbiAgYml0cyAtPSBsZW4gPDwgMztcbiAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXR1cm4gKi9cbiAgc3RybS5uZXh0X2luID0gX2luO1xuICBzdHJtLm5leHRfb3V0ID0gX291dDtcbiAgc3RybS5hdmFpbF9pbiA9IChfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCkpO1xuICBzdHJtLmF2YWlsX291dCA9IChfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpKTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICByZXR1cm47XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IGFkbGVyMzIgICAgICAgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbmNvbnN0IGNyYzMyICAgICAgICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG5jb25zdCBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG5jb25zdCBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG5jb25zdCBDT0RFUyA9IDA7XG5jb25zdCBMRU5TID0gMTtcbmNvbnN0IERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9GSU5JU0gsIFpfQkxPQ0ssIFpfVFJFRVMsXG4gIFpfT0ssIFpfU1RSRUFNX0VORCwgWl9ORUVEX0RJQ1QsIFpfU1RSRUFNX0VSUk9SLCBaX0RBVEFfRVJST1IsIFpfTUVNX0VSUk9SLCBaX0JVRl9FUlJPUixcbiAgWl9ERUZMQVRFRFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuY29uc3QgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xuY29uc3QgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG5jb25zdCAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG5jb25zdCAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG5jb25zdCAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xuY29uc3QgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xuY29uc3QgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG5jb25zdCAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG5jb25zdCAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbmNvbnN0ICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG5jb25zdCAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG5jb25zdCAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbmNvbnN0ICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xuY29uc3QgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xuY29uc3QgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xuY29uc3QgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xuY29uc3QgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbmNvbnN0ICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG5jb25zdCAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuY29uc3QgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbmNvbnN0ICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbmNvbnN0ICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG5jb25zdCAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG5jb25zdCAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG5jb25zdCAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbmNvbnN0ICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG5jb25zdCAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG5jb25zdCAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbmNvbnN0ICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0ICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxuY29uc3QgRU5PVUdIX0xFTlMgPSA4NTI7XG5jb25zdCBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL2NvbnN0IEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxuY29uc3QgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbmNvbnN0IERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5jb25zdCB6c3dhcDMyID0gKHEpID0+IHtcblxuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn07XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IFVpbnQxNkFycmF5KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IFVpbnQxNkFycmF5KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cblxuY29uc3QgaW5mbGF0ZVJlc2V0S2VlcCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IEludDMyQXJyYXkoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVSZXNldCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59O1xuXG5cbmNvbnN0IGluZmxhdGVSZXNldDIgPSAoc3RybSwgd2luZG93Qml0cykgPT4ge1xuICBsZXQgd3JhcDtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovXG4gIHN0YXRlLndyYXAgPSB3cmFwO1xuICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7XG4gIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVJbml0MiA9IChzdHJtLCB3aW5kb3dCaXRzKSA9PiB7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBjb25zdCBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgY29uc3QgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBpbmZsYXRlSW5pdCA9IChzdHJtKSA9PiB7XG5cbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufTtcblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG5sZXQgdmlyZ2luID0gdHJ1ZTtcblxubGV0IGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuXG5jb25zdCBmaXhlZHRhYmxlcyA9IChzdGF0ZSkgPT4ge1xuXG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICBsZW5maXggPSBuZXcgSW50MzJBcnJheSg1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgSW50MzJBcnJheSgzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIGxldCBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn07XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmNvbnN0IHVwZGF0ZXdpbmRvdyA9IChzdHJtLCBzcmMsIGVuZCwgY29weSkgPT4ge1xuXG4gIGxldCBkaXN0O1xuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgVWludDhBcnJheShzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICBzdGF0ZS53aW5kb3cuc2V0KHNyYy5zdWJhcnJheShlbmQgLSBzdGF0ZS53c2l6ZSwgZW5kKSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIGNvcHksIGVuZCAtIGNvcHkgKyBkaXN0KSwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgc3RhdGUud2luZG93LnNldChzcmMuc3ViYXJyYXkoZW5kIC0gY29weSwgZW5kKSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn07XG5cblxuY29uc3QgaW5mbGF0ZSA9IChzdHJtLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBzdGF0ZTtcbiAgbGV0IGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIGxldCBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIGxldCBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICBsZXQgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICBsZXQgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICBsZXQgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIGxldCBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgbGV0IGZyb21fc291cmNlO1xuICBsZXQgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICBsZXQgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy9sZXQgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIGxldCBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICBsZXQgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgY29uc3QgaGJ1ZiA9IG5ldyBVaW50OEFycmF5KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICBsZXQgb3B0cztcblxuICBsZXQgbjsgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlIGZvciBORUVEX0JJVFNcblxuICBjb25zdCBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIG5ldyBVaW50OEFycmF5KFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdKTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSztcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICAgIGNhc2UgSEVBRDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICEhISBwYWtvIHBhdGNoLiBGb3JjZSB1c2UgYG9wdGlvbnMud2luZG93Qml0c2AgaWYgcGFzc2VkLlxuICAgICAgICAvLyBSZXF1aXJlZCB0byBhbHdheXMgdXNlIG1heCB3aW5kb3cgc2l6ZSBieSBkZWZhdWx0LlxuICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICAgICAgLy9zdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG5cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVElNRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhUUkE6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW50IHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IFVpbnQ4QXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEuc2V0KFxuICAgICAgICAgICAgICAgIGlucHV0LnN1YmFycmF5KFxuICAgICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgICAgICBuZXh0ICsgY29weVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOQU1FOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBIQ1JDOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJQ1RJRDpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESUNUOlxuICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEU6XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFRE86XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMTtcbiAgICAgICAgYml0cyAtPSAxO1xuICAgICAgICAvLy0tLS8vXG5cbiAgICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU1RPUkVEOlxuICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWTpcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICAgIG91dHB1dC5zZXQoaW5wdXQuc3ViYXJyYXkobmV4dCwgbmV4dCArIGNvcHkpLCBwdXQpO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPREVMRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5fOlxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTjpcbiAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgICAvLy0tLVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVORVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1Q6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1RFWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExJVDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGxlZnQtLTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENIRUNLOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIC8vIFVzZSAnfCcgaW5zdGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkdUSDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUVuZCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBsZXQgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVHZXRIZWFkZXIgPSAoc3RybSwgaGVhZCkgPT4ge1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSztcbn07XG5cblxuY29uc3QgaW5mbGF0ZVNldERpY3Rpb25hcnkgPSAoc3RybSwgZGljdGlvbmFyeSkgPT4ge1xuICBjb25zdCBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgbGV0IHN0YXRlO1xuICBsZXQgZGljdGlkO1xuICBsZXQgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0Mjtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0Mjtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlQ29weSA9IGluZmxhdGVDb3B5O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlUHJpbWUgPSBpbmZsYXRlUHJpbWU7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlVW5kZXJtaW5lID0gaW5mbGF0ZVVuZGVybWluZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgTUFYQklUUyA9IDE1O1xuY29uc3QgRU5PVUdIX0xFTlMgPSA4NTI7XG5jb25zdCBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL2NvbnN0IEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG5jb25zdCBDT0RFUyA9IDA7XG5jb25zdCBMRU5TID0gMTtcbmNvbnN0IERJU1RTID0gMjtcblxuY29uc3QgbGJhc2UgPSBuZXcgVWludDE2QXJyYXkoWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXSk7XG5cbmNvbnN0IGxleHQgPSBuZXcgVWludDhBcnJheShbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXSk7XG5cbmNvbnN0IGRiYXNlID0gbmV3IFVpbnQxNkFycmF5KFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXSk7XG5cbmNvbnN0IGRleHQgPSBuZXcgVWludDhBcnJheShbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXSk7XG5cbmNvbnN0IGluZmxhdGVfdGFibGUgPSAodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cykgPT5cbntcbiAgY29uc3QgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgbGV0IGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgbGV0IHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIGxldCBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICBsZXQgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICBsZXQgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICBsZXQgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIGxldCBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgbGV0IHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgbGV0IGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIGxldCBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICBsZXQgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIGxldCBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICBsZXQgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgbGV0IG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIGxldCBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIGxldCBiYXNlX2luZGV4ID0gMDtcbi8vICBsZXQgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIGxldCBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICBjb25zdCBjb3VudCA9IG5ldyBVaW50MTZBcnJheShNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICBjb25zdCBvZmZzID0gbmV3IFVpbnQxNkFycmF5KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIGxldCBleHRyYSA9IG51bGw7XG4gIGxldCBleHRyYV9pbmRleCA9IDA7XG5cbiAgbGV0IGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW5mbGF0ZV90YWJsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtdW5hcnktb3BzICovXG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vY29uc3QgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL2NvbnN0IFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy9jb25zdCBaX1JMRSAgICAgICAgICAgICAgID0gMztcbmNvbnN0IFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL2NvbnN0IFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG5jb25zdCBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuY29uc3QgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vY29uc3QgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG5jb25zdCBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IGxldCBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxuY29uc3QgU1RPUkVEX0JMT0NLID0gMDtcbmNvbnN0IFNUQVRJQ19UUkVFUyA9IDE7XG5jb25zdCBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxuY29uc3QgTUlOX01BVENIICAgID0gMztcbmNvbnN0IE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxuY29uc3QgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbmNvbnN0IExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxuY29uc3QgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG5jb25zdCBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxuY29uc3QgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbmNvbnN0IEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG5jb25zdCBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxuY29uc3QgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG5jb25zdCBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxuY29uc3QgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuY29uc3QgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG5jb25zdCBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbmNvbnN0IGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdKTtcblxuY29uc3QgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM10pO1xuXG5jb25zdCBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddKTtcblxuY29uc3QgYmxfb3JkZXIgPVxuICBuZXcgVWludDhBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxuY29uc3QgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG5jb25zdCBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxuY29uc3Qgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbmNvbnN0IF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxuY29uc3QgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxuY29uc3QgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG5jb25zdCBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxubGV0IHN0YXRpY19sX2Rlc2M7XG5sZXQgc3RhdGljX2RfZGVzYztcbmxldCBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5jb25zdCBkX2NvZGUgPSAoZGlzdCkgPT4ge1xuXG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuY29uc3QgcHV0X3Nob3J0ID0gKHMsIHcpID0+IHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuY29uc3Qgc2VuZF9iaXRzID0gKHMsIHZhbHVlLCBsZW5ndGgpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59O1xuXG5cbmNvbnN0IHNlbmRfY29kZSA9IChzLCBjLCB0cmVlKSA9PiB7XG5cbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuY29uc3QgYmlfcmV2ZXJzZSA9IChjb2RlLCBsZW4pID0+IHtcblxuICBsZXQgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmNvbnN0IGJpX2ZsdXNoID0gKHMpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuY29uc3QgZ2VuX2JpdGxlbiA9IChzLCBkZXNjKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICBjb25zdCB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICBjb25zdCBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICBjb25zdCBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgY29uc3QgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICBjb25zdCBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICBjb25zdCBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICBjb25zdCBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICBsZXQgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgbGV0IG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIGxldCB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICBsZXQgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICBsZXQgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5jb25zdCBnZW5fY29kZXMgPSAodHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KSA9PlxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICBjb25zdCBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgbGV0IGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGxldCBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5jb25zdCB0cl9zdGF0aWNfaW5pdCA9ICgpID0+IHtcblxuICBsZXQgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIGxldCBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIGxldCBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICBsZXQgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIGNvbnN0IGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmNvbnN0IGluaXRfYmxvY2sgPSAocykgPT4ge1xuXG4gIGxldCBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuY29uc3QgYmlfd2luZHVwID0gKHMpID0+XG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmNvbnN0IGNvcHlfYmxvY2sgPSAocywgYnVmLCBsZW4sIGhlYWRlcikgPT5cbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHMucGVuZGluZ19idWYuc2V0KHMud2luZG93LnN1YmFycmF5KGJ1ZiwgYnVmICsgbGVuKSwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5jb25zdCBzbWFsbGVyID0gKHRyZWUsIG4sIG0sIGRlcHRoKSA9PiB7XG5cbiAgY29uc3QgX24yID0gbiAqIDI7XG4gIGNvbnN0IF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuY29uc3QgcHFkb3duaGVhcCA9IChzLCB0cmVlLCBrKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICBjb25zdCB2ID0gcy5oZWFwW2tdO1xuICBsZXQgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59O1xuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIGNvbnN0IFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuY29uc3QgY29tcHJlc3NfYmxvY2sgPSAocywgbHRyZWUsIGR0cmVlKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIGxldCBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgbGV0IGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgbGV0IGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIGxldCBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICBsZXQgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5jb25zdCBidWlsZF90cmVlID0gKHMsIGRlc2MpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIGNvbnN0IHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgY29uc3Qgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgY29uc3QgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICBjb25zdCBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICBsZXQgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgbGV0IG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICBsZXQgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmNvbnN0IHNjYW5fdHJlZSA9IChzLCB0cmVlLCBtYXhfY29kZSkgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIGxldCBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICBsZXQgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgbGV0IG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIGxldCBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIGxldCBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgbGV0IG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5jb25zdCBzZW5kX3RyZWUgPSAocywgdHJlZSwgbWF4X2NvZGUpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIGxldCBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICBsZXQgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgbGV0IGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgbGV0IG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICBsZXQgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5jb25zdCBidWlsZF9ibF90cmVlID0gKHMpID0+IHtcblxuICBsZXQgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5jb25zdCBzZW5kX2FsbF90cmVlcyA9IChzLCBsY29kZXMsIGRjb2RlcywgYmxjb2RlcykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIGxldCByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmNvbnN0IGRldGVjdF9kYXRhX3R5cGUgPSAocykgPT4ge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIGxldCBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgbGV0IG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn07XG5cblxubGV0IHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmNvbnN0IF90cl9pbml0ID0gKHMpID0+XG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuY29uc3QgX3RyX3N0b3JlZF9ibG9jayA9IChzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpID0+XG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5jb25zdCBfdHJfYWxpZ24gPSAocykgPT4ge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuY29uc3QgX3RyX2ZsdXNoX2Jsb2NrID0gKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgPT5cbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIGxldCBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIGxldCBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5jb25zdCBfdHJfdGFsbHkgPSAocywgZGlzdCwgbGMpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy9sZXQgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbm1vZHVsZS5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xubW9kdWxlLmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbm1vZHVsZS5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbm1vZHVsZS5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFpTdHJlYW07XG4iLCIvKipcbiAqIFRoaXMgTW9kdWxlIGNvbnRhaW5zIGNsYXNzZXMgcmVsZXZhbnQgdG8gZGF0YSBhYm91dCBhIHVzZXIgaW4gdGhlIHZpcnR1YWwgM0QgZW52aXJvbm1lbnQuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG5pbXBvcnQgeyBIaUZpVXRpbGl0aWVzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9IaUZpVXRpbGl0aWVzXCI7XG5cblxuLyoqXG4gKiBJbnN0YW50aWF0aW9ucyBvZiB0aGlzIGNsYXNzIGRlZmluZSBhIHBvc2l0aW9uIGluIDNEIHNwYWNlLiBUaGUgcG9zaXRpb24gb2YgYSB1c2VyIGFmZmVjdHMgdGhlIHdheSB0aGUgbWl4ZWQgc3BhdGlhbFxuICogYXVkaW8gaXMgaGVhcmQgYnkgdGhlIHVzZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2ludDNEIHtcbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCAreCBpcyB0byB0aGUgcmlnaHQgYW5kIC14IGlzIHRvIHRoZSBsZWZ0LiBVbml0cyBmb3IgdGhpcyBtZW1iZXIgdmFyaWFibGUgYXJlICoqbWV0ZXJzKiouXG4gICAgICovXG4gICAgeDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsICt5IGlzIGludG8gdGhlIHNjcmVlbiBhbmQgLXkgaXMgb3V0IG9mIHRoZSBzY3JlZW4gdG93YXJkcyB0aGUgdXNlci4gVW5pdHMgZm9yIHRoaXMgbWVtYmVyIHZhcmlhYmxlIGFyZSAqKm1ldGVycyoqLlxuICAgICAqL1xuICAgIHk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCAreiBpcyB1cCBhbmQgLXogaXMgZG93bi4gVW5pdHMgZm9yIHRoaXMgbWVtYmVyIHZhcmlhYmxlIGFyZSAqKm1ldGVycyoqLlxuICAgICAqL1xuICAgIHo6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBgUG9pbnQzRGAgb2JqZWN0LiBBbGwgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuIFVuc2V0IHBhcmFtZXRlcnMgd2lsbCBiZSBzZXQgdG8gYDBgLiBSZW1lbWJlciwgYWxsIHVuaXRzIGZvciBtZW1iZXIgdmFyaWFibGVzIGFyZSBgbWV0ZXJzYC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IHggPSAwLCB5ID0gMCwgeiA9IDAgfTogeyB4PzogbnVtYmVyLCB5PzogbnVtYmVyLCB6PzogbnVtYmVyIH0gPSB7fSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgIH1cbn1cblxuLyoqXG4gKiBJbnN0YW50aWF0aW9ucyBvZiB0aGlzIGNsYXNzIGRlZmluZSBhbiBvcmllbnRhdGlvbiBpbiAzRCBzcGFjZSBpbiBRdWF0ZXJuaW9uIGZvcm1hdC4gQSB1c2VyJ3Mgb3JpZW50YXRpb24gaW4gM0Qgc3BhY2VcbiAqIGFmZmVjdHMgdGhlIHdheSB0aGUgbWl4ZWQgc3BhdGlhbCBhdWRpbyBpcyBoZWFyZCBieSB0aGUgdXNlci4gQWRkaXRpb25hbGx5LCBvcmllbnRhdGlvbiBhZmZlY3RzIHRoZSB3YXlcbiAqIGEgdXNlcidzIGF1ZGlvIGlucHV0IHByb3BhZ2F0ZXMgdGhyb3VnaCBhIHNwYWNlOiBzcGVha2VycyBmYWNpbmcgZGlyZWN0bHkgdG93YXJkcyBhIGxpc3RlbmVyIHdpbGwgc291bmQgbG91ZGVyIHRoYW5cbiAqIHNwZWFrZXJzIGZhY2luZyBhd2F5IGZyb20gYSBsaXN0ZW5lci5cbiAqL1xuZXhwb3J0IGNsYXNzIE9yaWVudGF0aW9uUXVhdDNEIHtcbiAgICB3OiBudW1iZXI7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICB6OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYE9yaWVudGF0aW9uUXVhdDNEYCBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyB3ID0gMSwgeCA9IDAsIHkgPSAwLCB6ID0gMCB9OiB7IHc/OiBudW1iZXIsIHg/OiBudW1iZXIsIHk/OiBudW1iZXIsIHo/OiBudW1iZXIgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMudyA9IEhpRmlVdGlsaXRpZXMuY2xhbXBOb25hbih3LCAtMSwgMSwgMSk7XG4gICAgICAgIHRoaXMueCA9IEhpRmlVdGlsaXRpZXMuY2xhbXBOb25hbih4LCAtMSwgMSwgMCk7XG4gICAgICAgIHRoaXMueSA9IEhpRmlVdGlsaXRpZXMuY2xhbXBOb25hbih5LCAtMSwgMSwgMCk7XG4gICAgICAgIHRoaXMueiA9IEhpRmlVdGlsaXRpZXMuY2xhbXBOb25hbih6LCAtMSwgMSwgMCk7XG4gICAgfVxufVxuXG5cbi8vIGhlbHBlciBmdW5jdGlvbiB0aGF0IGtlZXBzIGFuIGFuZ2xlIGV4cHJlc3NlZCBpbiBkZWdyZWVzIGluIHRoZSByYW5nZSBdLTM2MCwgMzYwW1xuZnVuY3Rpb24gc2FuaXRpemVBbmdsZURlZ3JlZXModjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAvLyBpbiB0aGUgY2FzZSB2IGlzIEluZmluaXR5IG9yIE5hbiwgIGxldCdzIHNwZWNpYWwgY2FzZVxuICAgIGlmIChpc05hTih2KSB8fCB2ID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHYgPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gLTA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYnJpbmcgdGhlIHZhbHVlIGluIHRoZSByYW5nZSBdLTM2MCwgMzYwW1xuICAgICAgICAvLyBpZiB2IGlzIDwgMCB0aGVuIGl0IHdpbGwgY3ljbGUgaW4gXS0zNjAsIDBdXG4gICAgICAgIC8vIGlmIHYgaXMgPiAwIHRoZW4gaXQgd2lsbCBjeWNsZSBpbiBbMCwgMzYwW1xuICAgICAgICByZXR1cm4gdiAlIDM2MDtcbiAgICB9XG59XG5cbi8qKlxuICogSW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcyBkZWZpbmUgYW4gb3JpZW50YXRpb24gaW4gM0Qgc3BhY2UgcmVwcmVzZW50ZWQgYnkgZXVsZXIgYW5nbGVzLlxuICogVGhpcyBpcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgcXVhdGVybmlvbiByZXByZXNlbnRhdGlvbiBmb3Igb3JpZW50YXRpb24gd2hlbiB1cGRhdGluZyB0aGUgY2xpZW50XG4gKiBvciB3aGVuIHJlY2VpdmluZyB0aGUgdXBkYXRlcyBhYm91dCB0aGUgb3RoZXIgY2xpZW50cyBpbiB0aGUgc3BhY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBPcmllbnRhdGlvbkV1bGVyM0Qge1xuICAgIC8qKlxuICAgICAqIENvbnNpZGVyIGFuIGFpcmNyYWZ0OiBcIlBpdGNoXCIgaXMgZGVmaW5lZCBhcyBcIm5vc2UgdXAvZG93biBhYm91dCB0aGUgYXhpcyBydW5uaW5nIGZyb20gd2luZyB0byB3aW5nXCIuXG4gICAgICogKipOZWdhdGl2ZSBwaXRjaCoqIG1lYW5zIHRoYXQgdGhlIGFpcmNyYWZ0IG1vdmVzIGl0cyBub3NlICoqY2xvc2VyIHRvIHRoZSBncm91bmQqKi5cbiAgICAgKiAqKlBvc2l0aXZlIHBpdGNoKiogbWVhbnMgdGhhdCB0aGUgYWlyY3JhZnQgbW92ZXMgaXRzIG5vc2UgKiphd2F5IGZyb20gdGhlIGdyb3VuZCoqLlxuICAgICAqIFVuaXRzIGhlcmUgYXJlIGRlZ3JlZXMuXG4gICAgICovXG4gICAgcGl0Y2hEZWdyZWVzOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQ29uc2lkZXIgYW4gYWlyY3JhZnQ6IFwiWWF3XCIgaXMgZGVmaW5lZCBhcyBcIm5vc2UgbGVmdC9yaWdodCBhYm91dCB0aGUgYXhpcyBydW5uaW5nIHVwIGFuZCBkb3duXCIuXG4gICAgICogKipOZWdhdGl2ZSB5YXcqKiBtZWFucyB0aGF0IHRoZSBhaXJjcmFmdCB3aWxsIHJvdGF0ZSAqKmNsb2Nrd2lzZSoqIHdoZW4gdmlld2luZyB0aGUgYWlyY3JhZnQgZnJvbSBhYm92ZS5cbiAgICAgKiAqKlBvc2l0aXZlIHlhdyoqIG1lYW5zIHRoYXQgdGhlIGFpcmNyYWZ0IHdpbGwgcm90YXRlICoqY291bnRlci1jbG9ja3dpc2UqKiB3aGVuIHZpZXdpbmcgdGhlIGFpcmNyYWZ0IGZyb20gYWJvdmUuXG4gICAgICogVW5pdHMgaGVyZSBhcmUgZGVncmVlcy5cbiAgICAgKi9cbiAgICB5YXdEZWdyZWVzOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQ29uc2lkZXIgYW4gYWlyY3JhZnQ6IFwiUm9sbFwiIGlzIGRlZmluZWQgYXMgXCJyb3RhdGlvbiBhYm91dCB0aGUgYXhpcyBydW5uaW5nIGZyb20gbm9zZSB0byB0YWlsXCIuXG4gICAgICogKipQb3NpdGl2ZSByb2xsKiogbWVhbnMgdGhhdCB0aGUgYWlyY3JhZnQncyAqKnJpZ2h0IHdpbmcgd2lsbCBtb3ZlIGNsb3NlciB0byB0aGUgZ3JvdW5kKiouXG4gICAgICogKipOZWdhdGl2ZSByb2xsKiogbWVhbnMgdGhhdCB0aGUgYWlyY3JhZnQncyAqKmxlZnQgd2luZyB3aWxsIG1vdmUgY2xvc2VyIHRvIHRoZSBncm91bmQqKi5cbiAgICAgKiBVbml0cyBoZXJlIGFyZSBkZWdyZWVzLlxuICAgICAqL1xuICAgIHJvbGxEZWdyZWVzOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYE9yaWVudGF0aW9uRXVsZXIzRGAgb2JqZWN0LiBBbGwgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuIFVuc2V0IHBhcmFtZXRlcnMgd2lsbCBiZSBzZXQgdG8gYDBgLiBSZW1lbWJlciwgYWxsIHVuaXRzIGZvciBtZW1iZXIgdmFyaWFibGVzIGFyZSBgZGVncmVlc2AuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBwaXRjaERlZ3JlZXMgPSAwLCB5YXdEZWdyZWVzID0gMCwgcm9sbERlZ3JlZXMgPSAwIH06IHsgcGl0Y2hEZWdyZWVzPzogbnVtYmVyLCB5YXdEZWdyZWVzPzogbnVtYmVyLCByb2xsRGVncmVlcz86IG51bWJlciB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5waXRjaERlZ3JlZXMgPSBzYW5pdGl6ZUFuZ2xlRGVncmVlcyhwaXRjaERlZ3JlZXMpO1xuICAgICAgICB0aGlzLnlhd0RlZ3JlZXMgPSBzYW5pdGl6ZUFuZ2xlRGVncmVlcyh5YXdEZWdyZWVzKTtcbiAgICAgICAgdGhpcy5yb2xsRGVncmVlcyA9IHNhbml0aXplQW5nbGVEZWdyZWVzKHJvbGxEZWdyZWVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQXNpZGUgZnJvbSB0aGUgMyBhbmdsZXMgWWF3LCBQaXRjaCwgUm9sbCBkZWZpbmluZyBhbiBvcmllbnRhdGlvbiwgZXVsZXIgYW5nbGVzIHJlcXVpcmVzIFxuICogdG8gZGVmaW5lIHRoZSBvcmRlciBpbiB3aXRjaCB0aGUgaW5kaXZpZHVhbCB5YXcsIHBpdGNoIHJvbGwgcm90YXRpb25zIGFyZSBjb21iaW5lZC5cbiAqIFRoZXJlIGFyZSA2IG9yZGVycyBwb3NzaWJsZSBpZGVudGlmaWVkIGJ5IHRoZSBIaUZpRXVsZXJPcmRlciBlbnVtLlxuICogXG4gKiAgRm9yIGV4YW1wbGUsIHRoZSBvcmRlciBZYXdQaXRjaFJvbGwgaXMgZGVzY3JpYmluZyB0aGUgZm9sbG93aW5nIHNlcXVlbmNlXG4gKiAgc3RhcnRpbmcgZnJvbSB0aGUgYmFzZSAzZCBmcmFtZSxcbiAqICAxLyBZYXcsIHJvdGF0aW5nIGFyb3VuZCB0aGUgdmVydGljYWwgYXhpc1xuICogIDIvIFBpdGNoLCByb3RhdGluZyBhcm91bmQgdGhlIHJpZ2h0IGF4aXMgXG4gKiAgMy8gUm9sbCwgcm90YXRpbmcgYXJvdW5kIHRoZSBmcm9udCBheGlzXG4gKiAgdGhlIHJlc3VsdGluZyAzZCBmcmFtZSBvcmllbnRhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgYmFzZSBmcmFtZS5cbiAqL1xuZXhwb3J0IGVudW0gT3JpZW50YXRpb25FdWxlcjNET3JkZXIge1xuICAgIFBpdGNoWWF3Um9sbCA9IFwiUGl0Y2hZYXdSb2xsXCIsXG4gICAgWWF3UGl0Y2hSb2xsID0gXCJZYXdQaXRjaFJvbGxcIixcbiAgICBSb2xsUGl0Y2hZYXcgPSBcIlJvbGxQaXRjaFlhd1wiLFxuICAgIFJvbGxZYXdQaXRjaCA9IFwiUm9sbFlhd1BpdGNoXCIsXG4gICAgWWF3Um9sbFBpdGNoID0gXCJZYXdSb2xsUGl0Y2hcIixcbiAgICBQaXRjaFJvbGxZYXcgPSBcIlBpdGNoUm9sbFlhd1wiLFxufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIG9yaWVudGF0aW9uIHF1YXRlcm5pb24gZnJvbSB0aGUgc3BlY2lmaWVkIGV1bGVyIGFuZ2xlcy5cbiAqIFRoZSByZXN1bHRpbmcgcXVhdGVybmlvbiBpcyB0aGUgcm90YXRpb24gdHJhbnNmb3JtaW5nIGZyb20gY29tYmluaW5nIHRoZSBldWxlciBhbmdsZXMgcm90YXRpb25zIGluIHRoZSBzcGVjaWZpZWQgb3JkZXJcbiAqIFxuICogRm9yIGV4YW1wbGUsIHRoZSBvcmRlciBZYXdQaXRjaFJvbGwgaXMgY29tcHV0ZWQgYXMgZm9sbG93OlxuICogIHN0YXJ0aW5nIGZyb20gdGhlIGJhc2UgM2QgZnJhbWUsXG4gKiAgMS8gWWF3LCByb3RhdGluZyBhcm91bmQgdGhlIHZlcnRpY2FsIGF4aXNcbiAqICAyLyBQaXRjaCwgcm90YXRpbmcgYXJvdW5kIHRoZSByaWdodCBheGlzIFxuICogIDMvIFJvbGwsIHJvdGF0aW5nIGFyb3VuZCB0aGUgZnJvbnQgYXhpc1xuICogIHRoZSByZXN1bHRpbmcgM2QgZnJhbWUgb3JpZW50YXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIGJhc2UgZnJhbWUuXG4gKiAgVGhlIHJlc3VsdGluZyByb3RhdGlvbiBpcyBkZWZpbmluZyB0aGUgJ3JvdGF0ZWQnIHNwYWNlIHJlbGF0aXZlIHRvIHRoZSAnYmFzZScgc3BhY2UuXG4gKiAgQSB2ZWN0b3IgVnIgaW4gXCJyb3RhdGVkJyBzcGFjZSBhbmQgaXRzIGVxdWl2YWxlbnQgdmFsdWUgVmIgaW4gdGhlJ2Jhc2UnIHNwYWNlIGlzIGNvbXB1dGVkIGFzIGZvbGxvdzpcbiAqICBWYiA9IFtQXVtZXVtSXSBWclxuICogXG4gKiBAcGFyYW0gZXVsZXIgLSBUaGUgZXVsZXIgYW5nbGVzLlxuICogQHBhcmFtIG9yZGVyIC0gVGhlIGV1bGVyIG9yZGVyIGNvbnZlbnRpb24uXG4gKiBcbiAqIEByZXR1cm4gVGhlIGVuZCByZXN1bHRpbmcgcXVhdGVybmlvbiBkZWZpbmVkIGZyb20gdGhlIGV1bGVyIGFuZ2xlcyBjb21iaW5hdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZXVsZXJUb1F1YXRlcm5pb24oZXVsZXI6IE9yaWVudGF0aW9uRXVsZXIzRCwgb3JkZXI6IE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyKTogT3JpZW50YXRpb25RdWF0M0Qge1xuICAgIC8vIGNvbXB1dGUgdGhlIGluZGl2aWR1YWwgZXVsZXIgYW5nbGUgcm90YXRpb24gcXVhdGVybmlvbiB0ZXJtcyBzaW4oYW5nbGUvMikgYW5kIGNvcyhhYW5nbGUvMilcbiAgICBjb25zdCBIQUxGX0RFR19UT19SQUQgPSAwLjUgKiBNYXRoLlBJIC8gMTgwLjA7XG4gICAgbGV0IGNvcyA9IHsgUDogTWF0aC5jb3MoZXVsZXIucGl0Y2hEZWdyZWVzICogSEFMRl9ERUdfVE9fUkFEKSwgWTogTWF0aC5jb3MoZXVsZXIueWF3RGVncmVlcyAqIEhBTEZfREVHX1RPX1JBRCksIFI6IE1hdGguY29zKGV1bGVyLnJvbGxEZWdyZWVzICogSEFMRl9ERUdfVE9fUkFEKX07XG4gICAgbGV0IHNpbiA9IHsgUDogTWF0aC5zaW4oZXVsZXIucGl0Y2hEZWdyZWVzICogSEFMRl9ERUdfVE9fUkFEKSwgWTogTWF0aC5zaW4oZXVsZXIueWF3RGVncmVlcyAqIEhBTEZfREVHX1RPX1JBRCksIFI6IE1hdGguc2luKGV1bGVyLnJvbGxEZWdyZWVzICogSEFMRl9ERUdfVE9fUkFEKX07XG5cbiAgICAvLyB0aGUgY29tcHV0ZWQgcXVhdGVybmlvbiBjb21wb25lbnRzIGZvciB0aGUgNiBvcmRlcnMgYXJlIGJhc2VkIG9uIHRoZSBzYW1lIHBhdHRlcm5cbiAgICAvLyBxLnggPSBheCArLy0gYnggXG4gICAgLy8gcS55ID0gYXkgKy8tIGJ5IFxuICAgIC8vIHEueiA9IGF6ICsvLSBieiBcbiAgICAvLyBxLncgPSBhdyArLy0gYncgXG5cbiAgICBsZXQgYXggPSBzaW4uUCAqIGNvcy5ZICogY29zLlI7XG4gICAgbGV0IGF5ID0gY29zLlAgKiBzaW4uWSAqIGNvcy5SO1xuICAgIGxldCBheiA9IGNvcy5QICogY29zLlkgKiBzaW4uUjtcbiAgICBsZXQgYXcgPSBjb3MuUCAqIGNvcy5ZICogY29zLlI7XG5cbiAgICBsZXQgYnggPSBjb3MuUCAqIHNpbi5ZICogc2luLlI7XG4gICAgbGV0IGJ5ID0gc2luLlAgKiBjb3MuWSAqIHNpbi5SO1xuICAgIGxldCBieiA9IHNpbi5QICogc2luLlkgKiBjb3MuUjtcbiAgICBsZXQgYncgPSBzaW4uUCAqIHNpbi5ZICogc2luLlI7XG5cbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgLy8gZnJvbSAnYmFzZScgc3BhY2Ugcm90YXRlIFBpdGNoLCB0aGVuIFlhdyB0aGVuIFJvbGxcbiAgICAvLyBSZXN1bHRpbmcgcm90YXRpb24gaXMgZGVmaW5pbmcgdGhlICdyb3RhdGVkJyBzcGFjZSByZWxhdGl2ZSB0byB0aGUgJ2Jhc2UnIHNwYWNlLlxuICAgIC8vIEEgdmVjdG9yIFZyIGluIFwicm90YXRlZCcgc3BhY2UgYW5kIGl0cyBlcXVpdmFsZW50IHZhbHVlIFZiIGluIHRoZSdiYXNlJyBzcGFjZSBpcyBjb21wdXRlZCBhcyBmb2xsb3c6XG4gICAgLy8gVmIgPSBbUF1bWV1bUl0gVnJcbiAgICBjYXNlIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLlBpdGNoWWF3Um9sbDoge1xuICAgICAgICByZXR1cm4gbmV3IE9yaWVudGF0aW9uUXVhdDNEKHtcbiAgICAgICAgICAgICAgICB4OiBheCArIGJ4LFxuICAgICAgICAgICAgICAgIHk6IGF5IC0gYnksXG4gICAgICAgICAgICAgICAgejogYXogKyBieixcbiAgICAgICAgICAgICAgICB3OiBhdyAtIGJ3LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gYnJlYWs7XG5cbiAgICAvLyBGcm9tICdiYXNlJyBzcGFjZSByb3RhdGUgWWF3LCB0aGVuIFBpdGNoIHRoZW4gUm9sbC4uLlxuICAgIGNhc2UgT3JpZW50YXRpb25FdWxlcjNET3JkZXIuWWF3UGl0Y2hSb2xsOiB7XG4gICAgICAgIHJldHVybiBuZXcgT3JpZW50YXRpb25RdWF0M0Qoe1xuICAgICAgICAgICAgICAgIHg6IGF4ICsgYngsXG4gICAgICAgICAgICAgICAgeTogYXkgLSBieSxcbiAgICAgICAgICAgICAgICB6OiBheiAtIGJ6LFxuICAgICAgICAgICAgICAgIHc6IGF3ICsgYncsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBicmVhaztcbiBcbiAgICAvLyBGcm9tICdiYXNlJyBzcGFjZSByb3RhdGUgUm9sbCwgdGhlbiBQaXRjaCB0aGVuIFlhdy4uLlxuICAgIGNhc2UgT3JpZW50YXRpb25FdWxlcjNET3JkZXIuUm9sbFBpdGNoWWF3OiB7XG4gICAgICAgIHJldHVybiBuZXcgT3JpZW50YXRpb25RdWF0M0Qoe1xuICAgICAgICAgICAgICAgIHg6IGF4IC0gYngsXG4gICAgICAgICAgICAgICAgeTogYXkgKyBieSxcbiAgICAgICAgICAgICAgICB6OiBheiArIGJ6LFxuICAgICAgICAgICAgICAgIHc6IGF3IC0gYncsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBicmVhaztcbiBcbiAgICAvLyBGcm9tICdiYXNlJyBzcGFjZSByb3RhdGUgUm9sbCwgdGhlbiBZYXcgdGhlbiBQaXRjaC4uLlxuICAgIGNhc2UgT3JpZW50YXRpb25FdWxlcjNET3JkZXIuUm9sbFlhd1BpdGNoOiB7XG4gICAgICAgIHJldHVybiBuZXcgT3JpZW50YXRpb25RdWF0M0Qoe1xuICAgICAgICAgICAgICAgIHg6IGF4IC0gYngsXG4gICAgICAgICAgICAgICAgeTogYXkgKyBieSxcbiAgICAgICAgICAgICAgICB6OiBheiAtIGJ6LFxuICAgICAgICAgICAgICAgIHc6IGF3ICsgYncsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBicmVhaztcbiAgXG4gICAgLy8gRnJvbSAnYmFzZScgc3BhY2Ugcm90YXRlIFlhdywgdGhlbiBSb2xsIHRoZW4gUGl0Y2guLi5cbiAgICBjYXNlIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLllhd1JvbGxQaXRjaDoge1xuICAgICAgICByZXR1cm4gbmV3IE9yaWVudGF0aW9uUXVhdDNEKHtcbiAgICAgICAgICAgICAgICB4OiBheCArIGJ4LFxuICAgICAgICAgICAgICAgIHk6IGF5ICsgYnksXG4gICAgICAgICAgICAgICAgejogYXogLSBieixcbiAgICAgICAgICAgICAgICB3OiBhdyAtIGJ3LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gYnJlYWs7XG4gIFxuICAgIC8vIEZyb20gJ2Jhc2UnIHNwYWNlIHJvdGF0ZSBQaXRjaCwgdGhlbiBSb2xsIHRoZW4gWWF3Li4uXG4gICAgY2FzZSBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5QaXRjaFJvbGxZYXc6IHtcbiAgICAgICAgcmV0dXJuIG5ldyBPcmllbnRhdGlvblF1YXQzRCh7XG4gICAgICAgICAgICAgICAgeDogYXggLSBieCxcbiAgICAgICAgICAgICAgICB5OiBheSAtIGJ5LFxuICAgICAgICAgICAgICAgIHo6IGF6ICsgYnosXG4gICAgICAgICAgICAgICAgdzogYXcgKyBidyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGJyZWFrO1xuICAgIH0gICAgXG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgb3JpZW50YXRpb24gZXVsZXIgZGVjb21wb3NpdGlvbiBmcm9tIHRoZSBzcGVjaWZpZWQgcXVhdGVybmlvbi5cbiAqIFRoZSByZXN1bHRpbmcgZXVsZXIgaXMgdGhlIHJvdGF0aW9uIHRyYW5zZm9ybWluZyBmcm9tIGNvbWJpbmluZyB0aGUgZXVsZXIgYW5nbGVzIHJvdGF0aW9ucyBpbiB0aGUgc3BlY2lmaWVkIG9yZGVyXG4gKiBcbiAqIEZvciBleGFtcGxlLCB0aGUgb3JkZXIgWWF3UGl0Y2hSb2xsIGlzIGNvbXB1dGVkIGFzIGZvbGxvdzpcbiAqICBzdGFydGluZyBmcm9tIHRoZSBiYXNlIDNkIGZyYW1lLFxuICogIDEvIFlhdywgcm90YXRpbmcgYXJvdW5kIHRoZSB2ZXJ0aWNhbCBheGlzXG4gKiAgMi8gUGl0Y2gsIHJvdGF0aW5nIGFyb3VuZCB0aGUgcmlnaHQgYXhpcyBcbiAqICAzLyBSb2xsLCByb3RhdGluZyBhcm91bmQgdGhlIGZyb250IGF4aXNcbiAqICB0aGUgcmVzdWx0aW5nIDNkIGZyYW1lIG9yaWVudGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBiYXNlIGZyYW1lLlxuICogIFRoZSByZXN1bHRpbmcgcm90YXRpb24gaXMgZGVmaW5pbmcgdGhlICdyb3RhdGVkJyBzcGFjZSByZWxhdGl2ZSB0byB0aGUgJ2Jhc2UnIHNwYWNlLlxuICogIEEgdmVjdG9yIFZyIGluIFwicm90YXRlZCcgc3BhY2UgYW5kIGl0cyBlcXVpdmFsZW50IHZhbHVlIFZiIGluIHRoZSdiYXNlJyBzcGFjZSBpcyBjb21wdXRlZCBhcyBmb2xsb3c6XG4gKiAgVmIgPSBbUF1bWV1bUl0gVnJcbiAqIFxuICogQHBhcmFtIHF1YXQgLSBUaGUgb3JpZW50YXRpb24gcXVhdGVybmlvbi5cbiAqIEBwYXJhbSBvcmRlciAtIFRoZSBldWxlciBvcmRlciBjb252ZW50aW9uLlxuICogXG4gKiBAcmV0dXJuIFRoZSBlbmQgcmVzdWx0aW5nIHF1YXRlcm5pb24gZGVmaW5lZCBmcm9tIHRoZSBldWxlciBhbmdsZXMgY29tYmluYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV1bGVyRnJvbVF1YXRlcm5pb24ocXVhdDogT3JpZW50YXRpb25RdWF0M0QsIG9yZGVyOiBPcmllbnRhdGlvbkV1bGVyM0RPcmRlcik6IE9yaWVudGF0aW9uRXVsZXIzRCB7XG4gICAgLy8gV2UgbmVlZCB0byBjb252ZXJ0IHRoZSBxdWF0ZXJuaW9uIHRvIHRoZSBlcXVpdmFsZW50IG1hdDN4M1xuICAgIGxldCBxeDIgPSBxdWF0LnggKiBxdWF0Lng7XG4gICAgbGV0IHF5MiA9IHF1YXQueSAqIHF1YXQueTtcbiAgICBsZXQgcXoyID0gcXVhdC56ICogcXVhdC56O1xuICAgIC8vIGxldCBxdzIgPSBxdWF0LncgKiBxdWF0Lnc7IHdlIGNvdWxkIGNob29zZSB0byB1c2UgaXQgaW5zdGVhZCBvZiB0aGUgMSAtIDIqIHRlcm0uLi5cbiAgICBsZXQgcXd4ID0gcXVhdC53ICogcXVhdC54O1xuICAgIGxldCBxd3kgPSBxdWF0LncgKiBxdWF0Lnk7XG4gICAgbGV0IHF3eiA9IHF1YXQudyAqIHF1YXQuejtcbiAgICBsZXQgcXh5ID0gcXVhdC54ICogcXVhdC55O1xuICAgIGxldCBxeXogPSBxdWF0LnkgKiBxdWF0Lno7XG4gICAgbGV0IHF4eiA9IHF1YXQueiAqIHF1YXQueDtcbiAgICAvLyBST1QgTWF0MzMgPSAgeyAgMSAtIDJxeTIgLSAycXoyICB8ICAyKHF4eSAtIHF3eikgICAgfCAgMihxeHogKyBxd3kpICB9XG4gICAgLy8gICAgICAgICAgICAgIHsgIDIocXh5ICsgcXd6KSAgICAgfCAgMSAtIDJxeDIgLSAycXoyIHwgIDIocXl6IC0gcXd4KSAgfVxuICAgIC8vICAgICAgICAgICAgICB7ICAyKHF4eiAtIHF3eSkgICAgIHwgIDIocXl6ICsgcXd4KSAgICB8ICAxIC0gMnF4MiAtIDJxeTIgIH1cbiAgICBsZXQgcjAwID0gMS4wIC0gMi4wICogKHF5MiArIHF6Mik7XG4gICAgbGV0IHIxMCA9IDIuMCAqIChxeHkgKyBxd3opO1xuICAgIGxldCByMjAgPSAyLjAgKiAocXh6IC0gcXd5KTtcblxuICAgIGxldCByMDEgPSAyLjAgKiAocXh5IC0gcXd6KTtcbiAgICBsZXQgcjExID0gMS4wIC0gMi4wICogKHF4MiArIHF6Mik7IFxuICAgIGxldCByMjEgPSAyLjAgKiAocXl6ICsgcXd4KTtcbiAgIFxuICAgIGxldCByMDIgPSAyLjAgKiAocXh6ICsgcXd5KTtcbiAgICBsZXQgcjEyID0gMi4wICogKHF5eiAtIHF3eCk7XG4gICAgbGV0IHIyMiA9IDEuMCAtIDIuMCAqIChxeDIgKyBxeTIpOyBcblxuICAgIC8vIHRoZW4gZGVwZW5kaW5nIG9uIHRoZSBldWxlciByb3RhdGlvbiBvcmRlciBkZWNvbXBvc2l0aW9uLCB3ZSBleHRyYWN0IHRoZSBhbmdsZXMgXG4gICAgLy8gZnJvbSB0aGUgYmFzZSB2ZWN0b3IgY29tcG9uZW50c1xuICAgIGxldCBwaXRjaCA9IDA7XG4gICAgbGV0IHlhdyA9IDA7XG4gICAgbGV0IHJvbGwgPSAwO1xuICAgIGNvbnN0IE9ORV9NSU5VU19FUFNJTE9OID0gMC45OTk5OTk5O1xuICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICBjYXNlIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLlBpdGNoWWF3Um9sbDoge1xuICAgICAgICB5YXcgPSBNYXRoLmFzaW4oIEhpRmlVdGlsaXRpZXMuY2xhbXBOb3JtYWxpemVkKHIwMikgKTtcbiAgICAgICAgaWYgKCBNYXRoLmFicyggcjAyICkgPCBPTkVfTUlOVVNfRVBTSUxPTiApIHtcbiAgICAgICAgICAgIHBpdGNoID0gTWF0aC5hdGFuMiggLXIxMiwgcjIyKTtcbiAgICAgICAgICAgIHJvbGwgPSBNYXRoLmF0YW4yKCAtcjAxLCByMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGl0Y2ggPSBNYXRoLmF0YW4yKHIyMSwgcjExKTtcbiAgICAgICAgfSAgICAgICBcbiAgICB9IGJyZWFrO1xuICAgIGNhc2UgT3JpZW50YXRpb25FdWxlcjNET3JkZXIuWWF3UGl0Y2hSb2xsOiB7XG4gICAgICAgIHBpdGNoID0gTWF0aC5hc2luKCBIaUZpVXRpbGl0aWVzLmNsYW1wTm9ybWFsaXplZCgtcjEyKSApO1xuICAgICAgICBpZiAoIE1hdGguYWJzKCByMTIgKSA8IE9ORV9NSU5VU19FUFNJTE9OICkge1xuICAgICAgICAgICAgeWF3ID0gTWF0aC5hdGFuMihyMDIsIHIyMik7XG4gICAgICAgICAgICByb2xsID0gTWF0aC5hdGFuMihyMTAsIHIxMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5YXcgPSBNYXRoLmF0YW4yKC1yMjAsIHIwMCk7XG4gICAgICAgIH0gXG4gICAgfSBicmVhaztcbiAgICBjYXNlIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLlJvbGxQaXRjaFlhdzoge1xuICAgICAgICBwaXRjaCA9IE1hdGguYXNpbiggSGlGaVV0aWxpdGllcy5jbGFtcE5vcm1hbGl6ZWQocjIxKSApO1xuICAgICAgICBpZiAoIE1hdGguYWJzKCByMjEgKSA8IE9ORV9NSU5VU19FUFNJTE9OICkge1xuICAgICAgICAgICAgeWF3ID0gTWF0aC5hdGFuMigtcjIwLCByMjIpO1xuICAgICAgICAgICAgcm9sbCA9IE1hdGguYXRhbjIoLXIwMSwgcjExKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvbGwgPSBNYXRoLmF0YW4yKHIxMCwgcjAwKTtcbiAgICAgICAgfVxuICAgIH0gYnJlYWs7XG4gICAgY2FzZSBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5Sb2xsWWF3UGl0Y2g6IHtcbiAgICAgICAgeWF3ID0gTWF0aC5hc2luKCBIaUZpVXRpbGl0aWVzLmNsYW1wTm9ybWFsaXplZCgtcjIwKSApO1xuICAgICAgICBpZiAoIE1hdGguYWJzKCByMjAgKSA8IE9ORV9NSU5VU19FUFNJTE9OICkge1xuICAgICAgICAgICAgcGl0Y2ggPSBNYXRoLmF0YW4yKCByMjEsIHIyMik7XG4gICAgICAgICAgICByb2xsID0gTWF0aC5hdGFuMiggcjEwLCByMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm9sbCA9IE1hdGguYXRhbjIoIC1yMDEsIHIxMSk7XG4gICAgICAgIH0gIFxuICAgIH0gYnJlYWs7XG4gICAgY2FzZSBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5ZYXdSb2xsUGl0Y2g6IHtcbiAgICAgICAgcm9sbCA9IE1hdGguYXNpbiggSGlGaVV0aWxpdGllcy5jbGFtcE5vcm1hbGl6ZWQocjEwKSApO1xuICAgICAgICBpZiAoIE1hdGguYWJzKCByMTAgKSA8IE9ORV9NSU5VU19FUFNJTE9OICkge1xuICAgICAgICAgICAgcGl0Y2ggPSBNYXRoLmF0YW4yKCAtcjEyLCByMTEpO1xuICAgICAgICAgICAgeWF3ID0gTWF0aC5hdGFuMiggLXIyMCwgcjAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlhdyA9IE1hdGguYXRhbjIoIHIwMiwgcjIyKTtcbiAgICAgICAgfVxuICAgIH0gYnJlYWs7XG4gICAgY2FzZSBPcmllbnRhdGlvbkV1bGVyM0RPcmRlci5QaXRjaFJvbGxZYXc6IHtcbiAgICAgICAgcm9sbCA9IE1hdGguYXNpbiggSGlGaVV0aWxpdGllcy5jbGFtcE5vcm1hbGl6ZWQoLXIwMSkgKTtcbiAgICAgICAgaWYgKCBNYXRoLmFicyggcjAxICkgPCBPTkVfTUlOVVNfRVBTSUxPTiApIHtcbiAgICAgICAgICAgIHBpdGNoID0gTWF0aC5hdGFuMiggcjIxLCByMTEpO1xuICAgICAgICAgICAgeWF3ID0gTWF0aC5hdGFuMiggcjAyLCByMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWF3ID0gTWF0aC5hdGFuMiggLXIxMiwgcjIyKTtcbiAgICAgICAgfVxuICAgIH0gYnJlYWs7XG4gICAgfSAgICBcbiAgICBjb25zdCBSQURfVE9fREVHID0gMTgwLjAgLyBNYXRoLlBJO1xuICAgIHJldHVybiBuZXcgT3JpZW50YXRpb25FdWxlcjNEKHsgcGl0Y2hEZWdyZWVzOiBSQURfVE9fREVHICogcGl0Y2gsIHlhd0RlZ3JlZXM6IFJBRF9UT19ERUcgKiB5YXcsIHJvbGxEZWdyZWVzOiBSQURfVE9fREVHICogcm9sbCB9KTtcbn1cblxuLyoqXG4gKiBJbnN0YW50aWF0aW9ucyBvZiB0aGlzIGNsYXNzIGRlZmluZSBhIG1hcCBiZXR3ZWVuIGhhc2hlZCB2aXNpdCBJRHMgYW5kIHRoZSBnYWlucyBvZiBvdGhlciB1c2Vycy5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgaW4ge0BsaW5rIEhpRmlDb21tdW5pY2F0b3Iuc2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvbn0gdG8gY2hhbmdlIHRoZSBnYWlucyBvZiBvdGhlciB1c2VycyBhcyBwZXJjZWl2ZWQgYnkgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiwgcHJvdmlkaW5nIGEgbW9yZSBjb21mb3J0YWJsZSBsaXN0ZW5pbmcgZXhwZXJpZW5jZSBmb3IgdGhlIGNsaWVudC4gSWYgeW91IG5lZWQgdG8gcGVyZm9ybSBtb2RlcmF0aW9uIGFjdGlvbnMgb24gdGhlIHNlcnZlciBzaWRlLCB1c2UgdGhlIHtAbGluayBodHRwczovL2RvY3MuaGlnaGZpZGVsaXR5LmNvbS9yZXN0L2xhdGVzdC9pbmRleC5odG1sfEFkbWluaXN0cmF0aXZlIFJFU1QgQVBJfS5cbiAqXG4gKiBJbnRlcm5hbGx5LCB0aGlzIGNsYXNzIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBvdGhlciB1c2VyIGdhaW4gY2hhbmdlcyBuZWVkIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0IHR5cGUgT3RoZXJVc2VyR2Fpbk1hcCA9IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH07XG5cbi8qKlxuICogSW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcyBjb250YWluIGFsbCBvZiB0aGUgZGF0YSB0aGF0IGlzIHBvc3NpYmxlIHRvICoqc2VuZCB0byBBTkQgcmVjZWl2ZSBmcm9tKiogdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIFNlcnZlci5cbiAqIEFsbCBtZW1iZXIgZGF0YSBpbnNpZGUgdGhpcyBgY2xhc3NgIGNhbiBiZSBzZW50IHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBTZXJ2ZXIuIFNlZSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICogXG4gKiBTZWUge0BsaW5rIFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YX0gZm9yIGRhdGEgdGhhdCBjYW4ndCBiZSBzZW50IHRvIHRoZSBTZXJ2ZXIsIGJ1dCByYXRoZXIgY2FuIG9ubHkgYmUgcmVjZWl2ZWQgZnJvbSB0aGUgU2VydmVyIChpLmUuIGB2b2x1bWVEZWNpYmVsc2ApLlxuICogXG4gKiBNZW1iZXIgZGF0YSBvZiB0aGlzIGNsYXNzIHRoYXQgaXMgc2VudCB0byB0aGUgU2VydmVyIHdpbGwgYWZmZWN0IHRoZSBmaW5hbCBtaXhlZCBzcGF0aWFsIGF1ZGlvIGZvciBhbGwgbGlzdGVuZXJzIGluIHRoZSBzZXJ2ZXIncyB2aXJ0dWFsIHNwYWNlLlxuICovXG5leHBvcnQgY2xhc3MgSGlGaUF1ZGlvQVBJRGF0YSB7XG4gICAgLyoqXG4gICAgICogSWYgeW91IGRvbid0IHN1cHBseSBhIGBwb3NpdGlvbmAgd2hlbiBjb25zdHJ1Y3RpbmcgaW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcywgYHBvc2l0aW9uYCB3aWxsIGJlIGBudWxsYC5cbiAgICAgKiBcbiAgICAgKiDinJQgVGhlIGNsaWVudCBzZW5kcyBgcG9zaXRpb25gIGRhdGEgdG8gdGhlIHNlcnZlciB3aGVuIGBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIoKWAgaXMgY2FsbGVkLlxuICAgICAqIFxuICAgICAqIOKclCBUaGUgc2VydmVyIHNlbmRzIGBwb3NpdGlvbmAgZGF0YSB0byBhbGwgY2xpZW50cyBjb25uZWN0ZWQgdG8gYSBzZXJ2ZXIgZHVyaW5nIFwicGVlciB1cGRhdGVzXCIuXG4gICAgICovXG4gICAgcG9zaXRpb246IFBvaW50M0Q7XG4gICAgLyoqXG4gICAgICogSWYgeW91IGRvbid0IHN1cHBseSBhbiBgb3JpZW50YXRpb25RdWF0YCB3aGVuIGNvbnN0cnVjdGluZyBpbnN0YW50aWF0aW9ucyBvZiB0aGlzIGNsYXNzLCBgb3JpZW50YXRpb25RdWF0YCB3aWxsIGJlIGBudWxsYC5cbiAgICAgKiBcbiAgICAgKiDinJQgVGhlIGNsaWVudCBzZW5kcyBgb3JpZW50YXRpb25RdWF0YCBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2hlbiBgX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKClgIGlzIGNhbGxlZC5cbiAgICAgKiBcbiAgICAgKiDinJQgVGhlIHNlcnZlciBzZW5kcyBgb3JpZW50YXRpb25RdWF0YCBkYXRhIHRvIGFsbCBjbGllbnRzIGNvbm5lY3RlZCB0byBhIHNlcnZlciBkdXJpbmcgXCJwZWVyIHVwZGF0ZXNcIi5cbiAgICAgKi9cbiAgICBvcmllbnRhdGlvblF1YXQ6IE9yaWVudGF0aW9uUXVhdDNEO1xuICAgIC8qKlxuICAgICAqIEZvciBjb252ZW5pZW5jZSwgYSBFdWxlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgb3JpZW50YXRpb24gaXMgc3VwcG9ydGVkLlxuICAgICAqIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgd2F5IHRvIHNwZWNpZnkgdGhlIGBvcmllbnRhdGlvblF1YXRgIGZpZWxkIGluIHRoZSBgSGlGaUF1ZGlvQVBJRGF0YWAgdGhhdCBpcyBzZW50IHRvIG9yIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKiBcbiAgICAgKiAg4pyUIFdoZW4gdXNpbmcgZXVsZXIgcmVwcmVzZW50YXRpb24gdG8gdXBkYXRlIHRoZSBjbGllbnQgb3JpZW50YXRpb24sIHRoZSBlcXVpdmFsZW50IFF1YXRlcm5pb24gaXMgZXZhbHVhdGVkIGluIGBfdXBkYXRlVXNlckRhdGEoKWBcbiAgICAgKiBcbiAgICAgKiAg4pyUIFdoZW4gcmVxdWVzdGluZyBvcmllbnRhdGlvbiBFdWxlciBmcm9tIHNlcnZlciB1cGRhdGVzLCB0aGUgRXVsZXIgcmVwcmVzZW50YXRpb24gaXMgZXZhbHVhdGVkIGluIGBfaGFuZGxlVXNlckRhdGFVcGRhdGVzKClgXG4gICAgICovXG4gICAgb3JpZW50YXRpb25FdWxlcjogT3JpZW50YXRpb25FdWxlcjNEO1xuICAgIC8qKlxuICAgICAqIEEgdm9sdW1lIGxldmVsIGJlbG93IHRoaXMgdmFsdWUgaXMgY29uc2lkZXJlZCBiYWNrZ3JvdW5kIG5vaXNlIGFuZCB3aWxsIGJlIHNtb290aGx5IGdhdGVkIG9mZi5cbiAgICAgKiBUaGUgZmxvYXRpbmcgcG9pbnQgdmFsdWUgaXMgc3BlY2lmaWVkIGluIGRCRlMgKGRlY2liZWxzIHJlbGF0aXZlIHRvIGZ1bGwgc2NhbGUpIHdpdGggdmFsdWVzIGJldHdlZW4gLTk2IGRCIChpbmRpY2F0aW5nIG5vIGdhdGluZylcbiAgICAgKiBhbmQgMCBkQiAoZWZmZWN0aXZlbHkgbXV0aW5nIHRoZSBpbnB1dCBmcm9tIHRoaXMgdXNlcikuIEl0IGlzIGluIHRoZSBzYW1lIGRlY2liZWwgdW5pdHMgYXMgdGhlIFZvbHVtZURlY2liZWxzIGNvbXBvbmVudCBvZiBVc2VyRGF0YVN1YnNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICB2b2x1bWVUaHJlc2hvbGQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGlzIHZhbHVlIGFmZmVjdHMgaG93IGxvdWQgVXNlciBBIHdpbGwgc291bmQgdG8gVXNlciBCIGF0IGEgZ2l2ZW4gZGlzdGFuY2UgaW4gM0Qgc3BhY2UuXG4gICAgICogVGhpcyB2YWx1ZSBhbHNvIGFmZmVjdHMgdGhlIGRpc3RhbmNlIGF0IHdoaWNoIFVzZXIgQSBjYW4gYmUgaGVhcmQgaW4gM0Qgc3BhY2UuXG4gICAgICogSGlnaGVyIHZhbHVlcyBmb3IgVXNlciBBIG1lYW5zIHRoYXQgVXNlciBBIHdpbGwgc291bmQgbG91ZGVyIHRvIG90aGVyIHVzZXJzIGFyb3VuZCBVc2VyIEEsIGFuZCBpdCBhbHNvIG1lYW5zIHRoYXQgVXNlciBBIHdpbGwgYmUgYXVkaWJsZSBmcm9tIGEgZ3JlYXRlciBkaXN0YW5jZS5cbiAgICAgKiBJZiB5b3UgZG9uJ3Qgc3VwcGx5IGFuIGBoaUZpR2FpbmAgd2hlbiBjb25zdHJ1Y3RpbmcgaW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcywgYGhpRmlHYWluYCB3aWxsIGJlIGBudWxsYC5cbiAgICAgKiBcbiAgICAgKiDinJQgVGhlIGNsaWVudCBzZW5kcyBgaGlGaUdhaW5gIGRhdGEgdG8gdGhlIHNlcnZlciB3aGVuIGBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIoKWAgaXMgY2FsbGVkLlxuICAgICAqIFxuICAgICAqIOKdjCBUaGUgc2VydmVyIGRvZXMgbm90IHNlbmQgYGhpRmlHYWluYCBkYXRhIHRvIGFsbCBjbGllbnRzIGFzIHBhcnQgb2YgXCJwZWVyIHVwZGF0ZXNcIi5cbiAgICAgKi9cbiAgICBoaUZpR2FpbjogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoaXMgdmFsdWUgYWZmZWN0cyBob3cgZmFyIGEgdXNlcidzIHNvdW5kIHdpbGwgdHJhdmVsIGluIDNEIHNwYWNlLCB3aXRob3V0IGFmZmVjdGluZyB0aGUgdXNlcidzIGxvdWRuZXNzLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZXJlIGlzIGEgZ2xvYmFsIGF0dGVudWF0aW9uIHZhbHVlIChzZXQgZm9yIGEgZ2l2ZW4gc3BhY2UpIHRoYXQgYXBwbGllcyB0byBhbGwgdXNlcnMgaW4gYSBzcGFjZS4gVGhpcyBkZWZhdWx0IHNwYWNlXG4gICAgICogYXR0ZW51YXRpb24gaXMgdXN1YWxseSAwLjUsIHdoaWNoIHJlcHJlc2VudHMgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb24gb2YgYSByZWFsLXdvcmxkIGZhbGwtb2ZmIGluIHNvdW5kIG92ZXIgZGlzdGFuY2UuXG4gICAgICogTG93ZXIgbnVtYmVycyByZXByZXNlbnQgbGVzcyBhdHRlbnVhdGlvbiAoaS5lLiBzb3VuZCB0cmF2ZWxzIGZhcnRoZXIpOyBoaWdoZXIgbnVtYmVycyByZXByZXNlbnQgbW9yZSBhdHRlbnVhdGlvbiAoaS5lLiBzb3VuZCBkcm9wc1xuICAgICAqIG9mZiBtb3JlIHF1aWNrbHkpLlxuICAgICAqIFxuICAgICAqIFdoZW4gc2V0dGluZyB0aGlzIHZhbHVlIGZvciBhbiBpbmRpdmlkdWFsIHVzZXIsIHRoZSBmb2xsb3dpbmcgaG9sZHM6XG4gICAgICogICAtIFBvc2l0aXZlIG51bWJlcnMgc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgMSwgYW5kIHRoZXkgcmVwcmVzZW50IGEgbG9nYXJpdGhtaWMgYXR0ZW51YXRpb24uIFRoaXMgcmFuZ2UgaXMgcmVjb21tZW5kZWQsIGFzIGl0IGlzXG4gICAgICogbW9yZSBuYXR1cmFsIHNvdW5kaW5nLiAgU21hbGxlciBudW1iZXJzIHJlcHJlc2VudCBsZXNzIGF0dGVudWF0aW9uLCBzbyBhIG51bWJlciBzdWNoIGFzIDAuMiBjYW4gYmUgdXNlZCB0byBtYWtlIGEgcGFydGljdWxhciBcbiAgICAgKiB1c2VyJ3MgYXVkaW8gdHJhdmVsIGZhcnRoZXIgdGhhbiBvdGhlciB1c2VycycsIGZvciBpbnN0YW5jZSBpbiBcImFtcGxpZmllZFwiIGNvbmNlcnQgdHlwZSBzZXR0aW5ncy4gU2ltaWxhcmx5LCBhbiBleHRyZW1lbHkgXG4gICAgICogc21hbGwgbm9uLXplcm8gbnVtYmVyIChlLmcuIDAuMDAwMDEpIGNhbiBiZSB1c2VkIHRvIGVmZmVjdGl2ZWx5IHR1cm4gb2ZmIGF0dGVudWF0aW9uIGZvciBhIGdpdmVuIHVzZXIgd2l0aGluIGEgcmVhc29uYWJseSBcbiAgICAgKiBzaXplZCBzcGFjZSwgcmVzdWx0aW5nIGluIGEgXCJicm9hZGNhc3QgbW9kZVwiIHdoZXJlIHRoZSB1c2VyIGNhbiBiZSBoZWFyZCB0aHJvdWdob3V0IG1vc3Qgb2YgdGhlIHNwYWNlIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgbG9jYXRpb25cbiAgICAgKiByZWxhdGl2ZSB0byBvdGhlciB1c2Vycy4gKE5vdGU6IFRoZSBhY3R1YWwgdmFsdWUgXCIwXCIgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIHJlcHJlc2VudCB0aGUgZGVmYXVsdDsgZm9yIHNldHRpbmcgbWluaW1hbCBhdHRlbnVhdGlvbiwgXG4gICAgICogc21hbGwgbm9uLXplcm8gbnVtYmVycyBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLiBTZWUgYWxzbyBcInVzZXJSb2xsb2ZmXCIgYmVsb3cuKVxuICAgICAqICAgLSBOZWdhdGl2ZSBhdHRlbnVhdGlvbiBudW1iZXJzIGFyZSB1c2VkIHRvIHJlcHJlc2VudCBsaW5lYXIgYXR0ZW51YXRpb24sIGFuZCBhcmUgYSBzb21ld2hhdCBhcnRpZmljaWFsLCBub24tcmVhbC13b3JsZCBjb25jZXB0LiBIb3dldmVyLFxuICAgICAqIHRoaXMgc2V0dGluZyBjYW4gYmUgdXNlZCBhcyBhIGJsdW50IHRvb2wgdG8gZWFzaWx5IHRlc3QgYXR0ZW51YXRpb24sIGFuZCB0dW5lIGl0IGFnZ3Jlc3NpdmVseSBpbiBleHRyZW1lIGNpcmN1bXN0YW5jZXMuIFdoZW4gdXNpbmcgbGluZWFyIFxuICAgICAqIGF0dGVudWF0aW9uLCB0aGUgc2V0dGluZyBpcyB0aGUgZGlzdGFuY2UgaW4gbWV0ZXJzIGF0IHdoaWNoIHRoZSBhdWRpbyBiZWNvbWVzIHRvdGFsbHkgaW5hdWRpYmxlLlxuICAgICAqXG4gICAgICogSWYgeW91IGRvbid0IHN1cHBseSBhbiBgdXNlckF0dGVudWF0aW9uYCB3aGVuIGNvbnN0cnVjdGluZyBpbnN0YW50aWF0aW9ucyBvZiB0aGlzIGNsYXNzLCBgdXNlckF0dGVudWF0aW9uYCB3aWxsIGJlIGBudWxsYCBhbmQgdGhlXG4gICAgICogZGVmYXVsdCB3aWxsIGJlIHVzZWQuXG4gICAgICogXG4gICAgICog4pyUIFRoZSBjbGllbnQgc2VuZHMgYHVzZXJBdHRlbnVhdGlvbmAgZGF0YSB0byB0aGUgc2VydmVyIHdoZW4gYF90cmFuc21pdEhpRmlBdWRpb0FQSURhdGFUb1NlcnZlcigpYCBpcyBjYWxsZWQuXG4gICAgICogXG4gICAgICog4p2MIFRoZSBzZXJ2ZXIgbmV2ZXIgc2VuZHMgYHVzZXJBdHRlbnVhdGlvbmAgZGF0YS5cbiAgICAgKi9cbiAgICB1c2VyQXR0ZW51YXRpb246IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdXNlclJvbGxvZmYgVGhpcyB2YWx1ZSByZXByZXNlbnRzIHRoZSBwcm9ncmVzc2l2ZSBoaWdoIGZyZXF1ZW5jeSByb2xsLW9mZiBpbiBtZXRlcnMsIGEgbWVhc3VyZSBvZiBob3cgdGhlIGhpZ2hlciBmcmVxdWVuY2llcyBcbiAgICAgKiBpbiBhIHVzZXIncyBzb3VuZCBhcmUgZGFtcGVuZWQgYXMgdGhlIHVzZXIgZ2V0cyBmdXJ0aGVyIGF3YXkuIEJ5IGRlZmF1bHQsIHRoZXJlIGlzIGEgZ2xvYmFsIHJvbGwtb2ZmIHZhbHVlIChzZXQgZm9yIGEgZ2l2ZW4gc3BhY2UpLCBjdXJyZW50bHkgMTYgXG4gICAgICogbWV0ZXJzLCB3aGljaCBhcHBsaWVzIHRvIGFsbCB1c2VycyBpbiBhIHNwYWNlLiBUaGlzIHZhbHVlIHJlcHJlc2VudHMgdGhlIGRpc3RhbmNlIGZvciBhIDFrSHogcm9sbG9mZi4gVmFsdWVzIGluIHRoZSByYW5nZSBvZiBcbiAgICAgKiAxMiB0byAzMiBtZXRlcnMgcHJvdmlkZSBhIG1vcmUgXCJlbmNsb3NlZFwiIHNvdW5kLCBpbiB3aGljaCBoaWdoIGZyZXF1ZW5jaWVzIHRlbmQgdG8gYmUgZGFtcGVuZWQgb3ZlciBkaXN0YW5jZSBhcyB0aGV5IGFyZSBcbiAgICAgKiBpbiB0aGUgcmVhbCB3b3JsZC4gR2VuZXJhbGx5IGNoYW5nZXMgdG8gcm9sbC1vZmYgdmFsdWVzIHNob3VsZCBiZSBtYWRlIGZvciB0aGUgZW50aXJlIHNwYWNlIHJhdGhlciB0aGFuIGZvciBpbmRpdmlkdWFsIHVzZXJzLCBidXRcbiAgICAgKiBleHRyZW1lbHkgaGlnaCB2YWx1ZXMgKGUuZy4gOTk5OTkpIHNob3VsZCBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggXCJicm9hZGNhc3QgbW9kZVwiLXN0eWxlIHVzZXJBdHRlbnVhdGlvbiBzZXR0aW5ncyB0byBjYXVzZSB0aGVcbiAgICAgKiBicm9hZGNhc3RlZCB2b2ljZSB0byBzb3VuZCBjcmlzcCBhbmQgXCJ1cCBjbG9zZVwiIGV2ZW4gYXQgdmVyeSBsYXJnZSBkaXN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgZG9uJ3Qgc3VwcGx5IGFuIGB1c2VyUm9sbG9mZmAgd2hlbiBjb25zdHJ1Y3RpbmcgaW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcywgYHVzZXJSb2xsb2ZmYCB3aWxsIGJlIGBudWxsYC5cbiAgICAgKiBcbiAgICAgKiDinJQgVGhlIGNsaWVudCBzZW5kcyBgdXNlclJvbGxvZmZgIGRhdGEgdG8gdGhlIHNlcnZlciB3aGVuIGBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIoKWAgaXMgY2FsbGVkLlxuICAgICAqIFxuICAgICAqIOKdjCBUaGUgc2VydmVyIG5ldmVyIHNlbmRzIGB1c2VyUm9sbG9mZmAgZGF0YS5cbiAgICAgKi9cbiAgICB1c2VyUm9sbG9mZjogbnVtYmVyO1xuXG4gICAgLypcbiAgICAgKiBUaGlzIGlzIGFuIGludGVybmFsIGNsYXNzIGFuZCBpdCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIG5vcm1hbCB1c2FnZSBvZiB0aGUgQVBJLlxuICAgICAqXG4gICAgICogU2VlIGluc3RlYWQge0BsaW5rIEhpRmlDb21tdW5pY2F0b3Iuc2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvbn0sIHdoaWNoIGFsbG93cyB5b3UgdG8gc2V0IHRoZSBkZXNpcmVkIGdhaW5zIGZvciBvbmUgb3IgbW9yZSB1c2VycyBhcyBwZXJjZWl2ZWQgYnkgdGhpcyBjbGllbnQgb25seS4gSWYgeW91IG5lZWQgdG8gcGVyZm9ybSBtb2RlcmF0aW9uIGFjdGlvbnMgb24gdGhlIHNlcnZlciBzaWRlLCB1c2UgdGhlIHtAbGluayBodHRwczovL2RvY3MuaGlnaGZpZGVsaXR5LmNvbS9yZXN0L2xhdGVzdC9pbmRleC5odG1sfEFkbWluaXN0cmF0aXZlIFJFU1QgQVBJfS5cbiAgICAgKlxuICAgICAqIEludGVybmFsbHksIHRoaXMgdmFyaWFibGUgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIG90aGVyIHVzZXIgZ2FpbiBjaGFuZ2VzIG5lZWQgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLiBUaGUga2V5cyBhcmUgaGFzaGVkIHZpc2l0IElEcywgYW5kIHRoZSB2YWx1ZXMgYXJlIGdhaW5zLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb3RoZXJVc2VyR2FpblF1ZXVlOiBPdGhlclVzZXJHYWluTWFwO1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKHsgcG9zaXRpb24gPSBudWxsLCBvcmllbnRhdGlvblF1YXQgPSBudWxsLCBvcmllbnRhdGlvbkV1bGVyID0gbnVsbCwgdm9sdW1lVGhyZXNob2xkID0gbnVsbCwgaGlGaUdhaW4gPSBudWxsLCB1c2VyQXR0ZW51YXRpb24gPSBudWxsLCB1c2VyUm9sbG9mZiA9IG51bGwgfTogeyBwb3NpdGlvbj86IFBvaW50M0QsIG9yaWVudGF0aW9uUXVhdD86IE9yaWVudGF0aW9uUXVhdDNELCBvcmllbnRhdGlvbkV1bGVyPzogT3JpZW50YXRpb25FdWxlcjNELCB2b2x1bWVUaHJlc2hvbGQ/OiBudW1iZXIsIGhpRmlHYWluPzogbnVtYmVyLCB1c2VyQXR0ZW51YXRpb24/OiBudW1iZXIsIHVzZXJSb2xsb2ZmPzogbnVtYmVyIH0gPSB7fSkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHRoaXMub3JpZW50YXRpb25RdWF0ID0gb3JpZW50YXRpb25RdWF0O1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uRXVsZXIgPSBvcmllbnRhdGlvbkV1bGVyO1xuICAgICAgICB0aGlzLnZvbHVtZVRocmVzaG9sZCA9IHZvbHVtZVRocmVzaG9sZDtcbiAgICAgICAgdGhpcy5oaUZpR2FpbiA9IGhpRmlHYWluO1xuICAgICAgICB0aGlzLnVzZXJBdHRlbnVhdGlvbiA9IHVzZXJBdHRlbnVhdGlvbjtcbiAgICAgICAgdGhpcy51c2VyUm9sbG9mZiA9IHVzZXJSb2xsb2ZmO1xuICAgICAgICB0aGlzLl9vdGhlclVzZXJHYWluUXVldWUgPSB7fTtcbiAgICB9XG59XG5cbi8qKlxuICogSW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcyBjb250YWluIGFsbCBvZiB0aGUgZGF0YSB0aGF0IGlzIHBvc3NpYmxlIHRvICoqcmVjZWl2ZSBmcm9tKiogdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIFNlcnZlci5cbiAqIFNlZSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICogXG4gKiBTZWUge0BsaW5rIEhpRmlBdWRpb0FQSURhdGF9IGZvciBkYXRhIHRoYXQgY2FuIGJvdGggYmUgc2VudCB0byBhbmQgcmVjZWl2ZWQgZnJvbSB0aGUgU2VydmVyIChpLmUuIGBwb3NpdGlvbmApLlxuICovXG5leHBvcnQgY2xhc3MgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhIGV4dGVuZHMgSGlGaUF1ZGlvQVBJRGF0YSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBVc2VyIElEIGlzIGFuIGFyYml0cmFyeSBzdHJpbmcgcHJvdmlkZWQgYnkgYW4gYXBwbGljYXRpb24gZGV2ZWxvcGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB1c2VyIGFzc29jaWF0ZWQgd2l0aCBhIGNsaWVudC5cbiAgICAgKiBXZSByZWNvbW1lbmQgdGhhdCB0aGlzIGBwcm92aWRlZFVzZXJJRGAgaXMgdW5pcXVlIGFjcm9zcyBhbGwgdXNlcnMsIGJ1dCB0aGUgSGlnaCBGaWRlbGl0eSBBUEkgd2lsbCBub3QgZW5mb3JjZSB1bmlxdWVuZXNzIGFjcm9zcyBjbGllbnRzIGZvciB0aGlzIHZhbHVlLlxuICAgICAqL1xuICAgIHByb3ZpZGVkVXNlcklEOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhpcyBzdHJpbmcgaXMgYSBoYXNoZWQgdmVyc2lvbiBvZiB0aGUgcmFuZG9tIFVVSUQgdGhhdCBpcyBnZW5lcmF0ZWQgYXV0b21hdGljYWxseS5cbiAgICAgKiBcbiAgICAgKiBBIGNvbm5lY3RpbmcgY2xpZW50IHNlbmRzIHRoaXMgdmFsdWUgYXMgdGhlIGBzZXNzaW9uYCBrZXkgaW5zaWRlIHRoZSBhcmd1bWVudCB0byB0aGUgYGF1ZGlvbmV0LmluaXRgIGNvbW1hbmQuXG4gICAgICogXG4gICAgICogSXQgaXMgdXNlZCB0byBpZGVudGlmeSBhIGdpdmVuIGNsaWVudCBhY3Jvc3MgYSBjbG91ZCBvZiBtaXhlcnMgYW5kIGlzIGd1YXJhbnRlZWQgKFwiZ3VhcmFudGVlZFwiIGdpdmVuIHRoZSBjb250ZXh0IG9mIHJhbmRvbSBVVUlEUykgdG8gYmUgdW5pcXVlLlxuICAgICAqIEFwcGxpY2F0aW9uIGRldmVsb3BlcnMgc2hvdWxkIG5vdCBuZWVkIHRvIGludGVyYWN0IHdpdGggb3IgbWFrZSB1c2Ugb2YgdGhpcyB2YWx1ZSwgdW5sZXNzIHRoZXkgd2FudCB0byB1c2UgaXQgaW50ZXJuYWxseSBmb3IgdHJhY2tpbmcgb3Igb3RoZXIgcHVycG9zZXMuXG4gICAgICogXG4gICAgICogVGhpcyB2YWx1ZSBjYW5ub3QgYmUgc2V0IGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIuXG4gICAgICovXG4gICAgaGFzaGVkVmlzaXRJRDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgdXNlciBpbiBkZWNpYmVscy5cbiAgICAgKiBcbiAgICAgKiDinYwgVGhlIGNsaWVudCBuZXZlciBzZW5kcyBgdm9sdW1lRGVjaWJlbHNgIGRhdGEgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBcbiAgICAgKiDinJQgVGhlIHNlcnZlciBzZW5kcyBgdm9sdW1lRGVjaWJlbHNgIGRhdGEgdG8gYWxsIGNsaWVudHMgY29ubmVjdGVkIHRvIGEgc2VydmVyIGR1cmluZyBcInBlZXIgdXBkYXRlc1wiLlxuICAgICAqL1xuICAgIHZvbHVtZURlY2liZWxzOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgcGVlciBpcyBwcm92aWRpbmcgc3RlcmVvIGF1ZGlvLlxuICAgICAqXG4gICAgICogVGhlIHNlcnZlciBzZW5kcyBgaXNTdGVyZW9gIGRhdGEgdG8gYWxsIGNsaWVudHMgY29ubmVjdGVkIHRvIGEgc2VydmVyIGR1cmluZyBcInBlZXIgdXBkYXRlc1wiLlxuICAgICAqL1xuICAgIGlzU3RlcmVvOiBib29sZWFuO1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKHBhcmFtczogeyBwcm92aWRlZFVzZXJJRD86IHN0cmluZywgaGFzaGVkVmlzaXRJRD86IHN0cmluZywgdm9sdW1lRGVjaWJlbHM/OiBudW1iZXIsIHBvc2l0aW9uPzogUG9pbnQzRCwgb3JpZW50YXRpb25RdWF0PzogT3JpZW50YXRpb25RdWF0M0QsIGlzU3RlcmVvPzogYm9vbGVhbiB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgICAgdGhpcy5wcm92aWRlZFVzZXJJRCA9IHBhcmFtcy5wcm92aWRlZFVzZXJJRDtcbiAgICAgICAgdGhpcy5oYXNoZWRWaXNpdElEID0gcGFyYW1zLmhhc2hlZFZpc2l0SUQ7XG4gICAgICAgIHRoaXMudm9sdW1lRGVjaWJlbHMgPSBwYXJhbXMudm9sdW1lRGVjaWJlbHM7XG4gICAgICAgIHRoaXMuaXNTdGVyZW8gPSBwYXJhbXMuaXNTdGVyZW87XG4gICAgfVxufVxuIiwiLyoqXG4gKiBUaGlzIG1vZHVsZSBwZXJ0YWlucyB0byAzRCBBeGlzIGNvbmZpZ3VhdGlvbi4gTW9kaWZ5IHlvdXIgM0QgYXhpcyBjb25maWd1cmF0aW9uIHdoZW4gY29uc3RydWN0aW5nIGEgbmV3IFtbSGlGaUNvbW11bmljYXRvcl1dIG9iamVjdC5cbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5cbmltcG9ydCB7IEhpRmlMb2dnZXIgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL0hpRmlMb2dnZXJcIjtcbmltcG9ydCB7IE9yaWVudGF0aW9uUXVhdDNELCBQb2ludDNELCBPcmllbnRhdGlvbkV1bGVyM0RPcmRlciwgT3JpZW50YXRpb25FdWxlcjNEIH0gZnJvbSBcIi4vSGlGaUF1ZGlvQVBJRGF0YVwiO1xuXG5leHBvcnQgZW51bSBIaUZpQXhlcyB7XG4gICAgUG9zaXRpdmVYID0gXCJQb3NpdGl2ZSBYXCIsXG4gICAgTmVnYXRpdmVYID0gXCJOZWdhdGl2ZSBYXCIsXG4gICAgUG9zaXRpdmVZID0gXCJQb3NpdGl2ZSBZXCIsXG4gICAgTmVnYXRpdmVZID0gXCJOZWdhdGl2ZSBZXCIsXG4gICAgUG9zaXRpdmVaID0gXCJQb3NpdGl2ZSBaXCIsXG4gICAgTmVnYXRpdmVaID0gXCJOZWdhdGl2ZSBaXCJcbn1cblxuZXhwb3J0IGVudW0gSGlGaUhhbmRlZG5lc3Mge1xuICAgIFJpZ2h0SGFuZCA9IFwiUmlnaHQgSGFuZFwiLFxuICAgIExlZnRIYW5kID0gXCJMZWZ0IEhhbmRcIlxufVxuXG4vKipcbiAqIFRoZSBheGlzIGNvbmZpZ3VyYXRpb24gZGVzY3JpYmVzIHRoZSAzZCBmcmFtZSBvZiByZWZlcmVuY2UgaW4gd2hpY2ggYXJlIGV4cHJlc3NlZCB0aGUgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIG9mIHRoZSBIaWZpQ29tbXVuaWNhdG9yIHBlZXJzLlxuICogQWxsIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBzZW5kIG9yIHJlY2VpdmVkIGZyb20gdGhlIGFwaSBjYWxscyBhcmUgZXhwZWN0ZWQgdG8gYmUgZXhwcmVzc2VkIHVzaW5nIHRoYXQgc3BhY2UgY29udmVudGlvbi5cbiAqIE9uIHRoZSB3aXJlIGFuZCBpbiB0aGUgbWl4ZXIsIHRoZSBIaUZpIFNwYXRpYWwgQXVkaW8gc3lzdGVtIGlzIHVzaW5nIGEgc2luZ2xlIHVuaWZpZWQgY29udmVudGlvbiBjYWxsZWQgJ01peGVyU3BhY2UnIHdoaWNoIGlzIHRoZSBzYW1lIGFzIHRoZSBcbiAqIGRlZmF1bHQgdmFsdWUsIHNlZSB7QGxpbmsgb3VySGlGaUF4aXNDb25maWd1cmF0aW9ufS5cbiAqIFxuICogV2hlbiBjb252ZXJ0aW5nIHRoZSBvcmllbnRhdGlvbkV1bGVyLCB0byBvciBmcm9tIHRoZSBxdWF0ZXJuaW9uIHJlcHJlc2VudGF0aW9uLCB0aGUgTGlicmFyeSByZWxpZXMgb24gdGhlIEhpRmlDb21tdW5pY2F0b3IncyBheGlzQ29uZmlndXJhdGlvblxuICogdG8gYXBwbHkgdGhlIGV4cGVjdGVkIGNvbnZlbnRpb24gYW5kIGNvcnJlY3QgY29udmVyc2lvbi5cbiAqIFRoZSAnZXVsZXJPcmRlcicgZmllbGQgb2YgdGhlIGF4aXMgY29uZmlndXJhdGlvbiBpcyB1c2VkIGZvciB0aGlzIGNvbnZlcnNpb24uXG4gKiBcbiAqIOKaoCBXQVJOSU5HIOKaoCBcbiAqIFRoZSBheGlzIGNvbmZpZ3VyYXRpb24gZmllbGRzIChyaWdodEF4aXMsIGxlZnRBeGlzLCBpbnRvU2NyZWVuQXhpcywgb3V0T2ZTY3JlZW5BeGlzLCB1cEF4aXMsIGRvd25BeGlzLCBoYW5kZWRuZXNzKSBhcmUgbm90IGluIHVzZSB5ZXRcbiAqIE9ubHkgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoaXMgZmllbGRzIHdpbGwgcmVzdWx0IGluIHRoZSBleHBlY3RlZCBiZWhhdmlvci5cbiAqIFRoZSBldWxlck9yZGVyIGZpZWxkIGlzIHdvcmtpbmcgY29ycmVjbHR5IGFuZCBjYW4gYmUgY29uZmlndXJlZCBhdCB0aGUgY3JlYXRpb24gb2YgdGhlIEhpRmlDb21tdW5pY2F0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIEhpRmlBeGlzQ29uZmlndXJhdGlvbiB7XG4gICAgcmlnaHRBeGlzOiBIaUZpQXhlcztcbiAgICBsZWZ0QXhpczogSGlGaUF4ZXM7XG5cbiAgICBpbnRvU2NyZWVuQXhpczogSGlGaUF4ZXM7XG4gICAgb3V0T2ZTY3JlZW5BeGlzOiBIaUZpQXhlcztcblxuICAgIHVwQXhpczogSGlGaUF4ZXM7XG4gICAgZG93bkF4aXM6IEhpRmlBeGVzO1xuXG4gICAgaGFuZGVkbmVzczogSGlGaUhhbmRlZG5lc3M7XG5cbiAgICBldWxlck9yZGVyOiBPcmllbnRhdGlvbkV1bGVyM0RPcmRlcjtcblxuICAgIGNvbnN0cnVjdG9yKHtyaWdodEF4aXMsIGxlZnRBeGlzLCBpbnRvU2NyZWVuQXhpcywgb3V0T2ZTY3JlZW5BeGlzLCB1cEF4aXMsIGRvd25BeGlzLCBoYW5kZWRuZXNzLCBldWxlck9yZGVyfToge3JpZ2h0QXhpczogSGlGaUF4ZXMsIGxlZnRBeGlzOiBIaUZpQXhlcywgaW50b1NjcmVlbkF4aXM6IEhpRmlBeGVzLCBvdXRPZlNjcmVlbkF4aXM6IEhpRmlBeGVzLCB1cEF4aXM6IEhpRmlBeGVzLCBkb3duQXhpczogSGlGaUF4ZXMsIGhhbmRlZG5lc3M6IEhpRmlIYW5kZWRuZXNzLCBldWxlck9yZGVyOiBPcmllbnRhdGlvbkV1bGVyM0RPcmRlciB9KSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyByaWdodEF4aXMsIGxlZnRBeGlzLCBpbnRvU2NyZWVuQXhpcywgb3V0T2ZTY3JlZW5BeGlzLCB1cEF4aXMsIGRvd25BeGlzLCBoYW5kZWRuZXNzLCBldWxlck9yZGVyIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb250YWlucyB0aGUgYXBwbGljYXRpb24ncyAzRCBheGlzIGNvbmZpZ3VyYXRpb24uIEJ5IGRlZmF1bHQ6XG4gKiAtIGAreGAgaXMgdG8gdGhlIHJpZ2h0IGFuZCBgLXhgIGlzIHRvIHRoZSBsZWZ0XG4gKiAtIGAreWAgaXMgdXAgYW5kIGAteWAgaXMgZG93blxuICogLSBgK3pgIGlzIGJhY2sgYW5kIGAtemAgaXMgZnJvbnRcbiAqIC0gVGhlIGNvb3JkaW5hdGUgc3lzdGVtIGlzIHJpZ2h0LWhhbmRlZC5cbiAqIC0gRXVsZXIgb3JkZXIgaXMgYE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLllhd1BpdGNoUm9sbGBcbiAqL1xuZXhwb3J0IGxldCBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24gPSBuZXcgSGlGaUF4aXNDb25maWd1cmF0aW9uKHtcbiAgICByaWdodEF4aXM6IEhpRmlBeGVzLlBvc2l0aXZlWCxcbiAgICBsZWZ0QXhpczogSGlGaUF4ZXMuTmVnYXRpdmVYLFxuICAgIGludG9TY3JlZW5BeGlzOiBIaUZpQXhlcy5Qb3NpdGl2ZVksXG4gICAgb3V0T2ZTY3JlZW5BeGlzOiBIaUZpQXhlcy5OZWdhdGl2ZVksXG4gICAgdXBBeGlzOiBIaUZpQXhlcy5Qb3NpdGl2ZVosXG4gICAgZG93bkF4aXM6IEhpRmlBeGVzLk5lZ2F0aXZlWixcbiAgICBoYW5kZWRuZXNzOiBIaUZpSGFuZGVkbmVzcy5SaWdodEhhbmQsXG4gICAgZXVsZXJPcmRlcjogT3JpZW50YXRpb25FdWxlcjNET3JkZXIuWWF3UGl0Y2hSb2xsLFxufSk7XG5cbmV4cG9ydCBjbGFzcyBIaUZpQXhpc1V0aWxpdGllcyB7XG4gICAgc3RhdGljIHZlcmlmeShheGlzQ29uZmlndXJhdGlvbjogSGlGaUF4aXNDb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGxldCBpc1ZhbGlkID0gdHJ1ZTtcblxuICAgICAgICAvLyBTVEFSVCBsZWZ0L3JpZ2h0IGF4aXMgZXJyb3IgY2hlY2tpbmdcbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVgpIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblJpZ2h0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXN9LCBhbmQgTGVmdCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGF4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVYKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5SaWdodCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzfSwgYW5kIExlZnQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVZKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5SaWdodCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzfSwgYW5kIExlZnQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWSkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuUmlnaHQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpc30sIGFuZCBMZWZ0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgYXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWikge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuUmlnaHQgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpc30sIGFuZCBMZWZ0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLmxlZnRBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgYXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVopIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblJpZ2h0IEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXN9LCBhbmQgTGVmdCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVORCBsZWZ0L3JpZ2h0IGF4aXMgZXJyb3IgY2hlY2tpbmdcblxuICAgICAgICAvLyBTVEFSVCBpbnRvLXNjcmVlbi9vdXQtb2Ytc2NyZWVuIGF4aXMgZXJyb3IgY2hlY2tpbmdcbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVggJiYgYXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVgpIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcbkludG9TY3JlZW4gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzfSwgYW5kIE91dE9mU2NyZWVuIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVYKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5JbnRvU2NyZWVuIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpc30sIGFuZCBPdXRPZlNjcmVlbiBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVZICYmIGF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVZKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5JbnRvU2NyZWVuIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpc30sIGFuZCBPdXRPZlNjcmVlbiBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVkgJiYgYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWSkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuSW50b1NjcmVlbiBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXN9LCBhbmQgT3V0T2ZTY3JlZW4gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWikge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuSW50b1NjcmVlbiBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uaW50b1NjcmVlbkF4aXN9LCBhbmQgT3V0T2ZTY3JlZW4gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGF4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVopIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcbkludG9TY3JlZW4gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzfSwgYW5kIE91dE9mU2NyZWVuIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVORCBpbnRvLXNjcmVlbi9vdXQtb2Ytc2NyZWVuIGF4aXMgZXJyb3IgY2hlY2tpbmdcblxuICAgICAgICAvLyBTVEFSVCB1cC9kb3duIGF4aXMgZXJyb3IgY2hlY2tpbmdcbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLnVwQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGF4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVgpIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblVwIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi51cEF4aXN9LCBhbmQgRG93biBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGF4aXNDb25maWd1cmF0aW9uLnVwQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVYKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5VcCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzfSwgYW5kIERvd24gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi51cEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyAhPT0gSGlGaUF4ZXMuTmVnYXRpdmVZKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5VcCBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzfSwgYW5kIERvd24gQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzfSFgKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBheGlzQ29uZmlndXJhdGlvbi51cEF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWSkge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuVXAgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnVwQXhpc30sIGFuZCBEb3duIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgYXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXMgIT09IEhpRmlBeGVzLk5lZ2F0aXZlWikge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgSW52YWxpZCBheGlzIGNvbmZpZ3VyYXRpb24hXFxuVXAgQXhpcyBpcyAke2F4aXNDb25maWd1cmF0aW9uLnVwQXhpc30sIGFuZCBEb3duIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXNDb25maWd1cmF0aW9uLmRvd25BeGlzID09PSBIaUZpQXhlcy5Qb3NpdGl2ZVogJiYgYXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzICE9PSBIaUZpQXhlcy5OZWdhdGl2ZVopIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYEludmFsaWQgYXhpcyBjb25maWd1cmF0aW9uIVxcblVwIEF4aXMgaXMgJHtheGlzQ29uZmlndXJhdGlvbi51cEF4aXN9LCBhbmQgRG93biBBeGlzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uZG93bkF4aXN9IWApO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVORCB1cC9kb3duIGF4aXMgZXJyb3IgY2hlY2tpbmdcblxuICAgICAgICBpZiAoIShheGlzQ29uZmlndXJhdGlvbi5oYW5kZWRuZXNzID09PSBIaUZpSGFuZGVkbmVzcy5SaWdodEhhbmQgfHwgYXhpc0NvbmZpZ3VyYXRpb24uaGFuZGVkbmVzcyA9PT0gSGlGaUhhbmRlZG5lc3MuTGVmdEhhbmQpKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBJbnZhbGlkIGF4aXMgY29uZmlndXJhdGlvbiFcXG5IYW5kZWRuZXNzIGlzICR7YXhpc0NvbmZpZ3VyYXRpb24uaGFuZGVkbmVzc30hYCk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICog4pqgIFdBUk5JTkcg4pqgIFRoZSBjb2RlIGluIHRoaXMgZnVuY3Rpb24gSVMgd3JvbmcuXG4gICAgICogVE9ETzogaW1wbGVtZW50IHRoZSBmdW5jdGlvbiwganVzdCBhIE5PIE9QIGF0IHRoZSBtb21lbnQuXG4gICAgICogXG4gICAgICogQHBhcmFtIGF4aXNDb25maWd1cmF0aW9uIFxuICAgICAqIEBwYXJhbSBpbnB1dFBvaW50M0QgXG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zbGF0ZVBvaW50M0RUb01peGVyU3BhY2UoYXhpc0NvbmZpZ3VyYXRpb246IEhpRmlBeGlzQ29uZmlndXJhdGlvbiwgaW5wdXRQb2ludDNEOiBQb2ludDNEKTogUG9pbnQzRCB7XG4gICAgICAgIGxldCByZXR2YWwgPSBuZXcgUG9pbnQzRCgpO1xuICAgICAgICAvKlxuICAgICAgICBsZXQgaW5wdXRYSXNOdW1iZXIgPSB0eXBlb2YgKGlucHV0UG9pbnQzRC54KSA9PT0gXCJudW1iZXJcIjtcbiAgICAgICAgbGV0IGlucHV0WUlzTnVtYmVyID0gdHlwZW9mIChpbnB1dFBvaW50M0QueSkgPT09IFwibnVtYmVyXCI7XG4gICAgICAgIGxldCBpbnB1dFpJc051bWJlciA9IHR5cGVvZiAoaW5wdXRQb2ludDNELnopID09PSBcIm51bWJlclwiO1xuXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBpbnB1dFhJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnggPSBpbnB1dFBvaW50M0QueDtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGlucHV0WElzTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR2YWwueCA9IC1pbnB1dFBvaW50M0QueDtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGlucHV0WUlzTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR2YWwueCA9IGlucHV0UG9pbnQzRC55O1xuICAgICAgICB9IGVsc2UgaWYgKGF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGlucHV0WUlzTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR2YWwueCA9IC1pbnB1dFBvaW50M0QueTtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi51cEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWCAmJiBpbnB1dFpJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnggPSBpbnB1dFBvaW50M0QuejtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVYICYmIGlucHV0WklzTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR2YWwueCA9IC1pbnB1dFBvaW50M0QuejtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBpbnB1dFhJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnkgPSBpbnB1dFBvaW50M0QueDtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVZICYmIGlucHV0WElzTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR2YWwueSA9IC1pbnB1dFBvaW50M0QueDtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVZICYmIGlucHV0WUlzTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR2YWwueSA9IGlucHV0UG9pbnQzRC55O1xuICAgICAgICB9IGVsc2UgaWYgKGF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVZICYmIGlucHV0WUlzTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR2YWwueSA9IC1pbnB1dFBvaW50M0QueTtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi51cEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWSAmJiBpbnB1dFpJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnkgPSBpbnB1dFBvaW50M0QuejtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVZICYmIGlucHV0WklzTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR2YWwueSA9IC1pbnB1dFBvaW50M0QuejtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChheGlzQ29uZmlndXJhdGlvbi5yaWdodEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBpbnB1dFhJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnogPSBpbnB1dFBvaW50M0QueDtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5sZWZ0QXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGlucHV0WElzTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR2YWwueiA9IC1pbnB1dFBvaW50M0QueDtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5pbnRvU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGlucHV0WUlzTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR2YWwueiA9IGlucHV0UG9pbnQzRC55O1xuICAgICAgICB9IGVsc2UgaWYgKGF4aXNDb25maWd1cmF0aW9uLm91dE9mU2NyZWVuQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGlucHV0WUlzTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR2YWwueiA9IC1pbnB1dFBvaW50M0QueTtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi51cEF4aXMgPT09IEhpRmlBeGVzLlBvc2l0aXZlWiAmJiBpbnB1dFpJc051bWJlcikge1xuICAgICAgICAgICAgcmV0dmFsLnogPSBpbnB1dFBvaW50M0QuejtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyA9PT0gSGlGaUF4ZXMuUG9zaXRpdmVaICYmIGlucHV0WklzTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR2YWwueiA9IC1pbnB1dFBvaW50M0QuejtcbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICByZXR2YWwgPSBpbnB1dFBvaW50M0Q7XG4gICAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog4pqgIFdBUk5JTkcg4pqgIFRoZSBjb2RlIGluIHRoaXMgZnVuY3Rpb24gSVMgd3JvbmcuXG4gICAgICogVE9ETzogaW1wbGVtZW50IHRoZSBmdW5jdGlvbiwganVzdCBhIE5PIE9QIGF0IHRoZSBtb21lbnQuXG4gICAgICogXG4gICAgICogQHBhcmFtIGF4aXNDb25maWd1cmF0aW9uIFxuICAgICAqIEBwYXJhbSBpbnB1dE9yaWVudGF0aW9uUXVhdDNEIFxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2xhdGVQb2ludDNERnJvbU1peGVyU3BhY2UoYXhpc0NvbmZpZ3VyYXRpb246IEhpRmlBeGlzQ29uZmlndXJhdGlvbiwgbWl4ZXJQb2ludDNEOiBQb2ludDNEKTogUG9pbnQzRCB7XG4gICAgICAgIGxldCByZXR2YWwgPSBuZXcgUG9pbnQzRCgpO1xuICAgICAgICByZXR2YWwgPSBtaXhlclBvaW50M0Q7XG4gICAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog4pqgIFdBUk5JTkcg4pqgIFRoZSBjb2RlIGluIHRoaXMgZnVuY3Rpb24gSVMgd3JvbmcuXG4gICAgICogVE9ETzogaW1wbGVtZW50IHRoZSBmdW5jdGlvbiwganVzdCBhIE5PIE9QIGF0IHRoZSBtb21lbnQuXG4gICAgICogXG4gICAgICogQHBhcmFtIGF4aXNDb25maWd1cmF0aW9uIFxuICAgICAqIEBwYXJhbSBpbnB1dE9yaWVudGF0aW9uUXVhdDNEIFxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2xhdGVPcmllbnRhdGlvblF1YXQzRFRvTWl4ZXJTcGFjZShheGlzQ29uZmlndXJhdGlvbjogSGlGaUF4aXNDb25maWd1cmF0aW9uLCBpbnB1dE9yaWVudGF0aW9uUXVhdDNEOiBPcmllbnRhdGlvblF1YXQzRCk6IE9yaWVudGF0aW9uUXVhdDNEIHtcbiAgICAgICAgbGV0IHJldHZhbCA9IG5ldyBPcmllbnRhdGlvblF1YXQzRCgpO1xuICAgICAgICByZXR2YWwgPSBpbnB1dE9yaWVudGF0aW9uUXVhdDNEO1xuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOKaoCBXQVJOSU5HIOKaoCBUaGUgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIElTIHdyb25nLlxuICAgICAqIFRPRE86IGltcGxlbWVudCB0aGUgZnVuY3Rpb24sIGp1c3QgYSBOTyBPUCBhdCB0aGUgbW9tZW50LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBheGlzQ29uZmlndXJhdGlvbiBcbiAgICAgKiBAcGFyYW0gaW5wdXRPcmllbnRhdGlvblF1YXQzRCBcbiAgICAgKi9cbiAgICBzdGF0aWMgdHJhbnNsYXRlT3JpZW50YXRpb25RdWF0M0RGcm9tTWl4ZXJTcGFjZShheGlzQ29uZmlndXJhdGlvbjogSGlGaUF4aXNDb25maWd1cmF0aW9uLCBtaXhlck9yaWVudGF0aW9uUXVhdDNEOiBPcmllbnRhdGlvblF1YXQzRCk6IE9yaWVudGF0aW9uUXVhdDNEIHtcbiAgICAgICAgbGV0IHJldHZhbCA9IG5ldyBPcmllbnRhdGlvblF1YXQzRCgpO1xuICAgICAgICByZXR2YWwgPSBtaXhlck9yaWVudGF0aW9uUXVhdDNEO1xuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH1cbn1cbiIsIi8qKlxuICogTWV0aG9kcyBvbiB0aGUgW1tIaUZpQ29tbXVuaWNhdG9yXV0gY2xhc3MgYWxsb3cgZGV2ZWxvcGVycyB0byBwZXJmb3JtIGFjdGlvbnMgc3VjaCBhczpcbiAqIC0gYGNvbm5lY3RUb0hpRmlBdWRpb0FQSVNlcnZlcigpYDogQ29ubmVjdCB0byBhbmQgZGlzY29ubmVjdCBmcm9tIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIFNlcnZlclxuICogLSBgdXBkYXRlVXNlckRhdGFBbmRUcmFuc21pdCgpYDogVXBkYXRlIHRoZSB1c2VyJ3MgZGF0YSAocG9zaXRpb24sIG9yaWVudGF0aW9uLCBldGMpIG9uIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIFNlcnZlclxuICogLSBgc2V0SW5wdXRBdWRpb01lZGlhU3RyZWFtKClgOiBTZXQgYSBuZXcgaW5wdXQgYXVkaW8gbWVkaWEgc3RyZWFtIChmb3IgZXhhbXBsZSwgd2hlbiB0aGUgdXNlcidzIGF1ZGlvIGlucHV0IGRldmljZSBjaGFuZ2VzKVxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cblxuZGVjbGFyZSB2YXIgSElGSV9BUElfVkVSU0lPTjogc3RyaW5nO1xuXG5pbXBvcnQgeyBIaUZpQ29uc3RhbnRzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9IaUZpQ29uc3RhbnRzXCI7XG5pbXBvcnQgeyBXZWJSVENTZXNzaW9uUGFyYW1zLCBDdXN0b21TVFVOYW5kVFVSTkNvbmZpZyB9IGZyb20gXCIuLi9saWJyYXZpL1JhdmlTZXNzaW9uXCI7XG5pbXBvcnQgeyBIaUZpTG9nZ2VyIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9IaUZpTG9nZ2VyXCI7XG5pbXBvcnQgeyBIaUZpVXRpbGl0aWVzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9IaUZpVXRpbGl0aWVzXCI7XG5pbXBvcnQgeyBIaUZpQXVkaW9BUElEYXRhLCBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEsIFBvaW50M0QsIE9yaWVudGF0aW9uUXVhdDNELCBPcmllbnRhdGlvbkV1bGVyM0QsIE9yaWVudGF0aW9uRXVsZXIzRE9yZGVyLCBldWxlclRvUXVhdGVybmlvbiwgZXVsZXJGcm9tUXVhdGVybmlvbiwgT3RoZXJVc2VyR2Fpbk1hcCB9IGZyb20gXCIuL0hpRmlBdWRpb0FQSURhdGFcIjtcbmltcG9ydCB7IEhpRmlBeGlzQ29uZmlndXJhdGlvbiwgSGlGaUF4aXNVdGlsaXRpZXMsIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbiB9IGZyb20gXCIuL0hpRmlBeGlzQ29uZmlndXJhdGlvblwiO1xuaW1wb3J0IHsgSGlGaU1peGVyU2Vzc2lvbiwgU2V0T3RoZXJVc2VyR2FpbkZvclRoaXNDb25uZWN0aW9uUmVzcG9uc2UsIFNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb25SZXNwb25zZSwgT25NdXRlQ2hhbmdlZENhbGxiYWNrIH0gZnJvbSBcIi4vSGlGaU1peGVyU2Vzc2lvblwiO1xuaW1wb3J0IHsgQXZhaWxhYmxlVXNlckRhdGFTdWJzY3JpcHRpb25Db21wb25lbnRzLCBVc2VyRGF0YVN1YnNjcmlwdGlvbiB9IGZyb20gXCIuL0hpRmlVc2VyRGF0YVN1YnNjcmlwdGlvblwiO1xuXG4vKipcbiAqIFdoZW4gdGhlIHN0YXRlIG9mIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIFNlcnZlciBjaGFuZ2VzLCB0aGUgbmV3IHN0YXRlIHdpbGwgYmUgb25lIG9mIHRoZXNlIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGVudW0gSGlGaUNvbm5lY3Rpb25TdGF0ZXMge1xuICAgIENvbm5lY3RlZCA9IFwiQ29ubmVjdGVkXCIsXG4gICAgRGlzY29ubmVjdGVkID0gXCJEaXNjb25uZWN0ZWRcIixcbiAgICBGYWlsZWQgPSBcIkZhaWxlZFwiLFxuICAgIC8qKlxuICAgICAqIFRoZSBgSGlGaUNvbm5lY3Rpb25TdGF0ZWAgd2lsbCBiZSBgXCJVbmF2YWlsYWJsZVwiYCB3aGVuIHRoZSBBUEkgU2VydmVyIGlzIGF0IGNhcGFjaXR5LlxuICAgICAqL1xuICAgIFVuYXZhaWxhYmxlID0gXCJVbmF2YWlsYWJsZVwiXG59O1xuXG4vKipcbiAqIFxuICovXG5leHBvcnQgZW51bSBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXMge1xuICAgIC8qKlxuICAgICAqIFBhc3NpbmcgdGhpcyB2YWx1ZSB0byB0aGUge0BsaW5rIEhpRmlDb21tdW5pY2F0b3J9IGNvbnN0cnVjdG9yIG1lYW5zIHRoYXQgdGhlIFNlcnZlciB3aWxsIG5vdCBzZW5kIGFueVxuICAgICAqIFVzZXIgRGF0YSB1cGRhdGVzIHRvIHRoZSBjbGllbnQsIG1lYW5pbmcgVXNlciBEYXRhIFN1YnNjcmlwdGlvbnMgd2lsbCBub3QgZnVuY3Rpb24uIFRoaXMgU3RyZWFtaW5nIFNjb3BlXG4gICAgICogc2F2ZXMgYmFuZHdpZHRoIGFuZCwgbWFyZ2luYWxseSwgcHJvY2Vzc2luZyB0aW1lLlxuICAgICAqL1xuICAgIE5vbmUgPSBcIm5vbmVcIixcbiAgICAvKipcbiAgICAgKiBQYXNzaW5nIHRoaXMgdmFsdWUgdG8gdGhlIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yfSBjb25zdHJ1Y3RvciBtZWFucyB0aGF0IHRoZSBTZXJ2ZXIgd2lsbCBvbmx5IHNlbmRcbiAgICAgKiBfcGVlciBkYXRhXyB0byB0aGUgQ2xpZW50OyB0aGUgU2VydmVyIHdpbGwgbm90IHNlbmQgVXNlciBEYXRhIHBlcnRhaW5pbmcgdG8gdGhlIGNvbm5lY3RpbmcgQ2xpZW50IHdoZW5cbiAgICAgKiB0aGlzIERhdGEgU3RyZWFtaW5nIFNjb3BlIGlzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIFBlZXJzID0gXCJwZWVyc1wiLFxuICAgIC8qKlxuICAgICAqIFwiYWxsXCIgaXMgdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiB0aGUge0BsaW5rIEhpRmlDb21tdW5pY2F0b3J9IGNvbnN0cnVjdG9yIGlzIGNhbGxlZC4gQWxsIFVzZXIgRGF0YVxuICAgICAqIHdpbGwgYmUgc3RyZWFtZWQgZnJvbSB0aGUgU2VydmVyIHRvIHRoZSBDbGllbnQuXG4gICAgICovXG4gICAgQWxsID0gXCJhbGxcIlxufTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGV4cG9zZXMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB1c2VmdWwgZm9yIGNvbW11bmljYXRpbmcgZnJvbSB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgQ2xpZW50IHRvXG4gKiB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgU2VydmVyLiBcbiAqL1xuZXhwb3J0IGNsYXNzIEhpRmlDb21tdW5pY2F0b3Ige1xuICAgIC8vIFByZXZlbnRzIHVzZXJzIG9mIG91ciBjbGllbnQtc2lkZSBBUEkgZnJvbSBzbGFtbWluZyB0aGVpciBtaXhlciB3aXRoIHJlcXVlc3RzLlxuICAgIC8vIE9mIGNvdXJzZSwgYmVjYXVzZSB0aGlzIHJhdGUgbGltaXQgaXMgY2xpZW50c2lkZSwgaXQgY291bGQgYmUgd29ya2VkIGFyb3VuZC5cbiAgICB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNUzogbnVtYmVyO1xuICAgIHByaXZhdGUgX3RpbWVyczogYW55ID0ge1xuICAgICAgICB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXQ6IG51bGwsXG4gICAgICAgIHdhbnRlZFRvVHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhOiB0cnVlXG4gICAgfTtcblxuICAgIC8vIFRoaXMgaXMgdXN1YWxseSB0aGUgYE1lZGlhU3RyZWFtYCBhc3NvY2lhdGVkIHdpdGggYSB1c2VyJ3MgYXVkaW8gaW5wdXQgZGV2aWNlLFxuICAgIC8vIGJ1dCBpdCBjb3VsZCBiZSBhbnkgYE1lZGlhU3RyZWFtYC5cbiAgICBwcml2YXRlIF9pbnB1dEF1ZGlvTWVkaWFTdHJlYW06IE1lZGlhU3RyZWFtO1xuXG4gICAgLy8gVGhlc2UgbmV4dCB0d28gbWVtYmVyIHZhcmlhYmxlcyBhcmUgdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiB3aGF0IHRvIHNlbmQgdG8gdGhlIG1peGVyLlxuICAgIC8vIFRoZSBjbGllbnQgb25seSBzZW5kcyBkYXRhIHRoYXQgdGhlIG1peGVyIGRvZXNuJ3QgYWxyZWFkeSBrbm93IGFib3V0LlxuICAgIHByaXZhdGUgX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhOiBIaUZpQXVkaW9BUElEYXRhO1xuICAgIHByaXZhdGUgX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGE6IEhpRmlBdWRpb0FQSURhdGE7XG5cbiAgICAvLyBMaWJyYXJ5IHVzZXJzIGNhbiBtYWtlIHVzZSBvZiBcIlVzZXIgRGF0YSBTdWJzY3JpcHRpb25zXCIgdG8gY2F1c2Ugc29tZXRoaW5nIHRvIGhhcHBlblxuICAgIC8vIHdoZW4gdGhlIHNlcnZlciByZXBvcnRzIHRoYXQgYSB1c2VyJ3MgZGF0YSAtIHN1Y2ggYXMgcG9zaXRpb24sIG9yaWVudGF0aW9uLCBhbmQgdm9sdW1lIC0gaGFzIGJlZW4gbW9kaWZpZWQuXG4gICAgcHJpdmF0ZSBfdXNlckRhdGFTdWJzY3JpcHRpb25zOiBBcnJheTxVc2VyRGF0YVN1YnNjcmlwdGlvbj47XG5cbiAgICAvKipcbiAgICAgKiBTZWUge0BsaW5rIEhpRmlDb21tdW5pY2F0b3IuX29uVXNlcnNEaXNjb25uZWN0ZWR9LlxuICAgICAqL1xuICAgIG9uVXNlcnNEaXNjb25uZWN0ZWQ6IEZ1bmN0aW9uO1xuXG4gICAgLy8gVGhpcyBjb250YWlucyBkYXRhIGRlYWxpbmcgd2l0aCB0aGUgbWl4ZXIgc2Vzc2lvbiwgc3VjaCBhcyB0aGUgUkFWSSBzZXNzaW9uLCBXZWJSVEMgYWRkcmVzcywgZXRjLlxuICAgIHByaXZhdGUgX21peGVyU2Vzc2lvbjogSGlGaU1peGVyU2Vzc2lvbjtcblxuICAgIHByaXZhdGUgX3dlYlJUQ1Nlc3Npb25QYXJhbXM/OiBXZWJSVENTZXNzaW9uUGFyYW1zO1xuICAgIHByaXZhdGUgX2N1c3RvbVNUVU5hbmRUVVJOQ29uZmlnPzogQ3VzdG9tU1RVTmFuZFRVUk5Db25maWc7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIEhpRmlDb21tdW5pY2F0b3Igb2JqZWN0LiBPbmNlIHlvdSBoYXZlIGNyZWF0ZWQgYSBIaUZpQ29tbXVuaWNhdG9yLCB5b3UgY2FuIHVzZSB0aGVcbiAgICAgKiB7QGxpbmsgc2V0SW5wdXRBdWRpb01lZGlhU3RyZWFtfSBtZXRob2QgdG8gYXNzaWduIGFuIGlucHV0IGF1ZGlvIHN0cmVhbSB0byB0aGUgY29ubmVjdGlvbiwgYW5kXG4gICAgICogb25jZSB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZCwgdXNlIHRoZSB7QGxpbmsgZ2V0T3V0cHV0QXVkaW9NZWRpYVN0cmVhbX0gbWV0aG9kIHRvXG4gICAgICogcmV0cmlldmUgdGhlIG91dHB1dCBhdWRpbyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IF9fbmFtZWRQYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIGluaXRpYWxIaUZpQXVkaW9BUElEYXRhIC0gVGhlIGluaXRpYWwgcG9zaXRpb24sIG9yaWVudGF0aW9uLCBldGMgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9uIHN0YXRlIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBTZXJ2ZXIgY2hhbmdlcy4gU2VlIHtAbGluayBIaUZpQ29ubmVjdGlvblN0YXRlc30uXG4gICAgICogQHBhcmFtIG9uVXNlcnNEaXNjb25uZWN0ZWQgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHBlZXIgZGlzY29ubmVjdHMgZnJvbSB0aGUgU3BhY2UuXG4gICAgICogQHBhcmFtIHRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dE1TIC0gVXNlciBEYXRhIHVwZGF0ZXMgd2lsbCBub3QgYmUgc2VudCB0byB0aGUgc2VydmVyIGFueSBtb3JlIGZyZXF1ZW50bHkgdGhhbiB0aGlzIG51bWJlciBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogQHBhcmFtIHVzZXJEYXRhU3RyZWFtaW5nU2NvcGUgLSBDYW5ub3QgYmUgc2V0IGxhdGVyLiBTZWUge0BsaW5rIEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3Blc30uXG4gICAgICogQHBhcmFtIGhpRmlBeGlzQ29uZmlndXJhdGlvbiAtIENhbm5vdCBiZSBzZXQgbGF0ZXIuIFRoZSAzRCBheGlzIGNvbmZpZ3VyYXRpb24uIFNlZSB7QGxpbmsgb3VySGlGaUF4aXNDb25maWd1cmF0aW9ufSBmb3IgZGVmYXVsdHMuXG4gICAgICogQHBhcmFtIHdlYnJ0Y1Nlc3Npb25QYXJhbXMgLSBDYW5ub3QgYmUgc2V0IGxhdGVyLiBFeHRyYSBwYXJhbWV0ZXJzIHVzZWQgZm9yIGNvbmZpZ3VyaW5nIHRoZSB1bmRlcmx5aW5nIFdlYlJUQyBjb25uZWN0aW9uIHRvIHRoZSBBUEkgc2VydmVycy5cbiAgICAgKiBUaGVzZSBzZXR0aW5ncyBhcmUgbm90IGZyZXF1ZW50bHkgdXNlZDsgdGhleSBhcmUgcHJpbWFyaWx5IGZvciBzcGVjaWZpYyBqaXR0ZXIgYnVmZmVyIGNvbmZpZ3VyYXRpb25zLlxuICAgICAqIEBwYXJhbSBjdXN0b21TVFVOYW5kVFVSTkNvbmZpZyAtIENhbm5vdCBiZSBzZXQgbGF0ZXIuIFRoaXMgb2JqZWN0IGNhbiBiZSB1c2VkIGlmIHNwZWNpZmljIFNUVU4gYW5kIFRVUk4gc2VydmVyIGluZm9ybWF0aW9uIG5lZWRzIHRvIGJlXG4gICAgICogcHJvdmlkZWQgZm9yIG5lZ290aWF0aW5nIHRoZSB1bmRlcmx5aW5nIFdlYlJUQyBjb25uZWN0aW9uLiBCeSBkZWZhdWx0LCBIaWdoIEZpZGVsaXR5J3MgVFVSTiBzZXJ2ZXIgd2lsbCBiZSB1c2VkLCB3aGljaCBzaG91bGQgc3VmZmljZVxuICAgICAqIGZvciBtb3N0IG9wZXJhdGlvbnMuIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgdGVzdGluZyBvciBmb3IgdXNpbmcgYSBjb21tZXJjaWFsIFRVUk4gc2VydmVyIHByb3ZpZGVyIGZvciBkZWFsaW5nIHdpdGggcGFydGljdWxhcmx5IGNoYWxsZW5naW5nIGNsaWVudCBuZXR3b3Jrcy9maXJld2FsbHMuXG4gICAgICogU2VlIHtAbGluayBDdXN0b21TVFVOYW5kVFVSTkNvbmZpZ30gZm9yIHRoZSBmb3JtYXQgb2YgdGhpcyBvYmplY3QgKG5vdGUgdGhhdCBfYWxsXyB2YWx1ZXMgbXVzdCBiZSBwcm92aWRlZCB3aGVuIHNldHRpbmcgdGhpcykuXG4gICAgICogQHBhcmFtIG9uTXV0ZUNoYW5nZWQgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgbXV0ZSBzdGF0ZSBvZiB0aGUgY2xpZW50IGhhcyBjaGFuZ2VkLCBmb3IgZXhhbXBsZSB3aGVuIG11dGVkIGJ5IGFuIGFkbWluLiBTZWUge0BsaW5rIE9uTXV0ZUNoYW5nZWRDYWxsYmFja30gZm9yIHRoZSBpbmZvcm1hdGlvbiB0aGlzIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7XG4gICAgICAgIGluaXRpYWxIaUZpQXVkaW9BUElEYXRhID0gbmV3IEhpRmlBdWRpb0FQSURhdGEoKSxcbiAgICAgICAgb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkLFxuICAgICAgICBvblVzZXJzRGlzY29ubmVjdGVkLFxuICAgICAgICB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNUyA9IEhpRmlDb25zdGFudHMuREVGQVVMVF9UUkFOU01JVF9SQVRFX0xJTUlUX1RJTUVPVVRfTVMsXG4gICAgICAgIHVzZXJEYXRhU3RyZWFtaW5nU2NvcGUgPSBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXMuQWxsLFxuICAgICAgICBoaUZpQXhpc0NvbmZpZ3VyYXRpb24sXG4gICAgICAgIHdlYnJ0Y1Nlc3Npb25QYXJhbXMsXG4gICAgICAgIGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLFxuICAgICAgICBvbk11dGVDaGFuZ2VkXG4gICAgfToge1xuICAgICAgICBpbml0aWFsSGlGaUF1ZGlvQVBJRGF0YT86IEhpRmlBdWRpb0FQSURhdGEsXG4gICAgICAgIG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZD86IEZ1bmN0aW9uLFxuICAgICAgICBvblVzZXJzRGlzY29ubmVjdGVkPzogRnVuY3Rpb24sXG4gICAgICAgIHRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dE1TPzogbnVtYmVyLFxuICAgICAgICB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlPzogSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzLFxuICAgICAgICBoaUZpQXhpc0NvbmZpZ3VyYXRpb24/OiBIaUZpQXhpc0NvbmZpZ3VyYXRpb24sXG4gICAgICAgIHdlYnJ0Y1Nlc3Npb25QYXJhbXM/OiBXZWJSVENTZXNzaW9uUGFyYW1zLFxuICAgICAgICBjdXN0b21TVFVOYW5kVFVSTkNvbmZpZz86IEN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLFxuICAgICAgICBvbk11dGVDaGFuZ2VkPzogT25NdXRlQ2hhbmdlZENhbGxiYWNrLFxuICAgIH0gPSB7fSkge1xuICAgICAgICAvLyBJZiB1c2VyIHBhc3NlZCBpbiB0aGVpciBvd24gc3R1bi90dXJuIGNvbmZpZywgbWFrZSBzdXJlIGl0IG1hdGNoZXMgb3VyIGludGVyZmFjZSAoaXNoKS5cbiAgICAgICAgLy8gKEkgZG8gc28gd2lzaCB0aGF0IFR5cGVTY3JpcHQgY291bGQganVzdCBkbyB0aGlzIGZvciB1cyBiYXNlZCBvbiB0aGUgaW50ZXJmYWNlIGRlZmluaXRpb24sIGJ1dCBpdCBzZWVtcyB0aGF0IGl0IGNhbiBub3QuKVxuICAgICAgICBpZiAoY3VzdG9tU1RVTmFuZFRVUk5Db25maWcpIHtcbiAgICAgICAgICAgIGlmICghY3VzdG9tU1RVTmFuZFRVUk5Db25maWcuaGFzT3duUHJvcGVydHkoXCJzdHVuVXJsc1wiKSB8fCAhQXJyYXkuaXNBcnJheShjdXN0b21TVFVOYW5kVFVSTkNvbmZpZy5zdHVuVXJscykgfHwgY3VzdG9tU1RVTmFuZFRVUk5Db25maWcuc3R1blVybHMubGVuZ3RoID09IDAgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGBjdXN0b21TVFVOYW5kVFVSTkNvbmZpZy5zdHVuVXJsc1xcYCBtdXN0IGJlIHNwZWNpZmllZCBhbmQgbXVzdCBiZSBhIGxpc3QgY29udGFpbmluZyBhdCBsZWFzdCBvbmUgU1RVTiBzZXJ2ZXIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLmhhc093blByb3BlcnR5KFwidHVyblVybHNcIikgfHwgIUFycmF5LmlzQXJyYXkoY3VzdG9tU1RVTmFuZFRVUk5Db25maWcudHVyblVybHMpIHx8IGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnLnR1cm5VcmxzLmxlbmd0aCA9PSAwICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgY3VzdG9tU1RVTmFuZFRVUk5Db25maWcudHVyblVybHNcXGAgbXVzdCBiZSBzcGVjaWZpZWQgYW5kIG11c3QgYmUgYSBsaXN0IGNvbnRhaW5pbmcgYXQgbGVhc3Qgb25lIFRVUk4gc2VydmVyLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXN0b21TVFVOYW5kVFVSTkNvbmZpZy5oYXNPd25Qcm9wZXJ0eShcInR1cm5Vc2VybmFtZVwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgY3VzdG9tU1RVTmFuZFRVUk5Db25maWcudHVyblVzZXJuYW1lXFxgIG11c3QgYmUgc3BlY2lmaWVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXN0b21TVFVOYW5kVFVSTkNvbmZpZy5oYXNPd25Qcm9wZXJ0eShcInR1cm5DcmVkZW50aWFsXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGBjdXN0b21TVFVOYW5kVFVSTkNvbmZpZy50dXJuQ3JlZGVudGlhbFxcYCBtdXN0IGJlIHNwZWNpZmllZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXN0b21TVFVOYW5kVFVSTkNvbmZpZyA9IGN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnO1xuXG4gICAgICAgIC8vIE1ha2UgbWluaW11bSAxMG1zXG4gICAgICAgIGlmICh0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNUyA8IEhpRmlDb25zdGFudHMuTUlOX1RSQU5TTUlUX1JBVEVfTElNSVRfVElNRU9VVF9NUykge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBcXGB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNU1xcYCBtdXN0IGJlID49ICR7SGlGaUNvbnN0YW50cy5NSU5fVFJBTlNNSVRfUkFURV9MSU1JVF9USU1FT1VUX01TfW1zISBTZXR0aW5nIHRvICR7SGlGaUNvbnN0YW50cy5NSU5fVFJBTlNNSVRfUkFURV9MSU1JVF9USU1FT1VUX01TfW1zLi4uYCk7XG4gICAgICAgICAgICB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNUyA9IEhpRmlDb25zdGFudHMuTUlOX1RSQU5TTUlUX1JBVEVfTElNSVRfVElNRU9VVF9NUztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dE1TID0gdHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVM7XG5cbiAgICAgICAgaWYgKG9uVXNlcnNEaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Vc2Vyc0Rpc2Nvbm5lY3RlZCA9IG9uVXNlcnNEaXNjb25uZWN0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9taXhlclNlc3Npb24gPSBuZXcgSGlGaU1peGVyU2Vzc2lvbih7XG4gICAgICAgICAgICBcInVzZXJEYXRhU3RyZWFtaW5nU2NvcGVcIjogdXNlckRhdGFTdHJlYW1pbmdTY29wZSxcbiAgICAgICAgICAgIFwib25Vc2VyRGF0YVVwZGF0ZWRcIjogKGRhdGE6IEFycmF5PFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YT4pID0+IHsgdGhpcy5faGFuZGxlVXNlckRhdGFVcGRhdGVzKGRhdGEpOyB9LFxuICAgICAgICAgICAgXCJvblVzZXJzRGlzY29ubmVjdGVkXCI6IChkYXRhOiBBcnJheTxSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE+KSA9PiB7IHRoaXMuX29uVXNlcnNEaXNjb25uZWN0ZWQoZGF0YSk7IH0sXG4gICAgICAgICAgICBcIm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiOiBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsXG4gICAgICAgICAgICBcIm9uTXV0ZUNoYW5nZWRcIjogb25NdXRlQ2hhbmdlZFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEgPSBuZXcgSGlGaUF1ZGlvQVBJRGF0YSgpO1xuXG4gICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEgPSBuZXcgSGlGaUF1ZGlvQVBJRGF0YSgpO1xuXG4gICAgICAgIHRoaXMuX3VzZXJEYXRhU3Vic2NyaXB0aW9ucyA9IFtdO1xuXG4gICAgICAgIGlmICh3ZWJydGNTZXNzaW9uUGFyYW1zICYmIHdlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NaW5KaXR0ZXJCdWZmZXJEdXJhdGlvbiAmJiAod2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01pbkppdHRlckJ1ZmZlckR1cmF0aW9uIDwgMC4wIHx8IHdlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NaW5KaXR0ZXJCdWZmZXJEdXJhdGlvbiA+IDEwLjApKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYFRoZSB2YWx1ZSBvZiBcXGB3ZWJydGNTZXNzaW9uUGFyYW1zLmF1ZGlvTWluSml0dGVyQnVmZmVyRHVyYXRpb25cXGAgKCR7d2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01pbkppdHRlckJ1ZmZlckR1cmF0aW9ufSkgd2lsbCBiZSBjbGFtcGVkIHRvICgwLjAsIDEwLjApLmApO1xuICAgICAgICAgICAgd2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01pbkppdHRlckJ1ZmZlckR1cmF0aW9uID0gSGlGaVV0aWxpdGllcy5jbGFtcCh3ZWJydGNTZXNzaW9uUGFyYW1zLmF1ZGlvTWluSml0dGVyQnVmZmVyRHVyYXRpb24sIDAuMCwgMTAuMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlYnJ0Y1Nlc3Npb25QYXJhbXMgJiYgd2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01heEppdHRlckJ1ZmZlckR1cmF0aW9uICYmICh3ZWJydGNTZXNzaW9uUGFyYW1zLmF1ZGlvTWF4Sml0dGVyQnVmZmVyRHVyYXRpb24gPCAwLjAgfHwgd2VicnRjU2Vzc2lvblBhcmFtcy5hdWRpb01heEppdHRlckJ1ZmZlckR1cmF0aW9uID4gMTAuMCkpIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgVGhlIHZhbHVlIG9mIFxcYHdlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NYXhKaXR0ZXJCdWZmZXJEdXJhdGlvblxcYCAoJHt3ZWJydGNTZXNzaW9uUGFyYW1zLmF1ZGlvTWF4Sml0dGVyQnVmZmVyRHVyYXRpb259KSB3aWxsIGJlIGNsYW1wZWQgdG8gKDAuMCwgMTAuMCkuYCk7XG4gICAgICAgICAgICB3ZWJydGNTZXNzaW9uUGFyYW1zLmF1ZGlvTWF4Sml0dGVyQnVmZmVyRHVyYXRpb24gPSBIaUZpVXRpbGl0aWVzLmNsYW1wKHdlYnJ0Y1Nlc3Npb25QYXJhbXMuYXVkaW9NYXhKaXR0ZXJCdWZmZXJEdXJhdGlvbiwgMC4wLCAxMC4wKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93ZWJSVENTZXNzaW9uUGFyYW1zID0gd2VicnRjU2Vzc2lvblBhcmFtcztcblxuICAgICAgICBpZiAoaGlGaUF4aXNDb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoSGlGaUF4aXNVdGlsaXRpZXMudmVyaWZ5KGhpRmlBeGlzQ29uZmlndXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24ucmlnaHRBeGlzID0gaGlGaUF4aXNDb25maWd1cmF0aW9uLnJpZ2h0QXhpcztcbiAgICAgICAgICAgICAgICBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXMgPSBoaUZpQXhpc0NvbmZpZ3VyYXRpb24ubGVmdEF4aXM7XG4gICAgICAgICAgICAgICAgb3VySGlGaUF4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzID0gaGlGaUF4aXNDb25maWd1cmF0aW9uLmludG9TY3JlZW5BeGlzO1xuICAgICAgICAgICAgICAgIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbi5vdXRPZlNjcmVlbkF4aXMgPSBoaUZpQXhpc0NvbmZpZ3VyYXRpb24ub3V0T2ZTY3JlZW5BeGlzO1xuICAgICAgICAgICAgICAgIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbi51cEF4aXMgPSBoaUZpQXhpc0NvbmZpZ3VyYXRpb24udXBBeGlzO1xuICAgICAgICAgICAgICAgIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcyA9IGhpRmlBeGlzQ29uZmlndXJhdGlvbi5kb3duQXhpcztcbiAgICAgICAgICAgICAgICBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24uaGFuZGVkbmVzcyA9IGhpRmlBeGlzQ29uZmlndXJhdGlvbi5oYW5kZWRuZXNzO1xuICAgICAgICAgICAgICAgIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbi5ldWxlck9yZGVyID0gaGlGaUF4aXNDb25maWd1cmF0aW9uLmV1bGVyT3JkZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYFRoZXJlIGlzIGFuIGVycm9yIHdpdGggdGhlIHBhc3NlZCBcXGBIaUZpQXhpc0NvbmZpZ3VyYXRpb25cXGAsIHNvIHRoZSBuZXcgYXhpcyBjb25maWd1cmF0aW9uIHdhcyBub3Qgc2V0LiBUaGVyZSBhcmUgbW9yZSBlcnJvciBkZXRhaWxzIGluIHRoZSBsb2dzIGFib3ZlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgY3VycmVudCBBdWRpbyBBUEkgRGF0YSB3aXRoIHRoZSBnaXZlbiBkYXRhLCBidXQgdXNlIHRoZSAndXBkYXRlVXNlckRhdGEoKScgY2FsbCBmb3Igc2FuaXR5LlxuICAgICAgICB0aGlzLl91cGRhdGVVc2VyRGF0YShpbml0aWFsSGlGaUF1ZGlvQVBJRGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIHNlcnZlciBhbmQgdHJhbnNtaXRzIHRoZSBpbml0aWFsIHVzZXIgZGF0YSB0byB0aGUgc2VydmVyLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBoaWZpQXV0aEpXVCAgVGhpcyBKU09OIFdlYiBUb2tlbiAoSldUKSBpcyB1c2VkIGJ5IGNhbGxlcnMgdG8gYXNzb2NpYXRlIGEgdXNlciB3aXRoIGEgc3BlY2lmaWMgSGlnaCBGaWRlbGl0eSBTcGF0aWFsIEF1ZGlvIEFQSSBTZXJ2ZXIuXG4gICAgICogSldUcyBhcmUgYW4gaW5kdXN0cnktc3RhbmRhcmQgbWV0aG9kIGZvciBzZWN1cmVseSByZXByZXNlbnRpbmcgY2xhaW1zIGJldHdlZW4gdHdvIGFwcGxpY2F0aW9ucy5cbiAgICAgKiBcbiAgICAgKiAqKkltcG9ydGFudCBpbmZvcm1hdGlvbiBhYm91dCBKV1RzOioqXG4gICAgICogLSAqKkRvIG5vdCBleHBvc2UgSldUcyB0byB1c2VycyEqKiBBbnlvbmUgd2l0aCBhY2Nlc3MgdG8gb25lIG9mIHlvdXIgSldUcyB3aWxsIGJlIGFibGUgdG8gY29ubmVjdCB0byB5b3VyIEhpZ2ggRmlkZWxpdHkgU3BhdGlhbCBBdWRpbyBBUEkgU2VydmVyLlxuICAgICAqIC0gSW4geW91ciBhcHBsaWNhdGlvbidzIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQsIGVhY2ggY2xpZW50IHJ1bm5pbmcgeW91ciBhcHAgY29kZSBzaG91bGQgY29ubmVjdCB0byB0aGUgSGlnaCBGaWRlbGl0eSBTcGF0aWFsIEF1ZGlvIFNlcnZlciB3aXRoIGEgdW5pcXVlIEpXVC5cbiAgICAgKiBJbiB0aGUgY2FzZSBvZiBhIFdlYiBhcHBsaWNhdGlvbiwgeW91ciBhcHBsaWNhdGlvbiBzZXJ2ZXIgY29kZSBzaG91bGQgZ2VuZXJhdGUgYSBKV1QgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyIHJlcXVlc3RpbmcgeW91ciBXZWIgYXBwbGljYXRpb24uXG4gICAgICogXG4gICAgICogVG8gZ2VuZXJhdGUgYSBKV1QgZm9yIHVzZSB3aXRoIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSTpcbiAgICAgKiAxLiBIZWFkIHRvIHtAbGluayBodHRwczovL2p3dC5pby99IHRvIGZpbmQgdGhlIGFwcHJvcHJpYXRlIGxpYnJhcnkgZm9yIHlvdXIgbGFuZ2F1Z2UuXG4gICAgICogICAgIGEuIEZvciBOb2RlSlMgYXBwbGljYXRpb25zIGFuZCBXZWIgYXBwbGljYXRpb25zIGNvbXBpbGllZCBmcm9tIE5vZGVKUyBjb2RlLCB3ZSByZWNvbW1lbmQge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2pvc2V8am9zZX0uXG4gICAgICogMi4gVXNpbmcgdGhlIHtAbGluayBodHRwczovL2FjY291bnQuaGlnaGZpZGVsaXR5LmNvbS9kZXYvYWNjb3VudHxIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBEZXZlbG9wZXIgQ29uc29sZX0sXG4gICAgICogb2J0YWluIHlvdXIgQXBwIElELCBTcGFjZSBJRCwgYW5kIEFwcCBTZWNyZXQuXG4gICAgICogMy4gQ3JlYXRlIHlvdXIgdXNlcidzIEpXVCB1c2luZyB0aGUgYXBwcm9wcmlhdGUgbGlicmFyeSwgcGFzc2luZyB5b3VyIEFwcCBJRCwgU3BhY2UgSUQsIGFuZCBBcHAgU2VjcmV0LiBIZXJlIGlzIGFuIGV4YW1wbGUgb2Ygd2hhdCB0aGF0IG1pZ2h0IGxvb2sgbGlrZSwgdXNpbmcgTm9kZUpTIGFuZCBgam9zZWA6XG4gICAgICogICAgIGBgYFxuICAgICAqIGhpRmlTYW1wbGVKV1QgPSBhd2FpdCBuZXcgU2lnbkpXVCh7XG4gICAgICogICAgIFwiYXBwX2lkXCI6IEFQUF9JRCxcbiAgICAgKiAgICAgXCJzcGFjZV9pZFwiOiBTUEFDRV9JRFxuICAgICAqIH0pXG4gICAgICogLnNldFByb3RlY3RlZEhlYWRlcih7IGFsZzogJ0hTMjU2JywgdHlwOiAnSldUJyB9KVxuICAgICAqIC5zaWduKGNyeXB0by5jcmVhdGVTZWNyZXRLZXkoQnVmZmVyLmZyb20oQVBQX1NFQ1JFVCwgXCJ1dGY4XCIpKSk7XG4gICAgICogICAgIGBgYFxuICAgICAqIFBsZWFzZSByZWZlcmVuY2Ugb3VyIHtAbGluayBodHRwczovL3d3dy5oaWdoZmlkZWxpdHkuY29tL2FwaS9ndWlkZXMvbWlzYy9nZXRBSldUfFwiR2V0IGEgSldUXCIgZ3VpZGV9IGZvciBhZGRpdGlvbmFsIGNvbnRleHQuXG4gICAgICogNC4gUGFzcyB0aGUgY3JlYXRlZCBKV1QgdG8gYGNvbm5lY3RUb0hpRmlBdWRpb0FQSVNlcnZlcigpYC5cbiAgICAgKiBcbiAgICAgKiBBcyBvZiAyMDIxLTAxLTIxLCB3ZSd2ZSBhZGRlZCBjb2RlIGluIHRoaXMgZnVuY3Rpb24gd2hpY2gsIGluIHRoZSBicm93c2VyIGNvbnRleHQsIHNlYXJjaGVzIGZvciBhIGB0b2tlbmAgVVJMIHF1ZXJ5IHBhcmFtZXRlciBhbmQsIGlmIGEgSldUXG4gICAgICogaXNuJ3Qgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvbiwgdXNlcyB0aGUgdmFsdWUgb2YgdGhhdCBgdG9rZW5gIFVSTCBxdWVyeSBwYXJhbWV0ZXIgYXMgdGhlIEpXVC5cbiAgICAgKiBXZSBzaG91bGQgcmVtb3ZlIHRoYXQgbGF0ZXIsIGJlY2F1c2Ugd2UgYWxtb3N0IGNlcnRhaW5seSBkb24ndCB3YW50IHRoaXMgdG8gc3RheSBpbiB0aGUgQVBJIGNvZGUsIGJ1dCBpdCdzIF92ZXJ5XyBjb252ZW5pZW50IGZvciBzYW1wbGUgYXBwcyBmb3IgcmlnaHQgbm93LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNpZ25hbGluZ0hvc3RVUkwgQW4gVVJMIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIHZhbGlkIFdlYlJUQyBzaWduYWxpbmcgYWRkcmVzcyBhdCBIaWdoIEZpZGVsaXR5LiBUaGUgcGFzc2VkIGBzaWduYWxpbmdIb3N0VVJMYCBwYXJhbWV0ZXIgc2hvdWxkIG5vdCBjb250YWluIHRoZSBwcm90b2NvbFxuICAgICAqIG9yIHBvcnQgLSBlLmcuIGBzZXJ2ZXIuaGlnaGZpZGVsaXR5LmNvbWAgLSBhbmQgaXQgd2lsbCBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIHNpZ25hbGluZyBhZGRyZXNzIG9mIHRoZSBmb3JtOiBgd3NzOi8vJHtzaWduYWxpbmdIb3N0VVJMfToke3NpZ25hbGluZ1BvcnR9Lz90b2tlbj1gXG4gICAgICogSWYgdGhlIGRldmVsb3BlciBkb2VzIG5vdCBwYXNzIGEgYHNpZ25hbGluZ0hvc3RVUkxgIHBhcmFtZXRlciwgYSBkZWZhdWx0IFVSTCB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gU2VlOiB7QGxpbmsgREVGQVVMVF9QUk9EX0hJR0hfRklERUxJVFlfRU5EUE9JTlR9XG4gICAgICogUmVhZGluZyB0aGlzIHBhcmFtZXRlciBmcm9tIHRoZSBVUkwgKGlmIG5lZWRlZCkgc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBkZXZlbG9wZXIgYXMgcGFydCBvZiB0aGUgYXBwbGljYXRpb24gY29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaWduYWxpbmdQb3J0IFRoZSBwb3J0IHRvIHVzZSBmb3IgbWFraW5nIFdlYlNvY2tldCBjb25uZWN0aW9ucyB0byB0aGUgSGlnaCBGaWRlbGl0eSBzZXJ2ZXJzLlxuICAgICAqIElmIHRoZSBkZXZlbG9wZXIgZG9lcyBub3QgcGFzcyBhIGBzaWduYWxpbmdQb3J0YCBwYXJhbWV0ZXIsIHRoZSBkZWZhdWx0ICg0NDMpIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBTZWU6IHtAbGluayBERUZBVUxUX1BST0RfSElHSF9GSURFTElUWV9QT1JUfVxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIElmIHRoaXMgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWwsIHRoZSBQcm9taXNlIHdpbGwgcmVzb2x2ZSB3aXRoIGB7IHN1Y2Nlc3M6IHRydWUsIGF1ZGlvbmV0SW5pdFJlc3BvbnNlOiA8VGhlIHJlc3BvbnNlIHRvIGBhdWRpb25ldC5pbml0YCBmcm9tIHRoZSBzZXJ2ZXIgaW4gT2JqZWN0IGZvcm1hdD59YC5cbiAgICAgKiBJZiB1bnN1Y2Nlc3NmdWwsIHRoZSBQcm9taXNlIHdpbGwgcmVqZWN0IHdpdGggYHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiA8YW4gZXJyb3IgbWVzc2FnZT4gfWAuXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdFRvSGlGaUF1ZGlvQVBJU2VydmVyKGhpZmlBdXRoSldUOiBzdHJpbmcsIHNpZ25hbGluZ0hvc3RVUkw/OiBzdHJpbmcsIHNpZ25hbGluZ1BvcnQ/OiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgICBpZiAoIXRoaXMuX21peGVyU2Vzc2lvbikge1xuICAgICAgICAgICAgbGV0IGVyck1zZyA9IGBcXGB0aGlzLl9taXhlclNlc3Npb25cXGAgaXMgZmFsc2V5OyB0cnkgY3JlYXRpbmcgYSBuZXcgSGlGaUNvbW11bmljYXRvciBhbmQgc3RhcnRpbmcgb3Zlci5gO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyTXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9taXhlclNlc3Npb24uZ2V0Q3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUoKSA9PT0gSGlGaUNvbm5lY3Rpb25TdGF0ZXMuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICBsZXQgbXNnID0gYFNlc3Npb24gaXMgYWxyZWFkeSBjb25uZWN0ZWQhIElmIHlvdSBuZWVkIHRvIHJlc2V0IHRoZSBjb25uZWN0aW9uLCBwbGVhc2UgZGlzY29ubmVjdCBmdWxseSB1c2luZyBcXGBkaXNjb25uZWN0RnJvbUhpRmlBdWRpb0FQSVNlcnZlcigpXFxgIGFuZCBjYWxsIHRoaXMgbWV0aG9kIGFnYWluLmA7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBtc2dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1peGVyQ29ubmVjdGlvblJlc3BvbnNlO1xuICAgICAgICBsZXQgc2lnbmFsaW5nSG9zdFVSTFNhZmU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCB1cmwgPSBuZXcgVVJMKHNpZ25hbGluZ0hvc3RVUkwpO1xuICAgICAgICAgICAgc2lnbmFsaW5nSG9zdFVSTFNhZmUgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgICAgICBpZiAoc2lnbmFsaW5nUG9ydCA9PSBudWxsICYmIHVybC5wb3J0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgLy8gc29tZXRpbWVzIHRoZSBzaWduYWxpbmdQb3J0IGlzIHNwZWNpZmllZCBpbiB0aGUgc2lnbmFsSG9zdFVSTCBpbiB3aGljaCBjYXNlXG4gICAgICAgICAgICAgICAgLy8gd2UgZXh0cmFjdCB0aGUgcG9ydCBudW1iZXIgcmF0aGVyIHRoYW4gZmFsbGJhY2sgdG8gZGVmYXVsdFxuICAgICAgICAgICAgICAgIHNpZ25hbGluZ1BvcnQgPSBOdW1iZXIodXJsLnBvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIC8vIElmIHNpZ25hbGluZ0hvc3RVUkwgaXMgbm90IGRlZmluZWQsIHdlIGFzc2lnbiB0aGUgZGVmYXVsdCBVUkxcbiAgICAgICAgICAgIHNpZ25hbGluZ0hvc3RVUkxTYWZlID0gc2lnbmFsaW5nSG9zdFVSTCA/IHNpZ25hbGluZ0hvc3RVUkwgOiBIaUZpQ29uc3RhbnRzLkRFRkFVTFRfUFJPRF9ISUdIX0ZJREVMSVRZX0VORFBPSU5UO1xuICAgICAgICB9XG5cbiAgICAgICAgc2lnbmFsaW5nUG9ydCA9IHNpZ25hbGluZ1BvcnQgPyBzaWduYWxpbmdQb3J0IDogSGlGaUNvbnN0YW50cy5ERUZBVUxUX1BST0RfSElHSF9GSURFTElUWV9QT1JUO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgd2ViUlRDU2lnbmFsaW5nQWRkcmVzcyA9IGB3c3M6Ly8ke3NpZ25hbGluZ0hvc3RVUkxTYWZlfToke3NpZ25hbGluZ1BvcnR9Lz90b2tlbj1gO1xuICAgICAgICAgICAgdGhpcy5fbWl4ZXJTZXNzaW9uLndlYlJUQ0FkZHJlc3MgPSBgJHt3ZWJSVENTaWduYWxpbmdBZGRyZXNzfSR7aGlmaUF1dGhKV1R9YDtcblxuICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFVzaW5nIFdlYlJUQyBTaWduYWxpbmcgQWRkcmVzczpcXG4ke3dlYlJUQ1NpZ25hbGluZ0FkZHJlc3N9PHRva2VuIHJlZGFjdGVkPmApO1xuXG4gICAgICAgICAgICBtaXhlckNvbm5lY3Rpb25SZXNwb25zZSA9IGF3YWl0IHRoaXMuX21peGVyU2Vzc2lvbi5jb25uZWN0VG9IaUZpTWl4ZXIoeyB3ZWJSVENTZXNzaW9uUGFyYW1zOiB0aGlzLl93ZWJSVENTZXNzaW9uUGFyYW1zLCBjdXN0b21TVFVOYW5kVFVSTkNvbmZpZzogdGhpcy5fY3VzdG9tU1RVTmFuZFRVUk5Db25maWcgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yQ29ubmVjdGluZ1RvTWl4ZXIpIHtcbiAgICAgICAgICAgIGxldCBlcnJNc2cgPSBgRXJyb3Igd2hlbiBjb25uZWN0aW5nIHRvIG1peGVyIVxcbiR7ZXJyb3JDb25uZWN0aW5nVG9NaXhlcn1gO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyTXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YVRvU2VydmVyKHRydWUpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBhdWRpb25ldEluaXRSZXNwb25zZTogbWl4ZXJDb25uZWN0aW9uUmVzcG9uc2UuYXVkaW9uZXRJbml0UmVzcG9uc2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyB0aGUgZ2FpbiBvZiBhbm90aGVyIHVzZXIgZm9yIHRoaXMgY29tbXVuaWNhdG9yJ3MgY3VycmVudCBjb25uZWN0aW9uIG9ubHkuIFRoaXMgaXMgYSBzaW5nbGUgdXNlciB2ZXJzaW9uIG9mIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLnNldE90aGVyVXNlckdhaW5zRm9yVGhpc0Nvbm5lY3Rpb259LlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBhIG1vcmUgY29tZm9ydGFibGUgbGlzdGVuaW5nIGV4cGVyaWVuY2UgZm9yIHRoZSBjbGllbnQuIElmIHlvdSBuZWVkIHRvIHBlcmZvcm0gbW9kZXJhdGlvbiBhY3Rpb25zIHdoaWNoIGFwcGx5IHNlcnZlciBzaWRlLCB1c2UgdGhlIHtAbGluayBodHRwczovL2RvY3MuaGlnaGZpZGVsaXR5LmNvbS9yZXN0L2xhdGVzdC9pbmRleC5odG1sfEFkbWluaXN0cmF0aXZlIFJFU1QgQVBJfS5cbiAgICAgKiBcbiAgICAgKiBUbyB1c2UgdGhpcyBjb21tYW5kLCB0aGUgY29tbXVuaWNhdG9yIG11c3QgY3VycmVudGx5IGJlIGNvbm5lY3RlZCB0byBhIHNwYWNlLiBZb3UgY2FuIGNvbm5lY3QgdG8gYSBzcGFjZSB1c2luZyB7QGxpbmsgY29ubmVjdFRvSGlGaUF1ZGlvQVBJU2VydmVyfS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gaGFzaGVkVmlzaXRJZCAgVGhlIGhhc2hlZCB2aXNpdCBJRCBvZiB0aGUgdXNlciB3aG9zZSBnYWluIHdpbGwgYmUgYWRqdXN0ZWQuXG4gICAgICogVXNlIHtAbGluayBhZGRVc2VyRGF0YVN1YnNjcmlwdGlvbn0gYW5kIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLm9uVXNlcnNEaXNjb25uZWN0ZWR9IHRvIGtlZXAgdHJhY2sgb2YgdGhlIGhhc2hlZCB2aXNpdCBJRHMgb2YgY3VycmVudGx5IGNvbm5lY3RlZCB1c2Vycy5cbiAgICAgKiBcbiAgICAgKiBXaGVuIHlvdSBzdWJzY3JpYmUgdG8gdXNlciBkYXRhLCB5b3Ugd2lsbCBnZXQgYSBsaXN0IG9mIHtAbGluayBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGF9IG9iamVjdHMsIHdoaWNoIGVhY2ggY29udGFpbiwgYXQgbWluaW11bSwge0BsaW5rIFJlY2VpdmVkSGlmaUF1ZGlvQVBJRGF0YS5oYXNoZWRWaXNpdElEfXMgYW5kIHtAbGluayBSZWNlaXZlZEhpZmlBdWRpb0FQSURhdGEucHJvdmlkZWRVc2VySUR9cyBmb3IgZWFjaCB1c2VyIGluIHRoZSBzcGFjZS4gQnkgaW5zcGVjdGluZyBlYWNoIG9mIHRoZXNlIG9iamVjdHMsIHlvdSBjYW4gYXNzb2NpYXRlIGEgdXNlciB3aXRoIHRoZWlyIGhhc2hlZCB2aXNpdCBJRCwgaWYgeW91IGtub3cgdGhlaXIgcHJvdmlkZWQgdXNlciBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBnYWluICBUaGUgcmVsYXRpdmUgZ2FpbiB0byBhcHBseSB0byB0aGUgb3RoZXIgdXNlci4gQnkgZGVmYXVsdCwgdGhpcyBpcyBgMS4wYC4gVGhlIGdhaW4gY2FuIGJlIGFueSB2YWx1ZSBncmVhdGVyIG9yIGVxdWFsIHRvIGAwLjBgLlxuICAgICAqIEZvciBleGFtcGxlOiBhIGdhaW4gb2YgYDIuMGAgd2lsbCBkb3VibGUgdGhlIGxvdWRuZXNzIG9mIHRoZSB1c2VyLCB3aGlsZSBhIGdhaW4gb2YgYDAuNWAgd2lsbCBoYWx2ZSB0aGUgdXNlcidzIGxvdWRuZXNzLiBBIGdhaW4gb2YgYDAuMGAgd2lsbCBlZmZlY3RpdmVseSBtdXRlIHRoZSB1c2VyLlxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIElmIHRoaXMgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWwsIHRoZSBQcm9taXNlIHdpbGwgcmVzb2x2ZSB3aXRoIHtAbGluayBTZXRPdGhlclVzZXJHYWluRm9yVGhpc0Nvbm5lY3Rpb25SZXNwb25zZX0gd2l0aCBgc3VjY2Vzc2AgZXF1YWwgdG8gYHRydWVgLlxuICAgICAqIElmIHVuc3VjY2Vzc2Z1bCwgdGhlIFByb21pc2Ugd2lsbCByZWplY3Qgd2l0aCB7QGxpbmsgU2V0T3RoZXJVc2VyR2FpbkZvclRoaXNDb25uZWN0aW9uUmVzcG9uc2V9IHdpdGggYHN1Y2Nlc3NgIGVxdWFsIHRvIGBmYWxzZWAgYW5kIGBlcnJvcmAgc2V0IHRvIGFuIGVycm9yIG1lc3NhZ2UgZGVzY3JpYmluZyB3aGF0IHdlbnQgd3JvbmcuXG4gICAgICovXG4gICAgYXN5bmMgc2V0T3RoZXJVc2VyR2FpbkZvclRoaXNDb25uZWN0aW9uKHZpc2l0SWRIYXNoOiBzdHJpbmcsIGdhaW46IG51bWJlcik6IFByb21pc2U8U2V0T3RoZXJVc2VyR2FpbkZvclRoaXNDb25uZWN0aW9uUmVzcG9uc2U+IHtcbiAgICAgICAgbGV0IG90aGVyVXNlckdhaW5NYXA6IE90aGVyVXNlckdhaW5NYXAgPSB7fTtcbiAgICAgICAgb3RoZXJVc2VyR2Fpbk1hcFt2aXNpdElkSGFzaF0gPSBnYWluO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zZXRPdGhlclVzZXJHYWluc0ZvclRoaXNDb25uZWN0aW9uKG90aGVyVXNlckdhaW5NYXApO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyB0aGUgZ2FpbiBvZiBvbmUgb3IgbW9yZSB1c2VycyBmb3IgdGhpcyBjb21tdW5pY2F0b3IncyBjdXJyZW50IGNvbm5lY3Rpb24gb25seS5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgYSBtb3JlIGNvbWZvcnRhYmxlIGxpc3RlbmluZyBleHBlcmllbmNlIGZvciB0aGUgY2xpZW50LiBJZiB5b3UgbmVlZCB0byBwZXJmb3JtIG1vZGVyYXRpb24gYWN0aW9ucyBvbiB0aGUgc2VydmVyIHNpZGUsIHVzZSB0aGUge0BsaW5rIGh0dHBzOi8vZG9jcy5oaWdoZmlkZWxpdHkuY29tL3Jlc3QvbGF0ZXN0L2luZGV4Lmh0bWx8QWRtaW5pc3RyYXRpdmUgUkVTVCBBUEl9LlxuICAgICAqIFxuICAgICAqIFRvIHVzZSB0aGlzIGNvbW1hbmQsIHRoZSBjb21tdW5pY2F0b3IgbXVzdCBjdXJyZW50bHkgYmUgY29ubmVjdGVkIHRvIGEgc3BhY2UuIFlvdSBjYW4gY29ubmVjdCB0byBhIHNwYWNlIHVzaW5nIHtAbGluayBjb25uZWN0VG9IaUZpQXVkaW9BUElTZXJ2ZXJ9LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBvdGhlclVzZXJHYWluTWFwICBUaGUgbWFwIGJldHdlZW4gaGFzaGVkIHZpc2l0IElEcyBhbmQgdGhlIGRlc2lyZWQgYWRqdXN0ZWQgZ2FpbnMgb2YgdXNlcnMgZnJvbSB0aGUgcGVyc3BlY3RpdmUgb2YgdGhpcyBjbGllbnQsIGZvciB0aGlzIGNvbm5lY3Rpb24gb25seS5cbiAgICAgKiBcbiAgICAgKiBVc2Uge0BsaW5rIGFkZFVzZXJEYXRhU3Vic2NyaXB0aW9ufSBhbmQge0BsaW5rIEhpRmlDb21tdW5pY2F0b3Iub25Vc2Vyc0Rpc2Nvbm5lY3RlZH0gdG8ga2VlcCB0cmFjayBvZiB0aGUgaGFzaGVkIHZpc2l0IElEcyBvZiBjdXJyZW50bHkgY29ubmVjdGVkIHVzZXJzLlxuICAgICAqIFxuICAgICAqIFdoZW4geW91IHN1YnNjcmliZSB0byB1c2VyIGRhdGEsIHlvdSB3aWxsIGdldCBhIGxpc3Qgb2Yge0BsaW5rIFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YX0gb2JqZWN0cywgd2hpY2ggZWFjaCBjb250YWluLCBhdCBtaW5pbXVtLCB7QGxpbmsgUmVjZWl2ZWRIaWZpQXVkaW9BUElEYXRhLmhhc2hlZFZpc2l0SUR9cyBhbmQge0BsaW5rIFJlY2VpdmVkSGlmaUF1ZGlvQVBJRGF0YS5wcm92aWRlZFVzZXJJRH1zIGZvciBlYWNoIHVzZXIgaW4gdGhlIHNwYWNlLiBCeSBpbnNwZWN0aW5nIGVhY2ggb2YgdGhlc2Ugb2JqZWN0cywgeW91IGNhbiBhc3NvY2lhdGUgYSB1c2VyIHdpdGggdGhlaXIgaGFzaGVkIHZpc2l0IElELCBpZiB5b3Uga25vdyB0aGVpciBwcm92aWRlZCB1c2VyIElELlxuICAgICAqIFxuICAgICAqIFRoZSByZWxhdGl2ZSBnYWluIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgb3RoZXIgdXNlciB3aXRoIHRoZSBtYXRjaGluZyBoYXNoZWQgdmlzaXQgSUQuIEJ5IGRlZmF1bHQsIHRoaXMgaXMgYDEuMGAuIFRoZSBnYWluIGNhbiBiZSBhbnkgdmFsdWUgZ3JlYXRlciBvciBlcXVhbCB0byBgMC4wYC5cbiAgICAgKiBGb3IgZXhhbXBsZTogYSBnYWluIG9mIGAyLjBgIHdpbGwgZG91YmxlIHRoZSBsb3VkbmVzcyBvZiB0aGUgdXNlciwgd2hpbGUgYSBnYWluIG9mIGAwLjVgIHdpbGwgaGFsdmUgdGhlIHVzZXIncyBsb3VkbmVzcy4gQSBnYWluIG9mIGAwLjBgIHdpbGwgZWZmZWN0aXZlbHkgbXV0ZSB0aGUgdXNlci5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBJZiB0aGlzIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGUgUHJvbWlzZSB3aWxsIHJlc29sdmUgd2l0aCB7QGxpbmsgU2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlfSB3aXRoIGBzdWNjZXNzYCBlcXVhbCB0byBgdHJ1ZWAuXG4gICAgICogSWYgdW5zdWNjZXNzZnVsLCB0aGUgUHJvbWlzZSB3aWxsIHJlamVjdCB3aXRoIHtAbGluayBTZXRPdGhlclVzZXJHYWluc0ZvclRoaXNDb25uZWN0aW9uUmVzcG9uc2V9IHdpdGggYHN1Y2Nlc3NgIGVxdWFsIHRvIGBmYWxzZWAgYW5kIGBlcnJvcmAgc2V0IHRvIGFuIGVycm9yIG1lc3NhZ2UgZGVzY3JpYmluZyB3aGF0IHdlbnQgd3JvbmcuXG4gICAgICovXG4gICAgYXN5bmMgc2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvbihvdGhlclVzZXJHYWluTWFwOiBPdGhlclVzZXJHYWluTWFwKTogUHJvbWlzZTxTZXRPdGhlclVzZXJHYWluc0ZvclRoaXNDb25uZWN0aW9uUmVzcG9uc2U+IHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5fb3RoZXJVc2VyR2FpblF1ZXVlLCBvdGhlclVzZXJHYWluTWFwKTtcblxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBzdWNjZXNzOiByZXN1bHQuc3VjY2VzcyxcbiAgICAgICAgICAgIGVycm9yOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgZnJvbSB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkuIEFmdGVyIHRoaXMgY2FsbCwgdXNlciBkYXRhIHdpbGwgbm8gbG9uZ2VyIGJlIHRyYW5zbWl0dGVkIHRvIEhpZ2ggRmlkZWxpdHksIHRoZSBhdWRpb1xuICAgICAqIGlucHV0IHN0cmVhbSB3aWxsIG5vdCBiZSB0cmFuc21pdHRlZCB0byBIaWdoIEZpZGVsaXR5LCBhbmQgdGhlIHVzZXIgd2lsbCBubyBsb25nZXIgYmUgYWJsZSB0byBoZWFyIHRoZSBhdWRpbyBzdHJlYW0gZnJvbSBIaWdoIEZpZGVsaXR5LlxuICAgICAqL1xuICAgIGFzeW5jIGRpc2Nvbm5lY3RGcm9tSGlGaUF1ZGlvQVBJU2VydmVyKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGlmICghdGhpcy5fbWl4ZXJTZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGBObyBtaXhlciBzZXNzaW9uIGZyb20gd2hpY2ggd2UgY2FuIGRpc2Nvbm5lY3QhYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub25Vc2Vyc0Rpc2Nvbm5lY3RlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdXNlckRhdGFTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhID0gbmV3IEhpRmlBdWRpb0FQSURhdGEoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbWl4ZXJTZXNzaW9uLmRpc2Nvbm5lY3RGcm9tSGlGaU1peGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIGZpbmFsIG1peGVkIGF1ZGlvIGBNZWRpYVN0cmVhbWAgY29taW5nIGZyb20gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gU2VydmVyLlxuICAgICAqL1xuICAgIGdldE91dHB1dEF1ZGlvTWVkaWFTdHJlYW0oKTogTWVkaWFTdHJlYW0ge1xuICAgICAgICBpZiAodGhpcy5fbWl4ZXJTZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWl4ZXJTZXNzaW9uLmdldE91dHB1dEF1ZGlvTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNvbm5lY3Rpb24gdG8gSGlnaCBGaWRlbGl0eSwgYXMgb25lIG9mIHRoZSBIaUZpQ29ubmVjdGlvblN0YXRlcy5cbiAgICAgKiBUaGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgbm90IGF2YWlsYWJsZSAoZS5nLiBpZiB0aGUgSGlGaUNvbW11bmljYXRvclxuICAgICAqIGlzIHN0aWxsIGluIHRoZSBwcm9jZXNzIG9mIGluaXRpYWxpemluZyBpdHMgdW5kZXJseWluZyBIaUZpTWl4ZXJTZXNzaW9uKS5cbiAgICAgKi9cbiAgICBnZXRDb25uZWN0aW9uU3RhdGUoKTogSGlGaUNvbm5lY3Rpb25TdGF0ZXMge1xuICAgICAgICBpZiAodGhpcy5fbWl4ZXJTZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWl4ZXJTZXNzaW9uLmdldEN1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHNldCB0aGUgYE1lZGlhU3RyZWFtYCBhc3NvY2lhdGVkIHdpdGggdGhlIHVzZXIuIFRoaXMgYE1lZGlhU3RyZWFtYCB3aWxsIGJlIHNlbnQgdXAgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gU2VydmVycyBhbmRcbiAgICAgKiBtaXhlZCB3aXRoIG90aGVyIHVzZXJzJyBhdWRpbyBzdHJlYW1zLiBUaGUgcmVzdWx0YW50IG1peGVkIHN0cmVhbSB3aWxsIGJlIHNlbnQgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzLlxuICAgICAqXG4gICAgICogKipCZSBtaW5kZnVsKiogb2Ygc3VwcGx5aW5nIHRoaXMgc3RyZWFtIHVwb24gaW5pdGlhbCBjb25uZWN0aW9uIHdoZW4geW91IGFudGljaXBhdGUgdGhhdCB0aGUgdXNlciBpcyB1c2luZyBCbHVldG9vdGggYXVkaW9cbiAgICAgKiBpbnB1dCBhbmQgQmx1ZXRvb3RoIGF1ZGlvIG91dHB1dCBzaW11bHRhbmVvdXNseS4gTWFueSBCbHVldG9vdGggYXVkaW8gZGV2aWNlcyBkbyBub3Qgc3VwcG9ydCBzdGVyZW8gKHNwYXRpYWxpemVkKSBhdWRpb1xuICAgICAqIG91dHB1dCBhbmQgbWljcm9waG9uZSBhdWRpbyBpbnB1dCBzaW11bHRhbmVvdXNseSwgaW5jbHVkaW5nIHRoZSBwb3B1bGFyIGNvbWJpbmF0aW9uIG9mIGFuIGlQaG9uZSBhbmQgQWlyUG9kcy5cbiAgICAgKiBZb3VyIHVzZXJzIG1heSBoYXZlIGEgYmV0dGVyIGV4cGVyaWVuY2UgaWYgdGhleSBqb2luIHRoZSBTZXJ2ZXIgaW4gXCJsaXN0ZW4tb25seVwiIG1vZGUgLSBpLmUuIHdpdGhvdXQgbWljcm9waG9uZSBpbnB1dCAtIGFuZCB0aGVuXG4gICAgICogYXJlIGFza2VkIGZvciBtaWNyb3Bob25lIHBlcm1pc3Npb24gbGF0ZXIgKHdoaWNoIHdpbGwgZm9yY2UgdGhlaXIgQmx1ZXRvb3RoIG91dHB1dCBkZXZpY2UgaW50byBhIGxvd2VyLXF1YWxpdHksIHVuc3BhdGlhbGl6ZWQgbW9ubyBtb2RlKS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gbmV3SW5wdXRBdWRpb01lZGlhU3RyZWFtIC0gVGhlIG5ldyBgTWVkaWFTdHJlYW1gIHRvIHNlbmQgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gU2VydmVyLiBJZiB0aGlzXG4gICAgICogaXMgc2V0IHRvIGFuIGB1bmRlZmluZWRgIHZhbHVlLCB0aGUgZXhpc3RpbmcgaW5wdXQgc3RyZWFtIChpZiBvbmUgaXMgc2V0KSB3aWxsIGJlIGNsZWFyZWQuXG4gICAgICogQHBhcmFtIGlzU3RlcmVvIC0gYHRydWVgIGlmIHRoZSBpbnB1dCBzdHJlYW0gc2hvdWxkIGJlIHRyZWF0ZWQgYXMgc3RlcmVvLCBgZmFsc2VgIGZvciBtb25vIChkZWZhdWx0KS5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG5ldyBgTWVkaWFTdHJlYW1gIHdhcyBzdWNjZXNzZnVsbHkgc2V0LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRJbnB1dEF1ZGlvTWVkaWFTdHJlYW0obmV3SW5wdXRBdWRpb01lZGlhU3RyZWFtOiBNZWRpYVN0cmVhbSwgaXNTdGVyZW86IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCByZXR2YWwgPSBhd2FpdCB0aGlzLl9taXhlclNlc3Npb24uc2V0UkFWSUlucHV0QXVkaW8obmV3SW5wdXRBdWRpb01lZGlhU3RyZWFtLCBpc1N0ZXJlbyk7XG4gICAgICAgIGlmIChyZXR2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0QXVkaW9NZWRpYVN0cmVhbSA9IG5ld0lucHV0QXVkaW9NZWRpYVN0cmVhbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgRXJyb3IgdHJ5aW5nIHRvIHNldFJBVklJbnB1dEF1ZGlvIG9uIHRoaXMuX21peGVyU2Vzc2lvbmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgZnVuY3Rpb24gdG8gc2V0IHdoZXRoZXIgaW5wdXQgYXVkaW8gc3RyZWFtIHdpbGwgaGF2ZSB0aGUgYGVuYWJsZWRgIHByb3BlcnR5IG9mIGVhY2ggb2YgaXRzIGBNZWRpYVN0cmVhbVRyYWNrYHMgc2V0IHRvIGBmYWxzZWBcbiAgICAgKiAoYW5kIGFuIHVubXV0ZWQgc3RyZWFtIC0tIHRoZSBkZWZhdWx0IC0tIHdpbGwgaGF2ZSB0aGUgYGVuYWJsZWRgIHByb3BlcnR5IHNldCB0byBgdHJ1ZWApLiBUaGlzIHdpbGwgc2lsZW5jZSB0aGUgaW5wdXQsXG4gICAgICogYnV0IGhhcyBzcGVjaWZpYyBjb25zZXF1ZW5jZXM6XG4gICAgICogICAtIElmIHlvdSBhcmUgdXNpbmcgdGhlIHNhbWUgYE1lZGlhU3RyZWFtYCBvYmplY3QgaW4gb3RoZXIgd2F5cywgaXQgd2lsbCBiZSBhZmZlY3RlZCBieVxuICAgICAqIGNhbGxpbmcgdGhpcyBtZXRob2QuIFNvLCBpZiB5b3Ugd291bGQgbGlrZSB0byBtdXRlL3VubXV0ZSB0aGUgaW5wdXQgYXVkaW8gc3RyZWFtIHNlcGFyYXRlbHkgZm9yIHRoZVxuICAgICAqIEhpZ2ggRmlkZWxpdHkgYXVkaW8gdnMuIHNvbWUgb3RoZXIgdXNlIG9mIGl0LCBpdCBpcyByZWNvbW1lbmRlZCB0byBjbG9uZSB0aGUgYXVkaW8gc3RyZWFtIHNlcGFyYXRlbHlcbiAgICAgKiBmb3IgZWFjaCB1c2UuXG4gICAgICogICAtIFRoZSBlZmZlY3QgaXMgaW1tZWRpYXRlIGFuZCBjb3VsZCByZXN1bHQgaW4gYSBjbGljayBvciBvdGhlciBhdWRpbyBhcnRpZmFjdCBpZiB0aGVyZSBpcyBzdGVhZHkgc291bmQgYXRcbiAgICAgKiB0aGUgbW9tZW50IHRoZSBpbnB1dCBpcyBtdXRlZC5cbiAgICAgKlxuICAgICAqIEFuIGFsdGVyYXRpdmUgaXMgdG8gc2V0IHRoZSB1c2VyJ3Mge0BsaW5rIHZvbHVtZVRocmVzaG9sZH0gdG8gMCwgd2hpY2ggc21vb3RobHkgZ2F0ZXMgb2ZmIHRoZSB1c2VyJ3MgaW5wdXQuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBzdHJlYW0gd2FzIHN1Y2Nlc3NmdWxseSBtdXRlZC91bm11dGVkLCBgZmFsc2VgIGlmIGl0IHdhcyBub3QuIChUaGUgdXNlciBzaG91bGRcbiAgICAgKiBhc3N1bWUgdGhhdCBpZiB0aGlzIHJldHVybnMgYGZhbHNlYCwgbm8gY2hhbmdlIHdhcyBtYWRlIHRvIHRoZSBtdXRlICh0cmFjayBlbmFibGVkKSBzdGF0ZSBvZiB0aGUgc3RyZWFtLilcbiAgICAgKi9cbiAgICBhc3luYyBzZXRJbnB1dEF1ZGlvTXV0ZWQoaXNNdXRlZDogYm9vbGVhbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBpZiAodGhpcy5fbWl4ZXJTZXNzaW9uKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmRlYnVnKGBTZXR0aW5nIG11dGUgc3RhdGUgdG8gOiAke2lzTXV0ZWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fbWl4ZXJTZXNzaW9uLnNldElucHV0QXVkaW9NdXRlZChpc011dGVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgQ291bGRuJ3Qgc2V0IG11dGUgc3RhdGU6IE5vIFxcYF9taXhlclNlc3Npb25cXGAuYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBBIGJ1bmNoIG9mIGluZm8gYWJvdXQgdGhpcyBgSGlGaUNvbW11bmljYXRvcmAgaW5zdGFudGlhdGlvbiwgaW5jbHVkaW5nIFNlcnZlciBWZXJzaW9uLlxuICAgICAqL1xuICAgIGdldENvbW11bmljYXRvckluZm8oKTogYW55IHtcbiAgICAgICAgbGV0IHJldHZhbDogYW55ID0ge1xuICAgICAgICAgICAgXCJjbGllbnRJbmZvXCI6IHtcbiAgICAgICAgICAgICAgICBcImlucHV0QXVkaW9TdHJlYW1TZXRcIjogISF0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IGlzQnJvd3NlckNvbnRleHQgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChpc0Jyb3dzZXJDb250ZXh0ICYmIHR5cGVvZiAoSElGSV9BUElfVkVSU0lPTikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHZhbC5jbGllbnRJbmZvW1wiYXBpVmVyc2lvblwiXSA9IEhJRklfQVBJX1ZFUlNJT047XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWl4ZXJTZXNzaW9uICYmIHRoaXMuX21peGVyU2Vzc2lvbi5taXhlckluZm8pIHtcbiAgICAgICAgICAgIHJldHZhbFtcInNlcnZlckluZm9cIl0gPSB0aGlzLl9taXhlclNlc3Npb24ubWl4ZXJJbmZvO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBjb2xsZWN0aW5nIGRhdGEgYWJvdXQgdGhlIFdlYlJUQyBjb25uZWN0aW9uIGJldHdlZW4gQ2xpZW50IGFuZCBTZXJ2ZXIuXG4gICAgICogTm90ZSB0aGF0IHRoZSBkYXRhIGluc2lkZSB0aGUgcmVwb3J0cyBwZXJ0YWlucyBvbmx5IHRvIHBheWxvYWQgZGF0YSBpbnRlcm5hbCB0byB0aGUgV2ViUlRDIGNvbm5lY3Rpb25cbiAgICAgKiBhbmQgZG9lcyBub3QgaW5jbHVkZSBfdG90YWxfIGRhdGEgc2VudCBvdmVyIHRoZSB3aXJlIG9yIHJlY2VpdmVkIG92ZXIgdGhlIHdpcmUgaW4geW91ciBhcHBsaWNhdGlvbi5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25zIHdpbGwgYmUgcHJvdmlkZWQgdHdvIEFycmF5IGFyZ3VtZW50czogYHN0YXRzYCBhbmQgYHByZXZTdGF0c2AuXG4gICAgICogRWFjaCBvZiB0aG9zZSBBcnJheSBpdGVtcyBjb250YWlucyBvbmUgb3IgbW9yZSBPYmplY3RzLCB3aGljaCBhcmUgcmVwb3J0cyBvZiBXZWJSVEMgc3RhdHMgZGF0YSxcbiAgICAgKiBpbmNsdWRpbmcgZGF0YSBzdWNoIGFzIFwiYSB0aW1lc3RhbXBcIiwgXCJ0aGUgbnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIHNpbmNlIHRoZSBsYXN0IHJlcG9ydFwiIGFuZCBcImN1cnJlbnQgaml0dGVyIGJ1ZmZlciBkZWxheVwiLlxuICAgICAqL1xuICAgIHN0YXJ0Q29sbGVjdGluZ1dlYlJUQ1N0YXRzKGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuX21peGVyU2Vzc2lvbikge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgQ291bGRuJ3Qgc3RhcnQgY29sbGVjdGluZyBXZWJSVEMgU3RhdHM6IE5vIFxcYF9taXhlclNlc3Npb25cXGAhYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9taXhlclNlc3Npb24uc3RhcnRDb2xsZWN0aW5nV2ViUlRDU3RhdHMoY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgY29sbGVjdGluZyBkYXRhIGFib3V0IHRoZSBXZWJSVEMgY29ubmVjdGlvbiBiZXR3ZWVuIENsaWVudCBhbmQgU2VydmVyLlxuICAgICAqL1xuICAgIHN0b3BDb2xsZWN0aW5nV2ViUlRDU3RhdHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWl4ZXJTZXNzaW9uKSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLmVycm9yKGBDb3VsZG4ndCBzdG9wIGNvbGxlY3RpbmcgV2ViUlRDIFN0YXRzOiBObyBcXGBfbWl4ZXJTZXNzaW9uXFxgIWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWl4ZXJTZXNzaW9uLnN0b3BDb2xsZWN0aW5nV2ViUlRDU3RhdHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBjb3B5IG9mIHRoZSBVc2VyIERhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNsaWVudC4gRG9lcyAqKk5PVCoqIHVwZGF0ZVxuICAgICAqIHRoZSB1c2VyIGRhdGEgb24gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIHNlcnZlci4gVGhlcmUgYXJlIG5vIGdvb2QgcmVhc29ucyBmb3IgYSBjbGllbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uXG4gICAgICogYW5kIF9ub3RfIHVwZGF0ZSB0aGUgc2VydmVyIFVzZXIgRGF0YSwgYW5kIHRodXMgdGhpcyBmdW5jdGlvbiBpcyBgcHJpdmF0ZWAuXG4gICAgICogXG4gICAgICogWW91IGNhbiB1cGRhdGUgdXNlciBvcmllbnRhdGlvbiBieSBwYXNzaW5nIFF1YXRlcm5pb24gb3IgRXVsZXIgb3JpZW50YXRpb24gcmVwcmVzZW50YXRpb25zIHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgKiBUaGUgcXVhdGVybmlvbiByZXByZXNlbnRhdGlvbiBpcyBwcmVmZXJyZWQuXG4gICAgICogSWYgYm90aCByZXByZXNlbnRhdGlvbiBhcmUgcHJvdmlkZWQsIHRoZSBldWxlciByZXByZXNlbnRhdGlvbiBpcyBpZ25vcmVkLlxuICAgICAqIElmIG9ubHkgdGhlIGV1bGVyIHJlcHJlc2VudGF0aW9uIGlzIHByb3ZpZGVkLCBpdCBpcyB0aGVuIGNvbnZlcnRlZCBpbW1lZGlhdGVseSB0byB0aGUgZXF1aXZhbGVudCBxdWF0ZXJuaW9uIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIFRoZSBldWxlck9yZGVyIHVzZWQgZm9yIHRoZSBjb252ZXJzaW9uIGlzIHRoZSBwcm92aWRlZCBieSB0aGUgJ291ckF4aXNDb25maWd1cmF0aW9uLmV1bGVyT3JkZXInLlxuICAgICAqIEV1bGVyIHJlcHJlc2VudGF0aW9uIGlzIG5vdCB1c2VkIGludGVybmFsbHkgYW55bW9yZSBpbiB0aGUgSGlmaSBBUEkuXG4gICAgICogXG4gICAgICogQHBhcmFtIF9fbmFtZWRQYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIC0gVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gb3JpZW50YXRpb25RdWF0IC0gVGhlIG5ldyBvcmllbnRhdGlvblF1YXQgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9yaWVudGF0aW9uRXVsZXIgLSBUaGUgbmV3IG9yaWVudGF0aW9uRXVsZXIgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIHZvbHVtZVRocmVzaG9sZCAtIFRoZSBuZXcgdm9sdW1lVGhyZXNob2xkIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBoaUZpR2FpbiAtIFRoaXMgdmFsdWUgYWZmZWN0cyBob3cgbG91ZCBVc2VyIEEgd2lsbCBzb3VuZCB0byBVc2VyIEIgYXQgYSBnaXZlbiBkaXN0YW5jZSBpbiAzRCBzcGFjZS5cbiAgICAgKiBUaGlzIHZhbHVlIGFsc28gYWZmZWN0cyB0aGUgZGlzdGFuY2UgYXQgd2hpY2ggVXNlciBBIGNhbiBiZSBoZWFyZCBpbiAzRCBzcGFjZS5cbiAgICAgKiBIaWdoZXIgdmFsdWVzIGZvciBVc2VyIEEgbWVhbnMgdGhhdCBVc2VyIEEgd2lsbCBzb3VuZCBsb3VkZXIgdG8gb3RoZXIgdXNlcnMgYXJvdW5kIFVzZXIgQSwgYW5kIGl0IGFsc28gbWVhbnMgdGhhdCBVc2VyIEEgd2lsbCBiZSBhdWRpYmxlIGZyb20gYSBncmVhdGVyIGRpc3RhbmNlLlxuICAgICAqIFRoZSBuZXcgaGlGaUdhaW4gb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIHVzZXJBdHRlbnVhdGlvbiAtIFRoaXMgdmFsdWUgYWZmZWN0cyBob3cgZmFyIGEgdXNlcidzIHZvaWNlIHdpbGwgdHJhdmVsIGluIDNEIHNwYWNlLlxuICAgICAqIFRoZSBuZXcgYXR0ZW51YXRpb24gdmFsdWUgZm9yIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSB1c2VyUm9sbG9mZiAtIFRoaXMgdmFsdWUgYWZmZWN0cyB0aGUgZnJlcXVlbmN5IHJvbGxvZmYgZm9yIGEgZ2l2ZW4gdXNlci5cbiAgICAgKiBUaGUgbmV3IHJvbGxvZmYgdmFsdWUgZm9yIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIHByaXZhdGUgX3VwZGF0ZVVzZXJEYXRhKHsgcG9zaXRpb24sIG9yaWVudGF0aW9uUXVhdCwgb3JpZW50YXRpb25FdWxlciwgdm9sdW1lVGhyZXNob2xkLCBoaUZpR2FpbiwgdXNlckF0dGVudWF0aW9uLCB1c2VyUm9sbG9mZiB9OiB7IHBvc2l0aW9uPzogUG9pbnQzRCwgb3JpZW50YXRpb25FdWxlcj86IE9yaWVudGF0aW9uRXVsZXIzRCwgb3JpZW50YXRpb25RdWF0PzogT3JpZW50YXRpb25RdWF0M0QsIHZvbHVtZVRocmVzaG9sZD86IG51bWJlciwgaGlGaUdhaW4/OiBudW1iZXIsIHVzZXJBdHRlbnVhdGlvbj86IG51bWJlciwgdXNlclJvbGxvZmY/OiBudW1iZXIgfSA9IHt9KTogdm9pZCB7XG4gICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uID0gbmV3IFBvaW50M0QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24ueCA9IHBvc2l0aW9uLnggPz8gdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24ueDtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnkgPSBwb3NpdGlvbi55ID8/IHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi56ID0gcG9zaXRpb24ueiA/PyB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi56O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uUXVhdCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQgPSBuZXcgT3JpZW50YXRpb25RdWF0M0QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LncgPSBvcmllbnRhdGlvblF1YXQudyA/PyB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQudztcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC54ID0gb3JpZW50YXRpb25RdWF0LnggPz8gdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0Lng7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueSA9IG9yaWVudGF0aW9uUXVhdC55ID8/IHRoaXMuX2N1cnJlbnRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC55O1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnogPSBvcmllbnRhdGlvblF1YXQueiA/PyB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQuejtcbiAgICAgICAgfSBcbiAgICAgICAgLy8gaWYgb3JpZW50YXRpb24gaXMgcHJvdmlkZWQgYXMgYW4gZXVsZXIgZm9ybWF0LCB0aGVuIGRvIHRoZSBjb252ZXJzaW9uIGltbWVkaWF0ZWx5XG4gICAgICAgIGVsc2UgaWYgKG9yaWVudGF0aW9uRXVsZXIpIHtcbiAgICAgICAgICAgIGxldCBjaGVja2VkRXVsZXIgPSBuZXcgT3JpZW50YXRpb25FdWxlcjNEKG9yaWVudGF0aW9uRXVsZXIpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0ID0gZXVsZXJUb1F1YXRlcm5pb24oY2hlY2tlZEV1bGVyLCBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24uZXVsZXJPcmRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mICh2b2x1bWVUaHJlc2hvbGQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS52b2x1bWVUaHJlc2hvbGQgPSB2b2x1bWVUaHJlc2hvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoaGlGaUdhaW4pID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5oaUZpR2FpbiA9IE1hdGgubWF4KDAsIGhpRmlHYWluKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh1c2VyQXR0ZW51YXRpb24pID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS51c2VyQXR0ZW51YXRpb24gPSB1c2VyQXR0ZW51YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodXNlclJvbGxvZmYpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS51c2VyUm9sbG9mZiA9IE1hdGgubWF4KDAsIHVzZXJSb2xsb2ZmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgY2xpZW50c2lkZSByYXRlIGxpbWl0IHRpbWVvdXQgdXNlZCB0byBwcmV2ZW50IHVzZXIgZGF0YSBmcm9tIGJlaW5nIHNlbnQgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIHNlcnZlciB0b28gb2Z0ZW4uXG4gICAgICovXG4gICAgcHJpdmF0ZSBfbWF5YmVDbGVhclJhdGVMaW1pdFRpbWVvdXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl90aW1lcnMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXJzLnRyYW5zbWl0UmF0ZUxpbWl0VGltZW91dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90aW1lcnMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBrZWVwIGEgY2xpZW50c2lkZSBjb3B5IG9mIHRoZSBkYXRhIHRoYXQgd2UgbGFzdCB0cmFuc21pdHRlZCB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgc2VydmVyLiBXZSB1c2UgdGhpcyBkYXRhIHRvXG4gICAgICogZW5zdXJlIHRoYXQgd2Ugb25seSBzZW5kIHRvIHRoZSBzZXJ2ZXIgdGhlIG1pbmltdW0gc2V0IG9mIGRhdGEgbmVjZXNzYXJ5IC0gaS5lLiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBkYXRhIGNvbnRhaW5lZCBvbiB0aGUgc2VydmVyXG4gICAgICogYWJvdXQgdGhlIHVzZXIgYW5kIHRoZSBuZXcgZGF0YSB0aGF0IHRoZSBjbGllbnQgaGFzIGxvY2FsbHkuIFdlIHVzZSB0aGlzIGZ1bmN0aW9uIGhlcmUgdG8gdXBkYXRlIHRoZSBjbGllbnRzaWRlIGNvcHkgb2YgdGhlIGRhdGFcbiAgICAgKiB0aGF0IHdlIGxhc3QgdHJhbnNtaXR0ZWQuXG4gICAgICogXG4gICAgICogQHBhcmFtIGRhdGFKdXN0VHJhbnNtaXR0ZWQgLSBUaGUgZGF0YSB0aGF0IHdlIGp1c3QgdHJhbnNtaXR0ZWQgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIHNlcnZlci5cbiAgICAgKi9cbiAgICBwcml2YXRlIF91cGRhdGVMYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhKGRhdGFKdXN0VHJhbnNtaXR0ZWQ6IEhpRmlBdWRpb0FQSURhdGEpOiB2b2lkIHtcbiAgICAgICAgaWYgKGRhdGFKdXN0VHJhbnNtaXR0ZWQucG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24gPSBuZXcgUG9pbnQzRCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnggPSBkYXRhSnVzdFRyYW5zbWl0dGVkLnBvc2l0aW9uLnggPz8gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi54O1xuICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi55ID0gZGF0YUp1c3RUcmFuc21pdHRlZC5wb3NpdGlvbi55ID8/IHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24ueTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24ueiA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQucG9zaXRpb24ueiA/PyB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLno7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YUp1c3RUcmFuc21pdHRlZC5vcmllbnRhdGlvblF1YXQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdCA9IG5ldyBPcmllbnRhdGlvblF1YXQzRCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC53ID0gZGF0YUp1c3RUcmFuc21pdHRlZC5vcmllbnRhdGlvblF1YXQudyA/PyB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC53O1xuICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueCA9IGRhdGFKdXN0VHJhbnNtaXR0ZWQub3JpZW50YXRpb25RdWF0LnggPz8gdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnkgPSBkYXRhSnVzdFRyYW5zbWl0dGVkLm9yaWVudGF0aW9uUXVhdC55ID8/IHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0Lnk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC56ID0gZGF0YUp1c3RUcmFuc21pdHRlZC5vcmllbnRhdGlvblF1YXQueiA/PyB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC56O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiAoZGF0YUp1c3RUcmFuc21pdHRlZC52b2x1bWVUaHJlc2hvbGQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhW1widm9sdW1lVGhyZXNob2xkXCJdID0gZGF0YUp1c3RUcmFuc21pdHRlZC52b2x1bWVUaHJlc2hvbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIChkYXRhSnVzdFRyYW5zbWl0dGVkLmhpRmlHYWluKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YVtcImhpRmlHYWluXCJdID0gZGF0YUp1c3RUcmFuc21pdHRlZC5oaUZpR2FpbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChkYXRhSnVzdFRyYW5zbWl0dGVkLnVzZXJBdHRlbnVhdGlvbikgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGFbXCJ1c2VyQXR0ZW51YXRpb25cIl0gPSBkYXRhSnVzdFRyYW5zbWl0dGVkLnVzZXJBdHRlbnVhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChkYXRhSnVzdFRyYW5zbWl0dGVkLnVzZXJSb2xsb2ZmKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YVtcInVzZXJSb2xsb2ZmXCJdID0gZGF0YUp1c3RUcmFuc21pdHRlZC51c2VyUm9sbG9mZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChkYXRhSnVzdFRyYW5zbWl0dGVkLl9vdGhlclVzZXJHYWluUXVldWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEuX290aGVyVXNlckdhaW5RdWV1ZSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRUb0dhaW4gb2YgT2JqZWN0LmVudHJpZXMoZGF0YUp1c3RUcmFuc21pdHRlZC5fb3RoZXJVc2VyR2FpblF1ZXVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEuX290aGVyVXNlckdhaW5RdWV1ZVtpZFRvR2FpblswXV0gPSBpZFRvR2FpblsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgdGhlIGxvY2FsIHVzZXIgZGF0YSBwcm9wZXJseSwgdGhlbiBzZW5kcyB0aGF0IHVzZXIgZGF0YSB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgc2VydmVyLiBUaGlzIHRyYW5zZmVyIGlzIHJhdGUgbGltaXRlZC5cbiAgICAgKiBcbiAgICAgKiBUaGVyZSBpcyBubyByZWFzb24gYSBsaWJyYXJ5IHVzZXIgd291bGQgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gd2l0aG91dCBhbHNvIHNpbXVsdGFuZW91c2x5IHVwZGF0aW5nIFVzZXIgRGF0YSwgc28gdGhpcyBmdW5jdGlvbiBpcyBgcHJpdmF0ZWAuXG4gICAgICogXG4gICAgICogQHBhcmFtIGZvcmNlVHJhbnNtaXQgLSBgdHJ1ZWAgaWYgd2Ugc2hvdWxkIGlnbm9yZSB0aGUgY2xpZW50c2lkZSByYXRlIGxpbWl0ZXIgYW5kIHNlbmQgdGhlIGRhdGEgcmVnYXJkbGVzcyBvZiBpdHMgc3RhdHVzOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKiBAcmV0dXJucyBJZiB0aGlzIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsLCByZXR1cm5zIGB7IHN1Y2Nlc3M6IHRydWUsIHJhd0RhdGFUcmFuc21pdHRlZDogPHRoZSByYXcgZGF0YSB0aGF0IHdhcyB0cmFuc21pdHRlZCB0byB0aGUgc2VydmVyPn1gLiBJZiB1bnN1Y2Nlc3NmdWwsIHJldHVybnNcbiAgICAgKiBgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IDxhbiBlcnJvciBtZXNzYWdlPiB9YC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF90cmFuc21pdEhpRmlBdWRpb0FQSURhdGFUb1NlcnZlcihmb3JjZVRyYW5zbWl0PzogYm9vbGVhbik6IGFueSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGEgY2FsbGVyIGNhbid0IHRyYW5zbWl0IGRhdGEgZm9yIGFub3RoZXIgYHRoaXMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVNgIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgaWYgKHRoaXMuX21peGVyU2Vzc2lvbiAmJiAoIXRoaXMuX3RpbWVycy50cmFuc21pdFJhdGVMaW1pdFRpbWVvdXQgfHwgZm9yY2VUcmFuc21pdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVycy53YW50ZWRUb1RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fbWF5YmVDbGVhclJhdGVMaW1pdFRpbWVvdXQoKTtcbiAgICAgICAgICAgIGlmICghZm9yY2VUcmFuc21pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVycy50cmFuc21pdFJhdGVMaW1pdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF5YmVDbGVhclJhdGVMaW1pdFRpbWVvdXQoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGltZXJzLndhbnRlZFRvVHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc21pdEhpRmlBdWRpb0FQSURhdGFUb1NlcnZlcih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMudHJhbnNtaXRSYXRlTGltaXRUaW1lb3V0TVMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBkYXRhIHRvIHRyYW5zbWl0LCB3aGljaCBpcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBsYXN0IGRhdGEgd2UgdHJhbnNtaXR0ZWRcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgY3VycmVudCBkYXRhIHdlIGhhdmUgc3RvcmVkLlxuICAgICAgICAgICAvLyBsZXQgZGVsdGEgPSB0aGlzLl9sYXN0VHJhbnNtaXR0ZWRIaUZpQXVkaW9BUElEYXRhLmRpZmYodGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEpO1xuICAgICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHRyYW5zbGF0ZSB0aGUgbmV3IGBIaUZpQXVkaW9BUElEYXRhYCBvYmplY3QgZnJvbSBhYm92ZSBpbnRvIHN0cmluZ2lmaWVkIEpTT04gZGF0YSBpbiB0aGUgcHJvcGVyIGZvcm1hdCxcbiAgICAgICAgICAgIC8vIHRoZW4gc2VuZCB0aGF0IGRhdGEgdG8gdGhlIG1peGVyLlxuICAgICAgICAgICAgLy8gVGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByYXcgZGF0YSB0aGF0IGl0IHNlbnQgdG8gdGhlIG1peGVyLlxuICAgICAgICAgICAgbGV0IHRyYW5zbWl0UmV0dmFsID0gdGhpcy5fbWl4ZXJTZXNzaW9uLl90cmFuc21pdEhpRmlBdWRpb0FQSURhdGFUb1NlcnZlcih0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YSwgdGhpcy5fbGFzdFRyYW5zbWl0dGVkSGlGaUF1ZGlvQVBJRGF0YSk7XG4gICAgICAgICAgICBpZiAodHJhbnNtaXRSZXR2YWwuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIHRvIHVwZGF0ZSBvdXIgXCJsYXN0IHRyYW5zbWl0dGVkXCIgYEhpRmlBdWRpb0FQSURhdGFgIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIHRvIGNvbnRhaW4gdGhlIGRhdGEgdGhhdCB3ZSBqdXN0IHRyYW5zbWl0dGVkLlxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEodGhpcy5fY3VycmVudEhpRmlBdWRpb0FQSURhdGEpO1xuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIGluIHNvbWUgY2FzZXMsIGNsZWFuIHVwIHNvbWUgb2YgdGhlIHRyYW5zbWl0dGVkIGRhdGEgaGlzdG9yeVxuICAgICAgICAgICAgICAgIC8vIChwYXJ0aWN1bGFybHksIF9vdGhlclVzZXJHYWluUXVldWUpXG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW5VcEhpRmlBdWRpb0FQSURhdGFIaXN0b3J5KCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByYXdEYXRhVHJhbnNtaXR0ZWQ6IHRyYW5zbWl0UmV0dmFsLnN0cmluZ2lmaWVkRGF0YUZvck1peGVyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB0cmFuc21pdFJldHZhbC5lcnJvclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbWl4ZXJTZXNzaW9uICYmIHRoaXMuX3RpbWVycy50cmFuc21pdFJhdGVMaW1pdFRpbWVvdXQgJiYgIWZvcmNlVHJhbnNtaXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVycy53YW50ZWRUb1RyYW5zbWl0SGlGaUF1ZGlvQVBJRGF0YSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBUcmFuc2ZlciBpcyByYXRlIGxpbWl0ZWQuIFRyYW5zZmVyIHdpbGwgb2NjdXIgc2hvcnRseSBhdXRvbWF0aWNhbGx5LmBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX21peGVyU2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogYE5vIHNlcnZlciBjb25uZWN0aW9uIHlldDsgY2FuJ3QgdHJhbnNtaXQgdXNlciBkYXRhLmBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxseSwgd2UgdHJ5IHRvIGxpbWl0IHRoZSBhbW91bnQgb2YgZGF0YSB3ZSB0cmFuc21pdCB0byB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgc2VydmVyLCBieSByZW1lbWJlcmluZyB3aGF0IHdlXG4gICAgICogc2VudC4gU2VlIHtAbGluayBfdXBkYXRlVXNlckRhdGF9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB0aGlzIGlzIGRvbmUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGV4aXN0cyB0byBoYW5kbGUgYW55IHNjZW5hcmlvcyBvZiByZW1lbWJlcmluZyB0b28gbXVjaCBzZW50IGRhdGEuIEl0IGlzIGNhbGxlZCBqdXN0IGFmdGVyIGRhdGEgaXMgc3VjY2VzZnVsbHkgc2VudCwgd2hlbiBkYXRhIGlzIGtub3duIHRvIG5vIGxvbmdlciBiZSBuZWVkZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfY2xlYW5VcEhpRmlBdWRpb0FQSURhdGFIaXN0b3J5KCk6IHZvaWQge1xuICAgICAgICAvLyBBbHdheXMgY2xlYXIgX290aGVyVXNlckdhaW5RdWV1ZSBpbiBvdXIgbG9jYWwgZGF0YVxuICAgICAgICB0aGlzLl9jdXJyZW50SGlGaUF1ZGlvQVBJRGF0YS5fb3RoZXJVc2VyR2FpblF1ZXVlID0ge307XG5cbiAgICAgICAgbGV0IG1heENhY2hlZE90aGVyVXNlckdhaW5zID0gMTAwMDtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEuX290aGVyVXNlckdhaW5RdWV1ZSkubGVuZ3RoID4gbWF4Q2FjaGVkT3RoZXJVc2VyR2FpbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEuX290aGVyVXNlckdhaW5RdWV1ZSA9IHt9O1xuICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBTdG9yZWQgXFxgX2xhc3RUcmFuc21pdHRlZEhpRmlBdWRpb0FQSURhdGEuX290aGVyVXNlckdhaW5RdWV1ZVxcYCB3YXMgdG9vIGxhcmdlIGFuZCB3YXMgY2xlYXJlZCB0byBzYXZlIHNwYWNlLmApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgZnVuY3Rpb24gdGhhdCBjYWxscyB7QGxpbmsgX3VwZGF0ZVVzZXJEYXRhfSwgZm9sbG93ZWQgYnkge0BsaW5rIF90cmFuc21pdEhpRmlBdWRpb0FQSURhdGFUb1NlcnZlcn0uXG4gICAgICogRGV2ZWxvcGVycyBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uIGFzIG9mdGVuIGFzIHRoZXkgd2FudC4gVGhpcyBmdW5jdGlvbiB3aWxsIHVwZGF0ZSB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSBvZiB0aGUgdXNlcidzXG4gICAgICogcG9zaXRpb24sIG9yaWVudGF0aW9uLCBldGMuIE5vIG1hdHRlciBob3cgb2Z0ZW4gZGV2ZWxvcGVycyBjYWxsIHRoaXMgZnVuY3Rpb24sIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIHRyYW5zbWlzc2lvbiBpcyByYXRlLWxpbWl0ZWRcbiAgICAgKiBhbmQgd2lsbCBvbmx5IGJlIHNlbnQgdG8gdGhlIHNlcnZlciBvbmNlIGV2ZXJ5IGB0cmFuc21pdFJhdGVMaW1pdFRpbWVvdXRNU2AgbWlsbGlzZWNvbmRzLiBXaGVuIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGlzIHRyYW5zbWl0dGVkLFxuICAgICAqIHRoZSBtb3N0IHVwLXRvLWRhdGUgZGF0YSB3aWxsIGJlIHRyYW5zbWl0dGVkLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBuZXdVc2VyRGF0YSAtIFRoZSBuZXcgdXNlciBkYXRhIHRoYXQgd2Ugd2FudCB0byBzZW5kIHRvIHRoZSBIaWdoIEZpZGVsaXR5IEF1ZGlvIEFQSSBzZXJ2ZXIuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgcmV0dXJuIHZhbHVlIG9mIHtAbGluayBfdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXJ9LlxuICAgICAqL1xuICAgIHVwZGF0ZVVzZXJEYXRhQW5kVHJhbnNtaXQobmV3VXNlckRhdGE6IGFueSk6IHN0cmluZyB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVVzZXJEYXRhKG5ld1VzZXJEYXRhKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNtaXRIaUZpQXVkaW9BUElEYXRhVG9TZXJ2ZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmdlc3RzIHVzZXIgZGF0YSB1cGRhdGVzIGZyb20gdGhlIHNlcnZlciBhbmQsIGlmIHJlbGV2YW50LCBjYWxscyB0aGUgcmVsZXZhbnQgY2FsbGJhY2sgZnVuY3Rpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICAgKiBVc2VyIERhdGEgU3Vic2NyaXB0aW9ucy4gU2VlIHtAbGluayBhZGRVc2VyRGF0YVN1YnNjcmlwdGlvbn0uXG4gICAgICogXG4gICAgICogQHBhcmFtIG5ld1VzZXJEYXRhRnJvbVNlcnZlciAtIENvbnRhaW5zIGFsbCBvZiB0aGUgbmV3IHVzZXIgZGF0YSBtb3N0IHJlY2VudGx5IHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci4gXG4gICAgICovXG4gICAgcHJpdmF0ZSBfaGFuZGxlVXNlckRhdGFVcGRhdGVzKG5ld1VzZXJEYXRhRnJvbVNlcnZlcjogQXJyYXk8UmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhPik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fdXNlckRhdGFTdWJzY3JpcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgc3ViSXRyID0gMDsgc3ViSXRyIDwgdGhpcy5fdXNlckRhdGFTdWJzY3JpcHRpb25zLmxlbmd0aDsgc3ViSXRyKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5fdXNlckRhdGFTdWJzY3JpcHRpb25zW3N1Ykl0cl07XG5cbiAgICAgICAgICAgIC8vIERvbid0IGJvdGhlciBjb250aW51aW5nIHRvIGRvIGFueXRoaW5nIGlmIHRoZSBkZXZlbG9wZXIgZGlkbid0IHNwZWNpZnkgYSBjYWxsYmFjayBhc3NvY2lhdGVkXG4gICAgICAgICAgICAvLyB3aXRoIHRoZSBjdXJyZW50IFN1YnNjcmlwdGlvbiB0aGF0IHdlIGFyZSBwcm9jZXNzaW5nLlxuICAgICAgICAgICAgaWYgKCFjdXJyZW50U3Vic2NyaXB0aW9uLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjdXJyZW50U3Vic2NyaXB0aW9uQ2FsbGJhY2tEYXRhOiBBcnJheTxSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE+ID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGRhdGFJdHIgPSAwOyBkYXRhSXRyIDwgbmV3VXNlckRhdGFGcm9tU2VydmVyLmxlbmd0aDsgZGF0YUl0cisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnREYXRhRnJvbVNlcnZlciA9IG5ld1VzZXJEYXRhRnJvbVNlcnZlcltkYXRhSXRyXTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3Vic2NyaXB0aW9uLnByb3ZpZGVkVXNlcklEICYmIGN1cnJlbnREYXRhRnJvbVNlcnZlci5wcm92aWRlZFVzZXJJRCAhPT0gY3VycmVudFN1YnNjcmlwdGlvbi5wcm92aWRlZFVzZXJJRCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgbmV3Q2FsbGJhY2tEYXRhID0gbmV3IFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VycmVudERhdGFGcm9tU2VydmVyLnByb3ZpZGVkVXNlcklEKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBuZXdDYWxsYmFja0RhdGEucHJvdmlkZWRVc2VySUQgPSBjdXJyZW50RGF0YUZyb21TZXJ2ZXIucHJvdmlkZWRVc2VySUQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VycmVudERhdGFGcm9tU2VydmVyLmhhc2hlZFZpc2l0SUQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrRGF0YS5oYXNoZWRWaXNpdElEID0gY3VycmVudERhdGFGcm9tU2VydmVyLmhhc2hlZFZpc2l0SUQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHNob3VsZFB1c2hOZXdDYWxsYmFja0RhdGEgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbXBvbmVudEl0ciA9IDA7IGNvbXBvbmVudEl0ciA8IGN1cnJlbnRTdWJzY3JpcHRpb24uY29tcG9uZW50cy5sZW5ndGg7IGNvbXBvbmVudEl0cisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q29tcG9uZW50ID0gY3VycmVudFN1YnNjcmlwdGlvbi5jb21wb25lbnRzW2NvbXBvbmVudEl0cl07XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cy5Qb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudERhdGFGcm9tU2VydmVyLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrRGF0YS5wb3NpdGlvbiA9IGN1cnJlbnREYXRhRnJvbVNlcnZlci5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkUHVzaE5ld0NhbGxiYWNrRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cy5PcmllbnRhdGlvblF1YXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREYXRhRnJvbVNlcnZlci5vcmllbnRhdGlvblF1YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tEYXRhLm9yaWVudGF0aW9uUXVhdCA9IGN1cnJlbnREYXRhRnJvbVNlcnZlci5vcmllbnRhdGlvblF1YXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFB1c2hOZXdDYWxsYmFja0RhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXZhaWxhYmxlVXNlckRhdGFTdWJzY3JpcHRpb25Db21wb25lbnRzLk9yaWVudGF0aW9uRXVsZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGV1bGVyIHZlcnNpb24gb2Ygb3JpZW50YXRpb24gaWYgcXVhdCB2ZXJzaW9uIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RGF0YUZyb21TZXJ2ZXIub3JpZW50YXRpb25RdWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrRGF0YS5vcmllbnRhdGlvbkV1bGVyID0gZXVsZXJGcm9tUXVhdGVybmlvbihjdXJyZW50RGF0YUZyb21TZXJ2ZXIub3JpZW50YXRpb25RdWF0LCBvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24uZXVsZXJPcmRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFB1c2hOZXdDYWxsYmFja0RhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHMuVm9sdW1lRGVjaWJlbHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VycmVudERhdGFGcm9tU2VydmVyLnZvbHVtZURlY2liZWxzKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxsYmFja0RhdGEudm9sdW1lRGVjaWJlbHMgPSBjdXJyZW50RGF0YUZyb21TZXJ2ZXIudm9sdW1lRGVjaWJlbHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFB1c2hOZXdDYWxsYmFja0RhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHMuSXNTdGVyZW86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VycmVudERhdGFGcm9tU2VydmVyLmlzU3RlcmVvKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tEYXRhLmlzU3RlcmVvID0gY3VycmVudERhdGFGcm9tU2VydmVyLmlzU3RlcmVvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQdXNoTmV3Q2FsbGJhY2tEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUHVzaE5ld0NhbGxiYWNrRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3Vic2NyaXB0aW9uQ2FsbGJhY2tEYXRhLnB1c2gobmV3Q2FsbGJhY2tEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50U3Vic2NyaXB0aW9uLmNhbGxiYWNrICYmIGN1cnJlbnRTdWJzY3JpcHRpb25DYWxsYmFja0RhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdWJzY3JpcHRpb24uY2FsbGJhY2soY3VycmVudFN1YnNjcmlwdGlvbkNhbGxiYWNrRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGZ1bmN0aW9uIGNhbGxlZCBieSBvdXIgaW5zdGFudGlhdGlvbiBvZiBgSGlGaU1peGVyU2Vzc2lvbmAgdGhhdCBjYWxscyB0aGUgdXNlci1wcm92aWRlZCBgb25Vc2Vyc0Rpc2Nvbm5lY3RlZCgpYFxuICAgICAqIGZ1bmN0aW9uIGlmIG9uZSBleGlzdHMuXG4gICAgICogTGlicmFyeSB1c2VycyBjYW4gcHJvdmlkZSBhbiBgb25Vc2Vyc0Rpc2Nvbm5lY3RlZCgpYCBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGluc3RhbnRpYXRpbmcgdGhlIGBIaUZpQ29tbXVuaWNhdG9yYCBvYmplY3QsIG9yIGJ5IHNldHRpbmdcbiAgICAgKiBgSGlGaUNvbW11bmljYXRvci5vblVzZXJzRGlzY29ubmVjdGVkYCBhZnRlciBpbnN0YW50aWF0aW9uLlxuICAgICAqIEBwYXJhbSB1c2Vyc0Rpc2Nvbm5lY3RlZCAtIEFuIEFycmF5IG9mIHtAbGluayBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGF9IHJlZ2FyZGluZyB0aGUgdXNlcnMgd2hvIGRpc2Nvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9vblVzZXJzRGlzY29ubmVjdGVkKHVzZXJzRGlzY29ubmVjdGVkOiBBcnJheTxSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE+KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm9uVXNlcnNEaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Vc2Vyc0Rpc2Nvbm5lY3RlZCh1c2Vyc0Rpc2Nvbm5lY3RlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IFVzZXIgRGF0YSBTdWJzY3JpcHRpb24gdG8gdGhlIGxpc3Qgb2YgY2xpZW50c2lkZSBTdWJzY3JpcHRpb25zLiBVc2VyIERhdGEgU3Vic2NyaXB0aW9ucyBhcmUgdXNlZCB0byBvYnRhaW5cbiAgICAgKiBVc2VyIERhdGEgYWJvdXQgb3RoZXIgVXNlcnMuIEZvciBleGFtcGxlLCBpZiB5b3Ugc2V0IHVwIGEgVXNlciBEYXRhIFN1YnNjcmlwdGlvbiBmb3IgeW91ciBvd24gVXNlciBEYXRhLCB5b3UgY2FuIHVzZSB0aGF0IHN1YnNjcmlwdGlvbiBcbiAgICAgKiB0byBlbnN1cmUgdGhhdCB0aGUgZGF0YSBvbiB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgU2VydmVyIGlzIHRoZSBzYW1lIGFzIHRoZSBkYXRhIHlvdSBhcmUgc2VuZGluZ1xuICAgICAqIHRvIGl0IGZyb20gdGhlIGNsaWVudC4gXG4gICAgICogXG4gICAgICogVG8gY2hlY2sgaWYgYSB1c2VyIGhhcyBkaXNjb25uZWN0ZWQsIHVzZSB7QGxpbmsgSGlGaUNvbW11bmljYXRvci5vblVzZXJzRGlzY29ubmVjdGVkfS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gbmV3U3Vic2NyaXB0aW9uIC0gVGhlIG5ldyBVc2VyIERhdGEgU3Vic2NyaXB0aW9uIGFzc29jaWF0ZWQgd2l0aCBhIHVzZXIuIFxuICAgICAqL1xuICAgIGFkZFVzZXJEYXRhU3Vic2NyaXB0aW9uKG5ld1N1YnNjcmlwdGlvbjogVXNlckRhdGFTdWJzY3JpcHRpb24pOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLl9taXhlclNlc3Npb24pIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYE5vIFxcYF9taXhlclNlc3Npb25cXGAhIERhdGEgc3Vic2NyaXB0aW9uIG5vdCBhZGRlZC5gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9taXhlclNlc3Npb24udXNlckRhdGFTdHJlYW1pbmdTY29wZSA9PT0gSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzLk5vbmUpIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYER1cmluZyBcXGBIaUZpQ29tbXVuaWNhdG9yXFxgIGNvbnN0cnVjdGlvbiwgdGhlIHNlcnZlciB3YXMgc2V0IHVwIHRvICoqbm90Kiogc2VuZCB1c2VyIGRhdGEhIERhdGEgc3Vic2NyaXB0aW9uIG5vdCBhZGRlZC5gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIEhpRmlMb2dnZXIubG9nKGBBZGRpbmcgbmV3IFVzZXIgRGF0YSBTdWJzY3JpcHRpb246XFxuJHtKU09OLnN0cmluZ2lmeShuZXdTdWJzY3JpcHRpb24pfWApO1xuICAgICAgICB0aGlzLl91c2VyRGF0YVN1YnNjcmlwdGlvbnMucHVzaChuZXdTdWJzY3JpcHRpb24pO1xuICAgIH1cbn1cbiIsIi8qKlxuICogQ29kZSBpbiB0aGlzIG1vZHVsZSBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIFtbSGlGaUNvbW11bmljYXRvcl1dIG9iamVjdCB0byBtYW5hZ2UgdGhlIGNvbm5lY3Rpb24gYmV0d2VlbiBjbGllbnQgYW5kIHNlcnZlci5cbiAqIERldmVsb3BlcnMgZG8gbm90IG5lZWQgdG8gYW5kIHNob3VsZCBub3QgY29uc2lkZXIgdGhpcyBtb2R1bGUgd2hlbiB3cml0aW5nIHRoZWlyIGFwcGxpY2F0aW9ucy5cbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5cbmltcG9ydCB7IEhpRmlBdWRpb0FQSURhdGEsIE9yaWVudGF0aW9uUXVhdDNELCBQb2ludDNELCBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEsIE90aGVyVXNlckdhaW5NYXAgfSBmcm9tIFwiLi9IaUZpQXVkaW9BUElEYXRhXCI7XG5pbXBvcnQgeyBIaUZpTG9nZ2VyIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9IaUZpTG9nZ2VyXCI7XG5pbXBvcnQgeyBIaUZpQ29ubmVjdGlvblN0YXRlcywgSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzIH0gZnJvbSBcIi4vSGlGaUNvbW11bmljYXRvclwiO1xuXG5pbXBvcnQgeyBSYXZpVXRpbHMgfSBmcm9tIFwiLi4vbGlicmF2aS9SYXZpVXRpbHNcIjtcbmltcG9ydCB7IFJhdmlTZXNzaW9uLCBSYXZpU2Vzc2lvblN0YXRlcywgV2ViUlRDU2Vzc2lvblBhcmFtcywgQ3VzdG9tU1RVTmFuZFRVUk5Db25maWcgfSBmcm9tIFwiLi4vbGlicmF2aS9SYXZpU2Vzc2lvblwiO1xuaW1wb3J0IHsgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24sIFJhdmlTaWduYWxpbmdTdGF0ZXMgfSBmcm9tIFwiLi4vbGlicmF2aS9SYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiO1xuaW1wb3J0IHsgSGlGaUF4aXNVdGlsaXRpZXMsIG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbiB9IGZyb20gXCIuL0hpRmlBeGlzQ29uZmlndXJhdGlvblwiO1xuaW1wb3J0IHsgRGlhZ25vc3RpY3MgfSBmcm9tIFwiLi4vZGlhZ25vc3RpY3MvZGlhZ25vc3RpY3NcIjtcbmNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJyk7XG5cbmNvbnN0IElOSVRfVElNRU9VVF9NUyA9IDUwMDA7XG5jb25zdCBQRVJTT05BTF9WT0xVTUVfQURKVVNUX1RJTUVPVVRfTVMgPSA1MDAwO1xuXG5pbnRlcmZhY2UgQXVkaW9uZXRTZXRPdGhlclVzZXJHYWluc0ZvclRoaXNDb25uZWN0aW9uUmVzcG9uc2Uge1xuICAgIHN1Y2Nlc3M6IGJvb2xlYW4sXG4gICAgcmVhc29uPzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlIHtcbiAgICBzdWNjZXNzOiBib29sZWFuLFxuICAgIGVycm9yPzogc3RyaW5nLFxuICAgIGF1ZGlvbmV0U2V0T3RoZXJVc2VyR2FpbnNGb3JUaGlzQ29ubmVjdGlvblJlc3BvbnNlPzogQXVkaW9uZXRTZXRPdGhlclVzZXJHYWluc0ZvclRoaXNDb25uZWN0aW9uUmVzcG9uc2Vcbn1cblxuZXhwb3J0IHR5cGUgU2V0T3RoZXJVc2VyR2FpbkZvclRoaXNDb25uZWN0aW9uUmVzcG9uc2UgPSBTZXRPdGhlclVzZXJHYWluc0ZvclRoaXNDb25uZWN0aW9uUmVzcG9uc2U7XG5cbi8qKlxuICogVGhpcyBlbnVtIHN0cmluZyByZXByZXNlbnRzIHRoZSByZWFzb24gdGhlIGNsaWVudCdzIG11dGUgc3RhdGUgaGFzIHVwZGF0ZWQuXG4gKiBTZWUge0BsaW5rIE9uTXV0ZUNoYW5nZWRDYWxsYmFja30gZm9yIGhvdyB0aGlzIGlzIHVzZWQuXG4gKlxuICoge0BsaW5rIE11dGVSZWFzb24uQ0xJRU5UfSBpcyB1c2VkIHRvIGluZGljYXRlIHRoYXQgdGhlIGNsaWVudCBoYXMgYXR0ZW1wdGVkIHRvIGNoYW5nZSB0aGUgbXV0ZSBzdGF0ZSB1c2luZyB7QGxpbmsgSGlGaUNvbW11bmljYXRvci5zZXRJbnB1dEF1ZGlvTXV0ZWR9XG4gKlxuICoge0BsaW5rIE11dGVSZWFzb24uQURNSU59IGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCB0aGUgc2VydmVyIGhhcyBjaGFuZ2VkIHRoZSBjbGllbnQncyBtdXRlIHN0YXRlLlxuICpcbiAqIHtAbGluayBNdXRlUmVhc29uLklOVEVSTkFMfSBpcyB1c2VkIHRvIGluZGljYXRlIHRoYXQgdGhlIGNsaWVudCdzIG11dGUgc3RhdGUgaGFzIGNoYW5nZWQgZHVlIHRvIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiB0aGUgc3BhdGlhbCBhdWRpbyBBUEksIGZvciBleGFtcGxlIHRvIGtlZXAgdGhlIHN0YXRlIG9mIHRoZSBjbGllbnQgY29uc2lzdGVudCB3aXRoIHRoZSBzZXJ2ZXIuXG4qL1xuZXhwb3J0IGVudW0gTXV0ZVJlYXNvbiB7XG4gICAgQ0xJRU5UID0gXCJjbGllbnRcIixcbiAgICBBRE1JTiA9IFwiYWRtaW5cIixcbiAgICBJTlRFUk5BTCA9IFwiaW50ZXJuYWxcIlxufVxuXG4vKipcbiAqIFRoaXMgZXZlbnQgb2JqZWN0IGRlc2NyaWJlcyBob3cgYW5kIHdoeSB0aGUgbXV0ZSBzdGF0ZSBvZiB0aGUgY2xpZW50IGhhcyBjaGFuZ2VkLiBJdCBpcyBwYXNzZWQgaW4gYXMgYSBwYXJhbWV0ZXIgdG8ge0BsaW5rIE9uTXV0ZUNoYW5nZWRDYWxsYmFja30uXG4qL1xuZXhwb3J0IGNsYXNzIE11dGVDaGFuZ2VkRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0aGUgbXV0ZSBzdGF0ZSB3YXMgc2V0IHN1Y2Nlc3NmdWxseS5cbiAgICAgKiBUaGlzIG1heSBiZSBgZmFsc2VgIGlmIHRoZSBjbGllbnQgaXMgdHJ5aW5nIHRvIHVubXV0ZSB0aGVtc2VsdmVzIHdoZW4gbXV0ZWQgYnkgYW4gYWRtaW4sIG9yIGlmIHRoZXJlIHdhcyBhIGZhaWx1cmUgc2V0dGluZyB0aGUgbXV0ZSBzdGF0ZSBvZiB0aGUgaW5wdXQgZGV2aWNlLlxuICAgICovXG4gICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG11dGVkIHZhbHVlIHRoYXQgd291bGQgaGF2ZSBiZWVuIHNldCBpZiB0aGUgbXV0ZSBzdGF0ZSB3YXMgc2V0IHN1Y2Nlc2Z1bGx5LlxuICAgICAqIGB0cnVlYCBtZWFucyBtdXRlZCwgYGZhbHNlYCBtZWFucyB1bm11dGVkLlxuICAgICovXG4gICAgdGFyZ2V0SW5wdXRBdWRpb011dGVkVmFsdWU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBjdXJyZW50IG11dGVkIHZhbHVlIGFmdGVyIGF0dGVtcHRpbmcgdG8gc2V0IG11dGUgc3RhdGUuXG4gICAgICogYHRydWVgIG1lYW5zIG11dGVkLCBgZmFsc2VgIG1lYW5zIHVubXV0ZWQuXG4gICAgKi9cbiAgICBjdXJyZW50SW5wdXRBdWRpb011dGVkVmFsdWU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNsaWVudCBpcyBjdXJyZW50bHkgcHJldmVudGVkIGZyb20gdW5tdXRpbmcgdXNpbmcge0BsaW5rIEhpRmlDb21tdW5pY2F0b3Iuc2V0SW5wdXRBdWRpb011dGVkfS5cbiAgICAqL1xuICAgIGFkbWluUHJldmVudHNJbnB1dEF1ZGlvVW5tdXRpbmc6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSByZWFzb24gdGhlIG11dGUgc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgKi9cbiAgICBtdXRlUmVhc29uOiBNdXRlUmVhc29uO1xuXG4gICAgY29uc3RydWN0b3IoeyBzdWNjZXNzLCB0YXJnZXRJbnB1dEF1ZGlvTXV0ZWRWYWx1ZSwgY3VycmVudElucHV0QXVkaW9NdXRlZFZhbHVlLCBhZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nLCBtdXRlUmVhc29uIH06IHsgc3VjY2VzczogYm9vbGVhbiwgdGFyZ2V0SW5wdXRBdWRpb011dGVkVmFsdWU6IGJvb2xlYW4sIGN1cnJlbnRJbnB1dEF1ZGlvTXV0ZWRWYWx1ZTogYm9vbGVhbiwgYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZzogYm9vbGVhbiwgbXV0ZVJlYXNvbjogTXV0ZVJlYXNvbiB9KSB7XG4gICAgICAgIHRoaXMuc3VjY2VzcyA9IHN1Y2Nlc3M7XG4gICAgICAgIHRoaXMudGFyZ2V0SW5wdXRBdWRpb011dGVkVmFsdWUgPSB0YXJnZXRJbnB1dEF1ZGlvTXV0ZWRWYWx1ZTtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5wdXRBdWRpb011dGVkVmFsdWUgPSBjdXJyZW50SW5wdXRBdWRpb011dGVkVmFsdWU7XG4gICAgICAgIHRoaXMuYWRtaW5QcmV2ZW50c0lucHV0QXVkaW9Vbm11dGluZyA9IGFkbWluUHJldmVudHNJbnB1dEF1ZGlvVW5tdXRpbmc7XG4gICAgICAgIHRoaXMubXV0ZVJlYXNvbiA9IG11dGVSZWFzb247XG4gICAgfVxufVxuXG4vKipcbiAqIEFuIGBvbk11dGVDaGFuZ2VkYCBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIHRoaXMgc2lnbmF0dXJlIGNhbiBiZSBwcm92aWRlZCB0byB7QGxpbmsgSGlGaUNvbW11bmljYXRvci5jb25zdHJ1Y3Rvcn0uIFRoZSBmdW5jdGlvbiB5b3UgcHJvdmlkZSB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgbXV0ZSBzdGF0ZSBvZiB0aGUgY2xpZW50IG1heSBoYXZlIHVwZGF0ZWQuXG4gKlxuICogT25lIHNpdHVhdGlvbiB3aGVyZSB0aGlzIGlzIHVzZWZ1bCBpcyB3aGVuIHRoZSBjbGllbnQncyBtdXRlIHN0YXRlIGhhcyBiZWVuIGNoYW5nZWQgYnkgYW4gYWRtaW4sIGkuZS4gd2hlbiB7QGxpbmsgTXV0ZUNoYW5nZWRFdmVudC5tdXRlUmVhc29ufSBpcyB7QGxpbmsgTXV0ZVJlYXNvbi5BRE1JTn0uIElmIHtAbGluayBNdXRlQ2hhbmdlZEV2ZW50LmFkbWluUHJldmVudHNJbnB1dEF1ZGlvVW5tdXRpbmd9IGlzIGB0cnVlYCwgdGhlbiB0aGUgY2xpZW50IGlzIG11dGVkLCBhbmQgaXMgcHJldmVudGVkIGZyb20gdW5tdXRpbmcgd2hlbiB1c2luZyB7QGxpbmsgSGlGaUNvbW11bmljYXRvci5zZXRJbnB1dEF1ZGlvTXV0ZWR9LiBJZiB7QGxpbmsgTXV0ZUNoYW5nZWRFdmVudC5hZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nfSBpcyBgZmFsc2VgLCB0aGVuIHRoZSBjbGllbnQgaXMgbm8gbG9uZ2VyIHByZXZlbnRlZCBmcm9tIHVubXV0aW5nLCBidXQgaXMgbm90IGF1dG9tYXRpY2FsbHkgdW5tdXRlZC4gVGhlIGNsaWVudCBpcyBhbGxvd2VkIHRvIG11dGUgdGhlbXNlbGYgYXQgYW55IHRpbWUgcmVnYXJkbGVzcyBvZiB0aGUgY3VycmVudCBtdXRlIHN0YXRlLlxuICpcbiAqIElmIHtAbGluayBNdXRlQ2hhbmdlZEV2ZW50Lm11dGVSZWFzb259IGlzIGVxdWFsIHRvIHtAbGluayBNdXRlUmVhc29uLkNMSUVOVH0sIHRoZSBjbGllbnQgYXR0ZW1wdGVkIHRvIHNldCB0aGUgbXV0ZSBzdGF0ZSB0aHJvdWdoIHtAbGluayBIaUZpQ29tbXVuaWNhdG9yLnNldElucHV0QXVkaW9NdXRlZH0uXG4gKlxuICogSWYge0BsaW5rIE11dGVDaGFuZ2VkRXZlbnQubXV0ZVJlYXNvbn0gaXMgZXF1YWwgdG8ge0BsaW5rIE11dGVSZWFzb24uSU5URVJOQUx9LCB0aGUgY2xpZW50J3MgbXV0ZSBzdGF0ZSBoYXMgY2hhbmdlZCBkdWUgdG8gYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIHRoZSBzcGF0aWFsIGF1ZGlvIEFQSSwgZm9yIGV4YW1wbGUgdG8ga2VlcCB0aGUgc3RhdGUgb2YgdGhlIGNsaWVudCBjb25zaXN0ZW50IHdpdGggdGhlIHNlcnZlci5cbiAqXG4gKiBUaGlzIGNhbGxiYWNrIGNhbiBhbHNvIGJlIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZSBjbGllbnQgaXMgbXV0ZWQgYW5kIGRpc3BsYXkgdGhpcyBpbiB0aGUgY2xpZW50IFVJLCBhbmQgY2FuIGFsc28gYmUgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLiBUaGUgbXV0ZSBzdGF0ZSBvZiB0aGUgY2xpZW50IG1heSBub3QgaGF2ZSBjaGFuZ2VkIGFmdGVyIHRoaXMgY2FsbGJhY2suXG4qL1xuZXhwb3J0IHR5cGUgT25NdXRlQ2hhbmdlZENhbGxiYWNrID0gKG11dGVDaGFuZ2VkRXZlbnQ6IE11dGVDaGFuZ2VkRXZlbnQpID0+IHZvaWQ7XG5cbi8qKlxuICogSW5zdGFudGlhdGlvbnMgb2YgdGhpcyBjbGFzcyBjb250YWluIGRhdGEgYWJvdXQgYSBjb25uZWN0aW9uIGJldHdlZW4gYSBjbGllbnQgYW5kIGEgbWl4ZXIuXG4gKiBDbGllbnQgbGlicmFyeSB1c2VycyBzaG91bGRuJ3QgaGF2ZSB0byBjYXJlIGF0IGFsbCBhYm91dCB0aGUgdmFyaWFibGVzIGFuZCBtZXRob2RzIGNvbnRhaW5lZCBpbiB0aGlzIGNsYXNzLlxuICovXG5leHBvcnQgY2xhc3MgSGlGaU1peGVyU2Vzc2lvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIFJBVkkgU2lnbmFsaW5nIENvbm5lY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgTWl4ZXIgU2Vzc2lvbi5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjogUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb247XG4gICAgLyoqXG4gICAgICogVGhlIFJBVkkgU2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBNaXhlciBTZXNzaW9uLlxuICAgICAqL1xuICAgIHByaXZhdGUgX3JhdmlTZXNzaW9uOiBSYXZpU2Vzc2lvbjtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgY3VycmVudCBIaUZpIENvbm5lY3Rpb24gU3RhdGUsIHdoaWNoIGlzIGFuIGFic3RyYWN0aW9uIHNlcGFyYXRlIGZyb20gdGhlIFJBVkkgU2Vzc2lvbiBTdGF0ZSBhbmQgUkFWSSBTaWduYWxpbmcgU3RhdGUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGU6IEhpRmlDb25uZWN0aW9uU3RhdGVzO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB3aGVuIG11dGluZyBhbmQgdW5tdXRpbmcgdG8gc2F2ZSB0aGUgc3RhdGUgb2YgdGhlIHVzZXIncyBpbnB1dCBkZXZpY2UncyBgTWVkaWFUcmFja0NvbnN0cmFpbnRzYC5cbiAgICAgKiBXaGVuIGEgdXNlciBtdXRlcywgd2UgZXhwbGljaXRseSBjYWxsIGBzdG9wKClgIG9uIGFsbCBhdWRpbyB0cmFja3MgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyJ3MgaW5wdXQgZGV2aWNlLlxuICAgICAqIFdoZW4gYSB1c2VyIHVubXV0ZXMsIHdlIG11c3QgY2FsbCBgZ2V0VXNlck1lZGlhKClgIHRvIHJlLW9idGFpbiB0aG9zZSBhdWRpbyB0cmFja3MuIFdlIHdhbnQgdG8gY2FsbCBgZ2V0VXNlck1lZGlhKClgXG4gICAgICogd2l0aCB0aGUgc2FtZSBjb25zdHJhaW50cyB1c2VkIGJ5IHRoZSBhcHBsaWNhdGlvbiB3aGVuIF9pdF8gZmlyc3QgY2FsbHMgYGdldFVzZXJNZWRpYSgpYC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9jYWNoZWRNZWRpYVRyYWNrQ29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50cztcblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgcmVjZWl2ZSBwZWVyIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBpdCdzIGluIGEgZm9ybWF0IGxpa2UgdGhpczpcbiAgICAgKiB7XG4gICAgICogICAgIDMxODoge2M6IFwiIzVkZjFmNVwiLCBkOiBcIkhvd2FyZFwiLCBlOiBcIjg3M2M0ZDQzLWNjZDktNGNlNC05YWM3LWQ1ZmFkZTRkZWY5MjlhXCIsIGk6IFwie2YwY2UyMmJiLThiNjctNDA0NC1hOGM1LTY1YWVmYmNlNDA2MH1cIiwgbzogMCwg4oCmfVxuICAgICAqICAgICAzNDE6IHtlOiBcIjljNWFmNDRiLTdlM2YtOGY2NS01NDIxLTM3NGI0M2JlYmM0YVwiLCBpOiBcIntiZTM4YTI1Ni04NTBhLTRjOGQtYmRkZC1jZmU4MGFhZGRmZTl9XCIsIG86IDAsIHA6IHRydWUsIHY6IC0xMjAsIOKApn1cbiAgICAgKiB9XG4gICAgICogVGhlIHBlZXIgZGF0YSBkb2VzIG5vdCBhbHdheXMgY29udGFpbiBhbGwgcG9zc2libGUga2V5L3ZhbHVlIHBhaXJzIGFzc29jaWF0ZWQgd2l0aCBlYWNoIGtleSBpbiB0aGlzIE9iamVjdC4gSW4gZmFjdCwgbW9zdCBvZiB0aGUgdGltZSwgaXQgY29udGFpbnNcbiAgICAgKiBvbmx5IGEgZnJhY3Rpb24gb2YgdGhlIGRhdGEuIEZvciBleGFtcGxlLCB3ZSBtaWdodCByZWNlaXZlIGB7IDM0MToge3Y6IC00MH0gfWAgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIFdoZW4gdGhlIEhpRmkgQXVkaW8gTGlicmFyeSB1c2VyIHNldHMgdXAgYSBVc2VyIERhdGEgU3Vic2NyaXB0aW9uLCB0aGV5IGNhbiBvcHRpb25hbGx5IGFzc29jaWF0ZSB0aGUgU3Vic2NyaXB0aW9uIHdpdGggYSBcIlByb3ZpZGVkIFVzZXIgSURcIi5cbiAgICAgKiBTaW5jZSB0aGUgc2VydmVyIGRvZXNuJ3QgYWx3YXlzIHNlbmQgdGhlIFwiUHJvdmlkZWQgVXNlciBJRFwiIGluIHRoZXNlIHBlZXIgdXBkYXRlcywgd2UgaGF2ZSB0byBrZWVwIHRyYWNrIG9mIHRoZSAocHJlc3VtYWJseSBzdGFibGUpIGtleSBpbiBganNvbkRhdGEucGVlcnNgXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoYXQgXCJQcm92aWRlZCBVc2VyIElEXCIgaW4gb3JkZXIgdG8gZm9yd2FyZCB0aGF0IFwiUHJvdmlkZWQgVXNlciBJRFwiIHRvIHRoZSBTdWJzY3JpcHRpb24gaGFuZGxlciBhbmQgdGh1cyB0byB0aGUgTGlicmFyeSB1c2VyLlxuICAgICAqIFxuICAgICAqIEFuZCBzaW5jZSB3ZSBhcmUgY2FjaGluZyB0aGF0IG9uZSB2YWx1ZSwgd2UgYXJlIGFsc28gY2FjaGluZyB0aGUgZnVsbCBzdGF0ZSBmb3IgYWxsIGtub3duIHBlZXJzLlxuICAgICAqIFRoaXMgYWxsb3dzIHVzIHRvIG9wdGltaXplIHRoZSByZWNlaXZlZCBzdHJlYW0gb2YgY2hhbmdlZCBkYXRhIGZvciBhIGdpdmVuIHBlZXIgZnJvbSB0aGUgc2VydmVyIHRvIGp1c3QgdGhlIG5lY2Vzc2FyeSBiaXRzXG4gICAgICogYW5kIHJlY29uc3RydWN0IHRoZSBjb21wbGV0ZSBpbmZvcm1hdGlvbiB3aXRoIHRoZSBrbm93bGVkZ2Ugb2YgdGhlIGNhY2hlZCBzdGF0ZSBvZiB0aGF0YSBwZWVyLlxuICAgICAqIE9uZSBjYXZlYXQsIHRoZSBwb3NpdGlvbiBhbmQgb3JpZW5hdGlvblF1YXQgZmllbGRzIGNhY2hlZCBmb3IgYSBwZWVyIGFyZSBleHByZXNzZWQgaW4gdGhlICdNaXhlclNwYWNlJywgbm90IHRyYW5zZm9ybWVkIHlldCBpbiB0aGUgJ0NsaWVudFVzZXJTcGFjZScuXG4gICAgICogXG4gICAgICogVGh1cywgdGhlIExpYnJhcnkgdXNlciBzaG91bGQgbmV2ZXIgaGF2ZSB0byBjYXJlIGFib3V0IHRoZSBgX21peGVyUGVlcktleVRvU3RhdGVDYWNoZURpY3RgLlxuICAgICAqL1xuICAgIHByaXZhdGUgX21peGVyUGVlcktleVRvU3RhdGVDYWNoZURpY3Q6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFdlIHdpbGwgdHJhY2sgd2hldGhlciBvciBub3QgdGhlIGlucHV0IHN0cmVhbSBpcyBzdGVyZW8sIHNvIHRoYXRcbiAgICAgKiB3ZSBjYW4gYWR2aXNlIHRoZSBzZXJ2ZXIgdG8gbWl4IGl0IGFwcHJvcHJpYXRlbHlcbiAgICAgKi9cbiAgICBwcml2YXRlIF9pbnB1dEF1ZGlvTWVkaWFTdHJlYW1Jc1N0ZXJlbzogYm9vbGVhbjtcblxuICAgIHByaXZhdGUgX2FkbWluUHJldmVudHNJbnB1dEF1ZGlvVW5tdXRpbmc6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBfbGFzdFN1Y2Nlc3NmdWxJbnB1dEF1ZGlvTXV0ZWRWYWx1ZTogYm9vbGVhbjtcblxuICAgIHByaXZhdGUgb25NdXRlQ2hhbmdlZDogT25NdXRlQ2hhbmdlZENhbGxiYWNrO1xuXG4gICAgLyoqXG4gICAgICogT25seSB2YWxpZCBmb3IgdXNlcnMgY292ZXJlZCBieSBhIHVzZXIgZGF0YSBzdWJzY3JpcHRpb24uIFJlbWFpbnMgY29uc3RhbnQgYXQgZGlzY29ubmVjdCB1bnRpbCB0aGUgbmV4dCBjb25uZWN0LlxuICAgICAqL1xuICAgIHB1YmxpYyBjb25jdXJyZW5jeTpudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFdlYlJUQyBTdGF0cyBPYnNlcnZlciBjYWxsYmFja1xuICAgICAqL1xuICAgIHByaXZhdGUgX3N0YXRzT2JzZXJ2ZXJDYWxsYmFjazogRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBTZWUge0BsaW5rIEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3Blc30uXG4gICAgICovXG4gICAgdXNlckRhdGFTdHJlYW1pbmdTY29wZTogSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFdlYlJUQyBBZGRyZXNzIHRvIHdoaWNoIHdlIHdhbnQgdG8gY29ubmVjdCBhcyBhIHBhcnQgb2YgdGhpcyBTZXNzaW9uLiBUaGlzIFdlYlJUQyBBZGRyZXNzIGlzIG9idGFpbmVkIGZyb20gdGhlIE1peGVyIERpc2NvdmVyeSBBZGRyZXNzIGR1cmluZ1xuICAgICAqIHRoZSBgSGlGaUNvbW11bmljYXRvci5jb25uZWN0VG9IaUZpQXVkaW9BUElTZXJ2ZXIoKWAgY2FsbC5cbiAgICAgKi9cbiAgICB3ZWJSVENBZGRyZXNzOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBQZWVyIGRhdGEgaXMgcmV0dXJuZWQgZnJvbSB0aGUgU2VydmVyLlxuICAgICAqL1xuICAgIG9uVXNlckRhdGFVcGRhdGVkOiBGdW5jdGlvbjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgUGVlciBkaXNjb25uZWN0cyBmcm9tIHRoZSBTZXJ2ZXIuXG4gICAgICovXG4gICAgb25Vc2Vyc0Rpc2Nvbm5lY3RlZDogRnVuY3Rpb247XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgXCJjb25uZWN0aW9uIHN0YXRlXCIgY2hhbmdlcy5cbiAgICAgKiBSaWdodCBub3csIHRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHRoZSBSQVZJIHNlc3Npb24gc3RhdGUgY2hhbmdlcyB0b1xuICAgICAqIGBSYXZpU2Vzc2lvblN0YXRlcy5DT05ORUNURURgLCBgUmF2aVNlc3Npb25TdGF0ZXMuRElTQ09OTkVDVEVEYCwgYW5kIGBSYXZpU2Vzc2lvblN0YXRlcy5GQUlMRURgLlxuICAgICAqL1xuICAgIG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZDogRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbWl4ZXIgdG8gd2hpY2ggd2UgYXJlIGN1cnJlbnRseSBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgbWl4ZXJJbmZvOiBhbnk7XG5cbiAgICBwcml2YXRlIF9yYXZpRGlhZ25vc3RpY3M6IERpYWdub3N0aWNzO1xuICAgIHByaXZhdGUgX2hpZmlEaWFnbm9zdGljczogRGlhZ25vc3RpY3M7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gX19uYW1lZFBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gdXNlckRhdGFTdHJlYW1pbmdTY29wZSAtIFNlZSB7QGxpbmsgSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzfS5cbiAgICAgKiBcbiAgICAgKiBJZiBzZXQgdG8gYGZhbHNlYCwgVXNlciBEYXRhIFN1YnNjcmlwdGlvbnMgd2lsbCBzZXJ2ZSBubyBwdXJwb3NlLlxuICAgICAqIEBwYXJhbSBvblVzZXJEYXRhVXBkYXRlZCAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHNlcnZlciBzZW5kcyB1c2VyIGRhdGEgdG8gdGhlIGNsaWVudC4gSXJyZWxldmFudCBpZiBgdXNlckRhdGFTdHJlYW1pbmdTY29wZWAgaXMgYEhpRmlVc2VyRGF0YVN0cmVhbWluZ1Njb3Blcy5Ob25lYC5cbiAgICAgKiBAcGFyYW0gb25Vc2Vyc0Rpc2Nvbm5lY3RlZCAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHNlcnZlciBzZW5kcyB1c2VyIGRhdGEgYWJvdXQgcGVlcnMgd2hvIGp1c3QgZGlzY29ubmVjdGVkIHRvIHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyB1c2VyRGF0YVN0cmVhbWluZ1Njb3BlID0gSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzLkFsbCwgb25Vc2VyRGF0YVVwZGF0ZWQsIG9uVXNlcnNEaXNjb25uZWN0ZWQsIG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCwgb25NdXRlQ2hhbmdlZCB9OiB7IHVzZXJEYXRhU3RyZWFtaW5nU2NvcGU/OiBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXMsIG9uVXNlckRhdGFVcGRhdGVkPzogRnVuY3Rpb24sIG9uVXNlcnNEaXNjb25uZWN0ZWQ/OiBGdW5jdGlvbiwgb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkPzogRnVuY3Rpb24sIG9uTXV0ZUNoYW5nZWQ/OiBPbk11dGVDaGFuZ2VkQ2FsbGJhY2sgfSkge1xuICAgICAgICB0aGlzLndlYlJUQ0FkZHJlc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudXNlckRhdGFTdHJlYW1pbmdTY29wZSA9IHVzZXJEYXRhU3RyZWFtaW5nU2NvcGU7XG4gICAgICAgIHRoaXMub25Vc2VyRGF0YVVwZGF0ZWQgPSBvblVzZXJEYXRhVXBkYXRlZDtcbiAgICAgICAgdGhpcy5vblVzZXJzRGlzY29ubmVjdGVkID0gb25Vc2Vyc0Rpc2Nvbm5lY3RlZDtcbiAgICAgICAgdGhpcy5fbWl4ZXJQZWVyS2V5VG9TdGF0ZUNhY2hlRGljdCA9IHt9O1xuICAgICAgICB0aGlzLl9sYXN0U3VjY2Vzc2Z1bElucHV0QXVkaW9NdXRlZFZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25NdXRlQ2hhbmdlZCA9IG9uTXV0ZUNoYW5nZWQ7XG5cbiAgICAgICAgUmF2aVV0aWxzLnNldERlYnVnKGZhbHNlKTtcblxuICAgICAgICB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiA9IG5ldyBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbigpO1xuICAgICAgICB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbi5hZGRTdGF0ZUNoYW5nZUhhbmRsZXIoKGV2ZW50OiBhbnkpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25SQVZJU2lnbmFsaW5nU3RhdGVDaGFuZ2VkKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fcmF2aVNlc3Npb24gPSBuZXcgUmF2aVNlc3Npb24oKTtcbiAgICAgICAgdGhpcy5fcmF2aVNlc3Npb24uYWRkU3RhdGVDaGFuZ2VIYW5kbGVyKChldmVudDogYW55KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uUkFWSVNlc3Npb25TdGF0ZUNoYW5nZWQoZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCA9IG9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZDtcblxuICAgICAgICB0aGlzLl9yZXNldE1peGVySW5mbygpO1xuICAgICAgICB0aGlzLl9yYXZpRGlhZ25vc3RpY3MgPSBuZXcgRGlhZ25vc3RpY3Moe2xhYmVsOiAncmF2aScsIHNlc3Npb246IHRoaXMsIHJhdmk6IHRoaXMuX3JhdmlTZXNzaW9ufSk7XG4gICAgICAgIHRoaXMuX2hpZmlEaWFnbm9zdGljcyA9IG5ldyBEaWFnbm9zdGljcyh7bGFiZWw6ICdhcHAnLCBzZXNzaW9uOiB0aGlzLCByYXZpOiB0aGlzLl9yYXZpU2Vzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmlyc3QgaXMgdGhlIHN0YW5kYXJkIHdheSB0byB0ZWxsLCBidXQgYnJvd3NlciBoYXZlIGJ1Z3MgaW4gd2hpY2ggdGhleSBkb24ndCBmaXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzZWNvbmQgaXMgZW5vdWdoIGZvciBhbGwga25vd24gYnJvd3NlciBidWdzLCBleGNlcHQgZm9yIFNhZmFyaSBkZXNrdG9wIGNsb3NpbmcgYSB2aXNpYmxlIHRhYi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlT246IFsndmlzaWJpbGl0eWNoYW5nZScsICdwYWdlaGlkZScsICdiZWZvcmV1bmxvYWQnXX0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmRzIHRoZSBjb21tYW5kIGBhdWRpb25ldC5pbml0YCB0byB0aGUgbWl4ZXIuXG4gICAgICogXG4gICAgICogQHJldHVybnMgSWYgdGhpcyBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bCwgdGhlIFByb21pc2Ugd2lsbCByZXNvbHZlIHdpdGggYHsgc3VjY2VzczogdHJ1ZSwgYXVkaW9uZXRJbml0UmVzcG9uc2U6IDxUaGUgcmVzcG9uc2UgdG8gYGF1ZGlvbmV0LmluaXRgIGZyb20gdGhlIHNlcnZlciBpbiBPYmplY3QgZm9ybWF0Pn1gLlxuICAgICAqIElmIHVuc3VjY2Vzc2Z1bCwgdGhlIFByb21pc2Ugd2lsbCByZWplY3Qgd2l0aCBgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IDxhbiBlcnJvciBtZXNzYWdlPiB9YC5cbiAgICAgKi9cbiAgICBhc3luYyBwcm9taXNlVG9SdW5BdWRpb0luaXQoKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCBpbml0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBwcmltYXJ5OiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaXhlciB3aWxsIGhhc2ggdGhpcyByYW5kb21seS1nZW5lcmF0ZWQgVVVJRCwgdGhlbiBkaXNzZW1pbmF0ZSBpdCB0byBhbGwgY2xpZW50cyB2aWEgYHBlZXJEYXRhLmVgLlxuICAgICAgICAgICAgICAgIHZpc2l0X2lkOiB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRVVUlEKCksXG4gICAgICAgICAgICAgICAgc2Vzc2lvbjogdGhpcy5fcmF2aVNlc3Npb24uZ2V0VVVJRCgpLCAvLyBTdGlsbCByZXF1aXJlZCBmb3Igb2xkIG1peGVycy4gV2lsbCBldmVudHVhbGx5IGdvIGF3YXkuXG4gICAgICAgICAgICAgICAgc3RyZWFtaW5nX3Njb3BlOiB0aGlzLnVzZXJEYXRhU3RyZWFtaW5nU2NvcGUsXG4gICAgICAgICAgICAgICAgaXNfaW5wdXRfc3RyZWFtX3N0ZXJlbzogdGhpcy5faW5wdXRBdWRpb01lZGlhU3RyZWFtSXNTdGVyZW9cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgY29tbWFuZENvbnRyb2xsZXIgPSB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRDb21tYW5kQ29udHJvbGxlcigpO1xuICAgICAgICAgICAgaWYgKCFjb21tYW5kQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYENvdWxkbid0IGNvbm5lY3QgdG8gbWl4ZXI6IG5vIFxcYGNvbW1hbmRDb250cm9sbGVyXFxgIWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGluaXRUaW1lb3V0ID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGVyck1zZyA9IGBDb3VsZG4ndCBjb25uZWN0IHRvIG1peGVyOiBDYWxsIHRvIFxcYGluaXRcXGAgdGltZWQgb3V0IWBcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kaXNjb25uZWN0RnJvbUhpRmlNaXhlcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yQ2xvc2luZykge1xuICAgICAgICAgICAgICAgICAgICBlcnJNc2cgKz0gYFxcbkFkZGl0aW9uYWxseSwgdGhlcmUgd2FzIGFuIGVycm9yIHRyeWluZyB0byBjbG9zZSB0aGUgZmFpbGVkIGNvbm5lY3Rpb24uIEVycm9yOlxcbiR7ZXJyb3JDbG9zaW5nfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyTXNnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBJTklUX1RJTUVPVVRfTVMpO1xuXG4gICAgICAgICAgICBjb21tYW5kQ29udHJvbGxlci5xdWV1ZUNvbW1hbmQoXCJhdWRpb25ldC5pbml0XCIsIGluaXREYXRhLCBhc3luYyAocmVzcG9uc2U6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpbml0VGltZW91dCk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZFJlc3BvbnNlOiBhbnk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhlckluZm9bXCJjb25uZWN0ZWRcIl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1peGVySW5mb1tcImJ1aWxkX251bWJlclwiXSA9IHBhcnNlZFJlc3BvbnNlLmJ1aWxkX251bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhlckluZm9bXCJidWlsZF90eXBlXCJdID0gcGFyc2VkUmVzcG9uc2UuYnVpbGRfdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhlckluZm9bXCJidWlsZF92ZXJzaW9uXCJdID0gcGFyc2VkUmVzcG9uc2UuYnVpbGRfdmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhlckluZm9bXCJ2aXNpdF9pZF9oYXNoXCJdID0gcGFyc2VkUmVzcG9uc2UudmlzaXRfaWRfaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmF2aURpYWdub3N0aWNzLnByaW1lKHRoaXMubWl4ZXJJbmZvLnZpc2l0X2lkX2hhc2gpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWZpRGlhZ25vc3RpY3MucHJpbWUodGhpcy5taXhlckluZm8udmlzaXRfaWRfaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvbmV0SW5pdFJlc3BvbnNlOiBwYXJzZWRSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgQ291bGRuJ3QgcGFyc2UgaW5pdCByZXNwb25zZSEgUGFyc2UgZXJyb3I6XFxuJHtlfWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGBtaXhlcmAgYW5kIGBwZWVyYCBkYXRhIGlzIHNlbnQgZnJvbSB0aGUgTWl4ZXIgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIHdoZW4gbmVjZXNzYXJ5LlxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBgZ3ppcHBlZGAgZGF0YSBmcm9tIHRoZSBNaXhlci5cbiAgICAgKi9cbiAgICBoYW5kbGVSQVZJU2Vzc2lvbkJpbmFyeURhdGEoZGF0YTogYW55KSB7XG4gICAgICAgIGxldCB1bkdaaXBwZWREYXRhID0gcGFrby51bmd6aXAoZGF0YSwgeyB0bzogJ3N0cmluZycgfSk7XG4gICAgICAgIGxldCBqc29uRGF0YSA9IEpTT04ucGFyc2UodW5HWmlwcGVkRGF0YSk7XG5cbiAgICAgICAgaWYgKGpzb25EYXRhLmRlbGV0ZWRfdmlzaXRfaWRzKSB7XG4gICAgICAgICAgICBsZXQgYWxsRGVsZXRlZFVzZXJEYXRhOiBBcnJheTxSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE+ID0gW107XG5cbiAgICAgICAgICAgIGxldCBkZWxldGVkVmlzaXRJRHMgPSBqc29uRGF0YS5kZWxldGVkX3Zpc2l0X2lkcztcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVsZXRlZFZpc2l0SUQgb2YgZGVsZXRlZFZpc2l0SURzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhc2hlZFZpc2l0SUQgPSBkZWxldGVkVmlzaXRJRDtcblxuICAgICAgICAgICAgICAgIGxldCBkZWxldGVkVXNlckRhdGEgPSBuZXcgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaGVkVmlzaXRJRDogaGFzaGVkVmlzaXRJRFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbGV0IG1peGVyUGVlcktleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0KTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1peGVyUGVlcktleSBvZiBtaXhlclBlZXJLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0W21peGVyUGVlcktleV0uaGFzaGVkVmlzaXRJRCA9PT0gaGFzaGVkVmlzaXRJRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21peGVyUGVlcktleVRvU3RhdGVDYWNoZURpY3RbbWl4ZXJQZWVyS2V5XS5wcm92aWRlZFVzZXJJRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRVc2VyRGF0YS5wcm92aWRlZFVzZXJJRCA9IHRoaXMuX21peGVyUGVlcktleVRvU3RhdGVDYWNoZURpY3RbbWl4ZXJQZWVyS2V5XS5wcm92aWRlZFVzZXJJRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWxsRGVsZXRlZFVzZXJEYXRhLnB1c2goZGVsZXRlZFVzZXJEYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoZSBlbnRyeSBmcm9tIHRoZSBwZWVyIHN0YXRlIGNhY2hlXG4gICAgICAgICAgICB0aGlzLmNvbmN1cnJlbmN5IC09IGFsbERlbGV0ZWRVc2VyRGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGhpcy5vblVzZXJzRGlzY29ubmVjdGVkICYmIGFsbERlbGV0ZWRVc2VyRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblVzZXJzRGlzY29ubmVjdGVkKGFsbERlbGV0ZWRVc2VyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoanNvbkRhdGEucGVlcnMpIHtcbiAgICAgICAgICAgIGxldCBhbGxOZXdVc2VyRGF0YTogQXJyYXk8UmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhPiA9IFtdO1xuXG4gICAgICAgICAgICBsZXQgcGVlcktleXMgPSBPYmplY3Qua2V5cyhqc29uRGF0YS5wZWVycyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpdHIgPSAwOyBpdHIgPCBwZWVyS2V5cy5sZW5ndGg7IGl0cisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBlZXJEYXRhRnJvbU1peGVyID0ganNvbkRhdGEucGVlcnNbcGVlcktleXNbaXRyXV07XG5cbiAgICAgICAgICAgICAgICAvLyBTZWUge0BsaW5rIHRoaXMuX21peGVyUGVlcktleVRvU3RhdGVDYWNoZURpY3R9LlxuICAgICAgICAgICAgICAgIGxldCB1c2VyRGF0YUNhY2hlOiBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYSBrbm93biBwZWVyLCB3ZSBzaG91bGQgaGF2ZSBhbiBlbnRyeSBmb3IgaXQgaW4gdGhlIGNhY2hlIGRpY3RcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWl4ZXJQZWVyS2V5VG9TdGF0ZUNhY2hlRGljdFtwZWVyS2V5c1tpdHJdXSkge1xuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlID0gdGhpcy5fbWl4ZXJQZWVyS2V5VG9TdGF0ZUNhY2hlRGljdFtwZWVyS2V5c1tpdHJdXSBhcyBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBsZXQncyBjcmVhdGUgaXQuXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUgPSBuZXcgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21peGVyUGVlcktleVRvU3RhdGVDYWNoZURpY3RbcGVlcktleXNbaXRyXV0gPSB1c2VyRGF0YUNhY2hlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmN1cnJlbmN5ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBlbXB0eSBkYXRhIHRoYXQgd2lsbCBjb2xsZWN0IHRoZSBjaGFuZ2VzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICAgICAgICAvLyBhcyB3ZSBjb2xsZWN0IHRoZSBjaGFuZ2VzIGZyb20gdGhlIHJlY2VpdmVkIGRhdGEsIHdlIHdpbGwgYWxzbyB1cGRhdGUgdGhlIHVzZXJEYXRhQ2FjaGUgYXNzb2NpYXRlZCB3aXRoIHRoYXQgcGVlci5cbiAgICAgICAgICAgICAgICBsZXQgbmV3VXNlckRhdGEgPSBuZXcgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBgLkpgIGlzIHRoZSAncHJvdmlkZWRVc2VySUQnXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJEYXRhQ2FjaGUucHJvdmlkZWRVc2VySUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxyZWFkeSAgZGVmaW5lZCwgc2hvdWxkIGJlIHRoZSBzYW1lIGluaXRpYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLnByb3ZpZGVkVXNlcklEID0gdXNlckRhdGFDYWNoZS5wcm92aWRlZFVzZXJJRDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAocGVlckRhdGFGcm9tTWl4ZXIuSikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5wcm92aWRlZFVzZXJJRCA9IHBlZXJEYXRhRnJvbU1peGVyLko7XG4gICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLnByb3ZpZGVkVXNlcklEID0gcGVlckRhdGFGcm9tTWl4ZXIuSjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBgLmVgIGlzIHRoZSBgaGFzaGVkVmlzaXRJRGAsIHdoaWNoIGlzIGEgaGFzaGVkIHZlcnNpb24gb2YgdGhlIHJhbmRvbSBVVUlEIHRoYXQgYSBjb25uZWN0aW5nIGNsaWVudFxuICAgICAgICAgICAgICAgIC8vIHNlbmRzIGFzIHRoZSBgc2Vzc2lvbmAga2V5IGluc2lkZSB0aGUgYXJndW1lbnQgdG8gdGhlIGBhdWRpb25ldC5pbml0YCBjb21tYW5kLlxuICAgICAgICAgICAgICAgIC8vIEl0IGlzIHVzZWQgdG8gaWRlbnRpZnkgYSBnaXZlbiBjbGllbnQgYWNyb3NzIGEgY2xvdWQgb2YgbWl4ZXJzLlxuICAgICAgICAgICAgICAgIGlmICh1c2VyRGF0YUNhY2hlLmhhc2hlZFZpc2l0SUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxyZWFkeSAgZGVmaW5lZCwgc2hvdWxkIGJlIHRoZSBzYW1lIGluaXRpYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLmhhc2hlZFZpc2l0SUQgPSB1c2VyRGF0YUNhY2hlLmhhc2hlZFZpc2l0SUQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLmUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUuaGFzaGVkVmlzaXRJRCA9IHBlZXJEYXRhRnJvbU1peGVyLmU7XG4gICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLmhhc2hlZFZpc2l0SUQgPSBwZWVyRGF0YUZyb21NaXhlci5lO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBzZXJ2ZXJTZW50TmV3VXNlckRhdGEgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIGBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEucG9zaXRpb24uKmBcbiAgICAgICAgICAgICAgICBsZXQgc2VydmVyU2VudE5ld1Bvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocGVlckRhdGFGcm9tTWl4ZXIueCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyRGF0YUNhY2hlLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLnBvc2l0aW9uID0gbmV3IFBvaW50M0QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBNaXhlciBzZW5kcyBwb3NpdGlvbiBkYXRhIGluIG1pbGxpbWV0ZXJzXG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUucG9zaXRpb24ueCA9IHBlZXJEYXRhRnJvbU1peGVyLnggLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3UG9zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci55KSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJEYXRhQ2FjaGUucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUucG9zaXRpb24gPSBuZXcgUG9pbnQzRCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE1peGVyIHNlbmRzIHBvc2l0aW9uIGRhdGEgaW4gbWlsbGltZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5wb3NpdGlvbi55ID0gcGVlckRhdGFGcm9tTWl4ZXIueSAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLnopID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlckRhdGFDYWNoZS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5wb3NpdGlvbiA9IG5ldyBQb2ludDNEKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTWl4ZXIgc2VuZHMgcG9zaXRpb24gZGF0YSBpbiBtaWxsaW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLnBvc2l0aW9uLnogPSBwZWVyRGF0YUZyb21NaXhlci56IC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld1Bvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgcmVjZWl2ZWQgYSBuZXcgcG9zaXRpb24gYW5kIHVwZGF0ZWQgdGhlIGNhY2hlIGVudHJ5LlxuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gYWRkIHRoZSBuZXcgcG9zaXRpb24gdmFsdWUgaW4gdGhlIG5ld1VzZXJEYXRhXG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlclNlbnROZXdQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBwb3NpdGlvbiB2YWx1ZSBmb3IgdGhlIG5ld1VzZXJEYXRhIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSByZWNlaXZlZCBwb3NpdGlvbiAoaWYgYW55KSB0byB0aGUgdXNlciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS5wb3NpdGlvbiA9IEhpRmlBeGlzVXRpbGl0aWVzLnRyYW5zbGF0ZVBvaW50M0RGcm9tTWl4ZXJTcGFjZShvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24sIHVzZXJEYXRhQ2FjaGUucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3VXNlckRhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEub3JpZW50YXRpb24uKmBcbiAgICAgICAgICAgICAgICBsZXQgc2VydmVyU2VudE5ld09yaWVudGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocGVlckRhdGFGcm9tTWl4ZXIuVykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyRGF0YUNhY2hlLm9yaWVudGF0aW9uUXVhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQgPSBuZXcgT3JpZW50YXRpb25RdWF0M0QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLm9yaWVudGF0aW9uUXVhdC53ID0gcGVlckRhdGFGcm9tTWl4ZXIuVyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdPcmllbnRhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLlgpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUub3JpZW50YXRpb25RdWF0ID0gbmV3IE9yaWVudGF0aW9uUXVhdDNEKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQueCA9IHBlZXJEYXRhRnJvbU1peGVyLlggLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTZW50TmV3T3JpZW50YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci5ZKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJEYXRhQ2FjaGUub3JpZW50YXRpb25RdWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLm9yaWVudGF0aW9uUXVhdCA9IG5ldyBPcmllbnRhdGlvblF1YXQzRCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUub3JpZW50YXRpb25RdWF0LnkgPSBwZWVyRGF0YUZyb21NaXhlci5ZIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld09yaWVudGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocGVlckRhdGFGcm9tTWl4ZXIuWikgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyRGF0YUNhY2hlLm9yaWVudGF0aW9uUXVhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5vcmllbnRhdGlvblF1YXQgPSBuZXcgT3JpZW50YXRpb25RdWF0M0QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YUNhY2hlLm9yaWVudGF0aW9uUXVhdC56ID0gcGVlckRhdGFGcm9tTWl4ZXIuWiAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdPcmllbnRhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIHJlY2VpdmVkIGEgbmV3IG9yaWVudGF0aW9uIGFuZCB1cGRhdGVkIHRoZSBjYWNoZSBlbnRyeS5cbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGFkZCB0aGUgbmV3IG9yaWVudGF0aW9uIHZhbHVlIGluIHRoZSBuZXdVc2VyRGF0YVxuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJTZW50TmV3T3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgb3JpZW50YXRpb24gdmFsdWUgZm9yIHRoZSBuZXdVc2VyRGF0YSBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCB0aGUgcmVjZWl2ZWQgb3JpZW50YXRpb24gKGlmIGFueSkgdG8gdGhlIHVzZXIgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgbmV3VXNlckRhdGEub3JpZW50YXRpb25RdWF0ID0gSGlGaUF4aXNVdGlsaXRpZXMudHJhbnNsYXRlT3JpZW50YXRpb25RdWF0M0RGcm9tTWl4ZXJTcGFjZShvdXJIaUZpQXhpc0NvbmZpZ3VyYXRpb24sIHVzZXJEYXRhQ2FjaGUub3JpZW50YXRpb25RdWF0KTtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld1VzZXJEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBgUmVjZWl2ZWRIaUZpQXVkaW9BUElEYXRhLnZvbHVtZURlY2liZWxzYFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBlZXJEYXRhRnJvbU1peGVyLnYpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQ2FjaGUudm9sdW1lRGVjaWJlbHMgPSBwZWVyRGF0YUZyb21NaXhlci52O1xuICAgICAgICAgICAgICAgICAgICBuZXdVc2VyRGF0YS52b2x1bWVEZWNpYmVscyA9IHBlZXJEYXRhRnJvbU1peGVyLnY7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclNlbnROZXdVc2VyRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YS5pc1N0ZXJlb2BcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwZWVyRGF0YUZyb21NaXhlci5zKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFDYWNoZS5pc1N0ZXJlbyA9IHBlZXJEYXRhRnJvbU1peGVyLnM7XG4gICAgICAgICAgICAgICAgICAgIG5ld1VzZXJEYXRhLmlzU3RlcmVvID0gcGVlckRhdGFGcm9tTWl4ZXIucztcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU2VudE5ld1VzZXJEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0aGUgbmV3VXNlckRhdGEgQU5EIHRoZSB1c2VyRGF0YUNhY2hlIGhhdmUgYmVlbiB1cGRhdGVkIHdpdGggdGhlIG5ldyB2YWx1ZXNcbiAgICAgICAgICAgICAgICAvLyBwcm9wYWdhdGUgbmV3VXNlckRhdGEgdG8gdXNlciBzcGFjZVxuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJTZW50TmV3VXNlckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsTmV3VXNlckRhdGEucHVzaChuZXdVc2VyRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vblVzZXJEYXRhVXBkYXRlZCAmJiBhbGxOZXdVc2VyRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblVzZXJEYXRhVXBkYXRlZChhbGxOZXdVc2VyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChqc29uRGF0YS5pbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YganNvbkRhdGEuaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RydWN0aW9uKSB8fCAhaW5zdHJ1Y3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBpbnN0cnVjdGlvbk5hbWUgPSBpbnN0cnVjdGlvblswXTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zdHJ1Y3Rpb25Bcmd1bWVudHMgPSBpbnN0cnVjdGlvbi5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25OYW1lID09PSBcIm11dGVcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkQmVNdXRlZDogYm9vbGVhbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uQXJndW1lbnRzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGluc3RydWN0aW9uQXJndW1lbnRzWzBdKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRCZU11dGVkID0gaW5zdHJ1Y3Rpb25Bcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEJlTXV0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0TXV0ZWRCeUFkbWluKHNob3VsZEJlTXV0ZWQsIE11dGVSZWFzb24uQURNSU4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgTWl4ZXIgZ2l2ZW4gYHRoaXMud2ViUlRDQWRkcmVzc2AuXG4gICAgICogXG4gICAgICogQHBhcmFtIF9fbmFtZWRQYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHdlYlJUQ1Nlc3Npb25QYXJhbXMgLSBQYXJhbWV0ZXJzIHBhc3NlZCB0byB0aGUgUkFWSSBzZXNzaW9uIHdoZW4gb3BlbmluZyB0aGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVqZWN0cyB3aXRoIGFuIGVycm9yIG1lc3NhZ2Ugc3RyaW5nIHVwb24gZmFpbHVyZSwgb3IgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzcG9uc2UgZnJvbSBgYXVkaW9uZXQuaW5pdGAgYXMgYSBzdHJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdFRvSGlGaU1peGVyKHsgd2ViUlRDU2Vzc2lvblBhcmFtcywgY3VzdG9tU1RVTmFuZFRVUk5Db25maWcgfTogeyB3ZWJSVENTZXNzaW9uUGFyYW1zPzogV2ViUlRDU2Vzc2lvblBhcmFtcywgY3VzdG9tU1RVTmFuZFRVUk5Db25maWc/OiBDdXN0b21TVFVOYW5kVFVSTkNvbmZpZyB9KTogUHJvbWlzZTxhbnk+IHtcblxuICAgICAgICBpZiAodGhpcy5fY3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUgPT09IEhpRmlDb25uZWN0aW9uU3RhdGVzLkNvbm5lY3RlZCAmJiB0aGlzLm1peGVySW5mb1tcImNvbm5lY3RlZFwiXSkge1xuICAgICAgICAgICAgbGV0IG1zZyA9IGBBbHJlYWR5IGNvbm5lY3RlZCEgSWYgYSByZWNvbm5lY3QgaXMgbmVlZGVkLCBwbGVhc2UgaGFuZyB1cCBhbmQgdHJ5IGFnYWluLmA7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMud2ViUlRDQWRkcmVzcykge1xuICAgICAgICAgICAgbGV0IGVyck1zZyA9IGBDb3VsZG4ndCBjb25uZWN0OiBcXGB0aGlzLndlYlJUQ0FkZHJlc3NcXGAgaXMgZmFsc2V5IWA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2Rpc2Nvbm5lY3RGcm9tSGlGaU1peGVyKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvckNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICBlcnJNc2cgKz0gYFxcbkFkZGl0aW9uYWxseSwgdGhlcmUgd2FzIGFuIGVycm9yIHRyeWluZyB0byBjbG9zZSB0aGUgZmFpbGVkIGNvbm5lY3Rpb24uIEVycm9yOlxcbiR7ZXJyb3JDbG9zaW5nfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyTXNnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGxldCBtaXhlcklzVW5hdmFpbGFibGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdGVtcFVuYXZhaWxhYmxlU3RhdGVIYW5kbGVyID0gKGV2ZW50OiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudCAmJiBldmVudC5zdGF0ZSA9PT0gUmF2aVNpZ25hbGluZ1N0YXRlcy5VTkFWQUlMQUJMRSkge1xuICAgICAgICAgICAgICAgIG1peGVySXNVbmF2YWlsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24ucmVtb3ZlU3RhdGVDaGFuZ2VIYW5kbGVyKHRlbXBVbmF2YWlsYWJsZVN0YXRlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF2aVNlc3Npb24uY2xvc2VSQVZJU2Vzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uLmFkZFN0YXRlQ2hhbmdlSGFuZGxlcih0ZW1wVW5hdmFpbGFibGVTdGF0ZUhhbmRsZXIpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbi5vcGVuUkFWSVNpZ25hbGluZ0Nvbm5lY3Rpb24odGhpcy53ZWJSVENBZGRyZXNzKVxuICAgICAgICB9IGNhdGNoIChlcnJvck9wZW5pbmdTaWduYWxpbmdDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgZXJyTXNnID0gYENvdWxkbid0IG9wZW4gc2lnbmFsaW5nIGNvbm5lY3Rpb24gdG8gXFxgJHt0aGlzLndlYlJUQ0FkZHJlc3Muc2xpY2UoMCwgdGhpcy53ZWJSVENBZGRyZXNzLmluZGV4T2YoXCJ0b2tlbj1cIikpfTx0b2tlbiByZWRhY3RlZD5cXGAhIEVycm9yOlxcbiR7ZXJyb3JPcGVuaW5nU2lnbmFsaW5nQ29ubmVjdGlvbn1gO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kaXNjb25uZWN0RnJvbUhpRmlNaXhlcigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3JDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgZXJyTXNnICs9IGBcXG5BZGRpdGlvbmFsbHksIHRoZXJlIHdhcyBhbiBlcnJvciB0cnlpbmcgdG8gY2xvc2UgdGhlIGZhaWxlZCBjb25uZWN0aW9uLiBFcnJvcjpcXG4ke2Vycm9yQ2xvc2luZ31gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24ucmVtb3ZlU3RhdGVDaGFuZ2VIYW5kbGVyKHRlbXBVbmF2YWlsYWJsZVN0YXRlSGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyTXNnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9yYXZpU2Vzc2lvbi5vcGVuUkFWSVNlc3Npb24oeyBzaWduYWxpbmdDb25uZWN0aW9uOiB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiwgcGFyYW1zOiB3ZWJSVENTZXNzaW9uUGFyYW1zLCBjdXN0b21TdHVuQW5kVHVybjogY3VzdG9tU1RVTmFuZFRVUk5Db25maWcgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yT3BlbmluZ1JBVklTZXNzaW9uKSB7XG4gICAgICAgICAgICBsZXQgZXJyTXNnID0gYENvdWxkbid0IG9wZW4gUkFWSSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCBcXGAke3RoaXMud2ViUlRDQWRkcmVzcy5zbGljZSgwLCB0aGlzLndlYlJUQ0FkZHJlc3MuaW5kZXhPZihcInRva2VuPVwiKSl9PHRva2VuIHJlZGFjdGVkPlxcYCEgRXJyb3I6XFxuJHtlcnJvck9wZW5pbmdSQVZJU2Vzc2lvbn1gO1xuICAgICAgICAgICAgaWYgKG1peGVySXNVbmF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIGVyck1zZyA9IGBIaWdoIEZpZGVsaXR5IHNlcnZlciBpcyBhdCBjYXBhY2l0eTsgc2VydmljZSBpcyB1bmF2YWlsYWJsZS5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kaXNjb25uZWN0RnJvbUhpRmlNaXhlcigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3JDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgZXJyTXNnICs9IGBcXG5BZGRpdGlvbmFsbHksIHRoZXJlIHdhcyBhbiBlcnJvciB0cnlpbmcgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb24uIEVycm9yOlxcbiR7ZXJyb3JDbG9zaW5nfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbi5yZW1vdmVTdGF0ZUNoYW5nZUhhbmRsZXIodGVtcFVuYXZhaWxhYmxlU3RhdGVIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJNc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGF1ZGlvbmV0SW5pdFJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXVkaW9uZXRJbml0UmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb21pc2VUb1J1bkF1ZGlvSW5pdCgpO1xuICAgICAgICB9IGNhdGNoIChpbml0RXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBlcnJNc2cgPSBgXFxgYXVkaW9uZXQuaW5pdFxcYCBjb21tYW5kIGZhaWxlZCEgRXJyb3I6XFxuJHtpbml0RXJyb3IuZXJyb3J9YDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGlzY29ubmVjdEZyb21IaUZpTWl4ZXIoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yQ2xvc2luZykge1xuICAgICAgICAgICAgICAgIGVyck1zZyArPSBgXFxuQWRkaXRpb25hbGx5LCB0aGVyZSB3YXMgYW4gZXJyb3IgdHJ5aW5nIHRvIGNsb3NlIHRoZSBmYWlsZWQgY29ubmVjdGlvbi4gRXJyb3I6XFxuJHtlcnJvckNsb3Npbmd9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uLnJlbW92ZVN0YXRlQ2hhbmdlSGFuZGxlcih0ZW1wVW5hdmFpbGFibGVTdGF0ZUhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVyck1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbi5yZW1vdmVTdGF0ZUNoYW5nZUhhbmRsZXIodGVtcFVuYXZhaWxhYmxlU3RhdGVIYW5kbGVyKTtcblxuICAgICAgICB0aGlzLmNvbmN1cnJlbmN5ID0gMDtcbiAgICAgICAgdGhpcy5fcmF2aVNlc3Npb24uZ2V0Q29tbWFuZENvbnRyb2xsZXIoKS5hZGRCaW5hcnlIYW5kbGVyKChkYXRhOiBhbnkpID0+IHsgdGhpcy5oYW5kbGVSQVZJU2Vzc2lvbkJpbmFyeURhdGEoZGF0YSkgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhdWRpb25ldEluaXRSZXNwb25zZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgZnJvbSB0aGUgTWl4ZXIuIENsb3NlcyB0aGUgUkFWSSBTaWduYWxpbmcgQ29ubmVjdGlvbiBhbmQgdGhlIFJBVkkgU2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCBfYWx3YXlzXyBSZXNvbHZlcyB3aXRoIGEgXCJzdWNjZXNzXCIgc3RhdHVzIHN0cmluZy5cbiAgICAgKi9cbiAgICBhc3luYyBkaXNjb25uZWN0RnJvbUhpRmlNaXhlcigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICB0aGlzLl9yYXZpRGlhZ25vc3RpY3Mubm90ZUV4cGxpY2l0QXBwbGljYXRpb25DbG9zZSgpO1xuICAgICAgICB0aGlzLl9oaWZpRGlhZ25vc3RpY3Mubm90ZUV4cGxpY2l0QXBwbGljYXRpb25DbG9zZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzY29ubmVjdEZyb21IaUZpTWl4ZXIoKTtcbiAgICB9XG4gICAgYXN5bmMgX2Rpc2Nvbm5lY3RGcm9tSGlGaU1peGVyKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNsb3NlKHRoaW5nVG9DbG9zZTogKFJhdmlTaWduYWxpbmdDb25uZWN0aW9uIHwgUmF2aVNlc3Npb24pLCBuYW1lT2ZUaGluZ1RvQ2xvc2U6IHN0cmluZywgY2xvc2VkU3RhdGU6IHN0cmluZykge1xuICAgICAgICAgICAgaWYgKHRoaW5nVG9DbG9zZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaW5nVG9DbG9zZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpbmdUb0Nsb3NlIHx8IHN0YXRlID09PSBjbG9zZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgVGhlIFJBVkkgJHtuYW1lT2ZUaGluZ1RvQ2xvc2V9IHdhcyBhbHJlYWR5IGNsb3NlZC5gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaW5nVG9DbG9zZSBpbnN0YW5jZW9mIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpbmdUb0Nsb3NlLmNsb3NlUkFWSVNpZ25hbGluZ0Nvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpbmdUb0Nsb3NlIGluc3RhbmNlb2YgUmF2aVNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGluZ1RvQ2xvc2UuY2xvc2VSQVZJU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYFRoZSBSQVZJICR7bmFtZU9mVGhpbmdUb0Nsb3NlfSBjbG9zZWQgc3VjY2Vzc2Z1bGx5IGZyb20gc3RhdGUgJHtzdGF0ZX0uYCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgVGhlIFJBVkkgJHtuYW1lT2ZUaGluZ1RvQ2xvc2V9IGRpZG4ndCBjbG9zZSBzdWNjZXNzZnVsbHkgZnJvbSBzdGF0ZSAke3N0YXRlfSEgRXJyb3I6XFxuJHtlfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYFRoZSBSQVZJICR7bmFtZU9mVGhpbmdUb0Nsb3NlfSB3YXMgbWlzc2luZy5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpbmdUb0Nsb3NlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IGNsb3NlKHRoaXMuX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uLCBcIlNpZ25hbGluZyBDb25uZWN0aW9uXCIsIFJhdmlTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEKTtcbiAgICAgICAgYXdhaXQgY2xvc2UodGhpcy5fcmF2aVNlc3Npb24sIFwiU2Vzc2lvblwiLCBSYXZpU2Vzc2lvblN0YXRlcy5DTE9TRUQpO1xuXG4gICAgICAgIHRoaXMuX3Jlc2V0TWl4ZXJJbmZvKCk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5fc2V0TXV0ZWRCeUFkbWluKGZhbHNlLCBNdXRlUmVhc29uLklOVEVSTkFMKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGBTdWNjZXNzZnVsbHkgZGlzY29ubmVjdGVkLmApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGF1ZGlvIGBNZWRpYVN0cmVhbWAgdGhhdCBpcyBzZW50IHRvIFJBVkkgdG8gYmUgbWl4ZWQuXG4gICAgICogQHBhcmFtIGlucHV0QXVkaW9NZWRpYVN0cmVhbSBUaGUgYE1lZGlhU3RyZWFtYCB0aGF0IGlzIHNlbnQgdG8gUkFWSSB0byBiZSBtaXhlZC5cbiAgICAgKiBAcGFyYW0gaXNTdGVyZW8gLSBgdHJ1ZWAgaWYgdGhlIGlucHV0IHN0cmVhbSBzaG91bGQgYmUgdHJlYXRlZCBhcyBzdGVyZW8uIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBuZXcgc3RyZWFtIHdhcyBzdWNjZXNzZnVsbHkgc2V0OyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRSQVZJSW5wdXRBdWRpbyhpbnB1dEF1ZGlvTWVkaWFTdHJlYW06IE1lZGlhU3RyZWFtLCBpc1N0ZXJlbzogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTxib29sZWFuPiB7XG5cbiAgICAgICAgbGV0IHJldHZhbCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fcmF2aVNlc3Npb24pIHtcbiAgICAgICAgICAgIGxldCBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5fcmF2aVNlc3Npb24uZ2V0U3RyZWFtQ29udHJvbGxlcigpO1xuICAgICAgICAgICAgaWYgKCFzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBDb3VsZG4ndCBzZXQgaW5wdXQgYXVkaW8gb24gX3JhdmlTZXNzaW9uLnN0cmVhbUNvbnRyb2xsZXI6IE5vIFxcYHN0cmVhbUNvbnRyb2xsZXJcXGAhYCk7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc2V0SW5wdXRBdWRpbyhpbnB1dEF1ZGlvTWVkaWFTdHJlYW0sIGlzU3RlcmVvKTtcbiAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgU3VjY2Vzc2Z1bGx5IHNldCBpbnB1dCBhdWRpbyBvbiBfcmF2aVNlc3Npb24uc3RyZWFtQ29udHJvbGxlciFgKTtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBDb3VsZG4ndCBzZXQgaW5wdXQgYXVkaW8gb24gX3JhdmlTZXNzaW9uLnN0cmVhbUNvbnRyb2xsZXI6IE5vIFxcYF9yYXZpU2Vzc2lvblxcYCFgKTtcbiAgICAgICAgICAgIHJldHZhbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHZhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0QXVkaW9NZWRpYVN0cmVhbUlzU3RlcmVvICE9IGlzU3RlcmVvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JhdmlTZXNzaW9uLmdldFN0YXRlKCkgPT09IFJhdmlTZXNzaW9uU3RhdGVzLkNPTk5FQ1RFRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGVyZW8gc3RhdHVzIGhhcyBjaGFuZ2VkOyBtYXkgbmVlZCB0byBjYWxsIGF1ZGlvbmV0LmluaXQgYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIud2FybihgU3RlcmVvIHN0YXR1cyBoYXMgY2hhbmdlZCBmcm9tICR7dGhpcy5faW5wdXRBdWRpb01lZGlhU3RyZWFtSXNTdGVyZW99IHRvICR7aXNTdGVyZW99OyBhdHRlbXB0aW5nIHRvIHJlLWluaXRpYWxpemUgd2l0aCB0aGUgbWl4ZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF1ZGlvbmV0SW5pdFJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXRBdWRpb01lZGlhU3RyZWFtSXNTdGVyZW8gPSBpc1N0ZXJlbztcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvbmV0SW5pdFJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9taXNlVG9SdW5BdWRpb0luaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaW5pdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGdvZXMgd3JvbmcsIGRvIHdlIGFjdHVhbGx5IGNhcmUgYWxsIHRoYXQgbXVjaD9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IGp1c3QgbWVhbnMgdGhhdCB0aGUgbWl4ZXIgd2lsbCBjb250aW51ZSB0byB0cmVhdCB0aGUgbmV3IHN0cmVhbSBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hhdGV2ZXIgc2V0dGluZyBpdCB3YXMgYmVmb3JlLiBGb3Igbm93LCBqdXN0IHJldHVybiB0aGUgZXJyb3IgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgdGhlIHVzZXIgdHJ5IGFnYWluIGlmIHRoZXkgd2FudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJNc2cgPSBgQXR0ZW1wdCB0byBjYWxsIFxcYGF1ZGlvbmV0LmluaXRcXGAgZm9yIGNoYW5nZSBpbiBzdGVyZW8gc3RhdHVzIGZhaWxlZCEgRXJyb3I6XFxuJHtpbml0RXJyb3IuZXJyb3J9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBhbHJlYWR5IGNvbm5lY3RlZCwgaXQnbGwganVzdCBwaWNrIHVwIHRoZSByaWdodCBzdGVyZW8gdmFsdWUgd2hlbiB3ZVxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIGl0IHRoZSBmaXJzdCB0aW1lLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dEF1ZGlvTWVkaWFTdHJlYW1Jc1N0ZXJlbyA9IGlzU3RlcmVvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGlucHV0IGF1ZGlvIHN0cmVhbSB0byBcIm11dGVkXCIgYnkgX2VpdGhlcl86XG4gICAgICogMS4gQ2FsbGluZyBgc3RvcCgpYCBvbiBhbGwgb2YgdGhlIGBNZWRpYVN0cmVhbVRyYWNrYHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyJ3MgaW5wdXQgYXVkaW8gc3RyZWFtIE9SXG4gICAgICogMi4gU2V0dGluZyBgdHJhY2suZW5hYmxlZCA9IGZhbHNlfHRydWVgIG9uIGFsbCBvZiB0aGUgdHJhY2tzIG9uIHRoZSB1c2VyJ3MgaW5wdXQgYXVkaW8gc3RyZWFtICh0aGUgZGVmYXVsdCBiZWhhdmlvcilcbiAgICAgKiBcbiAgICAgKiBNZXRob2QgMSB3aWxsIHdvcmsgaWYgYW5kIG9ubHkgaWY6XG4gICAgICogMS4gVGhlIGRldmVsb3BlciBoYXMgc2V0IHRoZSBgdHJ5VG9TdG9wTWljU3RyZWFtYCBhcmd1bWVudCB0byB0aGlzIGZ1bmN0aW9uIHRvIGB0cnVlYCBBTkRcbiAgICAgKiAyLiBUaGUgYXBwbGljYXRpb24gY29kZSBpcyBydW5uaW5nIGluIHRoZSBicm93c2VyIGNvbnRleHQgKG5vdCB0aGUgTm9kZUpTIGNvbnRleHQpIEFORFxuICAgICAqIDMuIFRoZSB1c2VyJ3MgYnJvd3NlciBnaXZlcyB0aGUgdXNlciB0aGUgYWJpbGl0eSB0byBwZXJtYW5lbnRseSBhbGxvdyBhIHdlYnNpdGUgdG8gYWNjZXNzIHRoZSB1c2VyJ3MgbWljcm9waG9uZVxuICAgICAqICAgIGFuZCBwcm92aWRlcyB0aGUgYG5hdmlnYXRvci5wZXJtaXNzaW9uc2AgYW5kIGBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnlgIG9iamVjdHMvbWV0aG9kcy5cbiAgICAgKiAgICAoUmVmZXIgdG8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Blcm1pc3Npb25zIC0gYXMgb2YgTWFyY2ggMjAyMSwgdGhpc1xuICAgICAqICAgIGxpc3QgZG9lcyBub3QgaW5jbHVkZSBTYWZhcmkgb24gZGVza3RvcCBvciBpT1MuKVxuICAgICAqIFxuICAgICAqIFJlYXNvbnMgdG8gdXNlIE1ldGhvZCAxOlxuICAgICAqIC0gQmx1ZXRvb3RoIEF1ZGlvIEkvTyBkZXZpY2VzIHdpbGwgc3dpdGNoIG1vZGVzIGJldHdlZW4gbW9ubyBvdXQgYW5kIHN0ZXJlbyBvdXQgd2hlbiB0aGUgdXNlciBpcyBtdXRlZCxcbiAgICAgKiB3aGljaCB5aWVsZHMgc2lnbmlmaWNhbnRseSBpbXByb3ZlZCBhdWRpbyBvdXRwdXQgcXVhbGl0eSBhbmQgcHJvcGVyIGF1ZGlvIHNwYXRpYWxpemF0aW9uLlxuICAgICAqIC0gV2hlbiB0aGUgdXNlciBpcyBtdXRlZCwgdGhlIGJyb3dzZXIgd2lsbCByZXBvcnQgdGhhdCB0aGVpciBtaWNyb3Bob25lIGlzIG5vdCBpbiB1c2UsIHdoaWNoIGNhbiBpbXByb3ZlXG4gICAgICogdXNlciB0cnVzdCBpbiB0aGUgYXBwbGljYXRpb24uXG4gICAgICogXG4gICAgICogUmVhc29ucyBfbm90XyB0byB1c2UgTWV0aG9kIDE6XG4gICAgICogLSBCZWNhdXNlIE1ldGhvZCAxIHJlcXVpcmVzIHJlLW9idGFpbmluZyBhbiBhdWRpbyBpbnB1dCBzdHJlYW0gdmlhIGBnZXRVc2VyTWVkaWEoKWAsIHRoZXJlIGlzIGEgc21hbGwgZGVsYXlcbiAgICAgKiBiZXR3ZWVuIHRoZSBtb21lbnQgdGhlIHVzZXIgdW4tbXV0ZXMgYW5kIHdoZW4gdGhlIHVzZXIgaXMgYWJsZSB0byBiZSBoZWFyZCBieSBvdGhlciB1c2VycyBpbiB0aGUgU3BhY2UuXG4gICAgICogLSBJZiBhIHVzZXIgaXMgdXNpbmcgYSBCbHVldG9vdGggQXVkaW8gSS9PIGRldmljZSwgdGhlcmUgaXMgYSBkZWxheSBiZXR3ZWVuIHRoZSBtb21lbnQgdGhlIHVzZXIgdW4tbXV0ZXNcbiAgICAgKiBhbmQgd2hlbiBhIHVzZXIgY2FuIGhlYXIgb3RoZXIgdXNlcnMgaW4gYSBTcGFjZSBkdWUgdG8gdGhlIGZhY3QgdGhhdCB0aGUgQmx1ZXRvb3RoIGF1ZGlvIGRldmljZSBtdXN0XG4gICAgICogc3dpdGNoIEkvTyBwcm9maWxlcy5cbiAgICAgKiAtIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB0aGUgYG5hdmlnYXRvci5wZXJtaXNzaW9uc2AgQVBJXG4gICAgICogXG4gICAgICogQHBhcmFtIG5ld011dGVkVmFsdWUgSWYgYHRydWVgLCB0aGUgaW5wdXQgYXVkaW8gc3RyZWFtIHdpbGwgYmUgbXV0ZWQuIElmIGBmYWxzZWAsIHRoZSBpbnB1dCBzdHJlYW0gd2lsbCBiZSB1bm11dGVkLlxuICAgICAqIEBwYXJhbSB0cnlUb1N0b3BNaWNTdHJlYW0gSWYgYGZhbHNlYCwgdGhpcyBmdW5jdGlvbiB3aWxsIHVzZSBNZXRob2QgMiBkZXNjcmliZWQgYWJvdmUgdG8gbXV0ZSBvciB1bm11dGUgdGhlIGlucHV0IGF1ZGlvIHN0cmVhbS4gSWYgYHRydWVgLCB0aGlzIGZ1bmN0aW9uIHdpbGwgdXNlIE1ldGhvZCAxLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3RyZWFtIHdhcyBzdWNjZXNzZnVsbHkgbXV0ZWQvdW5tdXRlZCwgYGZhbHNlYCBpZiBpdCB3YXMgbm90LlxuICAgICAqL1xuICAgIGFzeW5jIHNldElucHV0QXVkaW9NdXRlZChuZXdNdXRlZFZhbHVlOiBib29sZWFuLCB0cnlUb1N0b3BNaWNTdHJlYW06IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2V0TXV0ZWQobmV3TXV0ZWRWYWx1ZSwgdHJ5VG9TdG9wTWljU3RyZWFtLCBNdXRlUmVhc29uLkNMSUVOVCk7XG4gICAgfVxuXG4gICAgYXN5bmMgX3NldE11dGVkQnlBZG1pbihtdXRlZEJ5QWRtaW46IGJvb2xlYW4sIG11dGVSZWFzb246IE11dGVSZWFzb24pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgLy8gRm9yIG5vdzpcbiAgICAgICAgLy8gLSBBZG1pbiBtdXRpbmcgc2hvdWxkIG11dGUgdGhlIGNsaWVudCwgYW5kIHByZXZlbnQgdGhlIGNsaWVudCBmcm9tIHVubXV0aW5nXG4gICAgICAgIC8vIC0gQWRtaW4gdW5tdXRpbmcgc2hvdWxkIG5vdCB1bm11dGUgdGhlIGNsaWVudCwgYnV0IHNpbXBseSBhbGxvdyB0aGUgY2xpZW50IHRvIHVubXV0ZVxuICAgICAgICAvLyAtIFdoZW4gdGhlIGNvbm5lY3Rpb24gZW5kcywgdGhlIGNsaWVudCBpcyBhbGxvd2VkIHRvIHVubXV0ZSwgd2hpY2ggZm9yIG5vdyBpcyBlcXVpdmFsZW50IHRvIGFuIGFkbWluIHVubXV0ZVxuICAgICAgICB0aGlzLl9hZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nID0gbXV0ZWRCeUFkbWluO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2V0TXV0ZWQobXV0ZWRCeUFkbWluIHx8IHRoaXMuX2xhc3RTdWNjZXNzZnVsSW5wdXRBdWRpb011dGVkVmFsdWUsIGZhbHNlLCBtdXRlUmVhc29uKTtcbiAgICB9XG5cbiAgICBhc3luYyBfc2V0TXV0ZWQobmV3TXV0ZWRWYWx1ZTogYm9vbGVhbiwgdHJ5VG9TdG9wTWljU3RyZWFtOiBib29sZWFuLCBtdXRlUmVhc29uOiBNdXRlUmVhc29uKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGxldCBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgaWYgKG11dGVSZWFzb24gPT0gTXV0ZVJlYXNvbi5DTElFTlQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nICYmICFuZXdNdXRlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBDb3VsZG4ndCBzZXQgbXV0ZSBzdGF0ZTogTXV0ZWQgYnkgYWRtaW4uYCk7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICBzdWNjZXNzID0gYXdhaXQgdGhpcy5fdHJ5U2V0SW5wdXRBdWRpb011dGVkKG5ld011dGVkVmFsdWUsIHRyeVRvU3RvcE1pY1N0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RTdWNjZXNzZnVsSW5wdXRBdWRpb011dGVkVmFsdWUgPSBuZXdNdXRlZFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub25NdXRlQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5vbk11dGVDaGFuZ2VkKG5ldyBNdXRlQ2hhbmdlZEV2ZW50KHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgIHRhcmdldElucHV0QXVkaW9NdXRlZFZhbHVlOiBuZXdNdXRlZFZhbHVlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbnB1dEF1ZGlvTXV0ZWRWYWx1ZTogdGhpcy5fbGFzdFN1Y2Nlc3NmdWxJbnB1dEF1ZGlvTXV0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICBhZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nOiB0aGlzLl9hZG1pblByZXZlbnRzSW5wdXRBdWRpb1VubXV0aW5nLFxuICAgICAgICAgICAgICAgIG11dGVSZWFzb246IG11dGVSZWFzb25cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICB9XG5cbiAgICBhc3luYyBfdHJ5U2V0SW5wdXRBdWRpb011dGVkKG5ld011dGVkVmFsdWU6IGJvb2xlYW4sIHRyeVRvU3RvcE1pY1N0cmVhbTogYm9vbGVhbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBsZXQgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuX3JhdmlTZXNzaW9uLmdldFN0cmVhbUNvbnRyb2xsZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuX3JhdmlTZXNzaW9uICYmIHN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGxldCBoYXNNaWNQZXJtaXNzaW9uID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5hdmlnYXRvcikgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnBlcm1pc3Npb25zICYmIG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ6IFBlcm1pc3Npb25TdGF0dXM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHsgbmFtZTogJ21pY3JvcGhvbmUnIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggeyB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuc3RhdGUgPT09IFwiZ3JhbnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc01pY1Blcm1pc3Npb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0cnlUb1N0b3BNaWNTdHJlYW0gfHwgIWhhc01pY1Blcm1pc3Npb24gfHwgdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gRGV2ZWxvcGVyIGhhcyBleHBsaWNpdGx5IG9yIGltcGxpY2l0bHkgc2V0IGB0cnlUb1N0b3BNaWNTdHJlYW1gIHRvIGBmYWxzZWAgT1JcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSBpbiB0aGUgTm9kZUpTIGNvbnRleHQgT1JcbiAgICAgICAgICAgICAgICAvLyB0aGUgdXNlciBoYXNuJ3QgZ3JhbnRlZCBvciBjYW4ndCBncmFudCBwZXJtYW5lbnQgbWljIHBlcm1pc3Npb25zIHRvIG91ciBzY3JpcHQuLi5cbiAgICAgICAgICAgICAgICAvLyBPbiBpT1MgU2FmYXJpLCB0aGUgdXNlciBfY2FuJ3RfIGdyYW50IHBlcm1hbmVudCBtaWMgcGVybWlzc2lvbnMgdG8gb3VyIHNjcmlwdC5cbiAgICAgICAgICAgICAgICBsZXQgcmF2aUF1ZGlvU3RyZWFtID0gc3RyZWFtQ29udHJvbGxlci5faW5wdXRBdWRpb1N0cmVhbTtcblxuICAgICAgICAgICAgICAgIGlmIChyYXZpQXVkaW9TdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmF2aUF1ZGlvU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5lbmFibGVkID0gIW5ld011dGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgU3VjY2Vzc2Z1bGx5IHNldCBtdXRlIHN0YXRlIHRvICR7bmV3TXV0ZWRWYWx1ZX0gb24gX3JhdmlTZXNzaW9uLnN0cmVhbUNvbnRyb2xsZXIuX2lucHV0QXVkaW9TdHJlYW1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBDb3VsZG4ndCBzZXQgbXV0ZSBzdGF0ZTogTm8gXFxgX2lucHV0QXVkaW9TdHJlYW1cXGAgb24gXFxgX3JhdmlTZXNzaW9uLnN0cmVhbUNvbnRyb2xsZXJcXGAuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgYnJvd3NlciBjb250ZXh0LCBpZiBhbmQgb25seSBpZiB0aGUgdXNlciBoYXMgZ3JhbnRlZCBtaWMgcGVybWlzc2lvbnMgdG8gb3VyIHNjcmlwdCxcbiAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGNhbGwgYHN0b3AoKWAgb24gYWxsIGBNZWRpYVN0cmVhbVRyYWNrYHMgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHVzZXIncyBhdWRpbyBpbnB1dCBkZXZpY2Ugc3RyZWFtLiBUaGlzIGlzIHRvIGhvcGVmdWxseSBhbGxvdyB0aGUgT1MgdG8gc3dpdGNoIHRoZSB1c2VyJ3Mgb3V0cHV0IGF1ZGlvIGRldmljZVxuICAgICAgICAgICAgICAgIC8vIGludG8gaGFsZi1kdXBsZXggKGkuZS4gc3RlcmVvKSBtb2RlIGluIHRoZSBjYXNlIHdoZXJlIHRoYXQgb3V0cHV0IGRldmljZSBpcyBCbHVldG9vdGguXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzbid0IGdyYW50ZWQgcGVybWFuZW50IG1pYyBwZXJtaXNzaW9ucyB0byBvdXIgc2NyaXB0LCBkb2luZyB0aGlzIHdvdWxkIGJyZWFrIGZlYXR1cmVzIGxpa2UgcHVzaC10by10YWxrLFxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBicm93c2VyIHdvdWxkIHByb21wdCB0aGUgdXNlciBmb3IgcGVybWlzc2lvbiB0byBhY2Nlc3MgdGhlIG1pY3JvcGhvbmUgZXZlcnkgdGltZSB0aGV5IHVubXV0ZWQuXG4gICAgICAgICAgICAgICAgbGV0IHJhdmlBdWRpb1N0cmVhbSA9IHN0cmVhbUNvbnRyb2xsZXIuX2lucHV0QXVkaW9TdHJlYW07XG4gICAgICAgICAgICAgICAgaWYgKHJhdmlBdWRpb1N0cmVhbSAmJiBuZXdNdXRlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhdmlBdWRpb1N0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGBNZWRpYVRyYWNrQ29uc3RyYWludHNgIGFyZSB2ZXJ5IGxpa2VseSB0byBiZSB0aGUgc2FtZSBhY3Jvc3MgYWxsIGBNZWRpYVN0cmVhbVRyYWNrc2AuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaHVzLCBpbiB0aGUgY2FzZSBvZiBvdmVyd3JpdGluZyB0aGlzIHZhbHVlIG11bHRpcGxlIHRpbWVzIGR1ZSB0byBtdWx0aXBsZSB0cmFja3MgY29udGFpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoaW4gdGhlIGByYXZpQXVkaW9TdHJlYW1gLCB0aGVyZSBzaG91bGQgYmUgbm8gcHJvYmxlbXMuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRNZWRpYVRyYWNrQ29uc3RyYWludHMgPSB0cmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zZXRJbnB1dEF1ZGlvKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgU3VjY2Vzc2Z1bGx5IHNldCBtdXRlIHN0YXRlIHRvIFxcYHRydWVcXGAgYnkgc3RvcHBpbmcgYWxsIGlucHV0IG1lZGlhIHRyYWNrcyFgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcmF2aUF1ZGlvU3RyZWFtICYmICFuZXdNdXRlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdNZWRpYVN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgYXVkaW86IHRoaXMuX2NhY2hlZE1lZGlhVHJhY2tDb25zdHJhaW50cywgdmlkZW86IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnNldElucHV0QXVkaW8obmV3TWVkaWFTdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICBIaUZpTG9nZ2VyLmxvZyhgU3VjY2Vzc2Z1bGx5IHNldCBtdXRlIHN0YXRlIHRvIFxcYGZhbHNlXFxgIGJ5IGdldHRpbmcgbmV3IGlucHV0IG1lZGlhIHN0cmVhbSFgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYXZpQXVkaW9TdHJlYW0gJiYgIW5ld011dGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmF2aUF1ZGlvU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIEhpRmlMb2dnZXIubG9nKGBTdWNjZXNzZnVsbHkgc2V0IG11dGUgc3RhdGUgdG8gXFxgZmFsc2VcXGAgYnkgZW5hYmxpbmcgYWxsIHRyYWNrcyBvbiBcXGBfcmF2aVNlc3Npb24uc3RyZWFtQ29udHJvbGxlci5faW5wdXRBdWRpb1N0cmVhbVxcYCFgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBDb3VsZG4ndCBzZXQgbXV0ZSBzdGF0ZTogTm8gXFxgX2lucHV0QXVkaW9TdHJlYW1cXGAgb24gXFxgX3JhdmlTZXNzaW9uLnN0cmVhbUNvbnRyb2xsZXJcXGAuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci53YXJuKGBDb3VsZG4ndCBzZXQgbXV0ZSBzdGF0ZTogTm8gXFxgX3JhdmlTZXNzaW9uXFxgLCBvciBcXGBfcmF2aVNlc3Npb24uZ2V0U3RyZWFtQ29udHJvbGxlcigpXFxgIHJldHVybmVkIG51bGwuYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBvdXRwdXQgYE1lZGlhU3RyZWFtYCBmcm9tIHRoZSBNaXhlci4gVGhpcyBpcyB0aGUgZmluYWwsIG1peGVkLCBzcGF0aWFsaXplZCBhdWRpbyBzdHJlYW0gY29udGFpbmluZ1xuICAgICAqIGFsbCBzb3VyY2VzIHNlbnQgdG8gdGhlIE1peGVyLlxuICAgICAqIEByZXR1cm5zIFRoZSBtaXhlZCwgc3BhdGlhbGl6ZWQgYE1lZGlhU3RyZWFtYCBmcm9tIHRoZSBNaXhlci4gUmV0dXJucyBgbnVsbGAgaWYgaXQncyBub3QgcG9zc2libGUgdG8gb2J0YWluIHRoYXQgYE1lZGlhU3RyZWFtYC5cbiAgICAgKi9cbiAgICBnZXRPdXRwdXRBdWRpb01lZGlhU3RyZWFtKCk6IE1lZGlhU3RyZWFtIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yYXZpU2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuX3JhdmlTZXNzaW9uLmdldFN0cmVhbUNvbnRyb2xsZXIoKTtcblxuICAgICAgICBpZiAoIXN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cmVhbUNvbnRyb2xsZXIuZ2V0QXVkaW9TdHJlYW0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBjb25uZWN0aW9uLCBhbmRcbiAgICAgKiBmaXJlcyB0aGUgb25DaGFuZ2UgaGFuZGxlciBpZiB0aGF0IHN0YXRlIGhhcywgaW4gZmFjdCwgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0gc3RhdGVcbiAgICAgKi9cbiAgICBfc2V0Q3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUoc3RhdGU6IEhpRmlDb25uZWN0aW9uU3RhdGVzKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAodGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCh0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oaWZpRGlhZ25vc3RpY3MuZmlyZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlKCk6IEhpRmlDb25uZWN0aW9uU3RhdGVzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIFJBVkkgU2lnbmFsaW5nIFN0YXRlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIGV2ZW50IFxuICAgICAqL1xuICAgIGFzeW5jIG9uUkFWSVNpZ25hbGluZ1N0YXRlQ2hhbmdlZChldmVudDogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIEhpRmlMb2dnZXIubG9nKGBOZXcgUkFWSSBzaWduYWxpbmcgc3RhdGU6IFxcYCR7ZXZlbnQuc3RhdGV9XFxgYCk7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgUmF2aVNpZ25hbGluZ1N0YXRlcy5VTkFWQUlMQUJMRTpcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZShIaUZpQ29ubmVjdGlvblN0YXRlcy5VbmF2YWlsYWJsZSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGlzY29ubmVjdEZyb21IaUZpTWl4ZXIoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvckNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYEVycm9yIGVuY291bnRlcmVkIHdoaWxlIHRyeWluZyB0byBjbG9zZSB0aGUgY29ubmVjdGlvbi4gRXJyb3I6XFxuJHtlcnJvckNsb3Npbmd9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgUkFWSSBTZXNzaW9uIFN0YXRlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgYXN5bmMgb25SQVZJU2Vzc2lvblN0YXRlQ2hhbmdlZChldmVudDogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIEhpRmlMb2dnZXIubG9nKGBOZXcgUkFWSSBzZXNzaW9uIHN0YXRlOiBcXGAke2V2ZW50LnN0YXRlfVxcYGApO1xuICAgICAgICB0aGlzLl9yYXZpRGlhZ25vc3RpY3MuZmlyZSgpO1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkNPTk5FQ1RFRDpcbiAgICAgICAgICAgICAgICB0aGlzLl9taXhlclBlZXJLZXlUb1N0YXRlQ2FjaGVEaWN0ID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUoSGlGaUNvbm5lY3Rpb25TdGF0ZXMuQ29ubmVjdGVkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmF2aVNlc3Npb25TdGF0ZXMuRElTQ09OTkVDVEVEOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSA9PT0gSGlGaUNvbm5lY3Rpb25TdGF0ZXMuVW5hdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEN1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlKEhpRmlDb25uZWN0aW9uU3RhdGVzLkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGlzY29ubmVjdEZyb21IaUZpTWl4ZXIoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvckNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5sb2coYEVycm9yIGVuY291bnRlcmVkIHdoaWxlIHRyeWluZyB0byBjbG9zZSB0aGUgY29ubmVjdGlvbi4gRXJyb3I6XFxuJHtlcnJvckNsb3Npbmd9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSYXZpU2Vzc2lvblN0YXRlcy5GQUlMRUQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlID09PSBIaUZpQ29ubmVjdGlvblN0YXRlcy5VbmF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q3VycmVudEhpRmlDb25uZWN0aW9uU3RhdGUoSGlGaUNvbm5lY3Rpb25TdGF0ZXMuRmFpbGVkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VEOlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgYW4gXCJVbmF2YWlsYWJsZVwiIHN0YXRlLiAoVGhpcyB3aWxsIGhvcGVmdWxseVxuICAgICAgICAgICAgICAgIC8vIGJlIGFibGUgdG8gZ28gYXdheSBvbmNlIGNoYW5nZXMgZnJvbSBISUZJLTYyOSBhcmUgY29tcGxldGUsIGJ1dCBpcyBzYWZlIHRvIGxlYXZlIGluIGZvciBub3cuKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSA9PT0gSGlGaUNvbm5lY3Rpb25TdGF0ZXMuVW5hdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEN1cnJlbnRIaUZpQ29ubmVjdGlvblN0YXRlKEhpRmlDb25uZWN0aW9uU3RhdGVzLkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFydENvbGxlY3RpbmdXZWJSVENTdGF0cyhjYWxsYmFjazogRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yYXZpU2Vzc2lvbikge1xuICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihgQ291bGRuJ3Qgc3RhcnQgY29sbGVjdGluZyBXZWJSVEMgc3RhdHM6IE5vIFxcYF9yYXZpU2Vzc2lvblxcYCFgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zdGF0c09ic2VydmVyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcENvbGxlY3RpbmdXZWJSVENTdGF0cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RhdHNPYnNlcnZlckNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICAgICAgdGhpcy5fcmF2aVNlc3Npb24uYWRkU3RhdHNPYnNlcnZlcih0aGlzLl9zdGF0c09ic2VydmVyQ2FsbGJhY2spO1xuICAgIH1cblxuICAgIHN0b3BDb2xsZWN0aW5nV2ViUlRDU3RhdHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmF2aVNlc3Npb24pIHtcbiAgICAgICAgICAgIEhpRmlMb2dnZXIuZXJyb3IoYENvdWxkbid0IHN0b3AgY29sbGVjdGluZyBXZWJSVEMgc3RhdHM6IE5vIFxcYF9yYXZpU2Vzc2lvblxcYCFgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JhdmlTZXNzaW9uLnJlbW92ZVN0YXRzT2JzZXJ2ZXIodGhpcy5fc3RhdHNPYnNlcnZlckNhbGxiYWNrKTtcblxuICAgICAgICB0aGlzLl9zdGF0c09ic2VydmVyQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhIC0gVGhlIG5ldyB1c2VyIGRhdGEgdGhhdCB3ZSB3YW50IHRvIHNlbmQgdG8gdGhlIEhpZ2ggRmlkZWxpdHkgQXVkaW8gQVBJIHNlcnZlci5cbiAgICAgKiBAcmV0dXJucyBJZiB0aGlzIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsLCByZXR1cm5zIGB7IHN1Y2Nlc3M6IHRydWUsIHN0cmluZ2lmaWVkRGF0YUZvck1peGVyOiA8dGhlIHJhdyBkYXRhIHRoYXQgd2FzIHRyYW5zbWl0dGVkIHRvIHRoZSBzZXJ2ZXI+fWAuIElmIHVuc3VjY2Vzc2Z1bCwgcmV0dXJuc1xuICAgICAqIGB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogPGFuIGVycm9yIG1lc3NhZ2U+IH1gLlxuICAgICAqL1xuICAgIF90cmFuc21pdEhpRmlBdWRpb0FQSURhdGFUb1NlcnZlcihjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YTogSGlGaUF1ZGlvQVBJRGF0YSwgcHJldmlvdXNIaWZpQXVkaW9BUElEYXRhPzogSGlGaUF1ZGlvQVBJRGF0YSk6IGFueSB7XG4gICAgICAgIGlmICghdGhpcy5taXhlckluZm9bXCJjb25uZWN0ZWRcIl0gfHwgIXRoaXMuX3JhdmlTZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgQ2FuJ3QgdHJhbnNtaXQgZGF0YSB0byBtaXhlcjsgbm90IGNvbm5lY3RlZCB0byBtaXhlci5gXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRhdGFGb3JNaXhlcjogYW55ID0ge307XG5cbiAgICAgICAgLy8gaWYgYSBwb3NpdGlvbiBpcyBzcGVjaWZpZWQgd2l0aCB2YWxpZCBjb21wb25lbnRzLCBsZXQncyBjb25zaWRlciBhZGRpbmcgcG9zaXRpb24gcGF5bG9hZFxuICAgICAgICBpZiAoY3VycmVudEhpZmlBdWRpb0FQSURhdGEucG9zaXRpb24gJiYgKHR5cGVvZiAoY3VycmVudEhpZmlBdWRpb0FQSURhdGEucG9zaXRpb24ueCkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAmJiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi55KSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICYmICh0eXBlb2YgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnopID09PSBcIm51bWJlclwiKSkge1xuICAgICAgICAgICAgLy8gRGV0ZWN0IHRoZSBwb3NpdGlvbiBjb21wb25lbnRzIHdoaWNoIGhhdmUgcmVhbGx5IGNoYW5nZWQgY29tcGFyZWQgdG8gdGhlIHByZXZpb3VzIHN0YXRlIGtub3duIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgICAgbGV0IGNoYW5nZWRDb21wb25lbnRzOiB7IHg6IGJvb2xlYW4sIHk6IGJvb2xlYW4sIHo6IGJvb2xlYW4sIGNoYW5nZWQ6IGJvb2xlYW4gfSA9IHsgeDogZmFsc2UsIHk6IGZhbHNlLCB6OiBmYWxzZSwgY2hhbmdlZDogZmFsc2UgfTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEgJiYgcHJldmlvdXNIaWZpQXVkaW9BUElEYXRhLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnggIT09IHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi54KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnkgIT09IHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi55KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnBvc2l0aW9uLnogIT09IHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YS5wb3NpdGlvbi56KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnogPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnogPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTb21lIHBvc2l0aW9uIGNvbXBvbmVudHMgaGF2ZSBjaGFuZ2VkLCBsZXQncyBmaWxsIGluIHRoZSBwYXlsb2FkXG4gICAgICAgICAgICBpZiAoY2hhbmdlZENvbXBvbmVudHMuY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGxldCB0cmFuc2xhdGVkUG9zaXRpb24gPSBIaUZpQXhpc1V0aWxpdGllcy50cmFuc2xhdGVQb2ludDNEVG9NaXhlclNwYWNlKG91ckhpRmlBeGlzQ29uZmlndXJhdGlvbiwgY3VycmVudEhpZmlBdWRpb0FQSURhdGEucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gUG9zaXRpb24gZGF0YSBpcyBzZW50IGluIG1pbGxpbWV0ZXJzIGludGVnZXJzIHRvIHJlZHVjZSBKU09OIHNpemUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRDb21wb25lbnRzLngpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUZvck1peGVyW1wieFwiXSA9IE1hdGgucm91bmQodHJhbnNsYXRlZFBvc2l0aW9uLnggKiAxMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRDb21wb25lbnRzLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUZvck1peGVyW1wieVwiXSA9IE1hdGgucm91bmQodHJhbnNsYXRlZFBvc2l0aW9uLnkgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRDb21wb25lbnRzLnopIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUZvck1peGVyW1wielwiXSA9IE1hdGgucm91bmQodHJhbnNsYXRlZFBvc2l0aW9uLnogKiAxMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBvcmllbnRhdGlvbiBpcyBzcGVjaWZpZWQgd2l0aCB2YWxpZCBjb21wb25lbnRzLCBsZXQncyBjb25zaWRlciBhZGRpbmcgb3JpZW50YXRpb24gcGF5bG9hZFxuICAgICAgICBpZiAoY3VycmVudEhpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0ICYmICh0eXBlb2YgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC53KSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICYmICh0eXBlb2YgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC54KSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICYmICh0eXBlb2YgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC55KSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICYmICh0eXBlb2YgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC56KSA9PT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgICAgIC8vIERldGVjdCB0aGUgb3JpZW50YXRpb24gY29tcG9uZW50cyB3aGljaCBoYXZlIHJlYWxseSBjaGFuZ2VkIGNvbXBhcmVkIHRvIHRoZSBwcmV2aW91cyBzdGF0ZSBrbm93biBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkQ29tcG9uZW50czogeyB3OiBib29sZWFuLCB4OiBib29sZWFuLCB5OiBib29sZWFuLCB6OiBib29sZWFuLCBjaGFuZ2VkOiBib29sZWFuIH0gPSB7IHc6IGZhbHNlLCB4OiBmYWxzZSwgeTogZmFsc2UsIHo6IGZhbHNlLCBjaGFuZ2VkOiBmYWxzZSB9O1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YSAmJiBwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC53ICE9PSBwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LncpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMudyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEhpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnggIT09IHByZXZpb3VzSGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy54ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQueSAhPT0gcHJldmlvdXNIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC55KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ29tcG9uZW50cy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLm9yaWVudGF0aW9uUXVhdC56ICE9PSBwcmV2aW91c0hpZmlBdWRpb0FQSURhdGEub3JpZW50YXRpb25RdWF0LnopIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMueiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDb21wb25lbnRzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMudyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMueCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMueSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMueiA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2hhbmdlZENvbXBvbmVudHMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNvbWUgb3JpZW50YXRpb24gY29tcG9uZW50cyBoYXZlIGNoYW5nZWQsIGxldCdzIGZpbGwgaW4gdGhlIHBheWxvYWRcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkQ29tcG9uZW50cy5jaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG1peGVyIGV4cGVjdHMgUXVhdGVybmlvbiBjb21wb25lbnRzIGluIGl0cyBzcGFjZSBhbmQgdG8gYmUgbXVsaXRpcGxpZWQgYnkgMTAwMC5cbiAgICAgICAgICAgICAgICBsZXQgdHJhbnNsYXRlZE9yaWVudGF0aW9uID0gSGlGaUF4aXNVdGlsaXRpZXMudHJhbnNsYXRlT3JpZW50YXRpb25RdWF0M0RUb01peGVyU3BhY2Uob3VySGlGaUF4aXNDb25maWd1cmF0aW9uLCBjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5vcmllbnRhdGlvblF1YXQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRDb21wb25lbnRzLncpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUZvck1peGVyW1wiV1wiXSA9IHRyYW5zbGF0ZWRPcmllbnRhdGlvbi53ICogMTAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRDb21wb25lbnRzLngpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUZvck1peGVyW1wiWFwiXSA9IHRyYW5zbGF0ZWRPcmllbnRhdGlvbi54ICogMTAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRDb21wb25lbnRzLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUZvck1peGVyW1wiWVwiXSA9IHRyYW5zbGF0ZWRPcmllbnRhdGlvbi55ICogMTAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgKGNoYW5nZWRDb21wb25lbnRzLnopIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHNlbmQgWiBhbGwgdGhlIHRpbWUgYXQgdGhlIG1vbWVudCB1bnRpbCB3ZSBtZXJnZSB0aGUgZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdoZmlkZWxpdHkvYXVkaW9uZXQtaGlmaS9wdWxsLzI3MVxuICAgICAgICAgICAgICAgIGRhdGFGb3JNaXhlcltcIlpcIl0gPSB0cmFuc2xhdGVkT3JpZW50YXRpb24ueiAqIDEwMDA7XG4gICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIChjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS52b2x1bWVUaHJlc2hvbGQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBkYXRhRm9yTWl4ZXJbXCJUXCJdID0gY3VycmVudEhpZmlBdWRpb0FQSURhdGEudm9sdW1lVGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiAoY3VycmVudEhpZmlBdWRpb0FQSURhdGEuaGlGaUdhaW4pID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBkYXRhRm9yTWl4ZXJbXCJnXCJdID0gTWF0aC5tYXgoMCwgY3VycmVudEhpZmlBdWRpb0FQSURhdGEuaGlGaUdhaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiAoY3VycmVudEhpZmlBdWRpb0FQSURhdGEudXNlckF0dGVudWF0aW9uKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgZGF0YUZvck1peGVyW1wiYVwiXSA9IGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnVzZXJBdHRlbnVhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgKGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnVzZXJSb2xsb2ZmKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgZGF0YUZvck1peGVyW1wiclwiXSA9IE1hdGgubWF4KDAsIGN1cnJlbnRIaWZpQXVkaW9BUElEYXRhLnVzZXJSb2xsb2ZmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoY3VycmVudEhpZmlBdWRpb0FQSURhdGEuX290aGVyVXNlckdhaW5RdWV1ZSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgbGV0IGNoYW5nZWRVc2VyR2FpbnM6IE90aGVyVXNlckdhaW5NYXAgPSB7fTtcbiAgICAgICAgICAgIGxldCBpZFRvR2FpbnMgPSBPYmplY3QuZW50cmllcyhjdXJyZW50SGlmaUF1ZGlvQVBJRGF0YS5fb3RoZXJVc2VyR2FpblF1ZXVlKTtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c090aGVyVXNlckdhaW5zID0gcHJldmlvdXNIaWZpQXVkaW9BUElEYXRhID8gcHJldmlvdXNIaWZpQXVkaW9BUElEYXRhLl9vdGhlclVzZXJHYWluUXVldWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkVG9HYWluIG9mIGlkVG9HYWlucykge1xuICAgICAgICAgICAgICAgIGxldCBoYXNoZWRWaXNpdElkID0gaWRUb0dhaW5bMF07XG4gICAgICAgICAgICAgICAgbGV0IGdhaW4gPSBpZFRvR2FpblsxXTtcbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YoZ2FpbikgPT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c090aGVyVXNlckdhaW5zICYmIHByZXZpb3VzT3RoZXJVc2VyR2FpbnNbaGFzaGVkVmlzaXRJZF0gPT09IGdhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYW5nZWRVc2VyR2FpbnNbaGFzaGVkVmlzaXRJZF0gPSBnYWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmVudHJpZXMoY2hhbmdlZFVzZXJHYWlucykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGF0YUZvck1peGVyW1wiVlwiXSA9IGNoYW5nZWRVc2VyR2FpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGF0YUZvck1peGVyKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbGwgdGhpcyBhIFwic3VjY2Vzc1wiIGV2ZW4gdGhvdWdoIHdlIGRpZG4ndCBzZW5kIGFueXRoaW5nIHRvIHRoZSBtaXhlci5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllZERhdGFGb3JNaXhlcjogSlNPTi5zdHJpbmdpZnkoe30pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbW1hbmRDb250cm9sbGVyID0gdGhpcy5fcmF2aVNlc3Npb24uZ2V0Q29tbWFuZENvbnRyb2xsZXIoKTtcblxuICAgICAgICAgICAgaWYgKGNvbW1hbmRDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0cmluZ2lmaWVkRGF0YUZvck1peGVyID0gSlNPTi5zdHJpbmdpZnkoZGF0YUZvck1peGVyKTtcbiAgICAgICAgICAgICAgICBjb21tYW5kQ29udHJvbGxlci5zZW5kSW5wdXQoc3RyaW5naWZpZWREYXRhRm9yTWl4ZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVkRGF0YUZvck1peGVyOiBzdHJpbmdpZmllZERhdGFGb3JNaXhlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYENhbid0IHRyYW5zbWl0IGRhdGEgdG8gbWl4ZXI7IG5vIFxcYGNvbW1hbmRDb250cm9sbGVyXFxgIS5gXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBvdXIgXCJNaXhlciBJbmZvXCIuIEhhcHBlbnMgdXBvbiBpbnN0YW50aWF0aW9uIGFuZCB3aGVuIGRpc2Nvbm5lY3RpbmcgZnJvbSB0aGUgbWl4ZXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfcmVzZXRNaXhlckluZm8oKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWl4ZXJJbmZvID0ge1xuICAgICAgICAgICAgXCJjb25uZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiLyoqXG4gKiBUaGlzIG1vZHVsZSBwZXJ0YWlucyB0byBVc2VyIERhdGEgU3Vic2NyaXB0aW9ucywgd2hpY2ggYWxsb3cgY2xpZW50cyB0byByZWNlaXZlIHVwZGF0ZXMgZnJvbSB0aGUgU2VydmVyIGFib3V0IGFsbCBuZXcgVXNlciBEYXRhLlxuICogU2VlIFtbYWRkVXNlckRhdGFTdWJzY3JpcHRpb25dXS5cbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5cbi8qKlxuICogV2hlbiBhZGRpbmcgYSBuZXcgVXNlciBEYXRhIFN1YnNjcmlwdGlvbiwgYSBjbGllbnQgbXVzdCBzcGVjaWZ5IG9uZSBvZiB0aGUgXCJjb21wb25lbnRzXCIgbGlzdGVkIGFzIGEgcGFydCBvZiB0aGlzIGBlbnVtYC5cbiAqIEZvciBleGFtcGxlLCBzdWJzY3JpYmluZyB0byBgUG9zaXRpb25gIHVwZGF0ZXMgZW5zdXJlcyB0aGF0IGEgU3Vic2NyaWJlciB3aWxsIHJlY2VpdmUgYWxsIGNoYW5nZXMgdG8gdGhhdCB1c2VyJ3MgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBlbnVtIEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cyB7XG4gICAgUG9zaXRpb24gPSBcIlBvc2l0aW9uXCIsXG4gICAgT3JpZW50YXRpb25FdWxlciA9IFwiT3JpZW50YXRpb24gKEV1bGVyKVwiLFxuICAgIE9yaWVudGF0aW9uUXVhdCA9IFwiT3JpZW50YXRpb24gKFF1YXRlcm5pb24pXCIsXG4gICAgVm9sdW1lRGVjaWJlbHMgPSBcIlZvbHVtZSAoRGVjaWJlbHMpXCIsXG4gICAgSXNTdGVyZW8gPSBcIklzU3RlcmVvXCJcbn1cblxuLyoqXG4gKiBVc2VyIERhdGEgU3Vic2NyaXB0aW9ucyBhbGxvdyBjbGllbnQgQVBJIHVzZXJzIHRvIHBlcmZvcm0gYWN0aW9ucywgc3VjaCBhcyBsb2dnaW5nLCB3aGVuIHRoZSBjbGllbnRcbiAqIHJlY2VpdmVzIG5ldyBVc2VyIERhdGEgZnJvbSB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBBUEkgU2VydmVyLlxuICovXG5leHBvcnQgY2xhc3MgVXNlckRhdGFTdWJzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSB1c2VyJ3MgYHByb3ZpZGVkVXNlcklEYCBhc3NvY2lhdGVkIHdpdGggdGhlIFN1YnNjcmlwdGlvbi4gU2VlIHtAbGluayBIaUZpQXVkaW9BUElEYXRhfS4gT3B0aW9uYWwuIElmIHVuc2V0LCB0aGUgU3Vic2NyaXB0aW9uIGNhbGxiYWNrXG4gICAgICogd2lsbCBiZSBjYWxsZWQgZm9yIGFsbCB1c2VycycgZGF0YSB3aGVuIGl0IGNoYW5nZXMuXG4gICAgICovXG4gICAgcHJvdmlkZWRVc2VySUQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgVXNlciBEYXRhIGNvbXBvbmVudHMgdG8gd2hpY2ggd2Ugd2FudCB0byBzdWJzY3JpYmUsIHN1Y2ggYXMgUG9zaXRpb24sIE9yaWVudGF0aW9uRXVsZXIsIG9yIFZvbHVtZURlY2liZWxzLlxuICAgICAqL1xuICAgIGNvbXBvbmVudHM6IEFycmF5PEF2YWlsYWJsZVVzZXJEYXRhU3Vic2NyaXB0aW9uQ29tcG9uZW50cz47XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgY2xpZW50IHJlY2VpdmVzIG5ldyBVc2VyIERhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBgY29tcG9uZW50YCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogVGhlIGZpcnN0IGFuZCBvbmx5IGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIG9mIHR5cGUgYEFycmF5PFJlY2VpdmVkSGlGaUF1ZGlvQVBJRGF0YT5gLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiBGdW5jdGlvbjtcbiAgICBcbiAgICBjb25zdHJ1Y3Rvcih7IHByb3ZpZGVkVXNlcklEID0gbnVsbCwgY29tcG9uZW50cywgY2FsbGJhY2sgfTogeyBwcm92aWRlZFVzZXJJRD86IHN0cmluZywgY29tcG9uZW50czogQXJyYXk8QXZhaWxhYmxlVXNlckRhdGFTdWJzY3JpcHRpb25Db21wb25lbnRzPiwgY2FsbGJhY2s6IEZ1bmN0aW9uIH0pIHtcbiAgICAgICAgdGhpcy5wcm92aWRlZFVzZXJJRCA9IHByb3ZpZGVkVXNlcklEO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxufSIsIi8qKlxuICogVGhpcyBtb2R1bGUgZGVmaW5lcyBhIG51bWJlciBvZiBjb25zdGFudHMgdXNlZCB0aHJvdWdob3V0IHRoZSBBUEkgY29kZS5cbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5cbi8qKlxuICogRGVmaW5lcyBhIG51bWJlciBvZiBjb25zdGFudHMgdXNlZCB0aHJvdWdob3V0IHRoZSBBUEkgY29kZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEhpRmlDb25zdGFudHMge1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIG1pbmltdW0gYW1vdW50IG9mIHRpbWUgdGhhdCBtdXN0IHBhc3MgYmV0d2VlbiBBUEkgdHJhbnNtaXNzaW9uXG4gICAgICogb2YgZGF0YSBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgTUlOX1RSQU5TTUlUX1JBVEVfTElNSVRfVElNRU9VVF9NUzogbnVtYmVyID0gMTA7XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgZGVmYXVsdCBhbW91bnQgb2YgdGltZSB0aGF0IG11c3QgcGFzcyBiZXR3ZWVuIEFQSSB0cmFuc21pc3Npb25cbiAgICAgKiBvZiBkYXRhIGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIHN0YXRpYyBERUZBVUxUX1RSQU5TTUlUX1JBVEVfTElNSVRfVElNRU9VVF9NUzogbnVtYmVyID0gNTA7XG4gICAgLyoqXG4gICAgICogVGhlIHByb2R1Y3Rpb24gZW5kcG9pbnQgZm9yIG91ciBIaWdoIEZpZGVsaXR5IGF1ZGlvIGNvbm5lY3Rpb25zLlxuICAgICAqL1xuICAgIHN0YXRpYyBERUZBVUxUX1BST0RfSElHSF9GSURFTElUWV9FTkRQT0lOVDogc3RyaW5nID0gXCJhcGkuaGlnaGZpZGVsaXR5LmNvbVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHBvcnQgZm9yIHNpZ25hbGluZyBjb25uZWN0aW9ucyB0byBvdXIgSGlnaCBGaWRlbGl0eSBhdWRpbyBzZXJ2ZXJzLlxuICAgICAqL1xuICAgIHN0YXRpYyBERUZBVUxUX1BST0RfSElHSF9GSURFTElUWV9QT1JUOiBudW1iZXIgPSA0NDM7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHt9XG59O1xuIiwiaW1wb3J0IHsgSGlGaU1peGVyU2Vzc2lvbiB9IGZyb20gXCIuLi9jbGFzc2VzL0hpRmlNaXhlclNlc3Npb25cIjtcbmltcG9ydCB7IFJhdmlTZXNzaW9uLCBTVEFUU19XQVRDSEVSX0ZJTFRFUiB9IGZyb20gXCIuLi9saWJyYXZpL1JhdmlTZXNzaW9uXCI7XG5cbmNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuY29uc3Qgbm9vcCA9IChfOmFueSk6YW55ID0+IHVuZGVmaW5lZDtcbmNvbnN0IHhTdG9yYWdlID0gaXNCcm93c2VyID8gd2luZG93LmxvY2FsU3RvcmFnZSA6IHtnZXRJdGVtOiBub29wLCBzZXRJdGVtOiBub29wLCByZW1vdmVJdGVtOiBub29wfTtcbmNvbnN0IHhBZGRFdmVudExpc3RlbmVyOmFueSA9IGlzQnJvd3NlciA/IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIDogbm9vcDtcbmNvbnN0IHhSZW1vdmVFdmVudExpc3RlbmVyOmFueSA9IGlzQnJvd3NlciA/IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyIDogbm9vcDtcbmNvbnN0IHhEb2N1bWVudCA9IGlzQnJvd3NlciA/IHdpbmRvdy5kb2N1bWVudCA6IHt2aXNpYmlsaXR5U3RhdGU6IHRydWUsIGFkZEV2ZW50TGlzdGVuZXI6IG5vb3AsIHJlbW92ZUV2ZW50TGlzdGVuZXI6IG5vb3B9O1xuY29uc3QgeE5hdmlnYXRvciA9IGlzQnJvd3NlciA/IHdpbmRvdy5uYXZpZ2F0b3IgOiB7b25MaW5lOiB0cnVlLCB1c2VyQWdlbnQ6IGBOb2RlSlMgJHsocHJvY2Vzcy5yZXBvcnQuZ2V0UmVwb3J0KCkgYXMgYW55KS5oZWFkZXIubm9kZWpzVmVyc2lvbn1gfTtcbmxldCB4ZmV0Y2ggPSBpc0Jyb3dzZXIgJiYgd2luZG93LmZldGNoO1xuaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICB0cnkge1xuICAgICAgICB4ZmV0Y2ggPSByZXF1aXJlKCdub2RlLWZldGNoJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICA7IC8vIFJlbWFpbnMgZmFsc2V5LiBEb24ndCByZXBvcnQsIGRvbid0IGxvZ1xuICAgIH1cbn1cblxuY29uc3Qgbm9uT3BlcmF0aXZlID0gXCJub24tb3BlcmF0aXZlXCI7XG5cblNUQVRTX1dBVENIRVJfRklMVEVSLnNldCgncmVtb3RlLWluYm91bmQtcnRwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTVEFUU19XQVRDSEVSX0ZJTFRFUi5nZXQoJ3JlbW90ZS1pbmJvdW5kLXJ0cCcpLmNvbmNhdChbJ3BhY2tldHNMb3N0JywgJ3RvdGFsUm91bmRUcmlwVGltZSddKSk7XG5TVEFUU19XQVRDSEVSX0ZJTFRFUi5zZXQoJ2luYm91bmQtcnRwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTVEFUU19XQVRDSEVSX0ZJTFRFUi5nZXQoJ2luYm91bmQtcnRwJykuY29uY2F0KFsncGFja2V0c0xvc3QnLCAncGFja2V0c1JlY2VpdmVkJywgJ2ppdHRlciddKSk7XG5TVEFUU19XQVRDSEVSX0ZJTFRFUi5zZXQoJ291dGJvdW5kLXJ0cCcsIFsndHlwZScsICdyZXRyYW5zbWl0dGVkUGFja2V0c1NlbnQnLCAncGFja2V0c1NlbnQnXSk7XG5cblNUQVRTX1dBVENIRVJfRklMVEVSLnNldCgnY2FuZGlkYXRlLXBhaXInLCBbJ3dyaXRhYmxlJywgJ3N0YXRlJywgJ25vbWluYXRlZCcsICdsb2NhbENhbmRpZGF0ZUlkJywgJ3JlbW90ZUNhbmRpZGF0ZUlkJ10pO1xuU1RBVFNfV0FUQ0hFUl9GSUxURVIuc2V0KCdyZW1vdGUtY2FuZGlkYXRlJywgWydpZCcsICdhZGRyZXNzJywgJ2lwJywgJ2NhbmRpZGF0ZVR5cGUnLCAncHJvdG9jb2wnXSk7XG5TVEFUU19XQVRDSEVSX0ZJTFRFUi5zZXQoJ2xvY2FsLWNhbmRpZGF0ZScsIFsnaWQnLCAnYWRkcmVzcycsICdpcCcsICdjYW5kaWRhdGVUeXBlJywgJ3Byb3RvY29sJ10pO1xuXG5pbnRlcmZhY2UgQ2FuZGlkYXRlUmVwb3J0IHtcbiAgICBpcD86IHN0cmluZztcbiAgICBhZGRyZXNzPzogc3RyaW5nO1xuICAgIGNhbmRpZGF0ZVR5cGU/OiBzdHJpbmc7XG4gICAgcHJvdG9jb2w/OiBzdHJpbmc7XG59XG5sZXQgblN0YXRzQ2xpZW50cyA9IDA7XG5sZXQgYnJvd3NlclN0YXRzOiBDYW5kaWRhdGVSZXBvcnQgPSB7fTtcbmxldCByZW1vdGVTdGF0czogQ2FuZGlkYXRlUmVwb3J0ID0ge307XG5sZXQgcmVwb3J0czphbnk7XG5jb25zdCB1c2VEZWJ1Z1ByZWZpeGVzID0gZmFsc2U7XG5cbi8qKiBcbiAqIEBpbnRlcm5hbFxuICogVGhpcyBpcyBub3QgZ2VuZXJhbCBwdXJwb3NlLCBidXQgc3BlY2lmaWNhbGx5IGluIHN1cHBvcnQgb2YgaW50ZXJuYWwgSGlGaWRlbGl0eSBjb25uZWN0aW9uIGZhaWx1cmVzLlxuICogSXQgaXMgbm90IGludGVuZGVkIHRvIGJlIHN1cHBvcnRlZCBmb3IgbG9uZyB0ZXJtLlxuICpcbiAqIEFuIGluc3RhbmNlIG9mIERpYWdub3N0aWNzIG1haW50YWlucyBhIHNldCBvZiBpbmZvcm1hdGlvbiwgYW5kIGhhcyBvcGVyYXRpb25zIHRvIHVwZGF0ZSB0aGF0IGluZm9ybWF0aW9uLCBhbmQgdG8gcmVwb3J0IGl0LlxuICogVGhlcmUgY2FuIGJlIG11bHRpcGxlIHN1Y2ggaW5zdGFuY2VzLCB0aGF0IGFyZSByZXBvcnRlZCBpbiBkaWZmZXJlbnQgY2lyY3Vtc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIERpYWdub3N0aWNzIHtcbiAgICBsYWJlbDogc3RyaW5nO1xuICAgIHVybDogc3RyaW5nO1xuICAgIGlkZW50aWZpZXI6IHN0cmluZztcbiAgICBzZXNzaW9uOiBIaUZpTWl4ZXJTZXNzaW9uO1xuICAgIHJhdmk6IFJhdmlTZXNzaW9uO1xuICAgIGV4cGxpY2l0QXBwbGljYXRpb25DbG9zZTogYm9vbGVhbjtcbiAgICB3ZWJTb2NrZXQ6IGFueTtcbiAgICBydGM6IGFueTtcbiAgICBmaXJlT246IEFycmF5PHN0cmluZz47XG4gICAgZmlyZUxpc3RlbmVyOiBGdW5jdGlvbjtcbiAgICBvbmxpbmVMaXN0ZW5lcjogRnVuY3Rpb247XG5cbiAgICBjb25zdHJ1Y3Rvcih7dXJsID0gXCJodHRwczovL3dlYnJ0Yy1kaWFnLmhpZ2hmaWRlbGl0eS5jb20vYXBpL3YxL2xvZ3MvcG9zdF9sb2dzXCIsXG4gICAgICAgICAgICAgICAgIGxhYmVsLCBzZXNzaW9uLCByYXZpLCBmaXJlT24gPSBbXX06e3VybD86c3RyaW5nLCBsYWJlbDpzdHJpbmcsIHNlc3Npb246SGlGaU1peGVyU2Vzc2lvbiwgcmF2aTpSYXZpU2Vzc2lvbiwgZmlyZU9uPzpBcnJheTxzdHJpbmc+fSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHt1cmwsIGxhYmVsLCBzZXNzaW9uLCByYXZpLCBmaXJlT259KTtcbiAgICAgICAgdGhpcy5jaGVja1BlcnNpc3RlZCgpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZmlyZUxpc3RlbmVyID0gKCkgPT4gdGhpcy5maXJlKCk7XG4gICAgICAgIHRoaXMub25saW5lTGlzdGVuZXIgPSAoKSA9PiB0aGlzLmNoZWNrUGVyc2lzdGVkKCk7XG4gICAgfVxuICAgIC8qKiBcbiAgICAgKiBBbiBpbnN0YW5jZSBpcyBwcmltZWQgd2hlbiBlbnRlcmluZyB0aGUgc3RhdGUgd2UgYXJlIGludGVyZXN0ZWQgaW4sIHVudGlsIHRoZSByZXBvcnQgaXMgZmlyZWQuXG4gICAgICovXG4gICAgcHJpbWUoaWRlbnRpZmllcjpzdHJpbmcpIHsgLy8gZS5nLiwgaGFzaGVkVmlzaXRJRC4gRG8gTk9UIHVzZSBhbnkgcGVyc29uYWxseSBpZGVudGlmaWFibGUgaW5mb3JtYXRpb24uIERhdGEgaXMgYSBsaWFiaWxpdHksIG5vdCBhbiBhc3NldC5cbiAgICAgICAgaWYgKHRoaXMuaXNQcmltZWQoKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLmNoZWNrUGVyc2lzdGVkKCk7IC8vIEJlY2F1c2UgdGhpcyBpcyBhIGxpa2VseSB0aW1lIHRvIGJlIHN1Y2Nlc3NmdWwuXG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG4gICAgICAgIHRoaXMuZ3JhYlJUQ0ludGVybmFscygpO1xuICAgICAgICBEaWFnbm9zdGljcy5zdGFydFN0YXRzKHRoaXMuc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuZmlyZU9uLmZvckVhY2goZXZlbnQgPT4gKHhEb2N1bWVudCBhcyBhbnkpLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuZmlyZUxpc3RlbmVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuIHdlIGdldCBpbnRvIGEgc3RhdGUgdGhhdCB3ZSB3YW50IHRvIGtub3cgbW9yZSBhYm91dCwgZS5nLiwgd2hlbiBsZWF2aW5nIHRoZSB0aGluZyB0aGF0IGNhdXNlZCB1cyB0byBwcmltZSgpLlxuICAgICAqL1xuICAgIGFzeW5jIGZpcmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ByaW1lZCgpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHJlcG9ydFN0cmluZyA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKCEgYXdhaXQgdGhpcy5yZXBvcnQocmVwb3J0U3RyaW5nKSkge1xuICAgICAgICAgICAgdGhpcy5wZXJzaXN0KHJlcG9ydFN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgbm90ZUV4cGxpY2l0QXBwbGljYXRpb25DbG9zZSgpIHtcbiAgICAgICAgdGhpcy5leHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2UgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIE1vc3RseSBpbnRlcm5hbCBzdHVmZi5cbiAgICAvLyBzdGF0ZS4uLlxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBwcmltZSgpLiBVc3VhbGx5IGludGVybmFsIHRvIHRoZSBvcGVyYXRpb25zIG9mIHRoZSBEaWFnbm9zdGljcywgYnV0IGNhbiBiZSBjYWxsZWQgZnJvbSBvdXRzaWRlLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBEaWFnbm9zdGljcy5zdG9wU3RhdHModGhpcy5zZXNzaW9uKTtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gbm9uT3BlcmF0aXZlO1xuICAgICAgICB0aGlzLmV4cGxpY2l0QXBwbGljYXRpb25DbG9zZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLndlYlNvY2tldCA9IHRoaXMucnRjID0ge307XG4gICAgICAgIC8vIGRvbid0IGxlYXZlIHRoZW0gaGFuZ2luZyBhcm91bmQuIEUuZy4sIGJlZm9yZXVubG9hZCBjYW4gbWVzcyB3aXRoIHRoZSBiZmNhY2hlLlxuICAgICAgICB0aGlzLmZpcmVPbi5mb3JFYWNoKGV2ZW50ID0+ICh4RG9jdW1lbnQgYXMgYW55KS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmZpcmVMaXN0ZW5lcikpO1xuICAgICAgICByZXBvcnRzID0ge1xuICAgICAgICAgICAgJ291dGJvdW5kLXJ0cCc6IHt9LFxuICAgICAgICAgICAgJ2luYm91bmQtcnRwJzoge30sXG4gICAgICAgICAgICAncmVtb3RlLWluYm91bmQtcnRwJzoge31cbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1ByaW1lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpZmllciAhPT0gbm9uT3BlcmF0aXZlO1xuICAgIH1cbiAgICAvLyBzdHJpbmdzLi4uXG4gICAgLyoqXG4gICAgICogQW5zd2VyIGEgc2luZ2xlIChsb25nKSBsb2cgbGluZSB0byByZXBvcnQuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9ICR7dGhpcy5pZGVudGlmaWVyfSBhcHBsb2dSZWFzb25fc2Vzc2lvbkVORGAgK1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdHMoJ2Jyb3dzZXJTdGF0cycpICtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXRzKCdtaXhlclN0YXRzJykgK1xuICAgICAgICAgICAgdGhpcy5ydHBTdGF0cygpICtcbiAgICAgICAgICAgIHRoaXMucnRjU3RhdGVzKCkgK1xuICAgICAgICAgICAgdGhpcy5zKCdOVU1fQ09OTkVDVEVEJywgdGhpcy5zZXNzaW9uLmNvbmN1cnJlbmN5LCAnXFxuJykgK1xuICAgICAgICAgICAgdGhpcy5zKCdBUFBTVEFURScsIHRoaXMuc2Vzc2lvbi5nZXRDdXJyZW50SGlGaUNvbm5lY3Rpb25TdGF0ZSgpLCAnXFxuJykgK1xuICAgICAgICAgICAgdGhpcy5zKCdSQVZJU1RBVEUnLCB0aGlzLnJhdmkuZ2V0U3RhdGUoKSkgK1xuICAgICAgICAgICAgdGhpcy5zKCdPTkxJTkUnLCB4TmF2aWdhdG9yLm9uTGluZSA/ICd5ZXMnIDogJ25vJykgK1xuICAgICAgICAgICAgdGhpcy5zKCdYUExJQ0lUQ0xPU0VEJywgdGhpcy5leHBsaWNpdEFwcGxpY2F0aW9uQ2xvc2UgPyAneWVzJyA6ICdubycpICtcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eUluZm8oKSArXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JbmZvKCkgK1xuICAgICAgICAgICAgKHVzZURlYnVnUHJlZml4ZXMgPyAnXFxuJyA6ICcnKSArXG4gICAgICAgICAgICBgIFske3hOYXZpZ2F0b3IudXNlckFnZW50fV1gO1xuICAgIH1cbiAgICBzKG5hbWU6c3RyaW5nLCB2YWx1ZTphbnksIGRlYnVnUHJlZml4ID0gJycpIHtcbiAgICAgICAgbGV0IHNlcGFyYXRvciA9IGlzTmFOKHZhbHVlKSA/ICdfJyA6ICc6JztcbiAgICAgICAgcmV0dXJuIGAke3VzZURlYnVnUHJlZml4ZXMgPyBkZWJ1Z1ByZWZpeCA6ICcnfSAke3RoaXMubGFiZWx9JHtuYW1lfSR7c2VwYXJhdG9yfSR7dmFsdWV9YDtcbiAgICB9XG4gICAgY29ubmVjdGlvbkluZm8oKSB7XG4gICAgICAgIGNvbnN0IGluZm86YW55ID0gKHhOYXZpZ2F0b3IgYXMgYW55KS5jb25uZWN0aW9uIHx8ICh4TmF2aWdhdG9yIGFzIGFueSkubW96Q29ubmVjdGlvbiB8fCAoeE5hdmlnYXRvciBhcyBhbnkpLndlYmtpdENvbm5lY3Rpb24gfHwge307XG4gICAgICAgIHJldHVybiB0aGlzLnMoJ0RFVklDRScsIGluZm8udHlwZSwgJ1xcbicpICtcbiAgICAgICAgICAgIHRoaXMucygnUkFUSU5HJywgaW5mby5lZmZlY3RpdmVUeXBlKSArXG4gICAgICAgICAgICB0aGlzLnMoJ0RMJywgaW5mby5kb3dubGluaykgK1xuICAgICAgICAgICAgdGhpcy5zKCdSVFQnLCBpbmZvLnJ0dCk7XG4gICAgfVxuICAgIHZpc2liaWxpdHlJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zKCdWSVNJQkxJVFknLCB4RG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSBmaXJlLCBJJ2QgbGlrZSB0byBkaXJlY3RseSBhc2sgdGhlIFJUQ1BlZXJDb25uZWN0aW9uIGFuZCBvdXIgc2lnbmFsaW5nIFdlYlNvY2tldCBzb21lIHF1ZXN0aW9ucywgYXMgYSBzYW5pdHkgY2hlY2tcbiAgICAgKiB0aGF0IHRoaW5ncyBtYXRjaCB0aGUgUmF2aSBzdGF0ZS4gQnV0IGlmIGFsbCBnb2VzIHdlbGwsIHdlJ3ZlIGFscmVhZHkgcmVsZWFzZWQgdGhlbS4gU28gaGVyZSB3ZSBncmFiIHRoZW0gd2hpbGUgd2UgY2FuIGFuZFxuICAgICAqIGhvbGQgb3VyIG93biByZWZlcmVuY2VzLCB0byBiZSBjbGVhcmVkIG9uIHJlc2V0KCk7XG4gICAgICovIFxuICAgIGdyYWJSVENJbnRlcm5hbHMoKSB7XG4gICAgICAgIGxldCByYXZpOmFueSA9IHRoaXMucmF2aSxcbiAgICAgICAgICAgIHJhdmlSVEM6YW55ID0gcmF2aS5fcmF2aUltcGxlbWVudGF0aW9uLFxuICAgICAgICAgICAgc2lnbmFsaW5nOmFueSA9IHJhdmlSVEMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24uX3NpZ25hbGluZ0ltcGxlbWVudGF0aW9uO1xuICAgICAgICB0aGlzLndlYlNvY2tldCA9IHNpZ25hbGluZy5fd2ViU29ja2V0O1xuICAgICAgICB0aGlzLnJ0YyA9IHJhdmlSVEMuX3J0Y0Nvbm5lY3Rpb247XG4gICAgfVxuICAgIHJ0Y1N0YXRlcygpIHtcbiAgICAgICAgLy8gVGhpcyBiaXphcnJlIHBhdHRlcm4gaXMgdG8gZ2V0IGFzIG11Y2ggaW5mbyBhcyBwb3NzaWJsZSwgZXZlbiBmcm9tIGJyb3dzZXJzIHN1Y2ggYXMgRmlyZWZveCB0aGF0XG4gICAgICAgIC8vIHRocm93IGVycm9ycyBmb3Igc29tZSBwcm9wZXJ0aWVzLlxuICAgICAgICBsZXQgY29sbGVjdG9yOmFueSA9IHt9LFxuICAgICAgICAgICAgc2FmZWx5R2V0ID0gKHByb3BlcnR5OnN0cmluZywgc291cmNlOmFueSA9IHRoaXMucnRjKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdG9yW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3JbcHJvcGVydHldID0gZS5uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIHNhZmVseUdldCgncmVhZHlTdGF0ZScsIHRoaXMud2ViU29ja2V0KTtcbiAgICAgICAgWydjb25uZWN0aW9uU3RhdGUnLCAnc2lnbmFsaW5nU3RhdGUnLCAnaWNlQ29ubmN0aW9uU3RhdGUnLCdpY2VHYXRoZXJpbmdTdGF0ZSddLmZvckVhY2gocCA9PiBzYWZlbHlHZXQocCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zKCdXZWJTb2NrZXQnLCBjb2xsZWN0b3IucmVhZHlTdGF0ZSwgJ1xcbicpICtcbiAgICAgICAgICAgIHRoaXMucygnUlRDJywgY29sbGVjdG9yLmNvbm5lY3Rpb25TdGF0ZSkgK1xuICAgICAgICAgICAgdGhpcy5zKCdTSUdOQUxJTkcnLCBjb2xsZWN0b3Iuc2lnbmFsaW5nU3RhdGUpICtcbiAgICAgICAgICAgIHRoaXMucygnSUNFJywgY29sbGVjdG9yLmljZUNvbm5lY3Rpb25TdGF0ZSkgK1xuICAgICAgICAgICAgdGhpcy5zKCdHQVRIRVJJTkcnLCBjb2xsZWN0b3IuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgIH1cbiAgICBjb25uZWN0aW9uU3RhdHMoa2luZDpzdHJpbmcpIHtcbiAgICAgICAgbGV0IHJlcG9ydCA9IGtpbmQgPT09ICdicm93c2VyU3RhdHMnID8gIGJyb3dzZXJTdGF0cyA6IHJlbW90ZVN0YXRzO1xuICAgICAgICByZXR1cm4gdGhpcy5zKGtpbmQrJ0lQJywgcmVwb3J0LmlwIHx8IHJlcG9ydC5hZGRyZXNzLCAnXFxuJykgK1xuICAgICAgICAgICAgdGhpcy5zKGtpbmQrJ1RZUEUnLCByZXBvcnQuY2FuZGlkYXRlVHlwZSkgK1xuICAgICAgICAgICAgdGhpcy5zKGtpbmQrJ1BST1RPQ09MJywgcmVwb3J0LnByb3RvY29sKTtcbiAgICB9XG4gICAgcnRwU3RhdHMoKSB7XG4gICAgICAgIGxldCBzOnN0cmluZyA9ICcnO1xuICAgICAgICBPYmplY3Qua2V5cyhyZXBvcnRzKS5mb3JFYWNoKHJlcG9ydE5hbWUgPT4ge1xuICAgICAgICAgICAgbGV0IHJlcG9ydCA9IHJlcG9ydHNbcmVwb3J0TmFtZV0sXG4gICAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocmVwb3J0KS5mb3JFYWNoKHByb3BlcnR5TmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgcyArPSB0aGlzLnMoYCR7cmVwb3J0TmFtZX1fJHtwcm9wZXJ0eU5hbWV9YCwgcmVwb3J0W3Byb3BlcnR5TmFtZV0sIGZpcnN0ID8gJ1xcbicgOiAnJyk7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIFxuICAgIC8vIFBob25pbmcgaG9tZS4uLlxuICAgIC8qKlxuICAgICAqIFJldHVybiBzdWNjZXNzLCBvciBhIHByb21pc2UgZm9yIHN1Y2Nlc3MuXG4gICAgICovXG4gICAgcmVwb3J0KHJlcG9ydFN0cmluZzpzdHJpbmcpIHtcbiAgICAgICAgaWYgKCF4TmF2aWdhdG9yLm9uTGluZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXhmZXRjaCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIGJlYWNvbiBpcyBzdWNjZXNzZnVsbHkgcXVldWVkLCBub3Qgc2VudC5cbiAgICAgICAgLy8gVWx0aW1hdGVseSwgd2Ugd291bGQgbmVlZCBhIHZlcmlmaWNhdGlvbiAoZS5nLiwgbmV4dCBzZXNzaW9uKSB0byBzZWUgaWYgdGhlIHByZXZpb3VzIGlkZW50aWZpZXIgd2FzIGxvZ2dlZC5cbiAgICAgICAgLy8gQSBmYWlsdXJlIGdldHMgbG9nZ2VkIHRvIGNvbnNvbGUgaW4gc29tZSBicm93c2VycywgYnV0IHRoZXkgZG9uJ3QgYWN0dWFsbHkgZW1pdCBhbiBlcnJvciBldmVudC5cbiAgICAgICAgLy8gcmV0dXJuIG5hdmlnYXRvci5zZW5kQmVhY29uKHRoaXMudXJsLCByZXBvcnRTdHJpbmcpO1xuICAgICAgICAvLyBJbnN0ZWFkLCBsZXQncyBQT1NUIGV4YWN0bHkgYXMgc2VuZEJlYWNvbiB3b3VsZCwgYW5kIGNoZWNrIHN1Y2Nlc3M6XG4gICAgICAgIHJldHVybiB4ZmV0Y2godGhpcy51cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ3RleHQvcGxhaW4nIH0sXG4gICAgICAgICAgICBib2R5OiByZXBvcnRTdHJpbmdcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2U6UmVzcG9uc2UpID0+IHJlc3BvbnNlLm9rLCAoeDphbnkpID0+IGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHJlcG9ydFN0cmluZyB0byB0aGUgc2V0IG9mIGRhdGEgYmVpbmcgc2F2ZWQgZm9yIGxhdGVyIHJlcG9ydGluZy5cbiAgICAgKi9cbiAgICBwZXJzaXN0KHJlcG9ydFN0cmluZzpzdHJpbmcpIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nID0geFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmxhYmVsKSB8fCBcIlwiO1xuICAgICAgICAvLyBCeSBjb25zdHJ1Y3Rpb24gZXhpc3RpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgZW1wdHkgb3Igb25lIGxpbmUuIEl0IGNvdWxkIGhhdmUgbXVsdGlwbGUgbGluZXMgaWZcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBidWcsIG9yIGlmIHRoZSBhcHBsaWNhdGlvbiBzaXRlIGxpbWl0cyB0aGUgY29ubmVjdC1zcmMgKG9yIGRlZmF1bHQtc3JjKVxuICAgICAgICAvLyBpbiBpdHMgQ29udGVudC1TZWN1cml0eS1Qb2xpY3kgaGVhZGVyIHdpdGhvdXQgYWxsb3dpbmcgdGhpcy51cmwuXG4gICAgICAgIC8vIElmIGl0IGlzIG1vcmUgdGhhbiBhIGxpbmUsIHdlIGFyZSBhY2N1bXVsYXRpbmcgc3R1ZmYgYW5kIHJlYWxseSBvdWdodCB0byBwaG9uZSBob21lIHRocm91Z2ggdGhlIG1peGVyIHdoZW4gY29ubmVjdGVkLlxuICAgICAgICBpZiAoZXhpc3RpbmcpIGV4aXN0aW5nICs9IFwiXFxuXCI7XG4gICAgICAgIHhTdG9yYWdlLnNldEl0ZW0odGhpcy5sYWJlbCwgZXhpc3RpbmcgKyByZXBvcnRTdHJpbmcpO1xuICAgICAgICAvLyBBbiBvcHRpbWl6YXRpb24gdG8gZ2V0IGNhdWdodCB1cCBvbiBkYXRhIHF1aWNrZXIgaW4gdGhlIGNhc2Ugd2hlcmUgbmV0d29yayBpcyBsb3N0IGFuZCByZXR1cm5zIHdoaWxlIHRhYiBpcyBzdGlsbCB1cC5cbiAgICAgICAgeEFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMub25saW5lTGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSdzIGFueXRoaW5nIHBlcnNpc3RlZCwgdHJ5IHRvIHJlcG9ydCBpdC4gSWYgc3VjY2Vzc2Z1bCwgY2xlYXIgcGVyc2lzdGVuY2UuXG4gICAgICovXG4gICAgYXN5bmMgY2hlY2tQZXJzaXN0ZWQoKSB7XG4gICAgICAgIHhSZW1vdmVFdmVudExpc3RlbmVyKCdvbmxpbmUnLCB0aGlzLm9ubGluZUxpc3RlbmVyKTtcbiAgICAgICAgbGV0IGV4aXN0aW5nID0geFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmxhYmVsKTtcbiAgICAgICAgaWYgKCFleGlzdGluZykgcmV0dXJuO1xuICAgICAgICBpZiAoISBhd2FpdCB0aGlzLnJlcG9ydChleGlzdGluZykpIHJldHVybjtcbiAgICAgICAgeFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmxhYmVsKTtcbiAgICB9XG4gICAgLy8gUlRDIHN0YXRzLi4uXG4gICAgLy8gUmF2aSBvbmx5IGFsbG93cyBvbmUgc3RhdHMgY29sbGVjdGlvbiBmdW5jdGlvbiBhdCBhIHRpbWUsIHNvIHdlJ2xsIGhhdmUgdG8gc2hhcmVcbiAgICAvLyBhbW9uZyBhbGwgdGhlIGRpYWdub3N0aWNzLlxuICAgIHN0YXRpYyBzdGFydFN0YXRzKHNlc3Npb246SGlGaU1peGVyU2Vzc2lvbikgeyAvLyBSZXN1bHRzIG5vdCBkZWZpbmVkIGlmIGNhbGxlZCB3aXRoIGRpZmZlcmVudCBzZXNzaW9uLlxuICAgICAgICBpZiAoblN0YXRzQ2xpZW50cysrID4gMCkgcmV0dXJuOyAvLyBTb21lb25lIHByaW1lZCBiZWZvcmUgdGhpcyBjYWxsIChhbmQgc2luY2UgdGhlIGZpbmFsIHJlc2V0KS5cbiAgICAgICAgc2Vzc2lvbi5zdGFydENvbGxlY3RpbmdXZWJSVENTdGF0cygobmV4dDphbnksIHByZXZpb3VzOmFueSkgPT4ge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gbmV4dC5maW5kKChyZXBvcnQ6YW55KSA9PiByZXBvcnQud3JpdGFibGUgfHwgcmVwb3J0Lm5vbWluYXRlZCksXG4gICAgICAgICAgICAgICAgbG9jYWxSZXBvcnQgPSBuZXh0LmZpbmQoKHJlcG9ydDphbnkpID0+IHJlcG9ydC5pZCA9PT0gc2VsZWN0ZWQubG9jYWxDYW5kaWRhdGVJZCksXG4gICAgICAgICAgICAgICAgcmVtb3RlUmVwb3J0ID0gbmV4dC5maW5kKChyZXBvcnQ6YW55KSA9PiByZXBvcnQuaWQgPT09IHNlbGVjdGVkLnJlbW90ZUNhbmRpZGF0ZUlkKTtcbiAgICAgICAgICAgIGlmIChsb2NhbFJlcG9ydCkgIGJyb3dzZXJTdGF0cyA9IGxvY2FsUmVwb3J0O1xuICAgICAgICAgICAgaWYgKHJlbW90ZVJlcG9ydCkgcmVtb3RlU3RhdHMgPSByZW1vdGVSZXBvcnQ7XG4gICAgICAgICAgICBmdW5jdGlvbiBub3RlKHR5cGU6c3RyaW5nLCBkZWx0YVByb3BlcnRpZXM6QXJyYXk8c3RyaW5nPiwgYWJzb2x1dGVQcm9wZXJ0aWVzOkFycmF5PHN0cmluZz4gPSBbXSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRSZXBvcnQobGlzdDphbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QuZmluZCgocmVwb3J0OmFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcG9ydC50eXBlID09IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXNSZXBvcnQgPSBmaW5kUmVwb3J0KHByZXZpb3VzKSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlcG9ydCA9IGZpbmRSZXBvcnQobmV4dCk7XG4gICAgICAgICAgICAgICAgZGVsdGFQcm9wZXJ0aWVzLmZvckVhY2gocHJvcGVydHkgPT4gcmVwb3J0c1t0eXBlXVtwcm9wZXJ0eV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXBvcnQgJiYgKG5leHRSZXBvcnRbcHJvcGVydHldIC0gKHByZXZpb3VzUmVwb3J0ID8gcHJldmlvdXNSZXBvcnRbcHJvcGVydHldIDogMCkpKTtcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVByb3BlcnRpZXMuZm9yRWFjaChwcm9wZXJ0eSA9PiByZXBvcnRzW3R5cGVdW3Byb3BlcnR5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJlcG9ydCAmJiBuZXh0UmVwb3J0W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3RlKCdvdXRib3VuZC1ydHAnLCBbJ3JldHJhbnNtaXR0ZWRQYWNrZXRzU2VudCcsICdwYWNrZXRzU2VudCddKTtcbiAgICAgICAgICAgIG5vdGUoJ2luYm91bmQtcnRwJywgWydwYWNrZXRzTG9zdCcsICdwYWNrZXRzUmVjZWl2ZWQnXSwgWydqaXR0ZXInXSk7XG4gICAgICAgICAgICBub3RlKCdyZW1vdGUtaW5ib3VuZC1ydHAnLCBbJ3BhY2tldHNMb3N0J10sIFsncm91bmRUcmlwVGltZScsICd0b3RhbFJvdW5kVHJpcFRpbWUnLCAnaml0dGVyJ10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHN0b3BTdGF0cyhzZXNzaW9uOkhpRmlNaXhlclNlc3Npb24pIHtcbiAgICAgICAgaWYgKCFuU3RhdHNDbGllbnRzKSByZXR1cm47XG4gICAgICAgIGlmICgtLW5TdGF0c0NsaWVudHMgPiAwKSByZXR1cm47ICAgLy8gU29tZW9uZSBpcyBzdGlsbCBwcmltZWQuICAgICBcbiAgICAgICAgc2Vzc2lvbi5zdG9wQ29sbGVjdGluZ1dlYlJUQ1N0YXRzKCk7XG4gICAgICAgIGJyb3dzZXJTdGF0cyA9IHJlbW90ZVN0YXRzID0ge307XG4gICAgfVxufVxuXG4iLCJkZWNsYXJlIHZhciBISUZJX0FQSV9WRVJTSU9OOiBzdHJpbmc7XG5cbi8vIENoZWNrIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHlcbmltcG9ydCB7IEhpRmlVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvSGlGaVV0aWxpdGllc1wiO1xuZXhwb3J0IHsgSGlGaVV0aWxpdGllcyB9O1xubGV0IGlzQnJvd3NlckNvbnRleHQgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCc7XG5pZiAoaXNCcm93c2VyQ29udGV4dCkge1xuICAgIEhpRmlVdGlsaXRpZXMuY2hlY2tCcm93c2VyQ29tcGF0aWJpbGl0eSgpO1xufVxubGV0IGFwaVZlcnNpb24gPSB0eXBlb2YgKEhJRklfQVBJX1ZFUlNJT04pID09PSBcInN0cmluZ1wiID8gSElGSV9BUElfVkVSU0lPTiA6IFwidW5rbm93blwiO1xuZXhwb3J0IHsgYXBpVmVyc2lvbiBhcyBoaUZpQVBJVmVyc2lvbiB9OyBcbmV4cG9ydCB7IGFwaVZlcnNpb24gfTsgXG5cblxuLy8gVmVyYm9zaXR5IGNhbiBiZSBnb29kIHNvbWV0aW1lcyFcbi8vIFRoZSBmaXJzdCBzZWN0aW9uIG9mIGBleHBvcnRgcyBoZXJlIGV4cG9zZSB0aGUgQ2xpZW50IExpYnJhcnkncyBlbnRyeSBwb2ludHNcbi8vIHVzaW5nIHZlcmJvc2UgbGFuZ3VhZ2UuIFRoaXMgdXN1YWxseSBtZWFucyB0aGF0IGV2ZXJ5IGVudHJ5IHBvaW50IGlzIHByZXBlbnRlZCB3aXRoIGBIaUZpYC5cbi8vIERvaW5nIHRoaXMgaGVscHMgcmVkdWNlIG5hbWVzcGFjZSBjb2xsaXNpb25zIGluIHVzZXIgYXBwbGljYXRpb25zLlxuLy8gU29tZSBwZW9wbGUgZG9uJ3Qgd2FudCB0byB0eXBlIGBIaUZpYCBldmVyeSB0aW1lIHRoZXkgd2FudCB0byB1c2Ugb3VyIENsaWVudCBMaWJyYXJ5LFxuLy8gc28gd2UgYWxzbyBvZmZlciBzaG9ydGVyIHN5bm9ueW1zIGZvciBldmVyeSBMaWJyYXJ5IGVudHJ5IHBvaW50LlxuLy8gU2Nyb2xsIGRvd24gdG8gY2hlY2sgb3V0IHRob3NlIHNob3J0ZXIgc3lub255bXMuXG5leHBvcnQgeyBIaUZpQXVkaW9BUElEYXRhLCBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEsIE9yaWVudGF0aW9uRXVsZXIzRCwgT3JpZW50YXRpb25RdWF0M0QsIFBvaW50M0QsIGV1bGVyVG9RdWF0ZXJuaW9uLCBldWxlckZyb21RdWF0ZXJuaW9ufSBmcm9tIFwiLi9jbGFzc2VzL0hpRmlBdWRpb0FQSURhdGFcIjtcbmV4cG9ydCB7IEhpRmlDb21tdW5pY2F0b3IsIEhpRmlDb25uZWN0aW9uU3RhdGVzLCBIaUZpVXNlckRhdGFTdHJlYW1pbmdTY29wZXMgfSBmcm9tIFwiLi9jbGFzc2VzL0hpRmlDb21tdW5pY2F0b3JcIjtcbmV4cG9ydCB7IFdlYlJUQ1Nlc3Npb25QYXJhbXMgfSBmcm9tIFwiLi9saWJyYXZpL1JhdmlTZXNzaW9uXCI7XG5leHBvcnQgeyBBdmFpbGFibGVVc2VyRGF0YVN1YnNjcmlwdGlvbkNvbXBvbmVudHMsIFVzZXJEYXRhU3Vic2NyaXB0aW9uIH0gZnJvbSBcIi4vY2xhc3Nlcy9IaUZpVXNlckRhdGFTdWJzY3JpcHRpb25cIjtcbmV4cG9ydCB7IEhpRmlMb2dMZXZlbCwgSGlGaUxvZ2dlciB9IGZyb20gXCIuL3V0aWxpdGllcy9IaUZpTG9nZ2VyXCI7XG5leHBvcnQgeyBIaUZpQ29uc3RhbnRzIH0gZnJvbSBcIi4vY29uc3RhbnRzL0hpRmlDb25zdGFudHNcIjtcbmV4cG9ydCB7IEhpRmlBeGVzLCBIaUZpSGFuZGVkbmVzcywgSGlGaUF4aXNDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4vY2xhc3Nlcy9IaUZpQXhpc0NvbmZpZ3VyYXRpb25cIjtcblxuLy8gSGVyZSBhcmUgdmFyaW91cyBleHBsaWNpdCBleHBvcnRzIGZyb20gd2l0aGluIHRoZSBgSGlGaVV0aWxpdGllc2AgY2xhc3MgZm9yIGNvbnZlbmllbmNlLlxubGV0IGdldEJlc3RBdWRpb0NvbnN0cmFpbnRzID0gSGlGaVV0aWxpdGllcy5nZXRCZXN0QXVkaW9Db25zdHJhaW50cztcbmV4cG9ydCB7IGdldEJlc3RBdWRpb0NvbnN0cmFpbnRzIH07XG5sZXQgcHJlY2lzZUludGVydmFsID0gSGlGaVV0aWxpdGllcy5wcmVjaXNlSW50ZXJ2YWw7XG5leHBvcnQgeyBwcmVjaXNlSW50ZXJ2YWwgfTtcblxuLy8gU2hvcnQgc3lub255bXMgZm9yIHRoZSBhYm92ZSBzdGFydCBoZXJlIVxuLy8gUGxlYXNlIGxldCB1cyBrbm93IGlmIGFueSBvZiB0aGVzZSBgZXhwb3J0c2AgY2F1c2UgbmFtZXNwYWNlIGNvbGxpc2lvbnNcbi8vIGluIHlvdXIgYXBwbGljYXRpb24uXG5leHBvcnQgeyBIaUZpQ29tbXVuaWNhdG9yIGFzIENvbW11bmljYXRvciwgSGlGaUNvbm5lY3Rpb25TdGF0ZXMgYXMgQ29ubmVjdGlvblN0YXRlcywgSGlGaVVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzIGFzIFVzZXJEYXRhU3RyZWFtaW5nU2NvcGVzIH0gZnJvbSBcIi4vY2xhc3Nlcy9IaUZpQ29tbXVuaWNhdG9yXCI7XG5leHBvcnQgeyBSZWNlaXZlZEhpRmlBdWRpb0FQSURhdGEgYXMgUmVjZWl2ZWRBdWRpb0FQSURhdGEsIEhpRmlBdWRpb0FQSURhdGEgYXMgQXVkaW9BUElEYXRhIH0gZnJvbSBcIi4vY2xhc3Nlcy9IaUZpQXVkaW9BUElEYXRhXCI7XG5leHBvcnQgeyBIaUZpTG9nZ2VyIGFzIExvZ2dlciwgSGlGaUxvZ0xldmVsIGFzIExvZ0xldmVsIH0gZnJvbSBcIi4vdXRpbGl0aWVzL0hpRmlMb2dnZXJcIjtcbmV4cG9ydCB7IEhpRmlVdGlsaXRpZXMgYXMgVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL0hpRmlVdGlsaXRpZXNcIjtcbmV4cG9ydCB7IEhpRmlDb25zdGFudHMgYXMgQ29uc3RhbnRzIH0gZnJvbSBcIi4vY29uc3RhbnRzL0hpRmlDb25zdGFudHNcIjtcbmV4cG9ydCB7IEhpRmlBeGVzIGFzIEF4ZXMsIEhpRmlIYW5kZWRuZXNzIGFzIEhhbmRlZG5lc3MsIEhpRmlBeGlzQ29uZmlndXJhdGlvbiBhcyBBeGlzQ29uZmlndXJhdGlvbiB9IGZyb20gXCIuL2NsYXNzZXMvSGlGaUF4aXNDb25maWd1cmF0aW9uXCI7XG4iLCJpbXBvcnQgeyBSYXZpVXRpbHMgfSBmcm9tICcuL1JhdmlVdGlscyc7XG5cbi8qKlxuICogVXNlZCBmb3Igc3RvcmluZyB0aGUgYmluYXJ5IGNvbW1hbmQgaGFuZGxlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IF9CSU5BUllfQ09NTUFORF9LRVkgPSBcIl9CSU5BUllcIjtcblxuXG4vKipcbiAqIE1vdXNlIHN0YXRlIG1lc3NhZ2UgaXMgNyBmbG9hdHMgYWthIDcgKiA0ID0gMjggYnl0ZXNcbiAqL1xuY29uc3QgX01PVVNFX1NUQVRFX0JVRkZFUl9TSVpFID0gMjg7XG5cbmVudW0gX0tFWV9DT0RFX1RBQkxFIHtcbiAgXCJDb250cm9sTGVmdFwiID0gMCxcbiAgXCJBbHRMZWZ0XCIgPSAxLFxuICBcIk9TTGVmdFwiID0gMixcbiAgXCJTcGFjZVwiID0gMyxcbiAgXCJPU1JpZ2h0XCIgPSA0LFxuICBcIkFsdFJpZ2h0XCIgPSA1LFxuICBcIkNvbnRyb2xSaWdodFwiID0gNixcblxuICBcIlNoaWZ0TGVmdFwiID0gNyxcbiAgXCJTaGlmdFJpZ2h0XCIgPSA4LFxuICBcIkNvbW1hXCIgPSA5LFxuICBcIlBlcmlvZFwiID0gMTAsXG4gIFwiU2xhc2hcIiA9IDExLFxuIFxuICBcIkNhcHNMb2NrXCIgPSAxMixcbiAgXCJFbnRlclwiID0gMTMsXG4gIFwiU2VtaWNvbG9uXCIgPSAxNCxcbiAgXCJRdW90ZVwiID0gMTUsXG5cbiAgXCJUYWJcIiA9IDE2LFxuICBcIkJyYWNrZXRMZWZ0XCIgPSAxNyxcbiAgXCJCcmFja2V0UmlnaHRcIiA9IDE4LFxuICBcIkJhY2tzbGFzaFwiID0gMTksXG5cbiAgXCJCYWNrcXVvdGVcIiA9IDIwLFxuICBcIk1pbnVzXCIgPSAyMSxcbiAgXCJFcXVhbFwiID0gMjIsXG5cbiAgXCJEaWdpdDBcIiA9IDIzLFxuICBcIkRpZ2l0MVwiID0gMjQsXG4gIFwiRGlnaXQyXCIgPSAyNSxcbiAgXCJEaWdpdDNcIiA9IDI2LFxuICBcIkRpZ2l0NFwiID0gMjcsXG4gIFwiRGlnaXQ1XCIgPSAyOCxcbiAgXCJEaWdpdDZcIiA9IDI5LFxuICBcIkRpZ2l0N1wiID0gMzAsXG4gIFwiRGlnaXQ4XCIgPSAzMSxcbiAgXCJEaWdpdDlcIiA9IDMyLFxuXG4gIFwiQmFja3NwYWNlXCIgPSAzMyxcblxuICBcIkVzY2FwZVwiID0gMzQsXG4gXG4gIFwiQXJyb3dMZWZ0XCIgPSAzNSxcbiAgXCJBcnJvd1JpZ2h0XCIgPSAzNixcbiAgXCJBcnJvd0Rvd25cIiA9IDM3LFxuICBcIkFycm93VXBcIiA9IDM4LFxuICBcIlBhZ2VEb3duXCIgPSAzOSxcbiAgXCJQYWdlVXBcIiA9IDQwLFxuICBcIkVuZFwiID0gNDEsXG4gIFwiSG9tZVwiID0gNDIsXG4gIFwiRGVsZXRlXCIgPSA0MyxcbiAgXCJJbnNlcnRcIiA9IDQ0LFxuXG4gIFwiTnVtcGFkMFwiID0gNDUsXG4gIFwiTnVtcGFkMVwiID0gNDYsXG4gIFwiTnVtcGFkMlwiID0gNDcsXG4gIFwiTnVtcGFkM1wiID0gNDgsXG4gIFwiTnVtcGFkNFwiID0gNDksXG4gIFwiTnVtcGFkNVwiID0gNTAsXG4gIFwiTnVtcGFkNlwiID0gNTEsXG4gIFwiTnVtcGFkN1wiID0gNTIsXG4gIFwiTnVtcGFkOFwiID0gNTMsXG4gIFwiTnVtcGFkOVwiID0gNTQsXG4gXG4gIFwiTnVtcGFkRGVjaW1hbFwiID0gNTUsXG4gIFwiTnVtcGFkRW50ZXJcIiA9IDU2LFxuICBcIk51bXBhZEFkZFwiID0gNTcsXG4gIFwiTnVtcGFkU3VidHJhY3RcIiA9IDU4LFxuICBcIk51bUxvY2tcIiA9IDU5LFxuICBcIk51bXBhZEVxdWFsXCIgPSA2MCxcbiAgXCJOdW1wYWRNdWx0aXBseVwiID0gNjEsXG4gIFwiTnVtcGFkRGl2aWRlXCIgPSA2MixcbiBcbiAgXCJLZXlBXCIgPSA2MyxcbiAgXCJLZXlCXCIgPSA2NCxcbiAgXCJLZXlDXCIgPSA2NSxcbiAgXCJLZXlEXCIgPSA2NixcbiAgXCJLZXlFXCIgPSA2NyxcbiAgXCJLZXlGXCIgPSA2OCxcbiAgXCJLZXlHXCIgPSA2OSxcbiAgXCJLZXlIXCIgPSA3MCxcbiAgXCJLZXlJXCIgPSA3MSxcbiAgXCJLZXlKXCIgPSA3MixcbiAgXCJLZXlLXCIgPSA3MyxcbiAgXCJLZXlMXCIgPSA3NCxcbiAgXCJLZXlNXCIgPSA3NSxcbiAgXCJLZXlOXCIgPSA3NixcbiAgXCJLZXlPXCIgPSA3NyxcbiAgXCJLZXlQXCIgPSA3OCxcbiAgXCJLZXlRXCIgPSA3OSxcbiAgXCJLZXlSXCIgPSA4MCxcbiAgXCJLZXlTXCIgPSA4MSxcbiAgXCJLZXlUXCIgPSA4MixcbiAgXCJLZXlVXCIgPSA4MyxcbiAgXCJLZXlWXCIgPSA4NCxcbiAgXCJLZXlXXCIgPSA4NSxcbiAgXCJLZXlYXCIgPSA4NixcbiAgXCJLZXlZXCIgPSA4NyxcbiAgXCJLZXlaXCIgPSA4OCxcbn07XG5jb25zdCBfS0VZQk9BUkRfU1RBVEVfQlVGRkVSX1NJWkUgPSAxMjtcblxuLyoqIFxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIFRoaXMgY2xhc3MgaGFuZGxlcyBxdWV1aW5nLCBtYW5hZ2luZywgYW5kIHRyYW5zbWl0dGluZyBjb21tYW5kcyBmcm9tIGEgUkFWSSBKYXZhU2NyaXB0IGNsaWVudFxuICogdG8gYSBSQVZJIHNlcnZlci4gXG4gKiBUaGlzIGNsYXNzIGlzIHByb3ZpZGVkIGJ5IGEge0BsaW5rIFJhdmlTZXNzaW9ufSBhbmQgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gKlxuICogRXhhbXBsZSB1c2FnZSAoc2VuZGluZyBpbmZvcm1hdGlvbiBvbiBtb3VzZSBkb3VibGUtY2xpY2spOlxuICogXG4gKiBgYGBcbiAqIHZhciBjb21tYW5kQ29udHJvbGxlciA9IHJhdmlTZXNzaW9uLmdldENvbW1hbmRDb250cm9sbGVyKCk7XG4gKiBsZXQgaGFuZGxlTW91c2VEb3VibGVDbGljayA9IChldmVudCkgPT4ge1xuICogICB2YXIgcG9zID0gbW91c2VIYW5kbGVyKGV2ZW50KVxuICogICBjb21tYW5kQ29udHJvbGxlci5zZW5kSW5wdXQoe1wiY1wiOiBcIkRvdWJsZUNsaWNrXCIsIFwicFwiOiBwb3MgfSlcbiAqIH07XG4gKmBgYFxuICovXG5leHBvcnQgY2xhc3MgUmF2aUNvbW1hbmRDb250cm9sbGVyIHtcbiAgX2NvbW1hbmRRdWV1ZU1hcDogTWFwPHN0cmluZywgYW55PjtcbiAgX251bVF1ZXVlZENvbW1hbmRzOiBudW1iZXI7XG4gIF9jb21tYW5kUXVldWVJbnRlcnZhbDogbnVtYmVyO1xuICBfY29tbWFuZFB1bXBUaW1lcjogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+O1xuXG4gIF9pbnB1dFRhcmdldDogSFRNTEVsZW1lbnQ7XG4gIF9rZXlib2FyZFRhcmdldDogSFRNTEVsZW1lbnQ7XG5cbiAgX21vdXNlU3RhdGVCdWZmZXI6IEFycmF5QnVmZmVyO1xuICBfbW91c2VTdGF0ZVVpbnQ4OiBVaW50OEFycmF5O1xuICBfbW91c2VTdGF0ZUZsb2F0OiBGbG9hdDMyQXJyYXk7XG5cbiAgX2tleWJvYXJkU3RhdGVCdWZmZXI6IEFycmF5QnVmZmVyO1xuICBfa2V5Ym9hcmRTdGF0ZTogVWludDhBcnJheTtcblxuICBfaW5wdXREYXRhQ2hhbm5lbDogUlRDRGF0YUNoYW5uZWw7XG4gIF9jb21tYW5kRGF0YUNoYW5uZWw6IFJUQ0RhdGFDaGFubmVsO1xuXG4gIC8qKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKlxuICAgKiBDb21tYW5kLWNoYW5uZWwgcmVsYXRlZDogXG4gICAqIHRoaXMuX2NvbW1hbmREYXRhQ2hhbm5lbDtcbiAgICogdGhpcy5fY29tbWFuZFF1ZXVlTWFwO1xuICAgKiB0aGlzLl9udW1RdWV1ZWRDb21tYW5kcztcbiAgICogdGhpcy5fY29tbWFuZFB1bXBUaW1lcjtcbiAgICogdGhpcy5fY29tbWFuZFF1ZXVlSW50ZXJ2YWw7XG4gICAqXG4gICAqIElucHV0LWNoYW5uZWwgcmVsYXRlZDpcbiAgICogdGhpcy5faW5wdXREYXRhQ2hhbm5lbDtcbiAgICogdGhpcy5faW5wdXRUYXJnZXQ7XG4gICAqIHRoaXMuX2tleWJvYXJkVGFyZ2V0O1xuICAgKi9cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUkFWSSBjb21tYW5kIGNvbnRyb2xsZXIuIFxuICAgKiBEZWZhdWx0cyB0aGUgY29tbWFuZFF1ZXVlSW50ZXJ2YWwgdG8gMSBzZWNvbmRcbiAgICogYW5kIGluaXRpYWxpemVzIHZhcmlhYmxlcy5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiY29uc3RydWN0b3JcIiwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgXG4gICAgdGhpcy5fY29tbWFuZFF1ZXVlTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX251bVF1ZXVlZENvbW1hbmRzID0gMDtcbiAgICB0aGlzLl9jb21tYW5kUXVldWVJbnRlcnZhbCA9IDEwMDA7XG4gICAgdGhpcy5fY29tbWFuZFB1bXBUaW1lciA9IG51bGw7XG5cbiAgICB0aGlzLl9pbnB1dFRhcmdldDtcbiAgICB0aGlzLl9rZXlib2FyZFRhcmdldDtcblxuICAgIC8vIE1vdXNlIHN0YXRlIGJ1ZmZlciBjb250YWlucyB0aGUgJ00nIGNoYXIgdG8gaW5kaWNhdGUgdGhlIHBheWxvYWQgb24gdGhlIGlucHV0IGRhdGEgY2hhbm5lbFxuICAgIHRoaXMuX21vdXNlU3RhdGVCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoX01PVVNFX1NUQVRFX0JVRkZFUl9TSVpFICsgNCk7XG4gICAgLy8gc2V0ICdNJyBhcyB0aGUgZmlyc3QgY2hhciBvZiB0aGUgTW91c2VkU3RhdGUgYnVmZmVyXG4gICAgdGhpcy5fbW91c2VTdGF0ZVVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fbW91c2VTdGF0ZUJ1ZmZlcik7XG4gICAgdGhpcy5fbW91c2VTdGF0ZVVpbnQ4WzBdID0gMHg0RFxuICAgIC8vIEFsbG9jYXRlIHRoZSB2aWV3IG9uIHRoZSBtb3VzZSBidWZmZXIgYXMgZmxvYXRzIHN0YXJ0aW5nIG9uIHRoZSAybmQgYnl0ZVxuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdCA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fbW91c2VTdGF0ZUJ1ZmZlciwgNCApO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFswXSA9IC0xLjA7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzFdID0gLTEuMDtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMl0gPSAtMS4wO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFszXSA9IC0xLjA7XG4gICAgXG4gICAgLy8gS2V5Ym9hcmQgc3RhdGUgYnVmZmVyIGNvbnRhaW5zIHRoZSAnaycgY2hhciB0byBpbmRpY2F0ZSB0aGUgcGF5bG9hZFxuICAgIHRoaXMuX2tleWJvYXJkU3RhdGVCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoX0tFWUJPQVJEX1NUQVRFX0JVRkZFUl9TSVpFICsgMSk7XG4gICAgdGhpcy5fa2V5Ym9hcmRTdGF0ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2tleWJvYXJkU3RhdGVCdWZmZXIpO1xuICAgIHRoaXMuX2tleWJvYXJkU3RhdGVbMF0gPSAweDRCOyAvLyBzZXQgJ0snIGFzIHRoZSBmaXJzdCBjaGFyIG9mIHRoZSBLZXlib2FyZFN0YXRlIGJ1ZmZlclxuICB9XG4gIFxuICAvKipcbiAgICogU2V0IHRoZSBpbnRlcnZhbCBhdCB3aGljaCB3ZSBzaG91bGQgc2VuZCBjb21tYW5kc1xuICAgKiB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge2ludH0gcXVldWVJbnRlcnZhbCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJldHdlZW5cbiAgICogc2VuZGluZyBjb21tYW5kcy4gRGVmYXVsdHMgdG8gMTAwMCAoMSBzZWNvbmQpLlxuICAgKi9cbiAgc2V0Q29tbWFuZFF1ZXVlSW50ZXJ2YWwocXVldWVJbnRlcnZhbDogbnVtYmVyKSB7XG4gICAgdGhpcy5fY29tbWFuZFF1ZXVlSW50ZXJ2YWwgPSBxdWV1ZUludGVydmFsO1xuICAgIC8vIElmIHRoZSBjb21tYW5kIHF1ZXVlIGlzIHJ1bm5pbmcsIHN0b3AgaXQgYW5kXG4gICAgLy8gcmVzdGFydCBpdC5cbiAgICBpZiAodGhpcy5fY29tbWFuZFB1bXBUaW1lcikge1xuICAgICAgdGhpcy5zdG9wTW9uaXRvcmluZ1F1ZXVlcygpO1xuICAgICAgdGhpcy5tb25pdG9yUXVldWVzKCk7XG4gICAgfVxuICB9XG4gIFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgbGlzdGVuaW5nIGZvciByZXNwb25zZXMgdG8gcXVldWVkIGNvbW1hbmRzXG4gICAqIEBjYWxsYmFjayBSYXZpQ29tbWFuZENvbnRyb2xsZXJ+Y29tbWFuZENhbGxiYWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZSBUaGUgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyXG4gICAqL1xuICAvKipcbiAgICogUXVldWUgdXAgYSBjb21tYW5kIHRvIGJlIHNlbnQgd2hlbiByZWFkeSwgYWxvbmdcbiAgICogdGhlIFwiY29tbWFuZFwiIGRhdGEgY2hhbm5lbC5cbiAgICogU2VlIGFsc28ge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI3NlbmRJbnB1dH1cbiAgICogdG8gc2VuZCBpbW1lZGlhdGUgaW5wdXQgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGhlcmUgaXMgYSByZXF1ZXN0IGZvciBhIG5ldyB2aWRlbyBrZXlmcmFtZTpcbiAgICogYGBgXG4gICAqIGNvbW1hbmRDb250cm9sbGVyLnF1ZXVlQ29tbWFuZChcInZpZGVvLmZvcmNlS2V5RnJhbWVcIiwge30sIGhhbmRsZXIpXG4gICAqXG4gICAqIGBgYFxuICAgKiBOT1RFOiBUaGVzZSBjb21tYW5kcyBzZW50IHRvIHRoZSBSQVZJIHNlcnZlciB3aWxsIGJlIHNlbnQgYXMgSlNPTixcbiAgICogYW5kIGhhbmRsZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGVzZSBjb21tYW5kcyBhcmUgZXhwZWN0ZWQgdG9cbiAgICogcmVjZWl2ZSBKU09OIGFzIGEgcmVzcG9uc2UuIElmIHlvdSBuZWVkIHRvIHByb2Nlc3MgYmluYXJ5IGRhdGFcbiAgICogcmVjZWl2ZWQgaW4gcmVzcG9uc2UgdG8gYSBjb21tYW5kLCB5b3Ugc2hvdWxkIHNlbmQgdGhlIGNvbW1hbmQgXG4gICAqIHdpdGhvdXQgYSBoYW5kbGVyLCBhbmQgdGhlbiBBTFNPIHNwZWNpZnkgYSBnbG9iYWwgYmluYXJ5IGxpc3RlbmVyXG4gICAqIHdpdGgge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI2FkZEJpbmFyeUhhbmRsZXJ9XG4gICAqIHRvIGlkZW50aWZ5IGFuZCBhcHByb3ByaWF0ZWx5IHByb2Nlc3MgdGhlIHJlc3BvbnNlLiBCaW5hcnlcbiAgICogZGF0YSBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIGEgY29tbWFuZCwgYW5kIHNvIGFsbCBiaW5hcnkgaGFuZGxlcnNcbiAgICogYXJlIGV4ZWN1dGVkIGZvciBhbGwgYmluYXJ5IGRhdGEgcmVjZWl2ZWQ7IGJpbmFyeSBoYW5kbGVycyBzaG91bGRcbiAgICogdGhlbXNlbHZlcyBkZXRlcm1pbmUgaWYgdGhlIGRhdGEgdGhleSd2ZSBiZWVuIGdpdmVuIGlzIHRoZSBkYXRhXG4gICAqIHRoZXkncmUgZXhwZWN0aW5nLiAoQW5kIGlmIHlvdSB3YW50IHRvIHNlbmQgdGhlIGNvbW1hbmQgYXMgYmluYXJ5XG4gICAqIGZyb20gdGhlIEpTIHNpZGUsIHVzZSB7bGluayBSYXZpQ29tbWFuZENvbnRyb2xsZXIjcXVldWVCaW5hcnlDb21tYW5kfSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmQgVGhlIGNvbW1hbmQgdG8gYWRkIHRvIHRoZSBxdWV1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gICBQYXJhbWV0ZXJzIHRvIGluY2x1ZGUgYWxvbmcgd2l0aCB0aGUgY29tbWFuZFxuICAgKiBAcGFyYW0ge1JhdmlDb21tYW5kQ29udHJvbGxlcn5jb21tYW5kQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhbnkgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXG4gICAqL1xuICBxdWV1ZUNvbW1hbmQoY29tbWFuZDogc3RyaW5nLCBwYXJhbTogYW55LCBoYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIC8vIEFkZCB0aGUgY29tbWFuZCB0byB0aGUgcXVldWUgZm9yIHRoaXMgcGFydGljdWxhclxuICAgIC8vIHR5cGUgb2YgY29tbWFuZFxuICAgIHZhciBjb21tYW5kUXVldWUgPSB0aGlzLl9jb21tYW5kUXVldWVNYXAuZ2V0KGNvbW1hbmQpO1xuICAgIGlmICghY29tbWFuZFF1ZXVlKSB7XG4gICAgICBjb21tYW5kUXVldWUgPSB7IHRvU2VuZDogW10sIGxpc3RlbmVyOiBbXSB9O1xuICAgICAgdGhpcy5fY29tbWFuZFF1ZXVlTWFwLnNldChjb21tYW5kLCBjb21tYW5kUXVldWUpO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVySW5zdGFuY2UgPSBudWxsO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAvLyBGb3Igbm93LCBhbGwgaGFuZGxlcnMgYXNzb2NpYXRlZCB3aXRoIGFjdHVhbCBzZW50IGNvbW1hbmRzXG4gICAgICAvLyBhcmUgbm90IFwic3RpY2t5XCIgKGkuZS4gdGhleSBvbmx5IGV4ZWN1dGUgb25jZSwgd2hlbiB0aGUgY29tbWFuZCByZXR1cm5zKVxuICAgICAgLy8gYW5kIHRoZXkgRE8gaGF2ZSBhIFwibWF0Y2hpbmcgc2VudCBjb21tYW5kXCJcbiAgICAgIGhhbmRsZXJJbnN0YW5jZSA9IG5ldyBSYXZpQ29tbWFuZEhhbmRsZXJJbnN0YW5jZShoYW5kbGVyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGNvbW1hbmRRdWV1ZS50b1NlbmQucHVzaCggbmV3IFJhdmlDb21tYW5kSW5zdGFuY2UoY29tbWFuZCwgcGFyYW0sIGhhbmRsZXJJbnN0YW5jZSkgKTtcblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiB3YWl0aW5nIGNvbW1hbmRzIHNlcGFyYXRlbHkgc28gd2UgZG9uJ3QgaGF2ZVxuICAgIC8vIHRvIGtlZXAgY2FsY3VsYXRpbmcgaXQgd2hlbiB3ZSBjaGVjayBmb3IgcXVldWVkIGNvbW1hbmRzXG4gICAgdGhpcy5fbnVtUXVldWVkQ29tbWFuZHMrKztcbiAgICBcbiAgICBSYXZpVXRpbHMubG9nKFwiQWRkZWQgY29tbWFuZCBcIiArIGNvbW1hbmQsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXVlIHVwIGEgYmluYXJ5IG1lc3NhZ2UgdG8gYmUgc2VudCB3aGVuIHJlYWR5LCBhbG9uZ1xuICAgKiB0aGUgXCJjb21tYW5kXCIgZGF0YSBjaGFubmVsLlxuICAgKiBTZWUgYWxzbyB7bGluayBSYXZpQ29tbWFuZENvbnRyb2xsZXIjc2VuZElucHV0fVxuICAgKiB0byBzZW5kIGltbWVkaWF0ZSBpbnB1dCB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBOT1RFOiBZb3UgY2FuIG5vdCBpbmNsdWRlIGEgaGFuZGxlciBpbiB0aGlzIG1ldGhvZCwgYmVjYXVzZVxuICAgKiBiaW5hcnkgbWVzc2FnZXMgYXJlIG5vdCBjdXJyZW50bHkgZGlzdGluZ3Vpc2hhYmxlIGZyb20gZWFjaFxuICAgKiBvdGhlciBhcyByZWdhcmRzIGhhbmRsZXJzIChpLmUuIHRoZXJlIGlzIG5vIFwiY29tbWFuZFwiIGFzc29jaWF0ZWRcbiAgICogd2l0aCBhIGJpbmFyeSBtZXNzYWdlKS4gSWYgeW91IHdhbnQgdG8gYXNzaWduIGEgaGFuZGxlciB0aGF0XG4gICAqIHdpbGwgcHJvY2VzcyBiaW5hcnkgbWVzc2FnZXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLCB1c2VcbiAgICoge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI2FkZEJpbmFyeUhhbmRsZXJ9XG4gICAqIHRvIGlkZW50aWZ5IGFuZCBhcHByb3ByaWF0ZWx5IHByb2Nlc3MgdGhlIHJlc3BvbnNlLiBCaW5hcnlcbiAgICogZGF0YSBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIGFuIGluZGl2aWR1YWwgY29tbWFuZCwgYW5kIHNvIGFsbCBiaW5hcnkgaGFuZGxlcnNcbiAgICogYXJlIGV4ZWN1dGVkIGZvciBhbGwgYmluYXJ5IGRhdGEgcmVjZWl2ZWQ7IGJpbmFyeSBoYW5kbGVycyBzaG91bGRcbiAgICogdGhlbXNlbHZlcyBkZXRlcm1pbmUgaWYgdGhlIGRhdGEgdGhleSd2ZSBiZWVuIGdpdmVuIGlzIHRoZSBkYXRhXG4gICAqIHRoZXkncmUgZXhwZWN0aW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBtZXNzYWdlIEFuIEFycmF5QnVmZmVyIChleHBlY3RlZCBieSB0aGUgc2VydmVyIHRvIGJlIGEgVWludDhBcnJheSkgdGhhdCBzaG91bGQgYmUgc2VudCB0byB0aGUgc2VydmVyXG4gICAqL1xuICBxdWV1ZUJpbmFyeUNvbW1hbmQobWVzc2FnZTogQXJyYXlCdWZmZXIpIHtcbiAgICAvLyBBZGQgdGhlIGNvbW1hbmQgdG8gdGhlIGJpbmFyeSBxdWV1ZSBcbiAgICBsZXQgY29tbWFuZCA9IF9CSU5BUllfQ09NTUFORF9LRVk7XG4gICAgdmFyIGNvbW1hbmRRdWV1ZSA9IHRoaXMuX2NvbW1hbmRRdWV1ZU1hcC5nZXQoY29tbWFuZCk7XG4gICAgaWYgKCEgY29tbWFuZFF1ZXVlKSB7XG4gICAgICBjb21tYW5kUXVldWUgPSB7IHRvU2VuZDogW10sIGxpc3RlbmVyOiBbXSB9O1xuICAgICAgdGhpcy5fY29tbWFuZFF1ZXVlTWFwLnNldChjb21tYW5kLCBjb21tYW5kUXVldWUpO1xuICAgIH1cblxuICAgIGNvbW1hbmRRdWV1ZS50b1NlbmQucHVzaCggbmV3IFJhdmlDb21tYW5kSW5zdGFuY2UobWVzc2FnZSwgbnVsbCwgbnVsbCkgKTtcblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiB3YWl0aW5nIGNvbW1hbmRzIHNlcGFyYXRlbHkgc28gd2UgZG9uJ3QgaGF2ZVxuICAgIC8vIHRvIGtlZXAgY2FsY3VsYXRpbmcgaXQgd2hlbiB3ZSBjaGVjayBmb3IgcXVldWVkIGNvbW1hbmRzXG4gICAgdGhpcy5fbnVtUXVldWVkQ29tbWFuZHMrKztcbiAgICBcbiAgICBSYXZpVXRpbHMubG9nKFwiQWRkZWQgYmluYXJ5IGNvbW1hbmRcIiwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gIH1cblxuICBcbiAgLyoqXG4gICAqIEFkZCBhIGNvbW1hbmQgaGFuZGxlciBvbmx5LCB3aXRob3V0IGFsc28gcXVldWluZyB1cCBhIGNvbW1hbmQgdG8gc2VuZC5cbiAgICogVGhpcyBsaXN0ZW5lciB3aWxsIHdhdGNoIGZvciBhIG1lc3NhZ2UgdG8gYmUgcmVjZWl2ZWQgZnJvbSB0aGVcbiAgICogc2VydmVyIChvbiB0aGUgXCJjb21tYW5kXCIgZGF0YSBjaGFubmVsKSB0aGF0IG1hdGNoZXMgdGhlIGV4cGVjdGVkXG4gICAqIG1lc3NhZ2UgbmFtZS4gV2hlbiByZWNlaXZlZCwgdGhlIGxpc3RlbmVyIHdpbGwgZXhlY3V0ZSwgYW5kIHRoZW4gZWl0aGVyIHN0aWNrIGFyb3VuZCBhbmRcbiAgICoga2VlcCB3YXRjaGluZyAoaWYgdGhlIFwiaXNTdGlja3lcIiBmbGFnIGlzIHNldCB0byB0cnVlKVxuICAgKiBvciBkZS1yZWdpc3RlciBpdHNlbGYgKGlmIFwiaXNTdGlja3lcIiBpcyBmYWxzZSkgYW5kIHN0b3AgbGlzdGVuaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRNZXNzYWdlIFRoZSBzdHJpbmcgdG8gd2F0Y2ggZm9yIGZyb20gdGhlIHNlcnZlciwgc29tZXRoaW5nIGxpa2UgXCJtZXNzYWdlLmxvY2F0aW9uXCJcbiAgICogQHBhcmFtIHtSYXZpQ29tbWFuZENvbnRyb2xsZXJ+Y29tbWFuZENhbGxiYWNrfSBoYW5kbGVyIEEgaGFuZGxlciB0aGF0IHNob3VsZCBwcm9jZXNzIGFueSBldmVudHMgbGFiZWxlZCB3aXRoIGV4cGVjdGVkTWVzc2FnZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RpY2t5IFdoZXRoZXIgdGhlIGhhbmRsZXIgc2hvdWxkIGV4ZWN1dGUgZXZlcnkgdGltZSB0aGUgbWVzc2FnZSBpcyByZWNlaXZlZCAodHJ1ZSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBqdXN0IHRoZSBmaXJzdCB0aW1lIChmYWxzZSlcbiAgICovXG4gIGFkZE1lc3NhZ2VIYW5kbGVyKGV4cGVjdGVkTWVzc2FnZTogc3RyaW5nLCBoYW5kbGVyOiBGdW5jdGlvbiwgaXNTdGlja3k6IGJvb2xlYW4pIHtcblxuICAgIC8vIFRoZSBjb21tYW5kIHF1ZXVlIG1hcCBpcyB1c2VkIHRvIHRyYWNrIGFsbCBjb21tYW5kcy9saXN0ZW5lcnM7XG4gICAgLy8gZW5zdXJlIHRoYXQgdGhpcyBwYXJ0aWN1bGFyIFwiZXhwZWN0ZWRNZXNzYWdlXCIgaGFzIGFuIGVudHJ5XG4gICAgdmFyIG1lc3NhZ2VFbnRyeSA9IHRoaXMuX2NvbW1hbmRRdWV1ZU1hcC5nZXQoZXhwZWN0ZWRNZXNzYWdlKTtcbiAgICBpZiAoISBtZXNzYWdlRW50cnkpIHtcbiAgICAgIG1lc3NhZ2VFbnRyeSA9IHsgdG9TZW5kOiBbXSwgbGlzdGVuZXI6IFtdIH07XG4gICAgICB0aGlzLl9jb21tYW5kUXVldWVNYXAuc2V0KGV4cGVjdGVkTWVzc2FnZSwgbWVzc2FnZUVudHJ5KTtcbiAgICB9XG4gICAgXG4gICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgd2FudCB0byBwdXQgYW55dGhpbmcgaW4gaXRzIFwidG9TZW5kXCIgYXJyYXksIGJ1dFxuICAgIC8vIHdlIGRvIHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIuXG4gICAgdmFyIGhhbmRsZXJJbnN0YW5jZSA9IG5ldyBSYXZpQ29tbWFuZEhhbmRsZXJJbnN0YW5jZShoYW5kbGVyLCBpc1N0aWNreSwgZmFsc2UpO1xuICAgIG1lc3NhZ2VFbnRyeS5saXN0ZW5lci5wdXNoKGhhbmRsZXJJbnN0YW5jZSk7IFxuXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGxpc3RlbmluZyBmb3IgYmluYXJ5IHNlcnZlciBtZXNzYWdlc1xuICAgKiBAY2FsbGJhY2sgUmF2aUNvbW1hbmRDb250cm9sbGVyfmJpbmFyeUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBhcyBhIFVpbnQ4QXJyYXkgdHlwZWQgYXJyYXlcbiAgICovXG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIGZvciBiaW5hcnkgZGF0YSBvbmx5LCB3aXRob3V0IGFsc28gcXVldWluZyB1cCBhIGNvbW1hbmQgdG8gc2VuZC5cbiAgICogVGhpcyBsaXN0ZW5lciB3aWxsIHdhdGNoIGZvciBhIGJpbmFyeSBtZXNzYWdlIHRvIGJlIHJlY2VpdmVkIGZyb20gdGhlXG4gICAqIHNlcnZlciAob24gdGhlIFwiY29tbWFuZFwiIGRhdGEgY2hhbm5lbCkuXG4gICAqIFdoZW4gcmVjZWl2ZWQsIHRoZSBsaXN0ZW5lciB3aWxsIGV4ZWN1dGUsIGFuZCB0aGVuIGVpdGhlciBzdGljayBhcm91bmQgYW5kXG4gICAqIGtlZXAgd2F0Y2hpbmcgKGlmIHRoZSBcImlzU3RpY2t5XCIgZmxhZyBpcyBzZXQgdG8gdHJ1ZSlcbiAgICogb3IgZGUtcmVnaXN0ZXIgaXRzZWxmIChpZiBcImlzU3RpY2t5XCIgaXMgZmFsc2UpIGFuZCBzdG9wIGxpc3RlbmluZy5cbiAgICpcbiAgICogTk9URTogQmluYXJ5IGRhdGEgaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhIGNvbW1hbmQsIGFuZCBzbyBhbGwgYmluYXJ5IGhhbmRsZXJzXG4gICAqIGFyZSBleGVjdXRlZCBmb3IgYWxsIGJpbmFyeSBkYXRhIHJlY2VpdmVkOyBiaW5hcnkgaGFuZGxlcnMgc2hvdWxkXG4gICAqIHRoZW1zZWx2ZXMgZGV0ZXJtaW5lIGlmIHRoZSBkYXRhIHRoZXkndmUgYmVlbiBnaXZlbiBpcyB0aGUgZGF0YVxuICAgKiB0aGV5J3JlIGV4cGVjdGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtSYXZpQ29tbWFuZENvbnRyb2xsZXJ+YmluYXJ5Q2FsbGJhY2t9IGhhbmRsZXIgQSBoYW5kbGVyIHRoYXQgc2hvdWxkIHByb2Nlc3MgYW55IGV2ZW50cyBsYWJlbGVkIHdpdGggZXhwZWN0ZWRNZXNzYWdlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdGlja3kgV2hldGhlciB0aGUgaGFuZGxlciBzaG91bGQgZXhlY3V0ZSBldmVyeSB0aW1lIHRoZSBtZXNzYWdlIGlzIHJlY2VpdmVkICh0cnVlKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGp1c3QgdGhlIGZpcnN0IHRpbWUgKGZhbHNlKVxuICAgKi9cbiAgYWRkQmluYXJ5SGFuZGxlcihoYW5kbGVyOiBGdW5jdGlvbiwgaXNTdGlja3k6IGJvb2xlYW4pIHtcbiAgICAvLyBTdG9yZSB0aGVzZSBoYW5kbGVycyBpbiB0aGUgc2FtZSBtYXAgYXMgdGhlIG90aGVyIGxpc3RlbmVyLW9ubHkgaGFuZGxlcnMsXG4gICAgLy8gYnV0IGp1c3QgdXNlIGEgc2luZ2xlIGNvbnN0YW50IGtleS5cbiAgICB0aGlzLmFkZE1lc3NhZ2VIYW5kbGVyKF9CSU5BUllfQ09NTUFORF9LRVksIGhhbmRsZXIsIGlzU3RpY2t5KTtcbiAgICAvLyBOT1RFOiBDdXJyZW50bHksIHdlIGRvbid0IHN1cHBvcnQgYW55IHNvcnQgb2YgXCJjb21tYW5kXCIgYXNzb2NpYXRlZFxuICAgIC8vIHdpdGggYmluYXJ5IG1lc3NhZ2VzIC0tIHdoZW4gd2UgZ2V0IGEgYmluYXJ5IG1lc3NhZ2UsIGFsbCBiaW5hcnlcbiAgICAvLyBoYW5kbGVycyBhcmUgY2FsbGVkLiBXZSBtYXkgZGVjaWRlIHRvIHJldGhpbmsgdGhpcyBpbiB0aGUgZnV0dXJlLlxuICB9XG4gIFxuICAvKipcbiAgICogU2VuZCBhbiBpbnB1dCBldmVudCBkaXJlY3RseSBmcm9tIHRoZSB1c2VyIHRvIHRoZSBSQVZJIHNlcnZlciBhbG9uZ1xuICAgKiB0aGUgXCJpbnB1dFwiIGRhdGEgY2hhbm5lbC5cbiAgICogU2VlIGFsc28ge2xpbmsgUmF2aUNvbW1hbmRDb250cm9sbGVyI3F1ZXVlQ29tbWFuZH0sIHdoaWNoIHF1ZXVlcyBjb21tYW5kcyBmb3IgbGF0ZXIgc2VuZGluZy5cbiAgICogVGhpcyBtZXRob2QgZG9lcyBub3QgZGVmaW5lIGNhbGxiYWNrcy5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGhlcmUgaXMgYW4gZXZlbnQgaGFuZGxlciBmb3Igc2VuZGluZyBtb3VzZSBtb3ZlbWVudDpcbiAgICogYGBgXG4gICAqIGxldCBoYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICogICB2YXIgcG9zID0gbW91c2VIYW5kbGVyKGV2ZW50KVxuICAgKiAgIGNvbW1hbmRDb250cm9sbGVyLnNlbmRJbnB1dCh7XCJjXCI6IFwiTW91c2VNb3ZlXCIsIFwicFwiOiBwb3MgfSlcbiAgICogfTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dEV2ZW50IEFuIGV2ZW50IHRvIHNlbmQuXG4gICAqL1xuICBzZW5kSW5wdXQoaW5wdXRFdmVudDogYW55KSB7XG4gICAgaWYgKHRoaXMuX2lucHV0RGF0YUNoYW5uZWwgJiYgdGhpcy5faW5wdXREYXRhQ2hhbm5lbC5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIC8vIFRoaXMgZ2V0cyBqdXN0IFdBWSB0b28gbm9pc3kgdG9vIHF1aWNrbHksXG4gICAgICAvLyBidXQgdW5jb21tZW50IGlmIG5lZWRlZDpcbiAgICAgIC8vIFJhdmlVdGlscy5sb2coXCJTZW5kaW5nIGlucHV0OlwiICsgSlNPTi5zdHJpbmdpZnkoaW5wdXRFdmVudCksIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgdGhpcy5faW5wdXREYXRhQ2hhbm5lbC5zZW5kKGlucHV0RXZlbnQpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEtpY2sgb2ZmIHBvbGxpbmcgZm9yIHF1ZXVlZCBjb21tYW5kcy5cbiAgICogRXZlcnkgc2Vjb25kLCB0aGlzIHdpbGwgc2VuZCB0aGVcbiAgICogbmV4dCBxdWV1ZWQgY29tbWFuZCBmcm9tIHRoZSBjb21tYW5kUXVldWUuXG4gICAqIFRoaXMgZG9lcyBub3QgbmVlZCB0byBiZSBjYWxsZWQgZXh0ZXJuYWxseTtcbiAgICogaXQgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBhcHByb3ByaWF0ZVxuICAgKiBjb21tYW5kIGRhdGEgY2hhbm5lbCBpcyBvcGVuZWQuIChTZWUge0BsaW5rIFJhdmlDb21tYW5kQ29udHJvbGxlciNfc2V0Q29tbWFuZERhdGFDaGFubmVsfSlcbiAgICogSG93ZXZlciwgaXQgY2FuIGJlIGNhbGxlZCBleHRlcm5hbGx5IGlmIGF0IGFueSBwb2ludFxuICAgKiB5b3UgbmVlZCB0byBzdG9wIGFuZCB0aGVuIHJlc3RhcnQgdGhlIHF1ZXVlIG1vbml0b3JpbmdcbiAgICogcHJvY2Vzcy5cbiAgICovXG4gIG1vbml0b3JRdWV1ZXMoKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIkJlZ2luIG1vbml0b3JpbmcgZm9yIHF1ZXVlZCBjb21tYW5kc1wiLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICB0aGlzLl9jb21tYW5kUHVtcFRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5fcHJvY2Vzc1NlbmRpbmdRdWV1ZWRDb21tYW5kcy5iaW5kKHRoaXMpLCB0aGlzLl9jb21tYW5kUXVldWVJbnRlcnZhbCk7ICBcbiAgfVxuICBcbiAgLyoqXG4gICAqIFN0b3AgcG9sbGluZyBmb3IgcXVldWVkIGNvbW1hbmRzIGFuZFxuICAgKiBubyBsb25nZXIgc2VuZCB0aGVtLiBDYWxsZWQgd2hlbiBhIFJBVkkgc2Vzc2lvbiBpcyBjbG9zZWRcbiAgICogKHNlZSB7QGxpbmsgUmF2aVNlc3Npb24jY2xvc2V9KS4gQ2FuIGFsc28gYmUgY2FsbGVkXG4gICAqIGV4dGVybmFsbHkgdG8gaGFsdCBjb21tYW5kIHByb2Nlc3NpbmcgaWYgbmVlZGVkLlxuICAgKi9cbiAgc3RvcE1vbml0b3JpbmdRdWV1ZXMoKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIlN0b3AgbW9uaXRvcmluZyBmb3IgcXVldWVkIGNvbW1hbmRzXCIsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY29tbWFuZFB1bXBUaW1lcik7XG4gICAgdGhpcy5fY29tbWFuZFB1bXBUaW1lciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgbmV4dCBxdWV1ZWQgY29tbWFuZC5cbiAgICogdGhpcyBnZXRzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgcXVldWUgbW9uaXRvclxuICAgKiBhbmQsIGluIGdlbmVyYWwsIHNob3VsZCBub3QgYmUgY2FsbGVkIGV4dGVybmFsbHkuXG4gICAqIFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NTZW5kaW5nUXVldWVkQ29tbWFuZHMoKSB7XG4gICAgaWYgKHRoaXMuX251bVF1ZXVlZENvbW1hbmRzIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gRm9yIGVhY2ggdHlwZSBvZiBjb21tYW5kIGluIHRoZSBtYXAsIHdlIGNhbiBzZW5kIHRoZSBmaXJzdCBvbmUgb2YgdGhlbS5cbiAgICB0aGlzLl9jb21tYW5kUXVldWVNYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZTogYW55LCBrZXk6IGFueSwgbWFwOiBhbnkpIHtcbiAgICAgIC8vIGlmIHRoaXMgcGFydGljdWxhciBjb21tYW5kIGhhcyBhIHF1ZXVlIG9mIGluc3RhbmNlcy4uLlxuICAgICAgaWYgKHZhbHVlLnRvU2VuZC5sZW5ndGgpIHtcbiAgICAgICAgLy8gR3JhYiB0aGUgZmlyc3Qgb25lIG9mZiB0aGUgcXVldWVcbiAgICAgICAgdmFyIGNvbW1hbmRJbnN0YW5jZSA9IHZhbHVlLnRvU2VuZC5zaGlmdCgpO1xuXG4gICAgICAgIC8vIElmIGEgaGFuZGxlciBpcyBkZWZpbmVkIHRoZW4gcHV0IGl0IG9uIHRoZSBsaXN0ZW5lciBtYXBcbiAgICAgICAgaWYgKGNvbW1hbmRJbnN0YW5jZS5faGFuZGxlcikge1xuICAgICAgICAgIC8vIEFkZCBpdCB0byB0aGUgbGlzdCBvZiBsaXN0ZW5lcnMgZm9yIGxhdGVyIGhhbmRsZXIgaGFuZGxpbmdcbiAgICAgICAgICB2YWx1ZS5saXN0ZW5lci5wdXNoKGNvbW1hbmRJbnN0YW5jZS5faGFuZGxlcik7ICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGV0J3Mgc2VuZCB0aGUgY29tbWFuZCFcbiAgICAgICAgaWYgKCB0aGlzLl9zZW5kQ29tbWFuZEluc3RhbmNlKGNvbW1hbmRJbnN0YW5jZSkgKSB7XG4gICAgICAgICAgdGhpcy5fbnVtUXVldWVkQ29tbWFuZHMtLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2VuZCBmYWlsZWQuIENvbW1hbmREYXRhQ2hhbm5lbCBtYXkgaGF2ZSBiZWVuIGRpc2Nvbm5lY3RlZC4gV2lsbCBub3QgcmV0cnkuXCIsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgICAgIC8vIElmIHdlIGRpZCB3YW50IHRvIHJldHJ5LCB0aG91Z2g6XG4gICAgICAgICAgLy92YWx1ZS50b1NlbmQucHVzaChjb21tYW5kSW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgYSBwYWlyIHsgY29tbWFuZCwgcGF5bG9hZCB9IHRvIGJlIHNlbnQgaGFzIGEgbWVzc2FnZSBvbiB0aGUgQ29tbWFuZERhdGFDaGFubmVsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb21tYW5kIC0gVGhlIGFjdHVhbCBzdHJpbmcgY29tbWFuZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF5bG9hZCAtIEFueSBwYXJhbWV0ZXJzIHRvIGJlIHNlbnQgb3IgcmVjZWl2ZWQgdGhlIGNvbW1hbmRcbiAgICogXG4gICAqIEByZXR1cm4gdGhlIG1lc3NhZ2UgYXMgYSB7c3RyaW5nfSBhcyBleHBlY3RlZCBieSB0aGUgc2VydmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplSnNvbkNvbW1hbmRNZXNzYWdlVG9TZW5kKGNvbW1hbmQ6IHN0cmluZywgcGF5bG9hZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcImNcIjogY29tbWFuZCwgXCJwXCI6IHBheWxvYWR9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnNlcmlhbGl6ZSBhIHJlY2VpdmVkIGNvbW1hbmQgbWVzc2FnZSBcbiAgICogSWYgdGhlIG1lc3NhZ2UgaXMgcGFyc2VkIGNvcnJlY3RseSB0aGVuIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgdmFsaWQgXCJDb21tYW5kTWVzc2FnZVwiIG9iamVjdFxuICAgKiBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcga2V5c1xuICAgKiAtIHtzdHJpbmd9ICdjb21tYW5kJyAtIFRoZSBjb21tYW5kIHRva2VuIGlkZW50aWZ5aW5nIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgbWVzc2FnZVxuICAgKiAtIHtzdHJpbmd9ICdwYXlsb2FkJyAtIFRoZSBhY3R1YWwgZGF0YSByZWNlaXZlZCBmcm9tIHRoZSBtZXNzYWdlXG4gICAqIFxuICAgKiBJZiB0aGUgcGFyc2luZyBkb2Vzbid0IG1hdGNoIGEgdmFsaWQgY29tbWFuZE1lc3NhZ2UgdGhlbiB0aGUgZnVuY3Rpb24gcmV0dXJucyBudWxsIGFuZCBsb2cgdGhlIHByb2JsZW1cbiAgICogXG4gICAqIEByZXR1cm4gQSB2YWxpZCBcIkNvbW1hbmRNZXNzYWdlXCIgb2JqZWN0IGFzIGRldGFpbGVkIGFib3ZlIG9yIG51bGxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91bnNlcmlhbGl6ZUpzb25Db21tYW5kTWVzc2FnZUZyb21SZWNlaXZlZChtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBsZXQgY29tbWFuZE1lc3NhZ2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1hbmRNZXNzYWdlID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKGBDb3VsZG4ndCBwYXJzZSBjb21tYW5kIG1lc3NhZ2UhIEVycm9yOlxcbiR7ZX1cXG4gRnVsbCBtZXNzYWdlIGNvbnRlbnRzOlxcbiR7bWVzc2FnZX1gLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjb21tYW5kTWVzc2FnZSBpcyBleHBlY3RlZCB0byBoYXZlIDIga2V5czpcbiAgICAvLyAnYyc6IHRoZSBjb21tYW5kIG5hbWUsIHRoZSB0b2tlbiBpZGVudGlmeWluZyB0aGUgY29tbWFuZCBkZXN0aW5hdGlvbiBmb3IgdGhpcyBtZXNzYWdlXG4gICAgLy8gJ3AnOiB0aGUgcGF5bG9hZCBkYXRhLCB0aGUgYWN0dWFsIGluZm9ybWF0aW9uIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlclxuICAgIGlmIChjb21tYW5kTWVzc2FnZSAmJiBjb21tYW5kTWVzc2FnZS5jICYmIGNvbW1hbmRNZXNzYWdlLnApIHtcbiAgICAgIHJldHVybiB7J2NvbW1hbmQnOiBjb21tYW5kTWVzc2FnZS5jLCAncGF5bG9hZCc6IGNvbW1hbmRNZXNzYWdlLnAgfTtcbiAgICB9XG4gICAgUmF2aVV0aWxzLmVycihcIk1lc3NhZ2UgY2Fubm90IGJlIHVuc2VyaWFsaXplZCBpbnRvIGEgQ29tbWFuZE1lc3NhZ2U6IFwiICsgbWVzc2FnZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBcbiAgICogU2VuZCBhIHBhcnRpY3VsYXIgY29tbWFuZCBpbnN0YW5jZSBpbW1lZGlhdGVseSAtLVxuICAgKiB0aGlzIGdldHMgdXNlZCBpbnRlcm5hbGx5IGJ5IHtAbGluayBSYXZpQ29tbWFuZENvbnRyb2xsZXIjX3Byb2Nlc3NTZW5kaW5nUXVldWVkQ29tbWFuZHN9XG4gICAqIGFuZCBpbiBnZW5lcmFsLCBzaG91bGQgbm90IGJlIGNhbGxlZCBleHRlcm5hbGx5LlxuICAgKiBcbiAgICogQHBhcmFtIHtSYXZpQ29tbWFuZEluc3RhbmNlfSBjb21tYW5kSW5zdGFuY2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZW5kQ29tbWFuZEluc3RhbmNlKGNvbW1hbmRJbnN0YW5jZTogUmF2aUNvbW1hbmRJbnN0YW5jZSkge1xuICAgIC8vIFJhdGhlciB0aGFuIGNoZWNraW5nIGZvciBhbiBvcGVuIGNoYW5uZWwgZXZlcnkgdGltZSwganVzdCB0cnkgaXQgYW5kXG4gICAgLy8gY2F0Y2ggYW55IGVycm9yc1xuICAgIHRyeSB7XG4gICAgICBsZXQgbWVzc2FnZSA9IGNvbW1hbmRJbnN0YW5jZS5fY29tbWFuZDtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gdGhpcy5fc2VyaWFsaXplSnNvbkNvbW1hbmRNZXNzYWdlVG9TZW5kKGNvbW1hbmRJbnN0YW5jZS5fY29tbWFuZCwgY29tbWFuZEluc3RhbmNlLl9wYXJhbSk7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJTZW5kaW5nIGNvbW1hbmQgXCIgKyBtZXNzYWdlLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJTZW5kaW5nIGJpbmFyeSBjb21tYW5kXCIsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tbWFuZERhdGFDaGFubmVsLnNlbmQobWVzc2FnZSk7XG4gICAgICAvLyB3ZSBkb24ndCBnZXQgYW55dGhpbmcgYmFjaywgc28ganVzdCBhc3N1bWUgaXQgc2VudCBpZiBpdCBkaWRuJ3QgdGhyb3cgYW4gZXJyb3IuLi5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIlJlY2VpdmVkIGVycm9yIHdoaWxlIHNlbmRpbmc6IFwiICsgZXJyLm1lc3NhZ2UsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFxuICAgKiBQcm9jZXNzIHRoZSBsaXN0ZW5lciBmb3IgdGhlIG1lc3NhZ2UgZnJvbSB0aGUgUkFWSSBzZXJ2ZXIgLS1cbiAgICogdGhpcyBnZXRzIHVzZWQgaW50ZXJuYWxseSBieSB7QGxpbmsgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9ufVxuICAgKiBhbmQgaW4gZ2VuZXJhbCwgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZXh0ZXJuYWxseS5cbiAgICogXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tU2VydmVyTWVzc2FnZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NMaXN0ZW5pbmdDb21tYW5kKGZyb21TZXJ2ZXJNZXNzYWdlOiBhbnkpIHtcblxuICAgIGxldCBzZXJ2ZXJEYXRhID0gZnJvbVNlcnZlck1lc3NhZ2UuZGF0YTtcbiAgICBsZXQgY29tbWFuZE1lc3NhZ2UgPSBudWxsO1xuXG4gICAgLy8gRmlyc3Qgb2ZmLCBpcyB0aGlzIGEgYmluYXJ5IG1lc3NhZ2Ugb3IgYSBKU09OIG1lc3NhZ2U/XG4gICAgLy8gSWYgaXQncyBhIEpTT04gbWVzc2FnZSwgaXQnbGwgYmUgYSBzdHJpbmc7IGlmIGl0J3MgYVxuICAgIC8vIGJpbmFyeSBtZXNzYWdlLCBpdCdsbCBiZSBhbiBBcnJheUJ1ZmZlci5cbiAgICAvLyAoQW5kIGlmIGl0J3MgbmVpdGhlciBvZiB0aG9zZSwgd2UnbGwgbGVhdmUgY29tbWFuZE1lc3NhZ2VcbiAgICAvLyB1bnNldCBhbmQgcGljayBpdCB1cCBsYXRlci4pXG4gICAgaWYgKHNlcnZlckRhdGEpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VydmVyRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSXQncyBKU09OLiBUaGUgY29tbWFuZCBpbmZvIGlzIGFscmVhZHkgaW4gdGhlIG1lc3NhZ2UuXG4gICAgICAgIGNvbW1hbmRNZXNzYWdlID0gdGhpcy5fdW5zZXJpYWxpemVKc29uQ29tbWFuZE1lc3NhZ2VGcm9tUmVjZWl2ZWQoc2VydmVyRGF0YSk7XG4gICAgICAgIHRoaXMuX2NvbnRpbnVlUHJvY2Vzc2luZ0xpc3RlbmluZ0NvbW1hbmQoY29tbWFuZE1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIGlmIChzZXJ2ZXJEYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe1xuICAgICAgICAvLyBJdCdzIGJpbmFyeS4gV2UnbGwgd3JhcCBpdCBpbiBhIHR5cGVkIGFycmF5XG4gICAgICAgIC8vIGFuZCB0aGVuIGluIGEgSmF2YVNjcmlwdCBzdHJ1Y3RcbiAgICAgICAgLy8gc28gdGhhdCBpdCBjYW4gYmUgcHJvY2Vzc2VkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgLy8gXCJwYXlsb2FkXCIgY29kZSBwYXRoIGFzIHRoZSBKU09OIGRhdGFcbiAgICAgICAgY29tbWFuZE1lc3NhZ2UgPSB7ICdjb21tYW5kJyA6IF9CSU5BUllfQ09NTUFORF9LRVksICdwYXlsb2FkJyA6IG5ldyBVaW50OEFycmF5KHNlcnZlckRhdGEpfTtcbiAgICAgICAgLy8gTk9URTogQ3VycmVudGx5LCB3ZSBkb24ndCBuYXRpdmVseSBpbmNsdWRlIGFueSBzb3J0IG9mIFwiY29tbWFuZFwiIGFzc29jaWF0ZWRcbiAgICAgICAgLy8gd2l0aCBiaW5hcnkgbWVzc2FnZXMgLS0gd2hlbiB3ZSBnZXQgYSBiaW5hcnkgbWVzc2FnZSwgYWxsIGJpbmFyeVxuICAgICAgICAvLyBoYW5kbGVycyBhcmUgY2FsbGVkLiBXZSBtYXkgZGVjaWRlIHRvIHJldGhpbmsgdGhpcyBpbiB0aGUgZnV0dXJlLlxuICAgICAgICB0aGlzLl9jb250aW51ZVByb2Nlc3NpbmdMaXN0ZW5pbmdDb21tYW5kKGNvbW1hbmRNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VydmVyRGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgc2VydmVyRGF0YS5hcnJheUJ1ZmZlcigpXG4gICAgICAgICAgLnRoZW4oKHByb2Nlc3NlZEFycmF5QnVmZmVyKSA9PiB7XG4gICAgICAgICAgICBjb21tYW5kTWVzc2FnZSA9IHsgJ2NvbW1hbmQnIDogX0JJTkFSWV9DT01NQU5EX0tFWSwgJ3BheWxvYWQnIDogbmV3IFVpbnQ4QXJyYXkocHJvY2Vzc2VkQXJyYXlCdWZmZXIpfTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRpbnVlUHJvY2Vzc2luZ0xpc3RlbmluZ0NvbW1hbmQoY29tbWFuZE1lc3NhZ2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jb250aW51ZVByb2Nlc3NpbmdMaXN0ZW5pbmdDb21tYW5kKGNvbW1hbmRNZXNzYWdlOiBhbnkpIHtcbiAgICBpZiAoIWNvbW1hbmRNZXNzYWdlKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKFwiUmVjZWl2ZWQgaW52YWxpZCBjb21tYW5kIG1lc3NhZ2UsIGlnbm9yaW5nOiBcIiArIEpTT04uc3RyaW5naWZ5KGNvbW1hbmRNZXNzYWdlKSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTGV0J3MgdHJ5IHRvIGZpbmQgdGhlIG1hdGNoaW5nIGxpc3RlbmVyKHMpIGZvciB0aGUgY29tbWFuZE1lc3NhZ2UgcmVjZWl2ZWQ6XG4gICAgdmFyIGZvdW5kQ29tbWFuZEluc3RhbmNlID0gdGhpcy5fY29tbWFuZFF1ZXVlTWFwLmdldChjb21tYW5kTWVzc2FnZS5jb21tYW5kKTtcbiAgICBpZiAoZm91bmRDb21tYW5kSW5zdGFuY2UpIHtcbiAgICAgIC8vIEhvdyBtYW55IGxpc3RlbmVycyBkb2VzIGl0IGhhdmU/XG4gICAgICB2YXIgbGVuZ3RoID0gZm91bmRDb21tYW5kSW5zdGFuY2UubGlzdGVuZXIubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgLyoqXG4gICAgICAgIFRPRE86IFdlIG5lZWQgdG8gYWRkIGJvdGggc2VydmVyICYgY2xpZW50IGZ1bmN0aW9uYWxpdHkgdGhhdFxuICAgICAgICB3aWxsIHRyYWNrIHRoZSBcImluc3RhbmNlXCIgb2YgYSBjb21tYW5kIGFuZCB0cmlnZ2VyIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgICBsaXN0ZW5lci4gUmlnaHQgbm93IHRoaXMgY291bGQgYmVoYXZlIHVuZXhwZWN0ZWRseSBpbiB0aGUgc2l0dWF0aW9uXG4gICAgICAgIHdoZXJlIHdlIHJlZ2lzdGVyIHR3byBkaWZmZXJlbnQgbGlzdGVuZXJzIGZvciB0aGUgc2FtZSBjb21tYW5kXG4gICAgICAgIGFuZCB0aGUgXCJ3cm9uZ1wiIG9uZSByZXR1cm5zIGZpcnN0LiBTZWUgQklHV09STEQtNDU2LiBXZSBjYW4gbWFrZVxuICAgICAgICB0aGlzIGNvZGUgY2xlYW5lciBvbmNlIHRoYXQncyBpbXBsZW1lbnRlZC5cblxuICAgICAgICBJbiB0aGUgbWVhbnRpbWUsIHdlJ2xsIGxlYXZlIHRoZSBcImluc3RhbmNlIG9mIGEgY29tbWFuZFwiIGJlaGF2aW9yIGFzIGlzLlxuICAgICAgICBBbmQgaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIgd2l0aCBhIFwibWF0Y2hpbmcgc2VudCBjb21tYW5kXCIsIHdlJ2xsXG4gICAgICAgIGV4ZWN1dGUgYWxsIHRoZSByZWxldmFudCBcImxpc3Rlbi1vbmx5XCIgbGlzdGVuZXJzLlxuXG4gICAgICAgIE5PVEU6IFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgYSBnaXZlbiBjb21tYW5kTWVzc2FnZSBcImNvbW1hbmRcIiBzdHJpbmdcbiAgICAgICAgKGUuZy4gXCJjb21tYW5kLmFib3V0XCIgb3IgXCJtZXNzYWdlLmxvY2F0aW9uXCIpIHdpbGwgb25seSBoYXZlIE9ORSBUWVBFXG4gICAgICAgIG9mIGxpc3RlbmVyOiBcIm1hdGNoaW5nIHNlbnQgY29tbWFuZFwiIG9yIFwibGlzdGVuLW9ubHlcIi4gSWYgeW91IHF1ZXVlXG4gICAgICAgIGEgY29tbWFuZCB3aXRoIGEgbGlzdGVuZXIsIGFuZCB0aGVuIEFMU08gdHJ5IHRvXG4gICAgICAgIGFzc29jaWF0ZSBhIGxpc3Rlbi1vbmx5IGxpc3RlbmVyIHdpdGggdGhhdCBzYW1lIGNvbW1hbmQgbmFtZSxcbiAgICAgICAgc3RyYW5nZSB0aGluZ3Mgd2lsbCBoYXBwZW4uIChTcGVjaWZpY2FsbHksIHRoZSBjb21tYW5kIGhhbmRsZXIgZm9yXG4gICAgICAgIHRoZSBzZW50IGNvbW1hbmQgd2lsbCBiZSB0aGUgb25seSB0aGluZyBleGVjdXRlZCB3aGVuIHlvdSBnZXQgdGhlIGZpcnN0XG4gICAgICAgIHJlc3BvbnNlIGJhY2ssIGJ1dCBpZiB5b3UgZ2V0IHN1YnNlcXVlbnQgcmVzcG9uc2VzIGJhY2ssIHRoZW4gdGhlXG4gICAgICAgIGxpc3Rlbi1vbmx5IGxpc3RlbmVyKHMpIHdpbGwgZXhlY3V0ZS4pIFdlIGNhbiByZW1vdmUgdGhpcyByZXN0cmljdGlvblxuICAgICAgICBvbmNlIEJJR1dPUkxELTQ1NiBpcyBpbXBsZW1lbnRlZC5cbiAgICAgICAgKiovXG4gICAgICAgIGlmIChmb3VuZENvbW1hbmRJbnN0YW5jZS5saXN0ZW5lclswXSAmJiBmb3VuZENvbW1hbmRJbnN0YW5jZS5saXN0ZW5lclswXS5faGFzTWF0Y2hpbmdTZW50Q29tbWFuZCkge1xuICAgICAgICAgIC8vIFRoZXJlIHdhcyBhbiBvcmlnaW5hbCBjb21tYW5kIHNlbnQgdGhhdCB3ZSdyZSBsaXN0ZW5pbmcgZm9yIGEgcmVzcG9uc2UgZm9yLCBcbiAgICAgICAgICAvLyBjb21tYW5kIHNlbnQsIHNvIHRoYXQgbWVhbnMgd2UganVzdCBleGVjdXRlIHRoZSBmaXJzdCBoYW5kbGVyLFxuICAgICAgICAgIC8vIHdoYXRldmVyIGl0IGlzLlxuICAgICAgICAgIHZhciBjb21tYW5kSW5zdGFuY2UgPSBmb3VuZENvbW1hbmRJbnN0YW5jZS5saXN0ZW5lci5zaGlmdCgpO1xuICAgICAgICAgIGlmIChjb21tYW5kSW5zdGFuY2UgJiYgY29tbWFuZEluc3RhbmNlLl9oYW5kbGVyKSB7XG4gICAgICAgICAgICBjb21tYW5kSW5zdGFuY2UuX2hhbmRsZXIoY29tbWFuZE1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICByZXR1cm47IC8vIHN1Y2Nlc3MsIGVuZCBvZiB0aGUgKGZpcnN0KSBsaXN0ZW5lclxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSYXZpVXRpbHMuZXJyKFwiVW5kZWZpbmVkIGNvbW1hbmQgaGFuZGxlcjogXCIgKyBjb21tYW5kTWVzc2FnZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld0xpc3RlbmVycyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZvdW5kQ29tbWFuZEluc3RhbmNlLmxpc3RlbmVyW2ldO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICYmIGxpc3RlbmVyLl9oYW5kbGVyKSB7XG4gICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gZXhlY3V0ZSB0aGUgaGFuZGxlclxuICAgICAgICAgICAgICBsaXN0ZW5lci5faGFuZGxlcihjb21tYW5kTWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIFJhdmlVdGlscy5lcnIoXCJVbmRlZmluZWQgbWVzc2FnZSBoYW5kbGVyOiBcIiArIGNvbW1hbmRNZXNzYWdlLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGl0J3Mgc3RpY2t5LCBhZGQgaXQgdG8gdGhlIFwibmV3XCIgbGlzdFxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICYmIGxpc3RlbmVyLl9pc1N0aWNreSkge1xuICAgICAgICAgICAgICBuZXdMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSB3aXRoIG9ubHkgdGhlIHN0aWNreSBvbmVzXG4gICAgICAgICAgZm91bmRDb21tYW5kSW5zdGFuY2UubGlzdGVuZXIgPSBuZXdMaXN0ZW5lcnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG5vIGxpc3RlbmVyIGRlZmluZWQsIGp1c3QgbW92ZSBvbiwgdGhpcyBpcyBhbiBvayBwYXRoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFxuICAgKiBTZXQgdGhlIGlucHV0IGRhdGEgY2hhbm5lbC5cbiAgICpcbiAgICogQHBhcmFtIHtSVENEYXRhQ2hhbm5lbH0gaW5wdXREYXRhQ2hhbm5lbCBUaGUgZGF0YUNoYW5uZWwgdG8gdXNlLiBXaGlsZSB0aGlzIGlzIGRlZmluZWQgYXMgYW4gUlRDRGF0YUNoYW5uZWwsXG4gICAqIGh5cG90aGV0aWNhbGx5IHNvbWUgb3RoZXIga2luZCBvZiBzdHJlYW0gdGhhdCBvZmZlcnMgdGhlIHNhbWUgQVBJIGFuZCBjYWxsYmFja3MgYXMgYW4gUlRDRGF0YUNoYW5uZWxcbiAgICogY291bGQgYWxzbyBiZSB1c2VkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldElucHV0RGF0YUNoYW5uZWwoaW5wdXREYXRhQ2hhbm5lbDogUlRDRGF0YUNoYW5uZWwpIHtcbiAgICB0aGlzLl9pbnB1dERhdGFDaGFubmVsID0gaW5wdXREYXRhQ2hhbm5lbDtcbiAgICBSYXZpVXRpbHMubG9nKFwiUmVjZWl2ZWQgbmV3IGlucHV0IGRhdGEgY2hhbm5lbCB3aXRoIGlkIFwiICsgdGhpcy5faW5wdXREYXRhQ2hhbm5lbC5pZCwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG5cbiAgICB0aGlzLl9pbnB1dERhdGFDaGFubmVsLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIFJhdmlVdGlscy5sb2coXCJfaW5wdXREYXRhQ2hhbm5lbCBvbm9wZW4sIHN0YXRlIGlzIFwiICsgdGhpcy5faW5wdXREYXRhQ2hhbm5lbC5yZWFkeVN0YXRlLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9pbnB1dERhdGFDaGFubmVsLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiX2lucHV0RGF0YUNoYW5uZWwgb25jbG9zZSwgc3RhdGUgaXMgXCIgKyB0aGlzLl9pbnB1dERhdGFDaGFubmVsLnJlYWR5U3RhdGUsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2lucHV0RGF0YUNoYW5uZWwub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2U6IGFueSkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIl9pbnB1dERhdGFDaGFubmVsIGdvdCBtZXNzYWdlOiBcIiArIChtZXNzYWdlLmRhdGEpLCBcIlJhdmlDb21tYW5kQ29udHJvbGxlclwiKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogXG4gICAqIFNldCB0aGUgY29tbWFuZCBkYXRhIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7UlRDRGF0YUNoYW5uZWx9IGNvbW1hbmREYXRhQ2hhbm5lbCBUaGUgZGF0YUNoYW5uZWwgdG8gdXNlLiBXaGlsZSB0aGlzIGlzIGRlZmluZWQgYXMgYW4gUlRDRGF0YUNoYW5uZWwsXG4gICAqIGh5cG90aGV0aWNhbGx5IHNvbWUgb3RoZXIga2luZCBvZiBzdHJlYW0gdGhhdCBvZmZlcnMgdGhlIHNhbWUgQVBJIGFuZCBjYWxsYmFja3MgYXMgYW4gUlRDRGF0YUNoYW5uZWxcbiAgICogY291bGQgYWxzbyBiZSB1c2VkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldENvbW1hbmREYXRhQ2hhbm5lbChjb21tYW5kRGF0YUNoYW5uZWw6IFJUQ0RhdGFDaGFubmVsKSB7XG4gICAgdGhpcy5fY29tbWFuZERhdGFDaGFubmVsID0gY29tbWFuZERhdGFDaGFubmVsO1xuICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCBuZXcgZGF0YSBjaGFubmVsIHdpdGggaWQgXCIgKyB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwuaWQsIFwiUmF2aUNvbW1hbmRDb250cm9sbGVyXCIpO1xuICBcbiAgICB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIl9jb21tYW5kRGF0YUNoYW5uZWwgb25vbnBlbiwgc3RhdGUgaXMgXCIgKyB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwucmVhZHlTdGF0ZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICAvLyBLaWNrIG9mZiB0aGUgbW9uaXRvcmluZyBvZiB0aGUgY29tbWFuZCBxdWV1ZXMgaW4gdGhlIGNvbW1hbmQgY29udHJvbGxlci5cbiAgICAgIHRoaXMubW9uaXRvclF1ZXVlcygpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2NvbW1hbmREYXRhQ2hhbm5lbC5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIl9jb21tYW5kRGF0YUNoYW5uZWwgb25jbG9zZSwgc3RhdGUgaXMgXCIgKyB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwucmVhZHlTdGF0ZSwgXCJSYXZpQ29tbWFuZENvbnRyb2xsZXJcIik7XG4gICAgICAvLyBTdG9wIG1vbml0b3JpbmcgdGhlIGNvbW1hbmQgcXVldWVcbiAgICAgIHRoaXMuc3RvcE1vbml0b3JpbmdRdWV1ZXMoKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9jb21tYW5kRGF0YUNoYW5uZWwub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2U6IGFueSkge1xuICAgICAgdGhpcy5fcHJvY2Vzc0xpc3RlbmluZ0NvbW1hbmQobWVzc2FnZSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgXG4gIC8qKlxuICAgKiBTZXQgYSBET00gZWxlbWVudCB0aGF0IGlzIHVzZWQgdG8gdHJhY2sgaW5wdXQgZXZlbnQgKG1vdXNlICYgdG91Y2gpXG4gICAqIHNldmVyYWwgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byB0aGUgZWxlbWVudCBhbmQgY29tbXVuaWNhdGUgaW5wdXQgZXZlbnRzIHRvIFJhdmkgU2VydmVyIHRocm91Z2ggdGhlIGlucHV0IGNoYW5uZWxcbiAgICogQHBhcmFtIHtFbGVtZW50fSBpbnB1dFRhcmdldEVsZW1lbnQgUmVmZXJlbmNlIHRvIHRoZSBKYXZhU2NyaXB0IERPTSBlbGVtZW50IHVzZWQgdG8gdHJhY2sgaW5wdXQgZXZlbnRzIFxuICAgKi9cbiAgc2V0SW5wdXRUYXJnZXQoaW5wdXRUYXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9pbnB1dFRhcmdldCkge1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZW1vdmUgPSBudWxsO1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZWVudGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX2lucHV0VGFyZ2V0Lm9ubW91c2VsZWF2ZSA9IG51bGw7XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNlZG93biA9IG51bGw7XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNldXAgPSBudWxsO1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub253aGVlbCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5faW5wdXRUYXJnZXQgPSBpbnB1dFRhcmdldEVsZW1lbnQ7XG5cbiAgICBpZiAodGhpcy5faW5wdXRUYXJnZXQpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZW1vdmUgPSAgZnVuY3Rpb24oZXZlbnQpIHsgdGhhdC5fdHJhY2tNb3VzZShldmVudCk7IH07XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNlZW50ZXIgPSBudWxsO1xuICAgICAgdGhpcy5faW5wdXRUYXJnZXQub25tb3VzZWxlYXZlID0gbnVsbDtcbiAgICAgIHRoaXMuX2lucHV0VGFyZ2V0Lm9ubW91c2Vkb3duID0gZnVuY3Rpb24oZXZlbnQpIHsgdGhhdC5fY2FwdHVyZU1vdXNlRG93bihldmVudCk7IH07XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbm1vdXNldXAgPSBmdW5jdGlvbihldmVudCkgeyB0aGF0Ll9yZXNldE1vdXNlRG93bihldmVudCk7IH07XG4gICAgICB0aGlzLl9pbnB1dFRhcmdldC5vbndoZWVsID0gIGZ1bmN0aW9uKGV2ZW50KSB7IHRoYXQuX3doZWVsTW91c2UoZXZlbnQpOyB9O1xuICAgIH1cbiAgfVxuXG4gc2V0S2V5Ym9hcmRUYXJnZXQoaW5wdXRUYXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9rZXlib2FyZFRhcmdldCkge1xuICAgICAgdGhpcy5fa2V5Ym9hcmRUYXJnZXQub25rZXlkb3duID0gbnVsbDtcbiAgICAgIHRoaXMuX2tleWJvYXJkVGFyZ2V0Lm9ua2V5dXAgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX2tleWJvYXJkVGFyZ2V0ID0gaW5wdXRUYXJnZXRFbGVtZW50O1xuXG4gICAgaWYgKHRoaXMuX2tleWJvYXJkVGFyZ2V0KSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2tleWJvYXJkVGFyZ2V0Lm9ua2V5ZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7IHRoYXQuX29uS2V5Ym9hcmREb3duKGV2ZW50KTsgfTtcbiAgICAgIHRoaXMuX2tleWJvYXJkVGFyZ2V0Lm9ua2V5dXAgPSBmdW5jdGlvbihldmVudCkgeyB0aGF0Ll9vbktleWJvYXJkVXAoZXZlbnQpOyB9O1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFxuICAgKi9cbiAgX2NhcHR1cmVNb3VzZURvd24oZTogTW91c2VFdmVudCkge1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFswXSA9IGUub2Zmc2V0WDtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMV0gPSBlLm9mZnNldFk7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzJdID0gZS5vZmZzZXRYO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFszXSA9IGUub2Zmc2V0WTtcblxuICAgIHRoaXMuX21vdXNlU3RhdGVVaW50OFsxXSA9IGUuYnV0dG9ucztcblxuICAgIC8vIEFuZCBzZW5kIHN0YXRlXG4gICAgdGhpcy5fc2VuZE1vdXNlU3RhdGUoKTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogXG4gICAqL1xuICBfcmVzZXRNb3VzZURvd24oZTogTW91c2VFdmVudCkge1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFswXSA9IC0xLjA7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzFdID0gLTEuMDtcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMl0gPSAtMS4wO1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFszXSA9IC0xLjA7XG5cbiAgICB0aGlzLl9tb3VzZVN0YXRlVWludDhbMV0gPSBlLmJ1dHRvbnM7XG5cbiAgICAvLyBBbmQgc2VuZCBzdGF0ZVxuICAgIHRoaXMuX3NlbmRNb3VzZVN0YXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFxuICAgKi9cbiAgX3RyYWNrTW91c2UoZTogTW91c2VFdmVudCkge1xuICAgIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBtb3VzZSBwb3MgaW4gdGhlIG91c2VTdGF0ZUJ1ZmZmZXJcbiAgICB0aGlzLl9tb3VzZVN0YXRlRmxvYXRbMF0gPSBlLm9mZnNldFg7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzFdID0gZS5vZmZzZXRZO1xuXG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzRdID0gdGhpcy5faW5wdXRUYXJnZXQub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzVdID0gdGhpcy5faW5wdXRUYXJnZXQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgdGhpcy5fbW91c2VTdGF0ZVVpbnQ4WzFdID0gZS5idXR0b25zO1xuXG4gICAgLy8gQW5kIHNlbmQgc3RhdGVcbiAgICB0aGlzLl9zZW5kTW91c2VTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFxuICAgKi9cbiAgX3doZWVsTW91c2UoZTogV2hlZWxFdmVudCkge1xuICAgIHRoaXMuX21vdXNlU3RhdGVGbG9hdFs2XSA9IGUuZGVsdGFZO1xuICAgIHRoaXMuX3NlbmRNb3VzZVN0YXRlKCk7XG4gICAgdGhpcy5fbW91c2VTdGF0ZUZsb2F0WzZdID0gMDtcbiAgfVxuXG4gIF9zZW5kTW91c2VTdGF0ZSgpIHtcbiAgICB0aGlzLnNlbmRJbnB1dCh0aGlzLl9tb3VzZVN0YXRlQnVmZmVyKTtcbiAgfVxuXG4gIF9rZXlCeXRlTnVtKGM6IGFueSkge1xuICAgIHJldHVybiBjID4+IDM7XG4gIH1cbiAgX2tleUJpdE1hc2soYzogYW55KSB7XG4gICAgcmV0dXJuICgxIDw8IChjICUgOCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25LZXlib2FyZERvd24oZTogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBjID0gX0tFWV9DT0RFX1RBQkxFWzxhbnk+IGUuY29kZV07XG4gICAgbGV0IGtleUJ5dGVOdW0gPSAxICsgdGhpcy5fa2V5Qnl0ZU51bShjKTtcbiAgICBsZXQga2V5Qnl0ZU1hc2sgPSB0aGlzLl9rZXlCaXRNYXNrKGMpO1xuICAgIGlmICgodGhpcy5fa2V5Ym9hcmRTdGF0ZVtrZXlCeXRlTnVtXSAmIGtleUJ5dGVNYXNrKSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9rZXlib2FyZFN0YXRlW2tleUJ5dGVOdW1dIHw9IGtleUJ5dGVNYXNrO1xuICAgICAgICB0aGlzLl9zZW5kS2V5Ym9hcmRTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uS2V5Ym9hcmRVcChlOiBLZXlib2FyZEV2ZW50KSB7XG4gICAgbGV0IGMgPSBfS0VZX0NPREVfVEFCTEVbPGFueT4gZS5jb2RlXTtcbiAgICBsZXQga2V5Qnl0ZU51bSA9IDEgKyB0aGlzLl9rZXlCeXRlTnVtKGMpO1xuICAgIGxldCBrZXlCeXRlTWFzayA9IHRoaXMuX2tleUJpdE1hc2soYyk7XG4gICAgaWYgKCh0aGlzLl9rZXlib2FyZFN0YXRlW2tleUJ5dGVOdW1dICYga2V5Qnl0ZU1hc2spICE9PSAwKSB7XG4gICAgICAgIHRoaXMuX2tleWJvYXJkU3RhdGVba2V5Qnl0ZU51bV0gXj0ga2V5Qnl0ZU1hc2s7XG4gICAgICAgIHRoaXMuX3NlbmRLZXlib2FyZFN0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX3NlbmRLZXlib2FyZFN0YXRlKCkge1xuICAgIHRoaXMuc2VuZElucHV0KHRoaXMuX2tleWJvYXJkU3RhdGVCdWZmZXIpO1xuICB9XG5cbn0gLy8gRW5kIG9mIHRoZSBSYXZpQ29tbWFuZENvbnRyb2xsZXIgY2xhc3NcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiogXG4gKlxuICogQSBjb21tYW5kIGluc3RhbmNlIGZvciB1c2Ugd2l0aCB0aGUgXG4gKiBSYXZpQ29tbWFuZENvbnRyb2xsZXIuIFRoaXMgaXMganVzdFxuICogYSBzcGVjaWFsaXplZCBvYmplY3QgdG8gdHJhY2sgdGhlIGNvbWJpbmF0aW9uIG9mXG4gKiBhIGNvbW1hbmQgdHlwZSwgdGhlIHBhcmFtZXRlcnMgZm9yIHRoYXQgY29tbWFuZCxcbiAqIGFuZCB0aGUgaGFuZGxlciB0byBiZSB1c2VkIGZvciB0aGUgY29tbWFuZCByZXN1bHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZCAtIFRoZSBhY3R1YWwgc3RyaW5nIGNvbW1hbmQgdG8gc2VuZFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtIC0gQW55IHBhcmFtZXRlcnMgdG8gYmUgc2VudCB0byB0aGUgY29tbWFuZFxuICogQHBhcmFtIHtSYXZpQ29tbWFuZENvbnRyb2xsZXIuUmF2aUNvbW1hbmRIYW5kbGVySW5zdGFuY2V9IGhhbmRsZXIgLSBBIGNhbGxiYWNrIGhhbmRsZXIgdG8gdXNlIHdoZW4gdGhlIGNvbW1hbmQgcmV0dXJucyBmcm9tIHRoZSBzZXJ2ZXJcbiAqIFxuICogQGNsYXNzIFJhdmlDb21tYW5kQ29udHJvbGxlci5SYXZpQ29tbWFuZEluc3RhbmNlXG4gKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBjb21tYW5kIHRoYXQgc2hvdWxkIGJlIFxuICogcXVldWVkIHVwIGluIHRoZSBSYXZpQ29tbWFuZENvbnRyb2xsZXIncyBjb21tYW5kIHF1ZXVlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJhdmlDb21tYW5kSW5zdGFuY2Uge1xuICBfY29tbWFuZDogYW55O1xuICBfcGFyYW06IGFueTtcbiAgX2hhbmRsZXI6IGFueTtcblxuICAvKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKiB0aGlzLl9jb21tYW5kO1xuICAgKiB0aGlzLl9wYXJhbTtcbiAgICogdGhpcy5faGFuZGxlcjtcbiAgICovXG4gIFxuICAvKiogXG4gICAqIEBwcml2YXRlIFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29tbWFuZDogYW55LCBwYXJhbTogYW55LCBoYW5kbGVyOiBhbnkpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiY29uc3RydWN0b3JcIiwgXCJSYXZpQ29tbWFuZEluc3RhbmNlXCIpO1xuICAgIHRoaXMuX2NvbW1hbmQgPSBjb21tYW5kO1xuICAgIHRoaXMuX3BhcmFtID0gcGFyYW07XG4gICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XG4gIH1cbn1cblxuLyoqIFxuICpcbiAqIEEgaGFuZGxlciBpbnN0YW5jZSBmb3IgdXNlIHdpdGggdGhlIFxuICogUmF2aUNvbW1hbmRDb250cm9sbGVyLiBUaGlzIGp1c3RcbiAqIHRyYWNrcyB0aGUgaGFuZGxlciBmdW5jdGlvbiBhbmQgd2hldGhlciBvciBcbiAqIG5vdCBpdCdzIFwic3RpY2t5LlwiIEhhbmRsZXJzIHRoYXQgYXJlIGFzc29jaWF0ZWRcbiAqIHdpdGggYSBwYXJ0aWN1bGFyIFNFTlQgY29tbWFuZCBhcmUgTk9UIHN0aWNreSBieVxuICogZGVmYXVsdCAoaS5lLiB0aGV5IGV4ZWN1dGUgb25jZSwgYW5kIHRoZW4gc3RvcFxuICogbGlzdGVuaW5nKSwgYnV0IGxpc3RlbmVycyB0aGF0IGFyZSByZWdpc3RlcmVkXG4gKiBieSB0aGVtc2VsdmVzIGNhbiBiZSBlaXRoZXIgc3RpY2t5IG9yIG5vdCBzdGlja3kuXG4gKiBAcGFyYW0ge1JhdmlDb21tYW5kQ29udHJvbGxlcn5jb21tYW5kQ2FsbGJhY2t9IGhhbmRsZXIgLSBBIGNhbGxiYWNrIGhhbmRsZXIgdG8gdXNlIHdoZW4gdGhlIGNvbW1hbmQgcmV0dXJucyBmcm9tIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdGlja3kgLSBXaGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciBzdGlja3MgYXJvdW5kIGZvcmV2ZXIgKHRydWUpIG9yIHN0b3BzIGxpc3RlbmluZyBhZnRlciBpdCBnZXRzXG4gKiBpdHMgZmlyc3QgcmVzcG9uc2UgKGZhbHNlKVxuICogQHBhcmFtIHtib29sZWFufSBoYXNNYXRjaGluZ1NlbnRDb21tYW5kIC0gV2hldGhlciBvciBub3QgdGhpcyBoYW5kbGVyIGhhcyBhIG1hdGNoaW5nIGNvbW1hbmQgdGhhdCB3YXMvaXMgZ29pbmcgdG8gYmUgXG4gKiBzZW50IHRvIHRoZSBzZXJ2ZXIgKHRydWUpLCBvciBpZiBpdCdzIGp1c3QgbGlzdGVuaW5nIGZvciBzb21ldGhpbmcgdGhlIHNlcnZlciBtaWdodCBzZW5kIG9uIGl0cyBvd24gKGZhbHNlKVxuICogXG4gKiBAY2xhc3MgUmF2aUNvbW1hbmRDb250cm9sbGVyLlJhdmlDb21tYW5kSGFuZGxlckluc3RhbmNlXG4gKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBoYW5kbGVyIHRoYXQgY2FuIGJlIFxuICogdXNlZCB0byBwcm9jZXNzIG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlclxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJhdmlDb21tYW5kSGFuZGxlckluc3RhbmNlIHtcbiAgX2hhbmRsZXI6IGFueTtcbiAgX2lzU3RpY2t5OiBib29sZWFuO1xuICBfaGFzTWF0Y2hpbmdTZW50Q29tbWFuZDogYm9vbGVhbjtcblxuICAvKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzOlxuICAgKiB0aGlzLl9oYW5kbGVyO1xuICAgKiB0aGlzLl9pc1N0aWNreTtcbiAgICogdGhpcy5faGFzTWF0Y2hpbmdTZW50Q29tbWFuZDtcbiAgICovXG4gIC8qKiBcbiAgICogQHByaXZhdGUgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihoYW5kbGVyOiBhbnksIGlzU3RpY2t5OiBib29sZWFuLCBoYXNNYXRjaGluZ1NlbnRDb21tYW5kOiBib29sZWFuKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aUNvbW1hbmRIYW5kbGVySW5zdGFuY2VcIik7XG4gICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdGhpcy5faXNTdGlja3kgPSBpc1N0aWNreTtcbiAgICB0aGlzLl9oYXNNYXRjaGluZ1NlbnRDb21tYW5kID0gaGFzTWF0Y2hpbmdTZW50Q29tbWFuZDtcbiAgfVxufVxuIiwiXG5pbXBvcnQgeyBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiwgUmF2aVNpZ25hbGluZ1N0YXRlcyB9IGZyb20gJy4vUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24nO1xuaW1wb3J0IHsgUmF2aVN0cmVhbUNvbnRyb2xsZXIgfSBmcm9tICcuL1JhdmlTdHJlYW1Db250cm9sbGVyJztcbmltcG9ydCB7IFJhdmlVdGlscyB9IGZyb20gJy4vUmF2aVV0aWxzJztcbmltcG9ydCB7IFJhdmlDb21tYW5kQ29udHJvbGxlciB9IGZyb20gJy4vUmF2aUNvbW1hbmRDb250cm9sbGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBXZWJSVENTZXNzaW9uUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGppdHRlciBidWZmZXIgZHVyYXRpb24uIFVuaXRzIGFyZSBzZWNvbmRzLiBUaGUgZGVmYXVsdCBpcyAwIHNlY29uZHMuXG4gICAqIFxuICAgKiBJbiBwcmFjdGljZSwgdGhpcyBzaG91bGQgYWx3YXlzIGJlIHNldCB0byAwIHNlY29uZHMsIHdoaWNoIGlzIHRoZSBkZWZhdWx0LiBTZXR0aW5nIHRoZSBtaW5pbXVtIGppdHRlciBidWZmZXIgZHVyYXRpb24gdG8gWCBzZWNvbmRzIG1lYW5zXG4gICAqIHRoYXQgYWxsIGF1ZGlvIHNlbnQgdG8gdGhlIHNlcnZlciB3aWxsIGFsd2F5cyBiZSBidWZmZXJlZCBhdCBsZWFzdCBieSBYIHNlY29uZHMuIFRoaXMgaXMgcmFyZWx5IGRlc2lyYWJsZTsgbG93ZXIgbGF0ZW5jeSBpcyBhbG1vc3QgYWx3YXlzIHByZWZlcnJlZC5cbiAgICogWW91IG1heSwgaG93ZXZlciwgd2FudCB0byBzZXQgdGhlIG1heGltdW0gaml0dGVyIGJ1ZmZlciBkdXJhdGlvbiBpZiB5b3VyIHVzZXJzIGFyZSBleHBlcmllbmNpbmcgZnJlcXVlbnQgYXVkaW8gZHJvcC1vdXRzOyByZWZlciB0byBgYXVkaW9NYXhKaXR0ZXJCdWZmZXJEdXJhdGlvbmAgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGF1ZGlvTWluSml0dGVyQnVmZmVyRHVyYXRpb24/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBqaXR0ZXIgYnVmZmVyIGR1cmF0aW9uLiBVbml0cyBhcmUgc2Vjb25kcy4gVGhlIGRlZmF1bHQgaXMgMSBzZWNvbmQuXG4gICAqIFxuICAgKiBTZXQgdGhlIGppdHRlciBidWZmZXIgZHVyYXRpb24gaGlnaCB0byByZWR1Y2UgdGhlIHBvc3NpYmlsaXR5IG9mIGF1ZGlvIGRyb3BvdXRzIGF0IHRoZSBjb3N0XG4gICAqIG9mIHBvdGVudGlhbGx5IGhpZ2hlciByb3VuZC10cmlwIGF1ZGlvIGxhdGVuY3kgb24gcG9vciBjb25uZWN0aW9ucy5cbiAgICovXG4gIGF1ZGlvTWF4Sml0dGVyQnVmZmVyRHVyYXRpb24/OiBudW1iZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIGEgdXNlciB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCAob3Igc2VydmVyLXByb3ZpZGVkKVxuICogU1RVTiBhbmQgVFVSTiBjb25maWd1cmF0aW9uIHRoYXQgaXMgb2ZmZXJlZCBieSB0aGUgY2xpZW50LiBOb3RlIHRoYXQgaWYgYSBjdXN0b20gc3R1biBhbmQgdHVybiBjb25maWd1cmF0aW9uIGlzXG4gKiB1c2VkLCBhbGwgb2YgaXRzIHZhbHVlcyBtdXN0IGJlIHByb3ZpZGVkIVxuICogKFNldHRpbmcgdGhlc2UgdmFsdWVzIGRvZXMgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB3aGF0IHRoZSBzZXJ2ZXIgb2ZmZXJzIGZvciBpdHMgc3R1biBhbmQgdHVybiBjb25maWd1cmF0aW9uO1xuICogaG93ZXZlciwgdGhlIHNlcnZlcnMgYXJlIGdlbmVyYWxseSBleHBlY3RlZCB0byBiZSBjb25maWd1cmVkIHNvIGFzIHRvIGJlIGVhc2lseSByZWFjaGFibGUgd2l0aG91dCB0aGUgbmVlZCBmb3IgVFVSTlxuICogb3IgdGhyb3VnaCB0aGUgdXNlIG9mIHRoZSBzdGFuZGFyZCBUVVJOIHNlcnZlcnMuKVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbVNUVU5hbmRUVVJOQ29uZmlnIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBTVFVOIHNlcnZlciBVUkxzIHRvIHVzZS4gVGhpcyBzaG91bGQgYmUgYSBsaXN0IG9mIHN0cmluZ3MsIGVhY2ggb2Ygd2hpY2ggaXMgaW4gdGhlXG4gICAqIGZvcm1hdCBcInN0dW46eC55LnpcIiBvciBcInN0dW46eC55Lno6cG9ydFwiLiBGb3IgaW5zdGFuY2U6XG4gICAqXG4gICAqIFsgXCJzdHVuOmZvby5iYXIuY29tOjE5MzAyXCIsIFwic3R1bjpiYXIuYmF6LmNvbVwiIF1cbiAgICovXG4gICBzdHVuVXJsczogc3RyaW5nW107XG4gICAvKipcbiAgICAqIEEgbGlzdCBvZiBUVVJOIHNlcnZlciBVUkxzIHRvIHVzZS4gVGhpcyBzaG91bGQgYmUgYSBsaXN0IG9mIHN0cmluZ3MsIGVhY2ggb2Ygd2hpY2ggaXMgaW4gdGhlXG4gICAgKiBmb3JtYXQgXCJ0dXJuOngueS56XCIgb3IgXCJ0dXJuOngueS56OnBvcnRcIi4gRm9yIGluc3RhbmNlOlxuICAgICpcbiAgICAqIFsgXCJ0dXJuOmZvby5iYXIuY29tOjM0NzhcIiwgXCJ0dXJuOmJhci5iYXouY29tXCIgXVxuICAgICpcbiAgICAqL1xuICAgdHVyblVybHM6IHN0cmluZ1tdO1xuICAgLyoqXG4gICAgKiBBIFRVUk4gdXNlcm5hbWUgdG8gdXNlIHdoZW4gY29ubmVjdGluZyB0byB0aGUgc3BlY2lmaWVkIFRVUk4gc2VydmVyKHMpLlxuICAgICovXG4gICB0dXJuVXNlcm5hbWU6IHN0cmluZztcbiAgIC8qKlxuICAgICogQSBUVVJOIGNyZWRlbnRpYWwgKHBhc3N3b3JkKSB0byB1c2Ugd2hlbiBjb25uZWN0aW5nIHRvIHRoZSBzcGVjaWZpZWQgVFVSTiBzZXJ2ZXIocykuXG4gICAgKi9cbiAgIHR1cm5DcmVkZW50aWFsOiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogRW51bSBmb3IgcmVwcmVzZW50aW5nIGRpZmZlcmVudCBwb3NzaWJsZSBzdGF0ZXNcbiAqIHRoYXQgYSBSQVZJIHNlc3Npb24gbWlnaHQgYmUgaW4uXG4gKiBcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGVudW0gUmF2aVNlc3Npb25TdGF0ZXMge1xuICBORVcgPSBcIm5ld1wiLFxuICBDT05ORUNUSU5HID0gXCJjaGVja2luZ1wiLFxuICBDT05ORUNURUQgPSBcImNvbm5lY3RlZFwiLFxuICBDT01QTEVURUQgPSBcImNvbXBsZXRlZFwiLFxuICBESVNDT05ORUNURUQgPSBcImRpc2Nvbm5lY3RlZFwiLFxuICBGQUlMRUQgPSBcImZhaWxlZFwiLFxuICBDTE9TRUQgPSBcImNsb3NlZFwiXG59O1xuXG4vKiogXG4gKiBAaW50ZXJuYWxcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgY29tbXVuaWNhdGlvbnMgc2Vzc2lvbiBiZXR3ZWVuIGEgUkFWSSBKUyBjbGllbnQgYW5kIGEgUkFWSSBzZXJ2ZXIuXG4gKiBUaGlzIGNsYXNzIHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgYnkgdGhlIFJBVkkgY29uc3VtZXIsIGFuZCB0aGVuIHVzZWQgdG8gb3Blbiwgd29yayB3aXRoLCBhbmQgY2xvc2UgXG4gKiBSQVZJIHNlc3Npb25zIGFzIG5lZWRlZC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBSYXZpU2Vzc2lvbiB7XG4gIC8qKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKlxuICAgKiB0aGlzLl91dWlkICAgICAgICAgICAgICAgICAvLyBBIFVVSUQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcGFydGljdWxhciBSYXZpU2Vzc2lvblxuICAgKiB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzICAvLyBBIGxpc3Qgb2YgaGFuZGxlcnMgdG8gY2FsbCB3aGVuIHNvbWV0aGluZyAoZS5nLiBzdGF0ZSksIFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMsIGluY2x1ZGluZyB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZFxuICAgKlxuICAgKiB0aGlzLl9yYXZpSW1wbGVtZW50YXRpb24gICAvLyBUaGUgaW1wbGVtZW50YXRpb24gb2YgZXhhY3RseSBob3cgdG8gaW1wbGVtZW50IHRoZSBSQVZJIGNvbm5lY3Rpb24gKGUuZy4gd2l0aCBXZWJSVEMpXG4gICAqIHRoaXMuX2NvbW1hbmRDb250cm9sbGVyXG4gICAqIHRoaXMuX3N0cmVhbUNvbnRyb2xsZXJcbiAgICpcbiAgICogdGhpcy5fc3RhdGUgICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgY29ubmVjdGlvblxuICAgKlxuICAgKiBfcmVzb2x2ZU9wZW4sIF9yZWplY3RPcGVuLCBfcmVzb2x2ZUNsb3NlLCBhbmQgX3JlamVjdENsb3NlOiBVc2VkIGZvciByZXNvbHZpbmcgdGhlIFByb21pc2VzXG4gICAqICAgICBtYWRlIGJ5IHRoZSBvcGVuIGFuZCBjbG9zZSBmdW5jdGlvbnMsIHdoaWNoIGdldCBoYW5kbGVkIG91dHNpZGUgb2YgdGhvc2UgZnVuY3Rpb25zIHRoZW1zZWx2ZXNcbiAgICovXG4gIF9zdGF0ZUNoYW5nZUhhbmRsZXJzOiBTZXQ8RnVuY3Rpb24+O1xuICBfdXVpZDogc3RyaW5nO1xuXG4gIF9jb21tYW5kQ29udHJvbGxlcjogUmF2aUNvbW1hbmRDb250cm9sbGVyO1xuICBfc3RyZWFtQ29udHJvbGxlcjogUmF2aVN0cmVhbUNvbnRyb2xsZXI7XG5cbiAgX3N0YXRlOiBSYXZpU2Vzc2lvblN0YXRlcztcblxuICBfcmF2aUltcGxlbWVudGF0aW9uOiBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb247XG5cbiAgX3Jlc29sdmVPcGVuOiBGdW5jdGlvbjsgX3JlamVjdE9wZW46IEZ1bmN0aW9uO1xuICBfcmVzb2x2ZUNsb3NlOiBGdW5jdGlvbjsgX3JlamVjdENsb3NlOiBGdW5jdGlvbjtcbiAgXG4gIF9vcGVuaW5nVGltZW91dDogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSYXZpU2Vzc2lvbi5cbiAgICogRGVmYXVsdHMgdG8gdXNpbmcgbmV3IFJhdmlDb21tYW5kQ29udHJvbGxlciBhbmQgUmF2aVN0cmVhbUNvbnRyb2xsZXJzXG4gICAqIGFuZCBpbml0aWFsaXplcyB0aGUgc3RhdGUgdG8gUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VELlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIEluaXRpYWxpemUgdGhlIGxpc3Qgb2YgaGFuZGxlcnMgYW5kIHRoZSBVVUlEXG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl91dWlkID0gUmF2aVV0aWxzLmNyZWF0ZVVVSUQoKTtcbiAgICBcbiAgICAvLyBBbmQgdGhlIGNvbW1hbmQgY29udHJvbGxlciBhbmQgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICB0aGlzLl9jb21tYW5kQ29udHJvbGxlciA9IG5ldyBSYXZpQ29tbWFuZENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyID0gbmV3IFJhdmlTdHJlYW1Db250cm9sbGVyKHRoaXMuX2NvbW1hbmRDb250cm9sbGVyKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuICAgIHRoaXMuX3N0YXRlID0gUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VEO1xuICAgIFxuICAgIC8vIElmIHdlIHdhbnRlZCB0byB1c2UgYSBkaWZmZXJlbnQgY29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbixcbiAgICAvLyB3ZSB3b3VsZCBuZXcoKSBpdCBoZXJlLiAoVE9ETzogTWFrZSB0aGlzIGNvbmZpZ3VyYWJsZSBpbiBzb21lXG4gICAgLy8gaW50ZXJlc3Rpbmcgd2F5LiBGb3Igbm93LCBpdCdzIGVub3VnaCBqdXN0IHRvIG1ha2UgaXQgZWFzaWx5IFxuICAgIC8vIHN3YXBwYWJsZSBpbiB0aGUgY29kZSBoZXJlLilcbiAgICB0aGlzLl9yYXZpSW1wbGVtZW50YXRpb24gPSBuZXcgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uKHRoaXMpO1xuICAgIC8vIFdoZW4gc29tZW9uZSBzZXRzIGFuIGlucHV0IGF1ZGlvIHN0cmVhbSBvbiB0aGUgc3RyZWFtIGNvbnRyb2xsZXIsXG4gICAgLy8gcGFzcyB0aGF0IGFsb25nIHRvIHRoZSBpbXBsZW1lbnRhdGlvbidzIF9hZGRBdWRpb0lucHV0U3RyZWFtIG1ldGhvZC5cbiAgICBjb25zdCByYXZpSW1wbCA9IHRoaXMuX3JhdmlJbXBsZW1lbnRhdGlvbjtcbiAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyLnNldElucHV0QXVkaW9DaGFuZ2VIYW5kbGVyKHJhdmlJbXBsLl9hZGRBdWRpb0lucHV0U3RyZWFtLmJpbmQocmF2aUltcGwpKTtcbiAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyLnNldElucHV0VmlkZW9DaGFuZ2VIYW5kbGVyKHJhdmlJbXBsLl9hZGRWaWRlb0lucHV0U3RyZWFtLmJpbmQocmF2aUltcGwpKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgUkFWSSBzZXNzaW9uLlxuICAgKiBcbiAgICogQHJldHVybnMge1JhdmlTZXNzaW9uU3RhdGVzfVxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgVVVJRCBvZiB0aGUgc2Vzc2lvblxuICAgKiBcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldFVVSUQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3V1aWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGxpc3RlbmluZyB0byBzdGF0ZSBjaGFuZ2VzXG4gICAqIEBjYWxsYmFjayBSYXZpU2Vzc2lvbn5zdGF0ZUNoYW5nZUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBBbiBvYmplY3QgdGhhdCB3aWxsIGNvbnRhaW4gaW5mb3JtYXRpb25cbiAgICogYWJvdXQgdGhlIHN0YXRlIGNoYW5nZS4gVGhpcyBpbmNsdWRlcyB0aGUgXCJldmVudC5zdGF0ZVwiIGtleSxcbiAgICogd2hpY2ggd2lsbCBoYXZlIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZSBmcm9tIHRoZSBSYXZpU2Vzc2lvblN0YXRlcyBlbnVtLlxuICAgKi9cbiAgLyoqXG4gICAqIEFkZCBhIGhhbmRsZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBzdGF0ZVxuICAgKiBjaGFuZ2UgZXZlbnRzLlxuICAgKiBUaGVzZSBhcmUgc3RvcmVkIGluIGEgU2V0IG9mIEZ1bmN0aW9uczsgdGhlcmVmb3JlLCBhIGdpdmVuIGZ1bmN0aW9uXG4gICAqIGNhbiBvbmx5IGV4aXN0IG9uY2UgaW4gdGhpcyBTZXQuXG4gICAqIFxuICAgKiBAcGFyYW0ge1JhdmlTZXNzaW9ufnN0YXRlQ2hhbmdlQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGFkZCBzdWNjZWVkZWRcbiAgICovXG4gIGFkZFN0YXRlQ2hhbmdlSGFuZGxlcihjaGFuZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzLmFkZChjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIGFkZGluZyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyOiBcIiArXG4gICAgICAgIGVyci5tZXNzYWdlLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgaGFuZGxlciBzbyB0aGF0IGl0IHN0b3BzIGxpc3RlbmluZyBmb3Igc3RhdGVcbiAgICogY2hhbmdlIGV2ZW50cy5cbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aVNlc3Npb25+c3RhdGVDaGFuZ2VDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBoYXMgYmVlbiBoYW5kbGluZyBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHJlbW92YWwgd2FzIHN1Y2Nlc3NmdWwgKGkuZS4gZGlkIG5vdCB0aHJvdyBhbiBlcnJvciAtLSBub3RlIHRoYXQgdGhpcyBkb2VzXG4gICAqIE5PVCBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciB3YXMgaW4gdGhlIHNldCBpbiB0aGUgZmlyc3QgcGxhY2UpXG4gICAqL1xuICByZW1vdmVTdGF0ZUNoYW5nZUhhbmRsZXIoY2hhbmdlSGFuZGxlcjogRnVuY3Rpb24pIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycy5kZWxldGUoY2hhbmdlSGFuZGxlcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIFJhdmlVdGlscy5lcnIoXCJFcnJvciByZW1vdmluZyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyOiBcIiArXG4gICAgICAgIGVyci5tZXNzYWdlLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgdGhlIFJhdmlDb21tYW5kQ29udHJvbGxlciBmb3IgdXNlIHdpdGggdGhpcyBSYXZpU2Vzc2lvbi5cbiAgICogVGhlIHtsaW5rIFJhdmlDb21tYW5kQ29udHJvbGxlcn0gaXMgdXNlZCB0byBzZW5kIGNvbW1hbmRzIGFuZCBpbnB1dCB0byB0aGUgUkFWSSBzZXJ2ZXIuXG4gICAqIFxuICAgKiBAcmV0dXJucyB7UmF2aUNvbW1hbmRDb250cm9sbGVyfVxuICAgKi9cbiAgZ2V0Q29tbWFuZENvbnRyb2xsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRDb250cm9sbGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgUmF2aVN0cmVhbUNvbnRyb2xsZXIgZm9yIHVzZSB3aXRoIHRoaXMgUmF2aVNlc3Npb24uXG4gICAqIFRoZSB7bGluayBSYXZpU3RyZWFtQ29udHJvbGxlcn0gaXMgdXNlZCB0byBzZW5kIGNvbW1hbmRzIGFuZCBpbnB1dCB0byB0aGUgUkFWSSBzZXJ2ZXIuXG4gICAqIFxuICAgKiBAcmV0dXJucyB7UmF2aVN0cmVhbUNvbnRyb2xsZXJ9XG4gICAqL1xuICBnZXRTdHJlYW1Db250cm9sbGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW1Db250cm9sbGVyO1xuICB9XG4gIFxuICAvKipcbiAgICogT3BlbiBhIFJBVkkgY29ubmVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24uIFJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgd2lsbCByZXNvbHZlIHdpdGggdGhlIGNvbm5lY3RlZCBzdGF0ZSBvbmNlIHRoZSBSYXZpU2Vzc2lvbiBpcyBjb25uZWN0ZWQuXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gX19uYW1lZFBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHNpZ25hbGluZ0Nvbm5lY3Rpb25cbiAgICogQHBhcmFtIHRpbWVvdXQgQSB0aW1vdXQgaW4gbXMgYWZ0ZXIgd2hpY2ggdG8gdGltZW91dCB0aGUgYXR0ZW1wdCB0byBjb25uZWN0LiBEZWZhdWx0cyB0byA1MDAwICg1IHNlY29uZHMpLlxuICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGFwcGxpZWQgdG8gdGhlIHNlcnZlciBzaWRlIG9mIHRoZSBzZXNzaW9uLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLFxuICAgKiBtZWFuaW5nIHRoYXQgd2UnbGwgcmVseSBvbiB0aGUgZGVmYXVsdCB2YWx1ZXMgYXMgZGVmaW5lZCBvbiB0aGUgc2VydmVyLlxuICAgKiAgICAgICAgICAgIFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIG9wZW5SQVZJU2Vzc2lvbih7c2lnbmFsaW5nQ29ubmVjdGlvbiwgdGltZW91dCA9IDUwMDAsIHBhcmFtcyA9IG51bGwsIGN1c3RvbVN0dW5BbmRUdXJuID0gbnVsbH06IHsgc2lnbmFsaW5nQ29ubmVjdGlvbjogUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24sIHRpbWVvdXQ/OiBudW1iZXIsIHBhcmFtcz86IFdlYlJUQ1Nlc3Npb25QYXJhbXMsIGN1c3RvbVN0dW5BbmRUdXJuPzogQ3VzdG9tU1RVTmFuZFRVUk5Db25maWd9KSB7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFJhdmlTZXNzaW9uU3RhdGVzLkNPTk5FQ1RFRCB8fCB0aGlzLl9zdGF0ZSA9PT0gUmF2aVNlc3Npb25TdGF0ZXMuQ09NUExFVEVEKSB7XG4gICAgICAgIC8vIFJlZi4gaWNlY29ubmVjdGlvbnN0YXRlcyBhdCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDUGVlckNvbm5lY3Rpb24vaWNlQ29ubmVjdGlvblN0YXRlXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgICBcIlRoZXJlIGlzIGFscmVhZHkgYW4gb3BlbiBSQVZJIHNlc3Npb24uIFRvIHJlY29ubmVjdCwgZmlyc3QgY2xvc2UgdGhlIGV4aXN0aW5nIGNvbm5lY3Rpb24sIGFuZCB0aGVuIGF0dGVtcHQgdG8gb3BlbiBhZ2Fpbi5cIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXZpU2Vzc2lvbiA9IHRoaXM7XG4gICAgLy8gVGVsbCBvdXIgY29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbiBhYm91dCB0aGlzIHNpZ25hbGluZyBjb25uZWN0aW9uIC0tXG4gICAgLy8gaXQgbWF5IG5lZWQgdG8gdGFsayB0byBpdCBkaXJlY3RseSB3aGlsZSBpdCdzIGF0dGVtcHRpbmcgdG8gbmVnb3RpYXRlXG4gICAgLy8gdGhlIGNvbm5lY3Rpb24uXG4gICAgdGhpcy5fcmF2aUltcGxlbWVudGF0aW9uLl9hc3NpZ25TaWduYWxpbmdDb25uZWN0aW9uKHNpZ25hbGluZ0Nvbm5lY3Rpb24pO1xuXG4gICAgLy8gU2V0IGEgdGltZW91dCBpbiBjYXNlIHRoZSBzZXNzaW9uIGdldHMgaHVuZyB1cCBzb21ld2hlcmVcbiAgICB0aGlzLl9vcGVuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJSYXZpU2Vzc2lvbi5vcGVuIHRpbWVkIG91dCBhZnRlciBcIiArIHRpbWVvdXQgKyBcIiBtc1wiO1xuICAgICAgICBSYXZpVXRpbHMubG9nKGVycm9yTWVzc2FnZSwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgICAgcmF2aVNlc3Npb24uX2Z1bGZpbGxQcm9taXNlcyh7IG1lc3NhZ2U6IGVycm9yTWVzc2FnZSB9LCBSYXZpU2Vzc2lvblN0YXRlcy5GQUlMRUQpO1xuICAgICAgICAvLyBDbG9zZSB0aGUgc2Vzc2lvbiB0byBjbGVhbiB1cCBvYmplY3RzLiBXZSd2ZSBhbHJlYWR5IHJlamVjdGVkIHRoZSBwcm9taXNlIGFib3ZlLlxuICAgICAgICByYXZpU2Vzc2lvbi5jbG9zZVJBVklTZXNzaW9uKCk7XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmF2aVNlc3Npb24uX3Jlc29sdmVPcGVuID0gcmVzb2x2ZTtcbiAgICAgIHJhdmlTZXNzaW9uLl9yZWplY3RPcGVuID0gcmVqZWN0O1xuXG4gICAgICAvLyBTdGFydCB0aGUgXCJvcGVuaW5nXCIgcHJvY2Vzc1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIk9wZW5pbmcgUkFWSSBzZXNzaW9uXCIsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgICB0aGlzLl9zdGF0ZSA9IFJhdmlTZXNzaW9uU3RhdGVzLk5FVztcbiAgICAgIHJhdmlTZXNzaW9uLl9yYXZpSW1wbGVtZW50YXRpb24uX29wZW4ocGFyYW1zLCBjdXN0b21TdHVuQW5kVHVybik7XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDbG9zZSBhIFJBVkkgY29ubmVjdGlvbiwgaW5jbHVkaW5nIHNodXR0aW5nIGRvd24gdGhlIFxuICAgKiByZWxldmFudCBSYXZpU3RyZWFtQ29udHJvbGxlciBhbmQgUmF2aUNvbW1hbmRDb250cm9sbGVyLiBSZXR1cm5zIGEgUHJvbWlzZVxuICAgKiB0aGF0IHdpbGwgcmVzb2x2ZSB3aXRoIHRoZSBjbG9zZWQgc3RhdGUgb25jZSB0aGUgUmF2aVNlc3Npb24gaXMgY2xvc2VkLlxuICAgKiBcbiAgICogQHBhcmFtIHtSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbn0gc2lnbmFsaW5nQ29ubmVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGNsb3NlUkFWSVNlc3Npb24oKSB7XG4gICAgdmFyIHJhdmlTZXNzaW9uID0gdGhpcztcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFJhdmlTZXNzaW9uU3RhdGVzLkNMT1NFRCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgXCJSQVZJIHNlc3Npb24gaXMgYWxyZWFkeSBjbG9zZWQuXCJcbiAgICApO1xuICAgXG4gICAgLy8gU3RhcnQgYnkgY2xvc2luZyBvdXQgY29tbWFuZCBjb250cm9sbGVyXG4gICAgLy8gYW5kIHRoZSBzdHJlYW0gY29udHJvbGxlci5cbiAgICB0aGlzLl9zdHJlYW1Db250cm9sbGVyLl9zdG9wKCk7XG4gICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIuc3RvcE1vbml0b3JpbmdRdWV1ZXMoKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByYXZpU2Vzc2lvbi5fcmVzb2x2ZUNsb3NlID0gcmVzb2x2ZTtcbiAgICAgIHJhdmlTZXNzaW9uLl9yZWplY3RDbG9zZSA9IHJlamVjdDtcblxuICAgICAgUmF2aVV0aWxzLmxvZyhcIkNsb3NpbmcgUkFWSSBzZXNzaW9uXCIsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgICByYXZpU2Vzc2lvbi5fcmF2aUltcGxlbWVudGF0aW9uLl9jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBHZXRzIGNhbGxlZCB3aGVuZXZlciB0aGUgc3RhdGUgY2hhbmdlcyAoYW5kIHNvbWV0aW1lcyB3aGVuIGl0IGRvZXNuJ3QsXG4gICAqIGJ1dCB3aGVuIHdlIGp1c3Qgd2FudCB0byBtYWtlIHN1cmUpLiBEZXBlbmRpbmcgb24gdGhlIG5ldyAob3IgY3VycmVudCkgc3RhdGUsXG4gICAqIHRoaXMgd2lsbCBhcHByb3ByaWF0ZWx5IGZ1bGZpbGwgb3V0c3RhbmRpbmcgcHJvbWlzZXMgdGhhdCBhcmUgcGVuZGluZ1xuICAgKiBpbiBlaXRoZXIgdGhlIG9wZW4gb3IgY2xvc2UgbWV0aG9kIChvciBib3RoKS5cbiAgICovXG4gIF9mdWxmaWxsUHJvbWlzZXMoZXZlbnQ6IGFueSA9IHt9LCBzdGF0ZTogUmF2aVNlc3Npb25TdGF0ZXMpIHtcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gZXZlbnQucmVhc29uIHx8IGV2ZW50Lm1lc3NhZ2UgfHwgc3RhdGU7XG4gICAgc3dpdGNoKHN0YXRlKSB7XG4gICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkNPTk5FQ1RFRDpcbiAgICAgIGNhc2UgUmF2aVNlc3Npb25TdGF0ZXMuQ09NUExFVEVEOlxuICAgICAgICBpZiAodGhpcy5fb3BlbmluZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9vcGVuaW5nVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl9vcGVuaW5nVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVPcGVuKSB0aGlzLl9yZXNvbHZlT3BlbigpO1xuICAgICAgICBpZiAodGhpcy5fcmVqZWN0Q2xvc2UpIHRoaXMuX3JlamVjdENsb3NlKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2Vzc2lvblN0YXRlcy5ESVNDT05ORUNURUQ6XG4gICAgICAgIC8vIE5PVEU6IFBlciBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDUGVlckNvbm5lY3Rpb24jUlRDSWNlQ29ubmVjdGlvblN0YXRlX2VudW1cbiAgICAgICAgLy8gXCJkaXNjb25uZWN0ZWRcIiBpcyBhIHBvdGVudGlhbGx5IHRyYW5zaWVudCBzdGF0ZSwgc28gaW4gdGhpcyBjYXNlIHdlIHdpbGwgc2ltcGx5IHdhaXQgdW50aWwgd2VcbiAgICAgICAgLy8gZ2V0IHRvIGNvbm5lY3RlZCwgY29tcGxldGUsIG9yIGZhaWxlZC5cbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIl9mdWxmaWxsUHJvbWlzZXM6IFBvc3NpYmxlIHRyYW5zaXRvcnkgc3RhdGUgRElTQ09OTkVDVEVEOyBsZWF2aW5nIHByb21pc2VzIHBlbmRpbmdcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkZBSUxFRDpcbiAgICAgICAgaWYgKHRoaXMuX29wZW5pbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb3BlbmluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5fb3BlbmluZ1RpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZWplY3RPcGVuKSB0aGlzLl9yZWplY3RPcGVuKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGlmICh0aGlzLl9yZWplY3RDbG9zZSkgdGhpcy5fcmVqZWN0Q2xvc2UoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgLy8gRXhwbGljaXRseSBjYWxsIHRoZSBpbXBsZW1lbnRhdGlvbidzIFwiY2xvc2VcIiBtZXRob2QgdG8gbWFrZVxuICAgICAgICAvLyByZWFsbHksIHJlYWxseSBzdXJlIGl0J3MgY2xvc2VkIGluIGFkZGl0aW9uIHRvIGJlaW5nIFwiZmFpbGVkXCIuXG4gICAgICAgIC8vIFRoZXNlIGFyZSBOT1QgdGhlIHNhbWUgc3RhdGUhIEEgXCJmYWlsZWRcIiBjb25uZWN0aW9uIG1heSBzdGlsbCBiZVxuICAgICAgICAvLyBhd2FyZSBvZiBpdHMgc2lnbmFsaW5nIGNvbm5lY3Rpb24gYW5kIG90aGVyIG5pY2V0aWVzLlxuICAgICAgICAvLyBLaWNrIG9mZiB0aGF0IGNsb3NlIGluIGEgdGltZW91dCB0byBnZXQgaXQgdG8gcnVuIGFzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGZyb20gdGhlIFByb21pc2UgcmVqZWN0aW9uLlxuICAgICAgICBsZXQgcmF2aVNlc3Npb24gPSB0aGlzO1xuICAgICAgICBjb25zdCBjbG9zZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByYXZpU2Vzc2lvbi5fcmF2aUltcGxlbWVudGF0aW9uLl9jbG9zZSgpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJhdmlTZXNzaW9uU3RhdGVzLkNMT1NFRDpcbiAgICAgICAgaWYgKHRoaXMuX29wZW5pbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb3BlbmluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5fb3BlbmluZ1RpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZWplY3RPcGVuKSB0aGlzLl9yZWplY3RPcGVuKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGlmICh0aGlzLl9yZXNvbHZlQ2xvc2UpIHRoaXMuX3Jlc29sdmVDbG9zZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERvIG5vdGhpbmcgZm9yIHRoZSBcImluIHByb2dyZXNzXCIgc3RhdGVzLCBsaWtlIFwiTkVXXCIgb3IgXCJDT05ORUNUSU5HXCJcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIl9mdWxmaWxsUHJvbWlzZXM6IFNraXBwaW5nIGluLXByb2dyZXNzIHN0YXRlIFwiICsgc3RhdGUsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgfVxuICB9XG4gIFxuICBcbiAgXG4gIC8qKlxuICAgKiBIYW5kbGVyIGZvciB3aGVuZXZlciBhIG5ldyBcInRyYWNrIGNoYW5uZWxcIiBzaG93cyB1cC4gKFdoZW4gdGhpcyBldmVudCBoYXBwZW5zXG4gICAqIHNob3VsZCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiwgYW5kIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0cmFjayBzaG91bGQgYmUgXG4gICAqIHN0b3JlZCBpbiB0aGUgcGFzc2VkIGV2ZW50IG9iamVjdC4pXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9PbnRyYWNrKGV2ZW50OiBhbnkpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGNvZGUgaXMgd29ya2luZyBpZiB3ZSBoYXZlIG9ubHkgb25lIG1lZGlhIHRyYWNrICh2aWRlbyBPUiBhdWRpbyksIG5vdCBzdXJlIGl0IHdvcmtzIHdpdGggbW9yZVxuICAgIC8vIE5lZWQgdG8gbWFrZSBpdCBtb3JlIHJvYnVzdCB3aXRoIGRpZmZlcmVudCBicmFuY2hlcyBiYXNlZCBvbiB0aGUgZXZlbnQgaW5mb1xuICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCBuZXcgdHJhY2s6IFwiLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgIFJhdmlVdGlscy5sb2coZXZlbnQsIFwiUmF2aVNlc3Npb25cIik7XG5cbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQudHJhY2sgJiYgZXZlbnQudHJhY2sua2luZCA9PT0gXCJ2aWRlb1wiKSB7IFxuICAgICAgUmF2aVV0aWxzLmxvZyhcIkFkZGluZyByZW1vdGUgdmlkZW8gdHJhY2sgdG8gc3RyZWFtIGNvbnRyb2xsZXJcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgIHRoaXMuX3N0cmVhbUNvbnRyb2xsZXIuX3NldFZpZGVvU3RyZWFtKGV2ZW50LnN0cmVhbXNbMF0pO1xuICAgICAgdGhpcy5fc3RyZWFtQ29udHJvbGxlci5fb25WaWRlb1N0cmVhbVN0YXRlQ2hhbmdlZChcInJlYWR5XCIpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQudHJhY2sgJiYgZXZlbnQudHJhY2sua2luZCA9PT0gXCJhdWRpb1wiKSB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiQWRkaW5nIHJlbW90ZSBhdWRpbyB0cmFjayB0byBzdHJlYW0gY29udHJvbGxlclwiLCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgICAgdGhpcy5fc3RyZWFtQ29udHJvbGxlci5fc2V0QXVkaW9TdHJlYW0oZXZlbnQuc3RyZWFtc1swXSk7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogSGFuZGxlciBmb3Igd2hlbmV2ZXIgYSBuZXcgXCJkYXRhIGNoYW5uZWxcIiBzaG93cyB1cC4gKFdoZW4gdGhpcyBldmVudCBoYXBwZW5zIHNob3VsZCBiZSBkZXRlcm1pbmVkXG4gICAqIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiwgYW5kIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGFubmVsIHNob3VsZCBiZSBzdG9yZWQgaW4gdGhlIHBhc3NlZCBldmVudCBvYmplY3QuKVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RvT25kYXRhY2hhbm5lbChldmVudDogYW55KSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIlJlY2VpdmVkIG5ldyBjaGFubmVsOiBcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICBSYXZpVXRpbHMubG9nKGV2ZW50LCBcIlJhdmlTZXNzaW9uXCIpO1xuICAgIFxuICAgIHN3aXRjaCAoZXZlbnQuY2hhbm5lbC5sYWJlbCkge1xuICAgICAgY2FzZSBcInJhdmkuaW5wdXRcIjpcbiAgICAgICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIuX3NldElucHV0RGF0YUNoYW5uZWwoZXZlbnQuY2hhbm5lbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJhdmkuY29tbWFuZFwiOlxuICAgICAgICB0aGlzLl9jb21tYW5kQ29udHJvbGxlci5fc2V0Q29tbWFuZERhdGFDaGFubmVsKGV2ZW50LmNoYW5uZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCB1bmtub3duIGRhdGEgY2hhbm5lbCBuYW1lZCBcIiArIGV2ZW50LmNoYW5uZWwubGFiZWwsIFwiUmF2aVNlc3Npb25cIik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBcbiAgICogR2VuZXJpYyBoYW5kbGVyIFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50OiBhbnkgPSB7fSwgc3RhdGU6IFJhdmlTZXNzaW9uU3RhdGVzKSB7XG4gICAgZXZlbnRbXCJzdGF0ZVwiXSA9IHN0YXRlO1xuXG4gICAgLy8gQWx3YXlzIHRyeSB0byBmdWxmaWxsIGFueSBvcGVuIHByb21pc2VzLCBldmVuIGlmIHRoZSBzdGF0ZSBoYXNuJ3QgY2hhbmdlZFxuICAgIHRoaXMuX2Z1bGZpbGxQcm9taXNlcyhldmVudCwgc3RhdGUpO1xuXG4gICAgLy8gQnV0IG9ubHkgY2FsbCBoYW5kbGVycyBpZiB0aGUgc3RhdGUgZGlkLCBpbiBmYWN0LCBjaGFuZ2VcbiAgICBpZiAoc3RhdGUgIT09IHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIGV2ZW50W1wic3RhdGVcIl0gPSBzdGF0ZTtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIl9oYW5kbGVTdGF0ZUNoYW5nZTogXCIgKyBSYXZpVXRpbHMuc2FmZWx5UHJpbnRhYmxlKGV2ZW50KSwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBsaXN0ZW5pbmcgdG8gc3RhdHNcbiAgICogQGNhbGxiYWNrIFJhdmlTZXNzaW9ufnN0YXRzT2JzZXJ2ZXJDYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdHMgQW4gb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIGluZm9ybWF0aW9uXG4gICAqIGFib3V0IHRoZSBzdGF0cyByZWNvcmRlZFxuICAgKi9cbiAgLyoqXG4gICAqIEFkZCBhIGhhbmRsZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBuZXcgc3RhdHMgZ2VuZXJhdGVkLlxuICAgKiBUaGVzZSBhcmUgc3RvcmVkIGluIGEgU2V0IG9mIEZ1bmN0aW9uczsgdGhlcmVmb3JlLCBhIGdpdmVuIGZ1bmN0aW9uXG4gICAqIGNhbiBvbmx5IGV4aXN0IG9uY2UgaW4gdGhpcyBTZXQuXG4gICAqIFxuICAgKiBAcGFyYW0ge1JhdmlTZXNzaW9ufnN0YXRzT2JzZXJ2ZXJDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBzaG91bGQgaGFuZGxlIGEgc3RhdGUgY2hhbmdlIGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYWRkIHN1Y2NlZWRlZFxuICAgKi9cbiAgYWRkU3RhdHNPYnNlcnZlcihvYnNlcnZlcjogRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fcmF2aUltcGxlbWVudGF0aW9uLl9hZGRTdGF0c09ic2VydmVyKG9ic2VydmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBoYW5kbGVyIHNvIHRoYXQgaXQgc3RvcHMgbGlzdGVuaW5nIGZvciBzdGF0cyB1cGRhdGVzLlxuICAgKiBcbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn5zdGF0c09ic2VydmVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHJlbW92YWwgd2FzIHN1Y2Nlc3NmdWwgKGkuZS4gZGlkIG5vdCB0aHJvdyBhbiBlcnJvciAtLSBub3RlIHRoYXQgdGhpcyBkb2VzXG4gICAqIE5PVCBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciB3YXMgaW4gdGhlIHNldCBpbiB0aGUgZmlyc3QgcGxhY2UpXG4gICAqL1xuICByZW1vdmVTdGF0c09ic2VydmVyKG9ic2VydmVyOiBGdW5jdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9yYXZpSW1wbGVtZW50YXRpb24uX3JlbW92ZVN0YXRzT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICB9XG4gIFxufSAvLyBFbmQgb2YgdGhlIFJhdmlTZXNzaW9uIGNsYXNzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbiAvKipcbiAgKiBAaW50ZXJuYWxcbiAqIENvbnN0YW50cyB1c2VkIGFzIHRoZSBkZWZhdWx0IGZpbHRlciBmb3IgdGhlIHN0YXRzIGNvbGxlY3RlZCBpbiB0aGUgUmF2aVN0YXRzV2F0Y2hlclxuICovXG5leHBvcnQgY29uc3QgU1RBVFNfV0FUQ0hFUl9GSUxURVIgPSBuZXcgTWFwKFtcbiAgW1wicmVtb3RlLWluYm91bmQtcnRwXCIsIFtcImlkXCIsIFwidHlwZVwiLCBcInRpbWVzdGFtcFwiLCBcInJvdW5kVHJpcFRpbWVcIiwgXCJqaXR0ZXJcIl0gXSxcbiAgW1wiaW5ib3VuZC1ydHBcIiwgW1wiaWRcIiwgXCJ0eXBlXCIsIFwidGltZXN0YW1wXCIsIFwiaml0dGVyQnVmZmVyRGVsYXlcIiwgXCJqaXR0ZXJCdWZmZXJFbWl0dGVkQ291bnRcIiwgXCJieXRlc1JlY2VpdmVkXCJdXVxuXSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBTdGF0c1dhdGNoZXIgaXMgdGhlIG9iamVjdCByZXNwb25zaWJsZSBmb3IgY2FsbGluZyBnZXRTdGF0cyBmcm9tIHRoZVxuICogUlRDUGVlckNvbm5lY3Rpb24gYXQgcmVndWxhciBpbnRlcnZhbHMuXG4gKiBUaGUgY2FwdHVyZWQgbWV0cmljcyBhcmUgZmlsdGVyZWQgYW5kIHBhc3NlZCBvbiB0byB0aGUgc3RhdHNPYnNlcnZlcihzKS5cbiAqIFRoZSBmaWx0ZXIgaXMgYSBkaWN0aW9uYXJ5IG9mIHRoZSByZXBvcnQgdHlwZSBhbmQgZmllbGRzLlxuICogQ3VycmVudCBkZWZhdWx0IHZhbHVlIGlzIGRlZmluZWQgaW4gU1RBVFNfV0FUQ0hFUl9GSUxURVIuXG4gKiBTdGF0c09ic2VydmVyIGlzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyAyIHBhcmFtZXRlcnMsIHRoZSBjdXJyZW50IHJlY29yZCBhbmQgdGhlIHByZXZpb3VzIHJlY29yZC5cbiAqIFNldmVyYWwgU3RhdHNPYnNlcnZlciBjYWxsYmFja3MgY2FuIGJlIGFkZGVkL3JlbW92ZWQgYnkgdXNlciBjb2RlIHRocm91Z2ggdGhlIGNvcnJlc3BvbmRpbmcgbWV0aG9kcyBvZiB0aGUgb2JqZWN0LlxuICogdGhlc2UgbWV0aG9kcyBhcmUgZXhwb3NlZCBwdWJsaWNhbGx5IG9uIHRoZSBSYXZpU2Vzc2lvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJhdmlXZWJSVENTdGF0c1dhdGNoZXIge1xuICBfcmF2aUltcGxlbWVudGF0aW9uOiBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb247XG4gIF9vYnNlcnZlcnM6IFNldDxGdW5jdGlvbj47XG4gIF9maWx0ZXI6IE1hcDxzdHJpbmcsIEFycmF5PGFueT4+O1xuICBfaW50ZXJ2YWw6IG51bWJlcjtcbiAgX3ByZXZTdGF0czogQXJyYXk8YW55PjtcblxuICBcbiAgLyoqXG4gICAqIFwiQ2xhc3NcIiB2YXJpYWJsZXMgdG8gYmUgYXdhcmUgb2Y6XG4gICAqIHRoaXMuX29ic2VydmVycyBpcyB0aGUgc2V0IG9mIG9ic2VydmVyIGNhbGxiYWNrcyByZWdpc3RlcmVkIGJ5IHVzZXIgY29kZVxuICAgKiB0aGlzLl9pbnRlcnZhbCBpcyB0aGUgaW50ZXJ2YWwgdGlja2luZyB0aGUgZ2V0U3RhdHMgY2FsbFxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFJhdmlTdGF0c1dhdGNoZXJcbiAgICogQHBhcmFtIHtSYXZpV2ViUlRDSW1wbGVtZW50YXRpb259IHdlYlJUQ0ltcGxlbWVudGF0aW9uIFRoZSBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24gYmVpbmcgd2F0Y2hlZFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdlYlJUQ0ltcGxlbWVudGF0aW9uOiBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24pIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiY29uc3RydWN0b3JcIiwgXCJSYXZpU3RhdHNXYXRjaGVyXCIpO1xuICAgIHRoaXMuX3JhdmlJbXBsZW1lbnRhdGlvbiA9IHdlYlJUQ0ltcGxlbWVudGF0aW9uO1xuICAgIHRoaXMuX29ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9maWx0ZXIgPSBTVEFUU19XQVRDSEVSX0ZJTFRFUjtcbiAgICB0aGlzLl9pbnRlcnZhbCA9IDA7XG4gICAgdGhpcy5fcHJldlN0YXRzID0gW107IFxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSB3YXRjaGVyXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBvYnNlcnZlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG5ldyBzdGF0cyBnZW5lcmF0ZWQuXG4gICAqIFRoZXNlIGFyZSBzdG9yZWQgaW4gYSBTZXQgb2YgRnVuY3Rpb25zOyB0aGVyZWZvcmUsIGEgZ2l2ZW4gZnVuY3Rpb25cbiAgICogY2FuIG9ubHkgZXhpc3Qgb25jZSBpbiB0aGlzIFNldC5cbiAgICogXG4gICAqIHN0YXRzT2JzZXJ2ZXJDYWxsYmFjayBmdW5jdGlvbiByZWNlaXZlcyAyIHBhcmFtZXRlcnMsIHRoZSBjdXJyZW50IHJlY29yZCBhbmQgdGhlIHByZXZpb3VzIHJlY29yZC5cbiAgICogZnVuY3Rpb24obmV3U3RhdHMsIHByZXZTdGF0cylcbiAgICogdGhlIFN0YXRzIHBhcmFtZXRlciBpcyBhbiBBcnJheSBvZiBvYmplY3RzLCBhIGZpbHRlcmVkIGRvd24gdmVyc2lvbiBvZiB0aGUgZGljdGlvbm5hcmllcyByZXR1cm5lZCBieSBcbiAgICogUlRDUGVlckNvbm5lY3Rpb24uZ2V0U3RhdHNcbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aVN0YXRzV2F0Y2hlcn5zdGF0c09ic2VydmVyQ2FsbGJhY2t9IG9ic2VydmVyIEEgY2FsbGJhY2sgd2hpY2ggd2lsbCByZWNlaXZlIHRoZSBzdGF0cyBzYW1wbGVzXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYWRkIHN1Y2NlZWRlZFxuICAgKi9cbiAgYWRkT2JzZXJ2ZXIob2JzZXJ2ZXI6IEZ1bmN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX29ic2VydmVycy5hZGQob2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5fb25PYnNlcnZlckNoYW5nZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKFwiRXJyb3IgYWRkaW5nIGEgc3RhdHMgb2JzZXJ2ZXI6IFwiICtcbiAgICAgICAgZXJyLm1lc3NhZ2UsIFwiUmF2aVN0YXRzV2F0Y2hlclwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBvYnNlcnZlciBzbyB0aGF0IGl0IHN0b3BzIGxpc3RlbmluZyBmb3Igc3RhdHMgdXBkYXRlcy5cbiAgICogXG4gICAqIEBwYXJhbSB7UmF2aVNlc3Npb25+c3RhdHNPYnNlcnZlckNhbGxiYWNrfSBvYnNlcnZlciBBIGNhbGxiYWNrIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgc2V0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcmVtb3ZhbCB3YXMgc3VjY2Vzc2Z1bCAoaS5lLiBkaWQgbm90IHRocm93IGFuIGVycm9yIC0tIG5vdGUgdGhhdCB0aGlzIGRvZXNcbiAgICogTk9UIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIHdhcyBpbiB0aGUgc2V0IGluIHRoZSBmaXJzdCBwbGFjZSlcbiAgICovXG4gIHJlbW92ZU9ic2VydmVyKG9ic2VydmVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9vYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgIHRoaXMuX29uT2JzZXJ2ZXJDaGFuZ2UoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIHJlbW92aW5nIGEgc3RhdHMgb2JzZXJ2ZXIgaGFuZGxlcjogXCIgK1xuICAgICAgICBlcnIubWVzc2FnZSwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgXG4gIC8vIFdoZW5ldmVyIG9ic2VydmVyKHMpIGFyZSBhZGRlZCBvciByZW1vdmUsXG4gIC8vIGxldCdzIG1ha2Ugc3VyZSB0aGUgd2F0Y2hlciBpcyBydW5uaW5nIGlmIHRoZXJlIGlzIGFueSBvYnNlcnZlci5cbiAgLy8gYW5kIGxldCdzIHR1cm4gb2ZmIHRoZSBjb2xsZWN0aW9uIG9mIHN0YXRzIGlmIHRoZSBzZXQgb2Ygb2JzZXJ2ZXJzIGlzIGVtcHR5LlxuICBfb25PYnNlcnZlckNoYW5nZSgpIHtcbiAgICBjb25zdCBJTlRFUlZBTCA9IDEwMDA7XG5cbiAgICB0aGlzLl9wcmV2U3RhdHMgPSBbXTtcbiAgICAvLyBzb21lIG9ic2VydmVycywgdGhlbiBtYWtlIHN1cmUgd2UgcnVuXG4gICAgaWYgKHRoaXMuX29ic2VydmVycy5zaXplID4gMCkge1xuICAgICAgaWYgKCF0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgICBzZXRJbnRlcnZhbChhc3luYyAoaGFuZGxlcjogYW55LCB0aW1lb3V0OiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHRoaXMuX3JhdmlJbXBsZW1lbnRhdGlvbi5fZ2V0U3RhdHMoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBsZXQgZmlsdGVyZWRTdGF0czphbnkgPSBbXTtcbiAgICAgICAgICBpZiAoc3RhdHMpIHtcbiAgICAgICAgICAgIHN0YXRzLmZvckVhY2goKHJlcG9ydDogYW55KSA9PiB7XG4gICAgICAgICAgICAgIC8vIEZpbHRlciBvbiB0aGUgcmVwb3J0IHR5cGVcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbHRlci5oYXMocmVwb3J0LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0ZWQgZmllbGRzIG11c3QgYmUgYSB2YWxpZCBhcnJheSBvZiBmaWVsZHM6XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkRmllbGRzID0gdGhpcy5fZmlsdGVyLmdldChyZXBvcnQudHlwZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gVGhlbiB3aXRoaW4gdGhlIHJlcG9ydCB0eXBlLCBwaWNrIG9uIHRoZSB3YW50ZWQgZmllbGRzXG4gICAgICAgICAgICAgICAgbGV0IGZpbHRlcmVkUmVwb3J0OiBhbnkgPSB7fTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEZpZWxkcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkUmVwb3J0W2tleV0gPSByZXBvcnRba2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZmlsdGVyZWQgcmVwb3J0IGZvdW5kIGluIHRoZSByZXN1bHQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRTdGF0cy5wdXNoKGZpbHRlcmVkUmVwb3J0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFN0YXRzIGhhdmUgYmVlbiBjb2xsZWN0ZWQsIG5vdyBsZXQncyBicm9hZGNhc3RcbiAgICAgICAgICBpZiAoZmlsdGVyZWRTdGF0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVycy5mb3JFYWNoICgob2JzZXJ2ZXIpPT57XG4gICAgICAgICAgICAgIG9ic2VydmVyKGZpbHRlcmVkU3RhdHMsIHRoaXMuX3ByZXZTdGF0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZWNvcmQgdGhlIHByb2R1Y2VkIHN0YXRzIGFzIHRoZSBtb3N0IHJlY2VudCBvbmVcbiAgICAgICAgICB0aGlzLl9wcmV2U3RhdHMgPSBmaWx0ZXJlZFN0YXRzO1xuICAgICAgICB9LCBJTlRFUlZBTCApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyBvYnNlcnZlcnMsIG1ha2Ugc3VyZSB3ZSBhcmUgc3RvcHBlZFxuICAgICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKlxuVE9ETzogQWRkIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYSBSQVZJIFBlZXIgQ29ubmVjdGlvbiBcImNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb25cIlxuY2xhc3Mgc2hvdWxkIGxvb2sgbGlrZS4gU29tZSBpbml0aWFsIG5vdGVzOlxuQ29uc3RydWN0b3I6IFRha2VzIGluIGEgUmF2aVNlc3Npb24gc28gdGhhdCBpdCBjYW4gdXNlIGl0cyBoYW5kbGVycy4gVGhlIGltcGxlbWVudGF0aW9uIGNsYXNzXG5pcyBleHBlY3RlZCB0byBhc3NpZ24gdGhlIFJhdmlTZXNzaW9uJ3MgX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBzdGF0ZSkgXG5oYW5kbGVyIHRvIGFueSBhcHByb3ByaWF0ZSBldmVudHMgdGhyb3duIGJ5IGl0cyBpbXBsZW1lbnRhdGlvbiBcbihhbmQvb3IgdGhyb3duIGJ5IGl0c2VsZikuXG5TaW1pbGFybHksIGl0IGlzIGV4cGVjdGVkIHRvIGNhbGwgdGhlIHBhcmVudCdzIF9kb09uZGF0YWNoYW5uZWwgYW5kIF9kb09udHJhY2tcbm1ldGhvZHMgd2hlbiBpdCBoYXMgZGF0YSBjaGFubmVsIGFuZCB0cmFjayBjaGFubmVscyByZWFkeS5cbiAgRXhwZWN0ZWQgbWV0aG9kczpcbiAgY29uc3RydWN0b3IocmF2aVNlc3Npb24pO1xuICBfYXNzaWduU2lnbmFsaW5nQ29ubmVjdGlvbigpO1xuICBfYWRkQXVkaW9JbnB1dFN0cmVhbShpbnB1dFN0cmVhbSk7XG4gIF9hZGRWaWRlb0lucHV0U3RyZWFtKGlucHV0U3RyZWFtKTtcbiAgX29wZW4oKTsgXG4gIF9jbG9zZSgpO1xuKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFVzZSB0aGUgY29ycmVjdCBjbGFzc2VzIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIGJlaW5nIFxuICogY2FsbGVkIGZyb20gbm9kZSBvciB0aGUgYnJvd3Nlci5cbiAqL1xubGV0IGNyb3NzUGxhdGZvcm1SVENQZWVyQ29ubmVjdGlvbjphbnkgPSBudWxsO1xubGV0IGNyb3NzUGxhdGZvcm1SVENTZXNzaW9uRGVzY3JpcHRpb246YW55ID0gbnVsbDtcbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gbm9kZSBjb250ZXh0XG4gIGNyb3NzUGxhdGZvcm1SVENQZWVyQ29ubmVjdGlvbiA9IHJlcXVpcmUoJ3dydGMnKS5SVENQZWVyQ29ubmVjdGlvbjtcbiAgY3Jvc3NQbGF0Zm9ybVJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IHJlcXVpcmUoJ3dydGMnKS5SVENTZXNzaW9uRGVzY3JpcHRpb247XG59IGVsc2Uge1xuICAvLyBicm93c2VyIGNvbnRleHRcbiAgY3Jvc3NQbGF0Zm9ybVJUQ1BlZXJDb25uZWN0aW9uID0gUlRDUGVlckNvbm5lY3Rpb247XG4gIGNyb3NzUGxhdGZvcm1SVENTZXNzaW9uRGVzY3JpcHRpb24gPSBSVENTZXNzaW9uRGVzY3JpcHRpb247XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBDb25zdGFudHMgdXNlZCBkdXJpbmcgc2Vzc2lvbiBuZWdvdGlhdGlvblxuICovXG5jb25zdCBERUZBVUxUX1NUVU5fQ09ORklHID0ge1xuICAndXJscyc6IFsnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMiddXG59O1xuY29uc3QgTEVHQUNZX1RVUk5fQ09ORklHID0ge1xuICAndXJscyc6IFsndHVybjp0dXJuLmhpZ2hmaWRlbGl0eS5jb206MzQ3OCddLFxuICAndXNlcm5hbWUnOiAnY2xvdWR1c2VyJyxcbiAgJ2NyZWRlbnRpYWwnOiAnY2hhcmlvdC10cmF2ZXN0eS1ob29rJ1xufTtcbmxldCBwZWVyQ29ubmVjdGlvbkNvbmZpZyA9IHtcbiAgJ2ljZVNlcnZlcnMnOiBbXG4gICAgREVGQVVMVF9TVFVOX0NPTkZJRyxcbiAgICBMRUdBQ1lfVFVSTl9DT05GSUdcbiAgXVxufTtcblxuLyoqIFxuICogQGludGVybmFsXG4gKiBBIFdlYlJUQyBpbXBsZW1lbnRhdGlvbiBmb3IgYSBSQVZJIHBlZXIgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uIHtcbiAgX3JhdmlTZXNzaW9uOiBSYXZpU2Vzc2lvbjtcbiAgX25lZ290aWF0b3I6IGFueTtcbiAgX3N0YXRzV2F0Y2hlcjogUmF2aVdlYlJUQ1N0YXRzV2F0Y2hlcjtcbiAgX3J0Y0Nvbm5lY3Rpb246IHR5cGVvZiBjcm9zc1BsYXRmb3JtUlRDUGVlckNvbm5lY3Rpb247XG4gIF9yYXZpQXVkaW9TZW5kZXJzOiBhbnk7XG4gIF9yYXZpVmlkZW9TZW5kZXJzOiBhbnk7XG4gIF9zaWduYWxpbmdDb25uZWN0aW9uOiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgX2N1c3RvbVN0dW5BbmRUdXJuOiBDdXN0b21TVFVOYW5kVFVSTkNvbmZpZztcbiAgXG4gIC8vIE5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgaW5wdXQgc3RyZWFtcyBpbiBjYXNlIHRoZXkgZ2V0IHNldFxuICAvLyBiZWZvcmUgdGhlIGFjdHVhbCBSVEMgY29ubmVjdGlvbiBpcyBhdmFpbGFibGUuXG4gIF9hdWRpb0lucHV0U3RyZWFtOiBNZWRpYVN0cmVhbTtcbiAgX3ZpZGVvSW5wdXRTdHJlYW06IE1lZGlhU3RyZWFtO1xuICBfc2hvcnRDaXJjdWl0SGFuZGxlcjogRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFwiQ2xhc3NcIiB2YXJpYWJsZXMgdG8gYmUgYXdhcmUgb2Y6XG4gICAqIHRoaXMuX3J0Y0Nvbm5lY3Rpb24gICAgICAgLy8gVGhlIGFjdHVhbCBSVENQZWVyQ29ubmVjdGlvblxuICAgKiB0aGlzLl9yYXZpU2Vzc2lvbiAgICAgICAgIC8vIFRoZSBcIm93bmluZ1wiIFJhdmlTZXNzaW9uXG4gICAqIHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24gLy8gQSBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHdoZW4gbmVnb3RpYXRpbmcgdGhlIHNlc3Npb25cbiAgICogdGhpcy5fbmVnb3RpYXRvciAgICAgICAgICAvLyBBIGJvdW5kIHZlcnNpb24gb2YgdGhlIGNvbm5lY3Rpb24gc2V0dXAgbWV0aG9kIHRoYXQgY2FuIGJlIHVzZWQgZm9yIG1lc3NhZ2UgaGFuZGxpbmdcbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn0gcmF2aVNlc3Npb24gVGhlIG93bmVyIG9mIHRoaXMgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocmF2aVNlc3Npb246IFJhdmlTZXNzaW9uKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgIHRoaXMuX3JhdmlTZXNzaW9uID0gcmF2aVNlc3Npb247XG4gICAgdGhpcy5fbmVnb3RpYXRvciA9IHRoaXMuX3NldHVwQ29ubmVjdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3N0YXRzV2F0Y2hlciA9IG5ldyBSYXZpV2ViUlRDU3RhdHNXYXRjaGVyKHRoaXMpO1xuICAgIHRoaXMuX3JhdmlBdWRpb1NlbmRlcnMgPSBbXTtcbiAgICB0aGlzLl9yYXZpVmlkZW9TZW5kZXJzID0gW107XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBSVEMgY29ubmVjdGlvbiB0byBhIG5ldyBmcmVzaCBvbmUuIFRoaXMgZ2V0cyBjYWxsZWQgb25jZSB3ZVxuICAgKiBoYXZlIHJlY2VpdmVkIHRoZSBpbml0aWFsIFNEUCBmcm9tIHRoZSBzZXJ2ZXIgKHNvIHRoYXQgd2UgY2FuIGF0dGFjaFxuICAgKiBkeW5hbWljIFRVUk4gaW5mb3JtYXRpb24gdG8gaXQgd2hlbiBpdCdzIGNyZWF0ZWQsIGFzIG5lZWRlZCkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdFJ0Y0Nvbm5lY3Rpb24oKSB7XG4gICAgY29uc3QgcmF2aVNlc3Npb24gPSB0aGlzLl9yYXZpU2Vzc2lvbjtcbiAgICBjb25zdCBzZXNzaW9uSW1wbGVtZW50YXRpb24gPSB0aGlzO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIG5ldyBSVEMgY29ubmVjdGlvbiAoZm9yIG5vZGUgb3IgdGhlIGJyb3dzZXIpXG4gICAgdGhpcy5fcnRjQ29ubmVjdGlvbiA9IG5ldyBjcm9zc1BsYXRmb3JtUlRDUGVlckNvbm5lY3Rpb24ocGVlckNvbm5lY3Rpb25Db25maWcpO1xuICAgIGNvbnN0IHJ0Y0Nvbm5lY3Rpb24gPSB0aGlzLl9ydGNDb25uZWN0aW9uO1xuICAgIFxuICAgIC8vIENsZWFyIG91dCBhbnkgb2xkIHRyYWNrIHNlbmRlcnNcbiAgICBsZXQgc2VuZGVycyA9IHJ0Y0Nvbm5lY3Rpb24uZ2V0U2VuZGVycygpO1xuICAgIHNlbmRlcnMuZm9yRWFjaCgoc2VuZGVyOiBhbnkpID0+IHtcbiAgICAgIHNlbmRlci5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgfSk7XG4gICAgdGhpcy5fcmF2aUF1ZGlvU2VuZGVycyA9IFtdO1xuICAgIHRoaXMuX3JhdmlWaWRlb1NlbmRlcnMgPSBbXTtcbiAgICBcbiAgICAvLyBUaGlzIG5ldyBSVENDb25uZWN0aW9uJ3Mgc3RhdGUgY2hhbmdlIGV2ZW50cyB3aWxsIGp1c3RcbiAgICAvLyBjYWxsIGJhY2sgdXAgdG8gdGhlIG1haW4gUmF2aVNlc3Npb24ncyBcbiAgICAvLyBzdGF0ZUNoYW5nZUhhbmRsZXJzLlxuICAgIC8vIE5PVEU6IFRha2UgYSBsb29rIGF0IEJJR1dPUkxELTEwNjIgYW5kIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1BlZXJDb25uZWN0aW9uI1JUQ0ljZUNvbm5lY3Rpb25TdGF0ZV9lbnVtXG4gICAgLy8gYW5kXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1BlZXJDb25uZWN0aW9uI1JUQ1BlZXJDb25uZWN0aW9uU3RhdGVfZW51bVxuICAgIC8vIHRvIHNlZSB3aHkgd2UncmUgbGlzdGVuaW5nIG9uIGljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSBpbnN0ZWFkIG9mIHBlZXJjb25uZWN0aW9uc3RhdGVjaGFuZ2VcbiAgICBydGNDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgXG4gICAgICBpZiAocnRjQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUgPT09IFwiY29ubmVjdGVkXCIgfHwgcnRjQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUgPT0gXCJjb21wbGV0ZWRcIikge1xuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2Vzc2lvbiBoYXMgZnVsbHkgY29ubmVjdGVkOyByZW1vdmluZyBzaG9ydC1jaXJjdWl0IGhhbmRsZXJcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIHNlc3Npb25JbXBsZW1lbnRhdGlvbi5fc2lnbmFsaW5nQ29ubmVjdGlvbi5yZW1vdmVTdGF0ZUNoYW5nZUhhbmRsZXIoc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9zaG9ydENpcmN1aXRIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHJhdmlTZXNzaW9uLl9oYW5kbGVTdGF0ZUNoYW5nZShldmVudCwgcnRjQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUpOyBcbiAgICB9KTtcblxuICAgIC8vIFNpbWlsaWFybHksIGxpc3RlbiBhdCB0aGUgUmF2aVNlc3Npb24gbGV2ZWwgZm9yIHRyYWNrIGFuZCBkYXRhIGNoYW5uZWwgZXZlbnRzXG4gICAgcnRjQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdkYXRhY2hhbm5lbCcsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgcmF2aVNlc3Npb24uX2RvT25kYXRhY2hhbm5lbChldmVudCk7IH0pO1xuICAgIHJ0Y0Nvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCBmdW5jdGlvbihldmVudDogYW55KSB7IHJhdmlTZXNzaW9uLl9kb09udHJhY2soZXZlbnQpOyB9KTtcblxuICAgIC8vIEhvd2V2ZXIsIHdlIG5lZWQgdG8gbGlzdGVuIGF0IG91ciBvd24gUlRDIGltcGxlbWVudGF0aW9uIGxldmVsIGZvciBpY2UgY2FuZGlkYXRlIGV2ZW50cywgXG4gICAgLy8gYmVjYXVzZSB0aGV5J3JlIHBhcnQgb2YgdGhlIHNlc3Npb24gbmVnb3RpYXRpb25cbiAgICBydGNDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9kb09uaWNlY2FuZGlkYXRlKGV2ZW50KTsgfSk7XG5cbiAgICAvLyBXaGVuIGEgbmVnb3RpYXRpb25uZWVlZGVkIGlzIHRyaWdnZXJlZCBmcm9tIHRoaXMgcGVlciwgc2lnbmFsIHRoZSBzZXJ2ZXIgc2lkZSB0byBpbml0aWF0ZSBhbiBvZmZlclxuICAgIC8vIEluIFJhdmksIHRoZSB3ZWJydGMgbmVnb3RpYXRpb24gaXMgYWx3YXlzIGluaXRpYXRlZCBmcm9tIHRoZSBzZXJ2ZXIgc2lkZVxuICAgIHJ0Y0Nvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignbmVnb3RpYXRpb25uZWVkZWQnLCBmdW5jdGlvbihldmVudDogYW55KSB7IHNlc3Npb25JbXBsZW1lbnRhdGlvbi5fZG9Pbm5lZ290aWF0aW9ubmVlZGVkKGV2ZW50KTsgfSk7XG5cbiAgICAvLyBXYXRjaCB0aGUgc2lnbmFsaW5nIHN0YXRlIGNoYW5nZXMgZm9yIGRlYnVnLlxuICAgIHJ0Y0Nvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcInNpZ25hbGluZ3N0YXRlY2hhbmdlXCIsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9kb09uc2lnbmFsaW5nc3RhdGVjaGFuZ2VkKGV2ZW50KTsgfSk7XG5cbiAgfVxuICBcbiAgLyoqXG4gICAqIFRlbGwgdGhpcyBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24gd2hhdCBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiB0byB1c2UuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgb3duaW5nIFJhdmlTZXNzaW9uLiBcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2Fzc2lnblNpZ25hbGluZ0Nvbm5lY3Rpb24oc2lnbmFsaW5nQ29ubmVjdGlvbjogUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24pIHtcbiAgICB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uID0gc2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEFkZCBhbiBpbnB1dCBzdHJlYW0gdG8gdGhpcyBjb25uZWN0aW9uLiAoVGhpcyBjYW4gYmUgZG9uZSBhdFxuICAgKiBhbnkgcG9pbnQgZHVyaW5nIHRoZSBjb25uZWN0aW9uLCB3aGljaCBpcyB3aHkgaXQncyBhIHNlcGFyYXRlIG1ldGhvZC4pXG4gICAqIFxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG93bmluZyBSYXZpU2Vzc2lvbiB3aGVuIGl0cyBzdHJlYW0gY29udHJvbGxlclxuICAgKiBnZXRzIGFuIGlucHV0IHN0cmVhbS4gXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9hZGRBdWRpb0lucHV0U3RyZWFtKHN0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICBjb25zdCBydGNDb25uZWN0aW9uID0gdGhpcy5fcnRjQ29ubmVjdGlvbjtcbiAgICBjb25zdCBzZXNzaW9uSW1wbGVtZW50YXRpb24gPSB0aGlzO1xuICAgIHZhciByZXR2YWwgPSBmYWxzZTtcblxuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIHRoaXMuX2F1ZGlvSW5wdXRTdHJlYW0gPSBzdHJlYW07XG4gICAgICBpZiAoISBydGNDb25uZWN0aW9uKSB7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJTZXR0aW5nIGF1ZGlvIGlucHV0IHN0cmVhbSB3aXRob3V0IGF2YWlsYWJsZSBSVEMgY29ubmVjdGlvbjsgd2lsbCBzdG9yZSBpdCB1bnRpbCByZWFkeVwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGtlZXAgdHJhY2sgb2YgdGhlIHNlbmRlcnMgdGhhdCB3ZSBpbnRlcmFjdCB3aXRoXG4gICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gdGhlIGxpc3Qgb2Ygc2VuZGVycyBvbiB0aGUgUlRDIGNvbm5lY3Rpb24sXG4gICAgICAvLyBiZWNhdXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlJ3JlIG9ubHkgd29ya2luZyB3aXRoIFxuICAgICAgLy8gc2VuZGVycyB0aGF0IG1hdGNoIG91ciBvd24gcGFyYW1ldGVycy5cbiAgICAgIGNvbnN0IGN1cnJlbnRTZW5kZXJzID0gdGhpcy5fcmF2aUF1ZGlvU2VuZGVycztcbiAgICAgIFxuICAgICAgLy8gTGlzdCBvZiBuZXcgdHJhY2tzIGluIHRoZSBwYXNzZWQgc3RyZWFtXG4gICAgICBjb25zdCBuZXdBdWRpb1RyYWNrcyA9IHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgICAgY29uc3QgbnVtTmV3VHJhY2tzID0gbmV3QXVkaW9UcmFja3MubGVuZ3RoO1xuXG4gICAgICBsZXQgaT0wO1xuICAgICAgZm9yIChpOyBpIDwgY3VycmVudFNlbmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRm9yIGVhY2ggb2YgdGhlIHRyYWNrcyB0aGF0IHdlIGFscmVhZHkga25vdyBhYm91dCxcbiAgICAgICAgLy8gcmVwbGFjZSB0aGVtIHdpdGggYSB0cmFjayBmcm9tIHRoZSBuZXcgc3RyZWFtLlxuICAgICAgICAvLyAoTm90ZTogdGhpcyBzZWVtcyB0byBhZGQgYSBsaXR0bGUgbGF0ZW5jeSB3aGVuIGl0IGdldHMgY2FsbGVkLFxuICAgICAgICAvLyBidXQgb24gdGhlIHBsdXMgc2lkZSwgZG9lcyBub3QgdHJpZ2dlciBhIHJlbmVnb3RpYXRpb24uIFRoZSBsYXRlbmN5XG4gICAgICAgIC8vIHRlbmRzIHRvIGRpc3NpcGF0ZSBvdmVyIHRpbWUuKVxuICAgICAgICBpZiAoaSA8IG51bU5ld1RyYWNrcykge1xuICAgICAgICAgIFJhdmlVdGlscy5sb2coXCJSZXBsYWNpbmcgYXVkaW8gdHJhY2sgI1wiICsgaSArIFwiICBpbiBydGNDb25uZWN0aW9uXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAgIGN1cnJlbnRTZW5kZXJzW2ldLnJlcGxhY2VUcmFjayhuZXdBdWRpb1RyYWNrc1tpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgdHJhY2tzIGluIHRoZSBvbGQgc3RyZWFtIHRoYW5cbiAgICAgICAgICAvLyBpbiB0aGUgbmV3IG9uZSwgc2V0IHRoZSBleHRyYXMgdG8gbnVsbCBcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2V0dGluZyBhdWRpbyBzZW5kZXIgI1wiICsgaSArIFwiIHRvIG51bGxcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgICAgY3VycmVudFNlbmRlcnNbaV0ucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIHRyYWNrcyBpbiB0aGUgbmV3IHN0cmVhbSB0aGVuXG4gICAgICAvLyBpbiB0aGUgb2xkLCBhZGQgdGhlbVxuICAgICAgZm9yIChpOyBpIDwgbnVtTmV3VHJhY2tzOyBpKyspIHtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIkFkZGluZyBsb2NhbCBhdWRpbyB0cmFjayAjXCIgKyBpICsgXCIgdG8gcnRjQ29ubmVjdGlvblwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgY3VycmVudFNlbmRlcnMucHVzaChydGNDb25uZWN0aW9uLmFkZFRyYWNrKG5ld0F1ZGlvVHJhY2tzW2ldLCBzdHJlYW0pKTtcbiAgICAgICAgLy8gV2UgZXhwZWN0IHRoZSAnbmVnb3RpYXRpb25uZWVkZWQnIGV2ZW50IHRvIGZpcmVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgc3RyZWFtIGFzc2lnbmVkIGlzIG51bGwgbWVhbmluZyB3ZSB3YW50IHRvIGtpbGwgYW55IGlucHV0IGF1ZGlvIHN0cmVhbVxuICAgICAgICBjb25zdCBjdXJyZW50U2VuZGVycyA9IHRoaXMuX3JhdmlBdWRpb1NlbmRlcnM7XG5cbiAgICAgICAgLy8gc2ltcGx5IHNldCBhbGwgdGhlIGV4aXN0aW5nIHNlbmRlcnMgdG8gbnVsbCB0cmFjay5cbiAgICAgICAgbGV0IGk9MDtcbiAgICAgICAgZm9yIChpOyBpIDwgY3VycmVudFNlbmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2V0dGluZyBhdWRpbyBzZW5kZXIgI1wiICsgaSArIFwiIHRvIG51bGxcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgICAgY3VycmVudFNlbmRlcnNbaV0ucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR2YWw7XG4gIH1cblxuICBfYWRkVmlkZW9JbnB1dFN0cmVhbShzdHJlYW06IE1lZGlhU3RyZWFtKSB7XG4gICAgY29uc3QgcnRjQ29ubmVjdGlvbiA9IHRoaXMuX3J0Y0Nvbm5lY3Rpb247XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHJldHZhbCA9IGZhbHNlO1xuXG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgdGhpcy5fdmlkZW9JbnB1dFN0cmVhbSA9IHN0cmVhbTtcbiAgICAgIGlmICghIHJ0Y0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNldHRpbmcgdmlkZW8gaW5wdXQgc3RyZWFtIHdpdGhvdXQgYXZhaWxhYmxlIFJUQyBjb25uZWN0aW9uOyB3aWxsIHN0b3JlIGl0IHVudGlsIHJlYWR5XCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2Uga2VlcCB0cmFjayBvZiB0aGUgc2VuZGVycyB0aGF0IHdlIGludGVyYWN0IHdpdGhcbiAgICAgIC8vIHNlcGFyYXRlbHkgZnJvbSB0aGUgbGlzdCBvZiBzZW5kZXJzIG9uIHRoZSBSVEMgY29ubmVjdGlvbixcbiAgICAgIC8vIGJlY2F1c2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UncmUgb25seSB3b3JraW5nIHdpdGggXG4gICAgICAvLyBzZW5kZXJzIHRoYXQgbWF0Y2ggb3VyIG93biBwYXJhbWV0ZXJzLlxuICAgICAgY29uc3QgY3VycmVudFNlbmRlcnMgPSB0aGlzLl9yYXZpVmlkZW9TZW5kZXJzO1xuICAgICAgXG4gICAgICAvLyBMaXN0IG9mIG5ldyB0cmFja3MgaW4gdGhlIHBhc3NlZCBzdHJlYW1cbiAgICAgIGNvbnN0IG5ld1ZpZGVvVHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICBjb25zdCBudW1OZXdUcmFja3MgPSBuZXdWaWRlb1RyYWNrcy5sZW5ndGg7XG4gICAgICBcbiAgICAgIC8vIEF0IHRoZSBtb21lbnQsIHJhdmkgY2xpZW50IHNlc3Npb24gb25seSBzdXBwb3J0IG9uZSBvdXRib3VuZCB2aWRlbyB0cmFja1xuICAgICAgaWYgKG51bU5ld1RyYWNrcyA+IDApIHtcbiAgICAgICAgLy8gSWYgY3VycmVudCB2aWRlbyBzZW5kZXIgZXhpc3RzIGFscmVhZHksIGp1c3QgcmVwbGFjZSB0cmFja1xuICAgICAgICBpZiAoY3VycmVudFNlbmRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIFJhdmlVdGlscy5sb2coXCJSZXBsYWNpbmcgdmlkZW8gdHJhY2sgIzAgaW4gcnRjQ29ubmVjdGlvblwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgICBjdXJyZW50U2VuZGVyc1swXS5yZXBsYWNlVHJhY2sobmV3VmlkZW9UcmFja3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVsc2UganVzdCBhZGQgdGhlIG5ldyB0cmFjayB0byB0aGUgUGVlckNvbm5lY3Rpb24uXG4gICAgICAgICAgUmF2aVV0aWxzLmxvZyhcIkFkZGluZyB2aWRlbyB0cmFjayAjMCB0byBydGNDb25uZWN0aW9uXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAgIGN1cnJlbnRTZW5kZXJzLnB1c2gocnRjQ29ubmVjdGlvbi5hZGRUcmFjayhuZXdWaWRlb1RyYWNrc1swXSkpO1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCB0aGUgJ25lZ290aWF0aW9ubmVlZGVkJyBldmVudCB0byBmaXJlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dmFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJBc3NpZ25lZCB2aWRlbyBzdHJlYW0gZG9lc24ndCBjb250YWluIHZpZG9lIHRyYWNrXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgfSAgICAgICAgICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlIHN0cmVhbSBhc3NpZ25lZCBpcyBudWxsIG1lYW5pbmcgd2Ugd2FudCB0byBraWxsIGFueSBpbnB1dCB2aWRlbyBzdHJlYW1cbiAgICAgIGNvbnN0IGN1cnJlbnRTZW5kZXJzID0gdGhpcy5fcmF2aVZpZGVvU2VuZGVycztcblxuICAgICAgLy8gc2ltcGx5IHNldCBhbGwgdGhlIGV4aXN0aW5nIHNlbmRlcnMgdG8gbnVsbCB0cmFjay5cbiAgICAgIGxldCBpPTA7XG4gICAgICBmb3IgKGk7IGkgPCBjdXJyZW50U2VuZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2V0dGluZyB2aWRlbyBzZW5kZXIgI1wiICsgaSArIFwiIHRvIG51bGxcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIGN1cnJlbnRTZW5kZXJzW2ldLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIGEgc2Vzc2lvbi4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIHRoaXMgYnkgYWRkaW5nIGEgaGFuZGxlciB0byB0aGUgc2lnbmFsaW5nQ29ubmVjdGlvblxuICAgKiB0aGF0IHdpbGwgbGlzdGVuIGZvciBcInJlYWR5IHRvIG5lZ290aWF0ZSBjb25uZWN0aW9uXCIgbWVzc2FnZXMgc28gdGhhdCB0aGUgXG4gICAqIF9zZXR1cENvbm5lY3Rpb24gbWV0aG9kIGNhbiB0aGVuIG5lZ290aWF0ZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBvd25pbmcgUmF2aVNlc3Npb24uIFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb3BlbihwYXJhbXM6IFdlYlJUQ1Nlc3Npb25QYXJhbXMsIGN1c3RvbVN0dW5BbmRUdXJuOiBDdXN0b21TVFVOYW5kVFVSTkNvbmZpZykge1xuICAgIFJhdmlVdGlscy5sb2coXCJBdHRlbXB0aW5nIHRvIG9wZW4gY29ubmVjdGlvbi4uLlwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICB0aGlzLl9jdXN0b21TdHVuQW5kVHVybiA9IGN1c3RvbVN0dW5BbmRUdXJuO1xuICAgIGlmICh0aGlzLl9ydGNDb25uZWN0aW9uXG4gICAgICAgICYmICh0aGlzLl9ydGNDb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PSAnY29ubmVjdGluZydcbiAgICAgICAgICAgIHx8IHRoaXMuX3J0Y0Nvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlID09ICdjb25uZWN0ZWQnKSlcbiAgICB7XG4gICAgICBSYXZpVXRpbHMubG9nKFwiV2UgYWxyZWFkeSBoYXZlIGEgY29ubmVjdGlvbiBpbiBwcm9ncmVzcy4gV2lsbCBub3QgYXR0ZW1wdCBhIG5ldyBvbmUuXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgLy8gVHJpZ2dlciBzdGF0ZSBjaGFuZ2UgaGFuZGxlciBvbiB0aGUgb3duaW5nIHNlc3Npb24gdG8gZmluYWxpemUgYW55IFxuICAgICAgLy8gcmVzaWR1YWwgUHJvbWlzZXNcbiAgICAgIHRoaXMuX3JhdmlTZXNzaW9uLl9oYW5kbGVTdGF0ZUNoYW5nZSh7XCJzdGF0ZVwiOnRoaXMuX3J0Y0Nvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlfSwgdGhpcy5fcnRjQ29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUpOyBcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2lnbmFsaW5nQ29ubmVjdGlvbikge1xuICAgICAgLy8gQWRkIGEgaGFuZGxlciBmb3Igc3RhdGUgY2hhbmdlIGV2ZW50cyBvbnRvIHRoZSBwcm92aWRlZFxuICAgICAgLy8gc2lnbmFsaW5nIGNvbm5lY3Rpb24uIFRoaXMgc2hvdWxkIGxpc3RlbiBmb3IgdGhlIGFwcHJvcHJpYXRlIFxuICAgICAgLy8gXCJyZWFkeSB0byBuZWdvdGlhdGUgY29ubmVjdGlvblwiIG1lc3NhZ2UgZnJvbSB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24uXG4gICAgICB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uLmFkZE1lc3NhZ2VIYW5kbGVyKHRoaXMuX25lZ290aWF0b3IpO1xuICAgICAgXG4gICAgICAvLyBBZGQgYSBzdGF0ZSBjaGFuZ2UgaGFuZGxlciB0byB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24uIElmIHRoZVxuICAgICAgLy8gY29ubmVjdGlvbiBjbG9zZXMgb3IgZmFpbHMgX3doaWxlIHdlJ3JlIGluIHRoZSBwcm9jZXNzIG9mIG5lZ290aWF0aW5nXG4gICAgICAvLyB0aGUgY29ubmVjdGlvbl8gKGkuZS4gYmVmb3JlIHRoZSBjb25uZWN0aW9uIGlzIGZ1bGx5IG9wZW4pLCB3ZSBzaG91bGQgc3RvcCB0cnlpbmcuXG4gICAgICAvLyBXZSByZW1vdmUgdGhpcyBoYW5kbGVyIG9uY2UgdGhlIFdlYlJUQyBjb25uZWN0aW9uIGlzIGZ1bGx5IG9wZW4sIGJlY2F1c2UgaWYgdGhlIFxuICAgICAgLy8gc2lnbmFsaW5nIGNvbm5lY3Rpb24gY2xvc2VzIF9hZnRlcl8gd2UndmUgZ290IGEgc3RhYmxlIGNvbm5lY3Rpb24sIHdlIHdhbnQgdG9cbiAgICAgIC8vIGxlYXZlIG91ciB3ZWJydGMgY29ubmVjdGlvbiBvcGVuIGFzIGxvbmcgYXMgcG9zc2libGUuXG4gICAgICB0aGlzLl9zaG9ydENpcmN1aXRIYW5kbGVyID0gdGhpcy5fY2FuY2VsT3BlbmluZ1Byb2Nlc3NPblNpZ25hbGluZ0Rpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24uYWRkU3RhdGVDaGFuZ2VIYW5kbGVyKHRoaXMuX3Nob3J0Q2lyY3VpdEhhbmRsZXIpO1xuXG4gICAgICAvLyBTZW5kIHRoZSBtYWdpYyBzdHJpbmcgZm9yIG9wZW5pbmcgYSBjb25uZWN0aW9uLlxuICAgICAgLy8gd2l0aCBwYXJhbXMgZXZlbnR1YWxseVxuICAgICAgbGV0IG1lc3NhZ2U6IGFueSA9IHt9O1xuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgIG1lc3NhZ2UgPSBwYXJhbXM7XG4gICAgICAgICAgbWVzc2FnZVtcInNlc3Npb25JRFwiXSA9IHRoaXMuX3JhdmlTZXNzaW9uLmdldFVVSUQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVzc2FnZSA9IHRoaXMuX3JhdmlTZXNzaW9uLmdldFVVSUQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2lnbmFsaW5nQ29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KHsncmVxdWVzdCc6IG1lc3NhZ2V9KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBhIHNlc3Npb24gdGhhdCdzIGluIHRoZSBwcm9jZXNzIG9mIGJlaW5nIG9wZW5lZC4gVGhpcyBnZXRzIGNhbGxlZCBpZlxuICAgKiB3ZSByZWNlaXZlIGEgc3RhdGUgY2hhbmdlIGZyb20gdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uIGFmdGVyIHRoZSBcIm9wZW5cIiBoYXMgYWxyZWFkeVxuICAgKiBiZWVuIGNhbGxlZC4gSWYgc28gKGFuZCBpZiB0aGF0IHN0YXRlIGNoYW5nZSBpcyBhbiBlcnJvci9jbG9zZSksIHdlIHNob3J0LWNpcmN1aXRcbiAgICogdGhlIHByb2Nlc3Mgb2Ygb3BlbmluZyB0aGUgc2Vzc2lvbiBhbmQgY2xvc2Ugb3V0IGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBUaGlzIGhhbmRsZXIgaXMgYWRkZWQgYnkgdGhlIF9vcGVuKCkgbWV0aG9kIGFuZCByZW1vdmVkIHdoZW4gZWl0aGVyIHRoZSBjb25uZWN0aW9uIGlzXG4gICAqIGNvbm5lY3RlZCBvciB3aGVuIHRoZSBfY2xvc2UoKSBtZXRob2QgaXMgY2FsbGVkLCB3aGljaGV2ZXIgY29tZXMgZmlyc3QuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9jYW5jZWxPcGVuaW5nUHJvY2Vzc09uU2lnbmFsaW5nRGlzY29ubmVjdCAoZXZlbnQ6IGFueSkge1xuICAgIGxldCBzdGF0ZSA9IGV2ZW50LnN0YXRlIHx8IFwidW5rbm93blwiO1xuICAgIGNvbnN0IHJhdmlTZXNzaW9uID0gdGhpcy5fcmF2aVNlc3Npb247XG4gICAgc3dpdGNoKHN0YXRlKSB7XG4gICAgICBjYXNlIFJhdmlTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEOlxuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2lnbmFsaW5nIHN0YXRlIGNsb3NlZCBiZWZvcmUgc2Vzc2lvbiB3YXMgZXN0YWJsaXNoZWQ7IGNsb3NpbmcgUmF2aVNlc3Npb25cIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIHJhdmlTZXNzaW9uLl9oYW5kbGVTdGF0ZUNoYW5nZShldmVudCwgUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VEKTtcbiAgICAgICAgLy8gQ2FsbCBfY2xvc2UgdG8gY2xlYW4gdXAgYWZ0ZXIgb3Vyc2VsdmVzXG4gICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2lnbmFsaW5nU3RhdGVzLkVSUk9SOlxuICAgICAgICBSYXZpVXRpbHMubG9nKFwiU2lnbmFsaW5nIHN0YXRlIGVycm9yZWQgb3V0IGJlZm9yZSBzZXNzaW9uIHdhcyBlc3RhYmxpc2hlZDsgY2xvc2luZyBSYXZpU2Vzc2lvblwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgcmF2aVNlc3Npb24uX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBSYXZpU2Vzc2lvblN0YXRlcy5GQUlMRUQpO1xuICAgICAgICB0aGlzLl9jbG9zZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUmF2aVNpZ25hbGluZ1N0YXRlcy5VTkFWQUlMQUJMRTpcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNpZ25hbGluZyBzdGF0ZSByZWFjaGVkICd1bmF2YWlsYWJsZScgYmVmb3JlIHNlc3Npb24gd2FzIGVzdGFibGlzaGVkOyBjbG9zaW5nIFJhdmlTZXNzaW9uXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICByYXZpU2Vzc2lvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTZXNzaW9uU3RhdGVzLkZBSUxFRCk7XG4gICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNpZ25hbGluZyBzdGF0ZSBoYXMgY2hhbmdlZCBkdXJpbmcgb3BlbmluZyBvZiBSQVZJIHNlc3Npb24sIGJ1dCBpcyBhbiBPSyBjaGFuZ2UuIE5ldyBzdGF0ZTogXCIgKyBzdGF0ZSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgfVxuICB9XG4gIFxuICBcbiAgLyoqXG4gICAqIENsb3NlIGEgc2Vzc2lvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBvd25pbmcgUmF2aVNlc3Npb24uIFxuICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBBTFdBWVMgZ29lcyB0aHJvdWdoIGl0cyBjbGVhbnVwIHByb2Nlc3MsXG4gICAqIGV2ZW4gaWYgdGhlcmUgaXNuJ3QgYW4gdW5kZXJseWluZyBSVEMgY29ubmVjdGlvbiBvciB0aGUgdW5kZXJseWluZ1xuICAgKiBSVEMgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGNsb3NlZC4gVGhpcyBpcyB0byBtYWtlIHN1cmUgdGhhdCBvdGhlciB0aGluZ3NcbiAgICogKGUuZy4gc3RhdGUgY2hhbmdlIGhhbmRsZXJzIG9uIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBhbmQgcHJvbWlzZXMpIGFsd2F5c1xuICAgKiBnZXQgY2xlYW5lZCB1cCBhcHByb3ByaWF0ZWx5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfY2xvc2UoKSB7XG4gICAgdGhpcy5fc3RhdHNXYXRjaGVyLnN0b3AoKTtcbiAgICBjb25zdCByYXZpU2Vzc2lvbiA9IHRoaXMuX3JhdmlTZXNzaW9uO1xuICAgIFJhdmlVdGlscy5sb2coXCJjbG9zaW5nXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuXG4gICAgaWYgKHRoaXMuX3J0Y0Nvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMuX3J0Y0Nvbm5lY3Rpb24uY2xvc2UoKTsgICAgXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIG91ciBzZXNzaW9uLW5lZ290aWF0aW5nIG1lc3NhZ2UgaGFuZGxlciBmcm9tIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvblxuICAgIHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24ucmVtb3ZlTWVzc2FnZUhhbmRsZXIodGhpcy5fbmVnb3RpYXRvcik7XG5cbiAgICAvLyBSZW1vdmUgdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uJ3Mgc3RhdGUgY2hhbmdlIGhhbmRsZXIgdGhhdCB3b3VsZCBoYXZlXG4gICAgLy8gc2hvcnQtY2lyY3VpdGVkIGNvbm5lY3Rpb24gbG9naWMgaWYgdGhlIHNpZ25hbGluZyBkaXNjb25uZWN0cyB3aGlsZVxuICAgIC8vIHdlJ3JlIHN0aWxsIHRyeWluZyB0byBuZWdvdGlhdGVcbiAgICB0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uLnJlbW92ZVN0YXRlQ2hhbmdlSGFuZGxlcih0aGlzLl9zaG9ydENpcmN1aXRIYW5kbGVyKTtcblxuICAgIC8vIF9ydGNDb25uZWN0aW9uIHdpbGwgYmUgcmVpbml0aWFsaXplZCBpZi93aGVuIGl0J3MgbmVlZGVkIGFnYWluLCBuZXh0IHRpbWVcbiAgICAvLyBhIGNvbm5lY3QgaXMgYXR0ZW1wZWQgYW5kIGFuIHNkcCBvZmZlciBhcnJpdmVzLlxuICAgIHRoaXMuX3J0Y0Nvbm5lY3Rpb24gPSBudWxsO1xuXG4gICAgLy8gTWFrZSBhYnNvbHV0ZWx5IHN1cmUgdGhlIG93bmluZyBzZXNzaW9uIGtub3dzIHdlJ3ZlIGNsb3NlZFxuICAgIHJhdmlTZXNzaW9uLl9oYW5kbGVTdGF0ZUNoYW5nZSh7fSwgUmF2aVNlc3Npb25TdGF0ZXMuQ0xPU0VEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHNlbmQgbG9jYWwgSUNFIGNhbmRpZGF0ZSBwcm9wb3NhbHMgdG8gdGhlIHNlcnZlci5cbiAgICogXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9PbmljZWNhbmRpZGF0ZShldmVudDogYW55KSB7XG4gICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSAmJiBldmVudC5jYW5kaWRhdGUgIT0gXCJcIikge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIlNlbmRpbmcgbG9jYWwgSUNFIGNhbmRpZGF0ZTogXCIgKyBKU09OLnN0cmluZ2lmeShldmVudC5jYW5kaWRhdGUpLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgIHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb24uc2VuZChKU09OLnN0cmluZ2lmeSh7J2ljZSc6IGV2ZW50LmNhbmRpZGF0ZSwgJ3V1aWQnOiB0aGlzLl9yYXZpU2Vzc2lvbi5nZXRVVUlEKCl9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJhdmlVdGlscy5sb2coXCJFbmQgb2YgbG9jYWwgSUNFIGNhbmRpZGF0ZXNcIiwgXCJSYXZpU2Vzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBIYW5kbGUgcmVuZWdvdGlhdGlvbiB3aGVuIG5lZWRlZC5cbiAgICogXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9Pbm5lZ290aWF0aW9ubmVlZGVkKGV2ZW50OiBhbnkpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwibmVlZCByZW5lZ290aWF0aW9uIHBsZWFzZVwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICBjb25zdCBtc2cgPSB7XG4gICAgICByZW5lZ290aWF0ZTogXCJwbGVhc2VcIixcbiAgICAgIHV1aWQ6IHRoaXMuX3JhdmlTZXNzaW9uLmdldFVVSUQoKVxuICAgIH07XG4gICAgY29uc3QgZGVzYyA9IEpTT04uc3RyaW5naWZ5KG1zZyk7XG4gICBcbiAgICAvLyBuZWdvdGlhdGlvbiBuZWVkZWQgYnV0IG9ubHkgaWYgd2UgYXJlIG5vdCBhbHJlYWR5IGN1cnJlbnRseSBuZWdvdGlhdGluZ1xuICAgIGlmICh0aGlzLl9zaWduYWxpbmdDb25uZWN0aW9uICYmIHRoaXMuX3J0Y0Nvbm5lY3Rpb24gJiYgdGhpcy5fcnRjQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gXCJzdGFibGVcIikge1xuICAgICAgdGhpcy5fc2lnbmFsaW5nQ29ubmVjdGlvbi5zZW5kKGRlc2MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgc2lnbmFsaW5nIHN0YXRlIGNoYW5nZS5cbiAgICogXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9PbnNpZ25hbGluZ3N0YXRlY2hhbmdlZChldmVudDogYW55KSB7XG4gICAgaWYgKHRoaXMuX3J0Y0Nvbm5lY3Rpb24pIHtcbiAgICAgIC8vIHNpbXBsZSBsb2dnaW5nIGZvciBub3dcbiAgICAgIFJhdmlVdGlscy5sb2coXCJTaWduYWxpbmdTdGF0ZSBjaGFuZ2VkOiBcIiArIHRoaXMuX3J0Y0Nvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2ZvcmNlQml0cmF0ZVVwKHNkcDogc3RyaW5nKSB7XG4gICAgLy8gTmVlZCB0byBmb3JtYXQgdGhlIFNEUCBkaWZmZXJlbnRseSBpZiB0aGUgaW5wdXQgaXMgc3RlcmVvLCBzbyBcbiAgICAvLyByZWFjaCB1cCBpbnRvIG91ciBvd25lcidzIHN0cmVhbSBjb250cm9sbGVyIHRvIGZpbmQgb3V0LlxuICAgIGNvbnN0IGxvY2FsQXVkaW9Jc1N0ZXJlbyA9IHRoaXMuX3JhdmlTZXNzaW9uLl9zdHJlYW1Db250cm9sbGVyLmlzU3RlcmVvSW5wdXQoKTtcbiAgICAvLyBVc2UgMTI4a2JwcyBmb3Igc3RlcmVvIHVwc3RyZWFtIGF1ZGlvLCA2NGticHMgZm9yIG1vbm9cbiAgICBjb25zdCBiaXRyYXRlID0gbG9jYWxBdWRpb0lzU3RlcmVvID8gMTI4MDAwIDogNjQwMDA7XG5cbiAgICAvLyBTRFAgbXVuZ2luZzogdXNlIDEyOGticHMgZm9yIHN0ZXJlbyB1cHN0cmVhbSBhdWRpbywgNjRrYnBzIGZvciBtb25vXG4gICAgcmV0dXJuIHNkcC5yZXBsYWNlKC9hPWZtdHA6MTExIC9nLCAnYT1mbXRwOjExMSBtYXhhdmVyYWdlYml0cmF0ZT0nK2JpdHJhdGUrJzsnKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZm9yY2VTdGVyZW9Eb3duKHNkcDogc3RyaW5nKSB7XG4gICAgLy8gbXVuZ2UgdGhlIFNEUCBhbnN3ZXI6IHJlcXVlc3QgMTI4a2JwcyBzdGVyZW8gZm9yIGRvd25zdHJlYW0gYXVkaW9cbiAgICByZXR1cm4gc2RwLnJlcGxhY2UoL2E9Zm10cDoxMTEgL2csICdhPWZtdHA6MTExIG1heGF2ZXJhZ2ViaXRyYXRlPTEyODAwMDtzcHJvcC1zdGVyZW89MTtzdGVyZW89MTsnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIGFsbCBtZXNzYWdlcyBvbiB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24gKHNlZSB0aGUgX29wZW4oKSBtZXRob2QpLCBhbmRcbiAgICogd2F0Y2hlcyBmb3IgdGhlIGFwcHJvcHJpYXRlIFNEUC1yZWxhdGVkIGV2ZW50cyBzbyB0aGF0IGl0IGNhbiBuZWdvdGlhdGUgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBDb25uZWN0aW9uKGV2ZW50OiBhbnkpIHtcbiAgICBsZXQgZnVsbE1lc3NhZ2U6YW55ID0gXCJcIjtcbiAgICBsZXQgc2lnbmFsOmFueSA9IFwiXCI7XG5cbiAgICBcbiAgICAvLyBMb2NhbCBjb3BpZXMgb2YgdXNlZnVsIHZhcmlhYmxlcyB0byBhdm9pZCBoYXZpbmcgdG8gYmluZFxuICAgIGNvbnN0IHJhdmlTZXNzaW9uID0gdGhpcy5fcmF2aVNlc3Npb247XG4gICAgY29uc3Qgc2lnbmFsaW5nQ29ubmVjdGlvbiA9IHRoaXMuX3NpZ25hbGluZ0Nvbm5lY3Rpb247XG4gICAgY29uc3Qgc2Vzc2lvbkltcGxlbWVudGF0aW9uID0gdGhpcztcbiAgICBcbiAgICAvLyBKdXN0IGluIGNhc2UsIG1ha2Ugc3VyZSB3ZSBoYXZlIGV2ZXJ5dGhpbmcgd2UgbmVlZFxuICAgIGlmICghcmF2aVNlc3Npb24gfHwgIXNpZ25hbGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgIFJhdmlVdGlscy5lcnIoXCJNaXNzaW5nIG9uZSBvZiByYXZpU2Vzc2lvbiBvciBzaWduYWxpbmdDb25uZWN0aW9uISBDYW4ndCBzZXQgdXAgY29ubmVjdGlvbi5cIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgbWVzc2FnZSwgYW5kIHRoYXQgaXQncyBmb3IgdGhpcyBwYXJ0aWN1bGFyIFJBVkkgc2Vzc2lvblxuICAgIGlmIChldmVudCAmJiBldmVudC5kYXRhKSB7XG4gICAgICBSYXZpVXRpbHMubG9nKCdNZXNzYWdlIGZyb20gc2VydmVyOiAnICsgZXZlbnQuZGF0YSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICBmdWxsTWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJhdmlVdGlscy5sb2coJ05vIG1lc3NhZ2UgcmVjZWl2ZWQgYnkgb25NZXNzYWdlIGhhbmRsZXInLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgIHJldHVybjsgLy8gTm8gbWVzc2FnZVxuICAgIH1cbiAgICBzaWduYWwgPSBmdWxsTWVzc2FnZVtyYXZpU2Vzc2lvbi5nZXRVVUlEKCldO1xuICAgIGlmICghc2lnbmFsKSByZXR1cm47IC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgZm9yIG1lXG5cbiAgICAvLyBXZSBoYXZlIGEgc2lnbmFsOyBjaGVjayBmaXJzdCB0byBzZWUgaWYgaXQncyBhbiBTRFBcbiAgICBpZiAoc2lnbmFsLnNkcCkge1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIlJlY2VpdmVkIHNkcCB0eXBlPVwiICsgc2lnbmFsLnR5cGUsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuXG4gICAgICAvLyB1c2UgdXNlci1zcGVjaWZpZWQgVFVSTiBjb25maWcgaWYgZm91bmRcbiAgICAgIGlmIChzZXNzaW9uSW1wbGVtZW50YXRpb24uX2N1c3RvbVN0dW5BbmRUdXJuKSB7XG4gICAgICAgIGNvbnN0IENVU1RPTV9UVVJOX0NPTkZJRyA9IHtcbiAgICAgICAgICAndXJscyc6IHNlc3Npb25JbXBsZW1lbnRhdGlvbi5fY3VzdG9tU3R1bkFuZFR1cm4udHVyblVybHMsXG4gICAgICAgICAgJ3VzZXJuYW1lJzogc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9jdXN0b21TdHVuQW5kVHVybi50dXJuVXNlcm5hbWUsXG4gICAgICAgICAgJ2NyZWRlbnRpYWwnOiBzZXNzaW9uSW1wbGVtZW50YXRpb24uX2N1c3RvbVN0dW5BbmRUdXJuLnR1cm5DcmVkZW50aWFsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IENVU1RPTV9TVFVOX0NPTkZJRyA9IHtcbiAgICAgICAgICAndXJscyc6IHNlc3Npb25JbXBsZW1lbnRhdGlvbi5fY3VzdG9tU3R1bkFuZFR1cm4uc3R1blVybHNcbiAgICAgICAgfTtcbiAgICAgICAgcGVlckNvbm5lY3Rpb25Db25maWcgPSB7XG4gICAgICAgICAgJ2ljZVNlcnZlcnMnOiBbXG4gICAgICAgICAgICBDVVNUT01fU1RVTl9DT05GSUcsXG4gICAgICAgICAgICBDVVNUT01fVFVSTl9DT05GSUdcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICAvLyBncmFiIHRoZSBUVVJOIGNvbmZpZyBpZiBmb3VuZFxuICAgICAgfSBlbHNlIGlmIChzaWduYWwudHVybiAmJiBzaWduYWwudHVybi51cmxzICYmIHNpZ25hbC50dXJuLnVzZXJuYW1lICYmIHNpZ25hbC50dXJuLmNyZWRlbnRpYWwpIHtcbiAgICAgICAgLy8gV2UgYXBwZWFyIHRvIG5lZWQgdG8gaHVtb3IgVHlwZVNjcmlwdCBieSBzZXR0aW5nIHRoaXMgdG8gYSBjb25zdGFudCB0aGVcbiAgICAgICAgLy8gc2FtZSB3YXkgd2UgZG8gZm9yIHRoZSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IERZTkFNSUNfVFVSTl9DT05GSUcgPSB7XG4gICAgICAgICAgJ3VybHMnOiBzaWduYWwudHVybi51cmxzLFxuICAgICAgICAgICd1c2VybmFtZSc6IHNpZ25hbC50dXJuLnVzZXJuYW1lLFxuICAgICAgICAgICdjcmVkZW50aWFsJzogc2lnbmFsLnR1cm4uY3JlZGVudGlhbFxuICAgICAgICB9O1xuICAgICAgICBwZWVyQ29ubmVjdGlvbkNvbmZpZyA9IHtcbiAgICAgICAgICAnaWNlU2VydmVycyc6IFtcbiAgICAgICAgICAgIERFRkFVTFRfU1RVTl9DT05GSUcsXG4gICAgICAgICAgICBEWU5BTUlDX1RVUk5fQ09ORklHXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBTQUQgU1RBVEUgT0YgQUZGQUlSUzogdGhlcmUgaXMgbm8gd2F5IChBRkFJQ1QpIHRvIG1vZGlmeVxuICAgICAgLy8gX3J0Y0Nvbm5lY3Rpb24uY29uZmlndXJhdGlvbiBhZnRlciB0aGUgUnRjQ29ubmVjdGlvbiBjdG9yLlxuICAgICAgLy8gV09SS0FST1VORDogd2Ugd2FpdCB1bnRpbCB0aGUgZmlyc3Qgd2Vic29ja2V0IG1lc3NhZ2UgKGUuZy4gdGhlIHNkcCBvZmZlciksXG4gICAgICAvLyB3aGljaCBjb3VsZCBpbmNsdWRlIFRVUk4gY29uZmlnIGluZm8sIGJlZm9yZSB3ZSBpbml0aWFsaXplIF9ydGNDb25uZWN0aW9uLlxuICAgICAgaWYgKCF0aGlzLl9ydGNDb25uZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2luaXRSdGNDb25uZWN0aW9uKCk7XG4gICAgICAgIC8vIElmIHNvbWVvbmUgaGFzIGFscmVhZHkgc2V0IHRoZSBhdWRpbyBpbnB1dCBzdHJlYW0sIGFkZCBpdCB0byB0aGUgcnRjIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gbm93IHRoYXQgaXQncyBiZWVuIGluaXRpYWxpemVkLlxuICAgICAgICBpZiAodGhpcy5fYXVkaW9JbnB1dFN0cmVhbSkge1xuICAgICAgICAgIHRoaXMuX2FkZEF1ZGlvSW5wdXRTdHJlYW0odGhpcy5fYXVkaW9JbnB1dFN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ZpZGVvSW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICB0aGlzLl9hZGRWaWRlb0lucHV0U3RyZWFtKHRoaXMuX3ZpZGVvSW5wdXRTdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcnRjQ29ubmVjdGlvbiA9IHRoaXMuX3J0Y0Nvbm5lY3Rpb247XG4gICAgXG4gICAgICAvLyBGb3JjZSBvdXIgZGVzaXJlZCBiaXRyYXRlIGJ5IG11bmdpbmcgdGhlIFNEUCwgYW5kIGNyZWF0ZSBhIHNlc3Npb24gZGVzY3JpcHRpb24gZm9yIGl0XG4gICAgICBzaWduYWwuc2RwID0gc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9mb3JjZUJpdHJhdGVVcChzaWduYWwuc2RwKTsgXG4gICAgICBjb25zdCBkZXNjID0gbmV3IGNyb3NzUGxhdGZvcm1SVENTZXNzaW9uRGVzY3JpcHRpb24oc2lnbmFsKTtcblxuICAgICAgLy8gU2V0IHRoZSBkZXNjcmlwdGlvbiBvbiB0aGUgUlRDIGNvbm5lY3Rpb24sIGFuZCBzZW5kIGFuZCBoYW5kbGUgdGhlIHZhcmlvdXMgU0RQc1xuICAgICAgcnRjQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjKVxuICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBhbnN3ZXJcbiAgICAgICByZXR1cm4gcnRjQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgIH0pXG4gICAgICAudGhlbihmdW5jdGlvbihhbnN3ZXI6IGFueSkge1xuICAgICAgICAvLyBGb3JjZSBzdGVyZW8gb24gdGhlIGRvd25zdHJlYW0gc3RyZWFtIGJ5IG11bmdpbmcgdGhlIFNEUFxuICAgICAgICBhbnN3ZXIuc2RwID0gc2Vzc2lvbkltcGxlbWVudGF0aW9uLl9mb3JjZVN0ZXJlb0Rvd24oYW5zd2VyLnNkcCk7IFxuICAgICAgICBSYXZpVXRpbHMubG9nKFwiQW5zd2VyOlwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhhbnN3ZXIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAvLyBzZXQgbG9jYWwgZGVzY3JpcHRpb25cbiAgICAgICAgcmV0dXJuIHJ0Y0Nvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgICAgdHlwZTogXCJhbnN3ZXJcIixcbiAgICAgICAgICBzZHA6IHJ0Y0Nvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbixcbiAgICAgICAgICB1dWlkOiByYXZpU2Vzc2lvbi5nZXRVVUlEKClcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGVzYyA9IEpTT04uc3RyaW5naWZ5KG1zZyk7XG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJTZW5kaW5nIGFuc3dlciB0byBzZXJ2ZXJcIiwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIC8vIFNlbmQgdGhlIGZpbmFsIHJlc3VsdCBiYWNrIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5zZW5kKGRlc2MpO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKHNpZ25hbC5pY2UpIHtcbiAgICAgIFJhdmlVdGlscy5sb2coXCJSZWNlaXZlZCByZW1vdGUgSUNFIGNhbmRpZGF0ZTogXCIgKyBKU09OLnN0cmluZ2lmeShzaWduYWwuaWNlKSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgICBpZiAodGhpcy5fcnRjQ29ubmVjdGlvbikge1xuICAgICAgICB0aGlzLl9ydGNDb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShzaWduYWwuaWNlKVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBSYXZpVXRpbHMubG9nKFwiQWRkZWQgcmVtb3RlIGNhbmRpZGF0ZVwiLCBcIlJhdmlXZWJSVENJbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGU6IGFueSkge1xuICAgICAgICAgIFJhdmlVdGlscy5lcnIoXCJFcnJvciBhdHRlbXB0aW5nIHRvIGFkZCByZW1vdGUgSUNFIGNhbmRpZGF0ZTogXCIgKyBlLm1lc3NhZ2UsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEtlZXAgdHJhY2sgb2YgaWNlIGNhbmRpZGF0ZXMgdW50aWwgd2UgaGF2ZSBhbiBydGNDb25uZWN0aW9uXG4gICAgICAgIFJhdmlVdGlscy5sb2coXCJJZ25vcmUgaWNlIGNhbmRpZGF0ZSB1bnRpbCB3ZSBoYXZlIGFuIHJ0Y0Nvbm5lY3Rpb24sIGljZT0nXCIgKyBKU09OLnN0cmluZ2lmeShzaWduYWwpICsgXCInXCIsIFwiUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb21lIG90aGVyIGhhbmRsZXIncyBwcm9ibGVtXG4gICAgICBSYXZpVXRpbHMubG9nKFwiVW5rbm93biBtZXNzYWdlIFwiICsgSlNPTi5zdHJpbmdpZnkoc2lnbmFsKSwgXCJSYXZpV2ViUlRDSW1wbGVtZW50YXRpb25cIik7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogQWRkIGEgaGFuZGxlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG5ldyBzdGF0cyBnZW5lcmF0ZWQuXG4gICAqIFRoZXNlIGFyZSBzdG9yZWQgaW4gYSBTZXQgb2YgRnVuY3Rpb25zOyB0aGVyZWZvcmUsIGEgZ2l2ZW4gZnVuY3Rpb25cbiAgICogY2FuIG9ubHkgZXhpc3Qgb25jZSBpbiB0aGlzIFNldC5cbiAgICogXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmF2aVNlc3Npb25+c3RhdHNPYnNlcnZlckNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2sgaGFuZGxlciB0aGF0IHNob3VsZCBoYW5kbGUgYSBzdGF0ZSBjaGFuZ2UgZXZlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBhZGQgc3VjY2VlZGVkXG4gICAqL1xuICBfYWRkU3RhdHNPYnNlcnZlcihvYnNlcnZlcjogRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHNXYXRjaGVyLmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBoYW5kbGVyIHNvIHRoYXQgaXQgc3RvcHMgbGlzdGVuaW5nIGZvciBzdGF0cyB1cGRhdGVzLlxuICAgKiBcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn5zdGF0c09ic2VydmVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHJlbW92YWwgd2FzIHN1Y2Nlc3NmdWwgKGkuZS4gZGlkIG5vdCB0aHJvdyBhbiBlcnJvciAtLSBub3RlIHRoYXQgdGhpcyBkb2VzXG4gICAqIE5PVCBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgaGFuZGxlciB3YXMgaW4gdGhlIHNldCBpbiB0aGUgZmlyc3QgcGxhY2UpXG4gICAqL1xuICBfcmVtb3ZlU3RhdHNPYnNlcnZlcihvYnNlcnZlcjogRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHNXYXRjaGVyLnJlbW92ZU9ic2VydmVyKG9ic2VydmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvc2UgdGhlIGdldFN0YXRzIGNhbGwgb24gdGhlIHJ0Y1BlZXJDb25uZWN0aW9uXG4gICAqIHVzZWQgYnkgdGhlIHN0YXRzV2F0Y2hlclxuICAgKi9cbiAgYXN5bmMgX2dldFN0YXRzKHNlbGVjdG9yOiBhbnkgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuX3J0Y0Nvbm5lY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydGNDb25uZWN0aW9uLmdldFN0YXRzKHNlbGVjdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgUmF2aVV0aWxzIH0gZnJvbSBcIi4vUmF2aVV0aWxzXCI7XG5cbi8qKlxuICogRW51bSBmb3IgcmVwcmVzZW50aW5nIGRpZmZlcmVudCBwb3NzaWJsZSBzdGF0ZXNcbiAqIHRoYXQgYSBSQVZJIHNpZ25hbGluZ0Nvbm5lY3Rpb24gbWlnaHQgYmUgaW4uXG4gKlxuICogXCJVTkFWQUlMQUJMRVwiIGlzIGEgY3VzdG9tIHN0YXRlIHRoYXQgZ2V0cyBzZXRcbiAqIGlmIHRoZSBzZXJ2ZXIgaXMgaW4gYSBcInJ1bm5pbmcsIGJ1dCBub3QgY3VycmVudGx5XG4gKiBhY2NlcHRpbmcgaW5jb21pbmcgY29ubmVjdGlvbnNcIiBzdGF0ZS5cbiAqIFxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZW51bSBSYXZpU2lnbmFsaW5nU3RhdGVzIHtcbiAgQ09OTkVDVElORyA9IFwiY29ubmVjdGluZ1wiLFxuICBPUEVOID0gXCJvcGVuXCIsXG4gIEVSUk9SID0gXCJlcnJvclwiLFxuICBDTE9TSU5HID0gXCJjbG9zaW5nXCIsXG4gIENMT1NFRCA9IFwiY2xvc2VkXCIsXG4gIFVOQVZBSUxBQkxFID0gXCJ1bmF2YWlsYWJsZVwiXG59O1xuXG4vKiogXG4gKlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIFNpZ25hbGluZyBjb25uZWN0aW9uIHNwZWNpZmljYWxseSBmb3IgaGFuZGxpbmcgUkFWSSBzZXNzaW9ucy5cbiAqIFRoaXMgZ2V0cyB1c2VkIGJ5IHRoZSBSYXZpU2Vzc2lvbiAoYW5kIGl0cyBQZWVyQ29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbilcbiAqIHRvIHNldCB1cCBhIFJhdmlTZXNzaW9uIGNvbm5lY3Rpb24uXG4gKiBUaGlzIGNsYXNzIHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgYnkgdGhlIFJBVkkgY29uc3VtZXIsIGFuZCB0aGVuIHVzZWQgdG8gb3Blbiwgd29yayB3aXRoLCBhbmQgY2xvc2UgXG4gKiBSQVZJIHNlc3Npb25zIGFzIG5lZWRlZC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiB7XG4gIC8qKlxuICAgKiBcIkNsYXNzXCIgdmFyaWFibGVzIHRvIGJlIGF3YXJlIG9mOlxuICAgKlxuICAgKiB0aGlzLl9zdGF0ZWNoYW5nZUhhbmRsZXJzICAgLy8gQSBsaXN0IG9mIGhhbmRsZXJzIHRvIGNhbGwgd2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VzXG4gICAqIHRoaXMuX21lc3NhZ2VIYW5kbGVycyAgICAgICAvLyBBIGxpc3Qgb2YgaGFuZGxlcnMgdG8gY2FsbCB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZFxuICAgKlxuICAgKiB0aGlzLl9zaWduYWxpbmdJbXBsZW1lbnRhdGlvbiAgIC8vIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBzaWduYWxpbmcgdG8gdXNlXG4gICAqXG4gICAqIHRoaXMuX3N0YXRlICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIGNvbm5lY3Rpb25cbiAgICpcbiAgICogX3Jlc29sdmVPcGVuLCBfcmVqZWN0T3BlbiwgX3Jlc29sdmVDbG9zZSwgYW5kIF9yZWplY3RDbG9zZTogVXNlZCBmb3IgcmVzb2x2aW5nIHRoZSBQcm9taXNlc1xuICAgKiAgICAgbWFkZSBieSB0aGUgb3BlbiBhbmQgY2xvc2UgZnVuY3Rpb25zLCB3aGljaCBnZXQgaGFuZGxlZCBvdXRzaWRlIG9mIHRob3NlIGZ1bmN0aW9ucyB0aGVtc2VsdmVzXG4gICAqL1xuICBfc3RhdGVDaGFuZ2VIYW5kbGVyczogU2V0PEZ1bmN0aW9uPjtcbiAgX21lc3NhZ2VIYW5kbGVyczogU2V0PEZ1bmN0aW9uPjtcbiAgX3N0YXRlOiBSYXZpU2lnbmFsaW5nU3RhdGVzO1xuICBfc2lnbmFsaW5nSW1wbGVtZW50YXRpb246IFJhdmlTaWduYWxpbmdXZWJTb2NrZXRJbXBsZW1lbnRhdGlvbjtcblxuICBfcmVzb2x2ZU9wZW46IEZ1bmN0aW9uOyBfcmVqZWN0T3BlbjogRnVuY3Rpb247XG4gIF9yZXNvbHZlQ2xvc2U6IEZ1bmN0aW9uOyBfcmVqZWN0Q2xvc2U6IEZ1bmN0aW9uO1xuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblxuICAgKiBEZWZhdWx0cyB0aGUgaGFuZGxlcnNcbiAgICogYW5kIGluaXRpYWxpemVzIHRoZSBzdGF0ZSB0byBSYXZpU2lnbmFsaW5nU3RhdGVzLkNMT1NFRC5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBSYXZpVXRpbHMubG9nKFwiQ29uc3RydWN0b3JcIiwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHRoZSBsaXN0IG9mIGhhbmRsZXJzXG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlcnMgPSBuZXcgU2V0KCk7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcbiAgICB0aGlzLl9zdGF0ZSA9IFJhdmlTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEO1xuICAgIFxuICAgIC8vIElmIHdlIHdhbnRlZCB0byB1c2UgYSBkaWZmZXJlbnQgc2lnbmFsaW5nIGltcGxlbWVudGF0aW9uLFxuICAgIC8vIHdlIHdvdWxkIG5ldygpIGl0IGhlcmUuIChUT0RPOiBNYWtlIHRoaXMgY29uZmlndXJhYmxlIGluIHNvbWVcbiAgICAvLyBpbnRlcmVzdGluZyB3YXkuIEZvciBub3csIGl0J3MgZW5vdWdoIGp1c3QgdG8gbWFrZSBpdCBlYXNpbHkgXG4gICAgLy8gc3dhcHBhYmxlIGluIHRoZSBjb2RlIGhlcmUuKVxuICAgIHRoaXMuX3NpZ25hbGluZ0ltcGxlbWVudGF0aW9uID0gbmV3IFJhdmlTaWduYWxpbmdXZWJTb2NrZXRJbXBsZW1lbnRhdGlvbih0aGlzKTtcbiAgICBcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uXG4gICAqIFxuICAgKiBAcmV0dXJucyB7UmF2aVNpZ25hbGluZ1N0YXRlc31cbiAgICovXG4gIGdldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBsaXN0ZW5pbmcgdG8gc3RhdGUgY2hhbmdlc1xuICAgKiBAY2FsbGJhY2sgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25+c3RhdGVDaGFuZ2VDYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgQW4gb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIGluZm9ybWF0aW9uXG4gICAqIGFib3V0IHRoZSBzdGF0ZSBjaGFuZ2UuIFRoaXMgaW5jbHVkZXMgdGhlIFwiZXZlbnQuc3RhdGVcIiBrZXksXG4gICAqIHdoaWNoIHdpbGwgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgdmFsdWUgZnJvbSB0aGUgUmF2aVNlc3Npb25TdGF0ZXMgZW51bS5cbiAgICovXG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIHRvIHRoZSBzZXQgb2Ygc3RhdGUgY2hhbmdlIGhhbmRsZXJzLlxuICAgKiBBbGwgaGFuZGxlcnMgaW4gdGhpcyBzZXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2l0aCBhIGNvcHkgb2YgdGhlIGV2ZW50XG4gICAqIGFueSB0aW1lIHRoZSBzdGF0ZSBvZiB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24gY2hhbmdlcy5cbiAgICogVGhlc2UgYXJlIHN0b3JlZCBpbiBhIFNldCBvZiBGdW5jdGlvbnM7IHRoZXJlZm9yZSwgYSBnaXZlbiBmdW5jdGlvblxuICAgKiBjYW4gb25seSBleGlzdCBvbmNlIGluIHRoaXMgU2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1JhdmlTaWduYWxpbmdDb25uZWN0aW9ufnN0YXRlQ2hhbmdlQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFjayBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIHN0YXRlIGNoYW5nZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGFkZCBzdWNjZWVkZWRcbiAgICovXG4gIGFkZFN0YXRlQ2hhbmdlSGFuZGxlcihjaGFuZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzLmFkZChjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIGFkZGluZyBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyOiBcIiArXG4gICAgICAgIGVyci5tZXNzYWdlLCBcIlJhdmlTaWduYWxpbmdDb25uZWN0aW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgaGFuZGxlciBmcm9tIHRoZSBsaXN0IG9mIHN0YXRlIGNoYW5nZSBoYW5kbGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbn5zdGF0ZUNoYW5nZUNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2sgaGFuZGxlciB0aGF0IGhhcyBiZWVuIGhhbmRsaW5nIGEgc3RhdGUgY2hhbmdlIGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcmVtb3ZhbCB3YXMgc3VjY2Vzc2Z1bCAoaS5lLiBkaWQgbm90IHRocm93IGFuIGVycm9yIC0tIG5vdGUgdGhhdCB0aGlzIGRvZXNcbiAgICogTk9UIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSBoYW5kbGVyIHdhcyBpbiB0aGUgc2V0IGluIHRoZSBmaXJzdCBwbGFjZSlcbiAgICovXG4gIHJlbW92ZVN0YXRlQ2hhbmdlSGFuZGxlcihjaGFuZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXR2YWwgPSB0aGlzLl9zdGF0ZUNoYW5nZUhhbmRsZXJzLmRlbGV0ZShjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIHJlbW92aW5nIGEgc3RhdGUgY2hhbmdlIGhhbmRsZXI6IFwiICtcbiAgICAgICAgZXJyLm1lc3NhZ2UsIFwiUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25cIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgbGlzdGVuaW5nIGZvciBtZXNzYWdlc1xuICAgKiBAY2FsbGJhY2sgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25+bWVzc2FnZUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEEgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICovXG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIHRvIHRoZSBsaXN0IG9mIG1lc3NhZ2UgcmVjZWl2ZWQgaGFuZGxlcnMuXG4gICAqIEFsbCBoYW5kbGVycyBpbiB0aGlzIGxpc3Qgd2lsbCBiZSB0cmlnZ2VyZWQgd2l0aCBhIGNvcHkgb2YgdGhlIFxuICAgKiBpbmNvbWluZyBtZXNzYWdlIGFueSB0aW1lIGEgbWVzc2FnZSBpcyByZWNlaXZlZC5cbiAgICogVGhlc2UgYXJlIHN0b3JlZCBpbiBhIFNldCBvZiBGdW5jdGlvbnM7IHRoZXJlZm9yZSwgYSBnaXZlbiBmdW5jdGlvblxuICAgKiBjYW4gb25seSBleGlzdCBvbmNlIGluIHRoaXMgU2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1JhdmlTaWduYWxpbmdDb25uZWN0aW9ufm1lc3NhZ2VDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBzaG91bGQgaGFuZGxlIGEgbWVzc2FnZSByZWNlaXZlZCBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGFkZCBzdWNjZWVkZWRcbiAgICovXG4gIGFkZE1lc3NhZ2VIYW5kbGVyKG1lc3NhZ2VIYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlcnMuYWRkKG1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgUmF2aVV0aWxzLmVycihcIkVycm9yIGFkZGluZyBhIG1lc3NhZ2UgaGFuZGxlcjogXCIgK1xuICAgICAgICBlcnIubWVzc2FnZSwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGhhbmRsZXIgZnJvbSB0aGUgbGlzdCBvZiBtZXNzYWdlIHJlY2VpdmVkIGhhbmRsZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JhdmlTaWduYWxpbmdDb25uZWN0aW9ufm1lc3NhZ2VDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBoYXMgYmVlbiBoYW5kbGluZyBhIG1lc3NhZ2UgcmVjZWl2ZWQgZXZlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSByZW1vdmFsIHdhcyBzdWNjZXNzZnVsIChpLmUuIGRpZCBub3QgdGhyb3cgYW4gZXJyb3IgLS0gbm90ZSB0aGF0IHRoaXMgZG9lc1xuICAgKiBOT1QgaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhlIGhhbmRsZXIgd2FzIGluIHRoZSBzZXQgaW4gdGhlIGZpcnN0IHBsYWNlKVxuICAgKi9cbiAgcmVtb3ZlTWVzc2FnZUhhbmRsZXIobWVzc2FnZUhhbmRsZXI6IEZ1bmN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVycy5kZWxldGUobWVzc2FnZUhhbmRsZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBSYXZpVXRpbHMuZXJyKFwiRXJyb3IgcmVtb3ZpbmcgYSBzdGF0ZSBjaGFuZ2UgaGFuZGxlcjogXCIgK1xuICAgICAgICBlcnIubWVzc2FnZSwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gYSBzaWduYWxpbmcgY29ubmVjdGlvbiB0byBhIHBhcnRpY3VsYXIgVVJMLiBSZXR1cm5zIGEgUHJvbWlzZVxuICAgKiB0aGF0IHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbiBpcyBjb25uZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBVUkwgVGhlIFVSTCBvZiB0aGUgc2lnbmFsaW5nIHNlcnZlcidzIGVuZHBvaW50IChlLmcuICd3c3M6Ly9mb28uYmFyLmJhejo4ODg5JylcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBvcGVuUkFWSVNpZ25hbGluZ0Nvbm5lY3Rpb24oVVJMOiBzdHJpbmcpIHtcbiAgICB2YXIgc2lnbmFsaW5nQ29ubmVjdGlvbiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBSYXZpU2lnbmFsaW5nU3RhdGVzLk9QRU4pIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgIFwiVGhlcmUgaXMgYWxyZWFkeSBhbiBvcGVuIFdlYlNvY2tldCBjb25uZWN0aW9uLiBUbyByZWNvbm5lY3QsIGZpcnN0IGNsb3NlIHRoZSBleGlzdGluZyBXZWJTb2NrZXQgYW5kIHRoZW4gYXR0ZW1wdCB0byBvcGVuIGFnYWluLlwiXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9yZXNvbHZlT3BlbiA9IHJlc29sdmU7XG4gICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9yZWplY3RPcGVuID0gcmVqZWN0O1xuICAgICAgLy8gU3RhcnQgdGhlIFwib3BlbmluZ1wiIHByb2Nlc3NcbiAgICAgIFJhdmlVdGlscy5sb2coXCJPcGVuaW5nIHNpZ25hbGluZyBjb25uZWN0aW9uIHRvIFwiICsgVVJMLCBcIlJhdmlTaWduYWxpbmdDb250cm9sbGVyXCIpO1xuICAgICAgbGV0IGV2ZW50ID0ge1wic3RhdGVcIjpSYXZpU2lnbmFsaW5nU3RhdGVzLkNPTk5FQ1RJTkd9O1xuICAgICAgdGhpcy5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuQ09OTkVDVElORyk7IFxuXG4gICAgICAvLyBBbmQgY2FsbCB0aGUgaW1wbGVtZW50YXRpb24ncyBvcGVuIG1ldGhvZFxuICAgICAgdGhpcy5fc2lnbmFsaW5nSW1wbGVtZW50YXRpb24uX29wZW4oVVJMKTtcbiAgICB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBzaWduYWxpbmcgc2VydmVyXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICovXG4gIHNlbmQobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fc2lnbmFsaW5nSW1wbGVtZW50YXRpb24uX3NlbmQobWVzc2FnZSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24uIFJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgdGhlIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjbG9zZVJBVklTaWduYWxpbmdDb25uZWN0aW9uKCkge1xuICAgIHZhciBzaWduYWxpbmdDb25uZWN0aW9uID0gdGhpcztcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFJhdmlTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICBcIlNpZ25hbGluZyBjb25uZWN0aW9uIGlzIGFscmVhZHkgY2xvc2VkLlwiXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9yZXNvbHZlQ2xvc2UgPSByZXNvbHZlO1xuICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5fcmVqZWN0Q2xvc2UgPSByZWplY3Q7XG4gICAgICAvLyBTdGFydCB0aGUgXCJjbG9zaW5nXCIgcHJvY2Vzc1xuICAgICAgUmF2aVV0aWxzLmxvZyhcIkNsb3Npbmcgc2lnbmFsaW5nIGNvbm5lY3Rpb25cIiwgXCJSYXZpU2lnbmFsaW5nQ29udHJvbGxlclwiKTtcbiAgICAgIGxldCBldmVudCA9IHtcInN0YXRlXCI6UmF2aVNpZ25hbGluZ1N0YXRlcy5DTE9TSU5HfTtcbiAgICAgIHRoaXMuX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBSYXZpU2lnbmFsaW5nU3RhdGVzLkNMT1NJTkcpOyBcblxuICAgICAgLy8gQW5kIGNhbGwgdGhlIGltcGxlbWVudGF0aW9uJ3Mgb3BlbiBtZXRob2RcbiAgICAgIHRoaXMuX3NpZ25hbGluZ0ltcGxlbWVudGF0aW9uLl9jbG9zZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEdlbmVyaWMgaGFuZGxlcnMgKi9cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVTdGF0ZUNoYW5nZShldmVudDogYW55ID0ge30sIHN0YXRlOiBSYXZpU2lnbmFsaW5nU3RhdGVzKSB7XG4gICAgLy8gQWx3YXlzIHRyeSB0byBmdWxmaWxsIGFueSBvcGVuIHByb21pc2VzLCBldmVuIGlmIHRoZSBzdGF0ZSBoYXNuJ3QgY2hhbmdlZFxuICAgIHRoaXMuX2Z1bGZpbGxQcm9taXNlcyhldmVudCwgc3RhdGUpO1xuXG4gICAgLy8gQnV0IG9ubHkgY2FsbCBoYW5kbGVycyBpZiB0aGUgc3RhdGUgZGlkLCBpbiBmYWN0LCBjaGFuZ2VcbiAgICBpZiAoc3RhdGUgIT09IHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIGV2ZW50W1wic3RhdGVcIl0gPSBzdGF0ZTtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIl9oYW5kbGVTdGF0ZUNoYW5nZTogXCIgKyBSYXZpVXRpbHMuc2FmZWx5UHJpbnRhYmxlKGV2ZW50KSwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogR2V0cyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHN0YXRlIGNoYW5nZXMgKGFuZCBzb21ldGltZXMgd2hlbiBpdCBkb2Vzbid0LFxuICAgKiBidXQgd2hlbiB3ZSBqdXN0IHdhbnQgdG8gbWFrZSBzdXJlKS4gRGVwZW5kaW5nIG9uIHRoZSBuZXcgKG9yIGN1cnJlbnQpIHN0YXRlLFxuICAgKiB0aGlzIHdpbGwgYXBwcm9wcmlhdGVseSBmdWxmaWxsIG91dHN0YW5kaW5nIHByb21pc2VzIHRoYXQgYXJlIHBlbmRpbmdcbiAgICogaW4gZWl0aGVyIHRoZSBvcGVuIG9yIGNsb3NlIG1ldGhvZCAob3IgYm90aCkuXG4gICAqL1xuICBfZnVsZmlsbFByb21pc2VzKGV2ZW50OiBhbnkgPSB7fSwgc3RhdGU6IFJhdmlTaWduYWxpbmdTdGF0ZXMpIHtcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gZXZlbnQucmVhc29uIHx8IGV2ZW50Lm1lc3NhZ2UgfHwgc3RhdGU7XG4gICAgUmF2aVV0aWxzLmxvZyhcIl9mdWxmaWxsUHJvbWlzZXM6IEhhbmRsaW5nIHN0YXRlIFwiICsgc3RhdGUsIFwiUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb25cIik7XG4gICAgc3dpdGNoKHN0YXRlKSB7XG4gICAgICBjYXNlIFJhdmlTaWduYWxpbmdTdGF0ZXMuT1BFTjpcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVPcGVuKSB0aGlzLl9yZXNvbHZlT3BlbigpO1xuICAgICAgICBpZiAodGhpcy5fcmVqZWN0Q2xvc2UpIHRoaXMuX3JlamVjdENsb3NlKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2lnbmFsaW5nU3RhdGVzLkNMT1NFRDpcbiAgICAgICAgaWYgKHRoaXMuX3JlamVjdE9wZW4pIHRoaXMuX3JlamVjdE9wZW4oZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVDbG9zZSkgdGhpcy5fcmVzb2x2ZUNsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2lnbmFsaW5nU3RhdGVzLkVSUk9SOlxuICAgICAgICBpZiAodGhpcy5fcmVqZWN0T3BlbikgdGhpcy5fcmVqZWN0T3BlbihlcnJvck1lc3NhZ2UpO1xuICAgICAgICBpZiAodGhpcy5fcmVqZWN0Q2xvc2UpIHRoaXMuX3JlamVjdENsb3NlKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSYXZpU2lnbmFsaW5nU3RhdGVzLlVOQVZBSUxBQkxFOlxuICAgICAgICBpZiAodGhpcy5fcmVqZWN0T3BlbikgdGhpcy5fcmVqZWN0T3BlbihlcnJvck1lc3NhZ2UpO1xuICAgICAgICBpZiAodGhpcy5fcmVzb2x2ZUNsb3NlKSB0aGlzLl9yZXNvbHZlQ2xvc2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBEbyBub3RoaW5nIGZvciB0aGUgXCJpbiBwcm9ncmVzc1wiIHN0YXRlcywgbGlrZSBcIk9QRU5JTkdcIiBvciBcIkNMT1NJTkdcIlxuICAgICAgICBSYXZpVXRpbHMubG9nKFwiX2Z1bGZpbGxQcm9taXNlczogU2tpcHBpbmcgaW4tcHJvZ3Jlc3Mgc3RhdGUgXCIgKyBzdGF0ZSwgXCJSYXZpU2lnbmFsaW5nQ29ubmVjdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZU1lc3NhZ2UobWVzc2FnZTogYW55KSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcIl9kb09ubWVzc2FnZTogXCIgKyBSYXZpVXRpbHMuc2FmZWx5UHJpbnRhYmxlKG1lc3NhZ2UpLCBcIlJhdmlTaWduYWxpbmdDb25uZWN0aW9uXCIpO1xuICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gdGhlIHNlcnZlciBzaWRlIGlzIGluIGFuIFwidW5hdmFpbGFibGVcIiBzdGF0ZSAtLSBpdCB3aWxsXG4gICAgLy8gc2VuZCBiYWNrIGEgc3BlY2lhbCBKU09OIHBhY2tldCBtYXJraW5nIGl0c2VsZiBhcyBcInNlcnZpY2UtdW5hdmFpbGFibGVcIi4gSGFuZGxlIHRoaXMgc2l0dWF0aW9uXG4gICAgLy8gZXhwbGljaXRseSBhcyBhIGN1c3RvbSBzdGF0ZS4gKFRoaXMgaXMga2luZCBvZiBhIGxvdCBvZiBjb2RlIGZvciBhIHJhcmUgb2NjdXJyZW5jZSwgYnV0IHdlXG4gICAgLy8gZG9uJ3Qgc2VuZCBhIHRvbiBvZiBtZXNzYWdlcyBvdmVyIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBhbmQgc28gSSBmZWVsIHJlYXNvbmFibHkgb2theSBhYm91dFxuICAgIC8vIGRvaW5nIHRoaXMgY2hlY2sgb24gZXZlcnkgbWVzc2FnZS4gLU1DSCkpXG4gICAgaWYgKG1lc3NhZ2UuZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VEYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VEYXRhLmVycm9yICYmIG1lc3NhZ2VEYXRhLmVycm9yID09PSBcInNlcnZpY2UtdW5hdmFpbGFibGVcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVN0YXRlQ2hhbmdlKHt9LCBSYXZpU2lnbmFsaW5nU3RhdGVzLlVOQVZBSUxBQkxFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IHBhcnNlIHRoZSBtZXNzYWdlIGFzIEpTT04sIGl0J3MgZGVmaW5pdGVseVxuICAgICAgICAgICAgLy8gbm90IHRoZSBcInVuYXZhaWxhYmxlXCIgbWVzc2FnZSBhbmQgcHJvYmFibHkgbWVhbnQgZm9yIHNvbWVvbmUgZWxzZSxcbiAgICAgICAgICAgIC8vIHNvIG5vLW9wIGhlcmUgYW5kIGp1c3QgbGV0IHRoZSByZXN0IG9mIHRoZSBjb2RlIGRlYWwgd2l0aCBpdC5cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVyKG1lc3NhZ2UpOyBcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbn0gLy8gRW5kIG9mIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLypcblRPRE86IEFkZCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGEgUmF2aVNpZ25hbGluZyBcImNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb25cIlxuY2xhc3Mgc2hvdWxkIGxvb2sgbGlrZS5cblxuQ29uc3RydWN0b3I6IHRha2VzIGEgUmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24gc28gdGhhdCBpdCBjYW4gdXNlIGl0cyBoYW5kbGVycy4gVGhlIGNsYXNzXG5pcyBleHBlY3RlZCB0byBhc3NpZ24gdGhlIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uJ3MgX2hhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBzdGF0ZSkgYW5kIF9oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpXG5oYW5kbGVycyB0byBhcHByb3ByaWF0ZSBldmVudHMgKGFuZC9vciB0aHJvdyB0aG9zZSBldmVudHMgaXRzZWxmKS5cblxuUmVxdWlyZWQgbWV0aG9kczogX29wZW4oVVJMKSwgX3NlbmQobWVzc2FnZSksIGFuZCBfY2xvc2UoKVxuXG4qL1xuXG4vKipcbiAqIFVzZSB0aGUgY29ycmVjdCBjbGFzc2VzIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIGJlaW5nIFxuICogY2FsbGVkIGZyb20gbm9kZSBvciB0aGUgYnJvd3Nlci5cbiAqL1xubGV0IGNyb3NzUGxhdGZvcm1XZWJTb2NrZXQ6YW55ID0gbnVsbDtcbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gbm9kZSBjb250ZXh0XG4gIGNyb3NzUGxhdGZvcm1XZWJTb2NrZXQgPSByZXF1aXJlKCd3cycpO1xufSBlbHNlIHtcbiAgLy8gYnJvd3NlciBjb250ZXh0XG4gIGNyb3NzUGxhdGZvcm1XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG59XG5cbi8qKiBcbiAqIEEgV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIGZvciB0aGUgUmF2aVNpZ25hbGluZyBjbGFzc1xuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUmF2aVNpZ25hbGluZ1dlYlNvY2tldEltcGxlbWVudGF0aW9uIHtcbiAgX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uOiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgX3dlYlNvY2tldDogYW55O1xuICBcbiAgLyoqXG4gICAqIFwiQ2xhc3NcIiB2YXJpYWJsZXMgdG8gYmUgYXdhcmUgb2Y6XG4gICAqIHRoaXMuX3dlYlNvY2tldCAgICAgIC8vIFRoZSBhY3R1YWwgY29ubmVjdGVkIHdlYiBzb2NrZXRcbiAgICogdGhpcy5fcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb24gLy8gdGhlIFwicGFyZW50XCIgc2lnbmFsaW5nIGNvbm5lY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSYXZpU2lnbmFsaW5nV2ViU29ja2V0SW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtIHtSYXZpU2Vzc2lvbn0gcmF2aVNlc3Npb24gVGhlIG93bmVyIG9mIHRoaXMgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb246IFJhdmlTaWduYWxpbmdDb25uZWN0aW9uKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aVNpZ25hbGluZ1dlYlNvY2tldEltcGxlbWVudGF0aW9uXCIpO1xuICAgIHRoaXMuX3JhdmlTaWduYWxpbmdDb25uZWN0aW9uID0gcmF2aVNpZ25hbGluZ0Nvbm5lY3Rpb247XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29wZW4oc29ja2V0QWRkcmVzczogc3RyaW5nKSB7XG4gICAgdmFyIHNpZ25hbGluZ0Nvbm5lY3Rpb24gPSB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjtcblxuICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBhbiBvcGVuIHdlYnNvY2tldCwgbWFrZSBzdXJlIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBrbm93cyBhYm91dCBpdCwgYW5kIHJldHVybiBpbW1lZGlhdGVseVxuICAgIGlmICh0aGlzLl93ZWJTb2NrZXQgJiYgdGhpcy5fd2ViU29ja2V0LnJlYWR5U3RhdGUgPT09IGNyb3NzUGxhdGZvcm1XZWJTb2NrZXQuT1BFTikge1xuICAgICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9oYW5kbGVTdGF0ZUNoYW5nZSh7fSwgUmF2aVNpZ25hbGluZ1N0YXRlcy5PUEVOKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3dlYlNvY2tldCA9IG5ldyBjcm9zc1BsYXRmb3JtV2ViU29ja2V0KHNvY2tldEFkZHJlc3MpO1xuXG4gICAgLy8gVGhlIFdlYlNvY2tldCdzIG9wZW4sIGVycm9yLCBhbmQgY2xvc2UgZXZlbnRzIHdpbGwganVzdFxuICAgIC8vIGNhbGwgYmFjayB1cCB0byB0aGUgbWFpbiBSYXZpU2lnbmFsaW5nQ29ubmVjdGlvbidzIFxuICAgIC8vIHN0YXRlQ2hhbmdlSGFuZGxlcnMuXG4gICAgLy8gKFdlIGNhbid0IHNldCB0aGVzZSB1bnRpbCB3ZSBhdHRlbXB0IHRvIG9wZW4gdGhlXG4gICAgLy8gV2ViU29ja2V0LCBiZWNhdXNlIHRoZXJlJ3Mgbm8gb3RoZXIgV2ViU29ja2V0IGNvbnN0cnVjdG9yLilcbiAgICB0aGlzLl93ZWJTb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgc2lnbmFsaW5nQ29ubmVjdGlvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuT1BFTik7IH0pO1xuICAgIHRoaXMuX3dlYlNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHsgc2lnbmFsaW5nQ29ubmVjdGlvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuRVJST1IpOyB9KTtcbiAgICB0aGlzLl93ZWJTb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBmdW5jdGlvbihldmVudDogYW55KSB7IFxuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuY29kZSAmJiBldmVudC5jb2RlID4gNDAwMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBcImNsb3NlXCIgZXZlbnQgaXMgcmVhbGx5IGFuIGVycm9yLCBiZWNhdXNlIHdlJ3JlXG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgb25lIG9mIG91ciBjdXN0b20gZXJyb3IgY29kZXMuIFRyZWF0IGl0IGFzIHN1Y2guXG4gICAgICAgICAgICBSYXZpVXRpbHMuZXJyKFwiX2hhbmRsZVN0YXRlQ2hhbmdlOiBzaWduYWxpbmcgZXJyb3IgY29kZSBcIiArIGV2ZW50LmNvZGUgKyBcIjogIFwiICsgZXZlbnQucmVhc29uLCBcIlJhdmlTaWduYWxpbmdDb25uZWN0aW9uXCIpO1xuICAgICAgICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuRVJST1IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2lnbmFsaW5nQ29ubmVjdGlvbi5faGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIFJhdmlTaWduYWxpbmdTdGF0ZXMuQ0xPU0VEKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQW55IGFkZGl0aW9uYWwgbWVzc2FnaW5nIGhhbmRsaW5nIGdldHMgZG9uZSBieSB0aGUgbWFpblxuICAgIC8vIFJhdmlTaWduYWxpbmdDb25uZWN0aW9uJ3MgbWVzc2FnZUhhbmRsZXJzXG4gICAgdGhpcy5fd2ViU29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihldmVudDogYW55KSB7IHNpZ25hbGluZ0Nvbm5lY3Rpb24uX2hhbmRsZU1lc3NhZ2UoZXZlbnQpOyB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VuZChtZXNzYWdlOiBhbnkpIHtcbiAgICBpZiAodGhpcy5fd2ViU29ja2V0ICYmIHRoaXMuX3dlYlNvY2tldC5yZWFkeVN0YXRlID09PSBjcm9zc1BsYXRmb3JtV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgUmF2aVV0aWxzLmxvZyhcIlNlbmRpbmcgbWVzc2FnZSB0byBzZXJ2ZXI6IFwiICsgbWVzc2FnZSwgXCJSYXZpU2lnbmFsaW5nV2ViU29ja2V0SW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIHRoaXMuX3dlYlNvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2xvc2UoKSB7XG4gICAgdmFyIHNpZ25hbGluZ0Nvbm5lY3Rpb24gPSB0aGlzLl9yYXZpU2lnbmFsaW5nQ29ubmVjdGlvbjtcbiAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IGNsb3NlZCwgbWFrZSBzdXJlIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBrbm93cyBhYm91dCBpdCBhbmQgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgaWYgKCEgdGhpcy5fd2ViU29ja2V0IHx8IHRoaXMuX3dlYlNvY2tldC5yZWFkeVN0YXRlID09PSBjcm9zc1BsYXRmb3JtV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgICBzaWduYWxpbmdDb25uZWN0aW9uLl9oYW5kbGVTdGF0ZUNoYW5nZSh7fSwgUmF2aVNpZ25hbGluZ1N0YXRlcy5DTE9TRUQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3dlYlNvY2tldC5jbG9zZSgpO1xuICAgIHRoaXMuX3dlYlNvY2tldCA9IG51bGw7XG4gIH1cbn1cblxuIiwiaW1wb3J0IHsgUmF2aUNvbW1hbmRDb250cm9sbGVyIH0gZnJvbSBcIi4vUmF2aUNvbW1hbmRDb250cm9sbGVyXCI7XG5pbXBvcnQgeyBSYXZpVXRpbHMgfSBmcm9tIFwiLi9SYXZpVXRpbHNcIjtcblxuLyoqIFxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIEhhbmRsZXMgaW50ZXJhY3Rpbmcgd2l0aCBtZWRpYSBzdHJlYW1zIGZvciBSQVZJIHNlc3Npb25zLlxuICogVGhpcyBjbGFzcyBpcyBwcm92aWRlZCBieSBhIHtAbGluayBSYXZpU2Vzc2lvbn0gYW5kIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICpcbiAqIEV4YW1wbGUgdXNhZ2UgKHNldHRpbmcgYW4gYXVkaW8gb3V0cHV0IGNvbnRhaW5lcik6IFxuICogXG4gKiBgYGBcbiAqIHZhciBzdHJlYW1Db250cm9sbGVyID0gcmF2aVNlc3Npb24uZ2V0U3RyZWFtQ29udHJvbGxlcigpO1xuICogc3RyZWFtQ29udHJvbGxlci5zZXRBdWRpb0NvbnRhaW5lcihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVtb3RlQXVkaW8nKSk7XG4gKmBgYFxuICogICBcbiAqL1xuZXhwb3J0IGNsYXNzIFJhdmlTdHJlYW1Db250cm9sbGVyIHtcbiAgX2NvbW1hbmRDb250cm9sbGVyOiBSYXZpQ29tbWFuZENvbnRyb2xsZXI7XG4gIF9hdWRpb1N0cmVhbTogTWVkaWFTdHJlYW07XG4gIF92aWRlb1N0cmVhbTogTWVkaWFTdHJlYW07XG4gIF9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkOiBGdW5jdGlvbjtcbiAgX29uSW5wdXRBdWRpb0NoYW5nZWQ6IEZ1bmN0aW9uO1xuICBfb25JbnB1dFZpZGVvQ2hhbmdlZDogRnVuY3Rpb247XG4gIF92aWRlb0NvbnRhaW5lcjogSFRNTFZpZGVvRWxlbWVudDtcbiAgX2F1ZGlvQ29udGFpbmVyOiBIVE1MQXVkaW9FbGVtZW50O1xuICBfaW5wdXRBdWRpb1N0cmVhbTogTWVkaWFTdHJlYW07XG4gIF9pc1N0ZXJlbzogYm9vbGVhbjtcbiAgX2lucHV0VmlkZW9TdHJlYW06IE1lZGlhU3RyZWFtO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUkFWSSBzdHJlYW0gY29udHJvbGxlci4gXG4gICAqIE5lZWRzIGFjY2VzcyB0byBhIFJhdmlDb21tYW5kQ29udHJvbGxlciBzbyBpdCBjYW4gc2VuZCB2aWRlby1yZWxhdGVkIGNvbW1hbmRzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJhdmlDb21tYW5kQ29udHJvbGxlcjogUmF2aUNvbW1hbmRDb250cm9sbGVyKSB7XG4gICAgUmF2aVV0aWxzLmxvZyhcImNvbnN0cnVjdG9yXCIsIFwiUmF2aVN0cmVhbUNvbnRyb2xsZXJcIik7XG4gICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIgPSByYXZpQ29tbWFuZENvbnRyb2xsZXI7XG4gICAgXG4gICAgLy8gVGhlIGF1ZGlvIHN0cmVhbSBhbmQgdmlkZW8gc3RyZWFtIGdldCBzZXQgYnkgdGhlIFJhdmlTZXNzaW9uIHdoZW4gdGhlXG4gICAgLy8gYXBwcm9wcmlhdGUgZXZlbnRzIGFyZSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICB0aGlzLl9hdWRpb1N0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fdmlkZW9TdHJlYW0gPSBudWxsO1xuICAgIFxuICAgIC8vIERlZmF1bHQgZm9yIHRoZSB2aWRlbyBzdHJlYW0gc3RhdGUgY2hhbmdlIGhhbmRsZXJcbiAgICB0aGlzLl9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24gKHN0YXRlOiBhbnkpIHsgUmF2aVV0aWxzLmxvZyhcIm9udmlkZW9zdHJlYW1zdGF0ZWNoYW5nZWQgXCIgKyBzdGF0ZSwgXCJSYXZpU3RyZWFtQ29udHJvbGxlclwiKTt9XG4gICAgLy8gRGVmYXVsdCBmb3IgdGhlIGlucHV0IGF1ZGlvIHN0cmVhbSBjaGFuZ2UgaGFuZGxlclxuICAgIHRoaXMuX29uSW5wdXRBdWRpb0NoYW5nZWQgPSBudWxsO1xuICAgIHRoaXMuX29uSW5wdXRWaWRlb0NoYW5nZWQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBzdHJlYW0gY29udHJvbGxlciBpcyBhd2FyZSBvZiBhIHZpZGVvIHN0cmVhbSBjb21pbmcgZnJvbSB0aGUgUkFWSSBzZXJ2ZXIsIFxuICAgKiByZXR1cm4gaXQuIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyB2aWRlbyBzdHJlYW0gYXZhaWxhYmxlLlxuICAgKiBAcmV0dXJucyB7TWVkaWFTdHJlYW19XG4gICAqL1xuICBnZXRWaWRlb1N0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlkZW9TdHJlYW07XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZXQgYSB2aWRlbyBzdHJlYW0gZm9yIHRoaXMgc3RyZWFtIGNvbnRyb2xsZXIuIElmIHRoZXJlIGlzIGFsc28gYSB2aWRlbyBjb250YWluZXJcbiAgICogc2V0LCB0aGlzIHdpbGwgYXR0YWNoIHRoZSBzdHJlYW0gdG8gdGhhdCB2aWRlbyBjb250YWluZXIgYXMgd2VsbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRWaWRlb1N0cmVhbSh2aWRlb1N0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICB0aGlzLl92aWRlb1N0cmVhbSA9IHZpZGVvU3RyZWFtO1xuICAgIGlmICh0aGlzLl92aWRlb0NvbnRhaW5lcikge1xuICAgICAgdGhpcy5fdmlkZW9Db250YWluZXIuc3JjT2JqZWN0ID0gdGhpcy5fdmlkZW9TdHJlYW07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBsaXN0ZW5pbmcgdG8gdmlkZW8gc3RyZWFtIHN0YXRlIGNoYW5nZXNcbiAgICogQGNhbGxiYWNrIFJhdmlTdHJlYW1Db250cm9sbGVyfnZpZGVvU3RhdGVDaGFuZ2VDYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgQW4gb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIGluZm9ybWF0aW9uXG4gICAqIGFib3V0IHRoZSBzdGF0ZSBjaGFuZ2UuIFxuICAgKiBUT0RPOiBMaXN0IHRoZSBwb3NzaWJsZSBzdGF0ZXMuIFxuICAgKi9cbiAgLyoqXG4gICAqIFNldCB0aGUgRE9NIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBkaXNwbGF5IGluY29taW5nIFJBVkkgdmlkZW9cbiAgICogQSBjYWxsYmFjayBoYW5kbGVyIGNhbiBhbHNvIGJlIHNwZWNpZmllZCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB2aWRlbyBzdHJlYW0gY2hhbmdlIHN0YXRlXG4gICAqIFRoaXMgY2FsbCBtdXN0IGhhcHBlbiBiZWZvcmUgc3RhcnRpbmcgYSBzZXNzaW9uIGFuZCB0aGUgdmlkZW8gZWxlbWVudCBpcyBpbW11dGFibGVcbiAgICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSB2aWRlb0VsZW1lbnQgUmVmZXJlbmNlIHRvIHRoZSBKYXZhU2NyaXB0IERPTSBlbGVtZW50IGluIHdoaWNoIHRvIGRpc3BsYXkgdmlkZW8uIFxuICAgKiBJdCBpcyBleHBlY3RlZCB0aGF0IHRoaXMgZWxlbWVudCBpcyBhIFwidmlkZW9cIiBlbGVtZW50LiBXaGVuIGEgdmlkZW8gdHJhY2sgaXMgb2J0YWluZWRcbiAgICogZnJvbSB0aGUgUmF2aVdlYlJUQ0ltcGxlbWVudGF0aW9uLCB0aGlzIGVsZW1lbnQncyBzcmNPYmplY3Qgd2lsbCBiZSBzZXQgYWNjb3JkaW5nbHkuXG4gICAqIEBwYXJhbSB7UmF2aVN0cmVhbUNvbnRyb2xsZXJ+dmlkZW9TdGF0ZUNoYW5nZUNhbGxiYWNrfSBvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkIE9wdGlvbmFsIGNhbGxiYWNrIHRvIGNhdGNoIGNoYW5nZXMgb2YgdGhlIHZpZGVvIHN0cmVhbSBjaGFuZ2Ugc3RhdGVzLlxuICAgKi9cbiAgc2V0VmlkZW9Db250YWluZXIodmlkZW9FbGVtZW50OiBIVE1MVmlkZW9FbGVtZW50LCBvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkOiBGdW5jdGlvbikge1xuICAgIHRoaXMuX3ZpZGVvQ29udGFpbmVyID0gdmlkZW9FbGVtZW50O1xuICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBiZWVuIGEgdmlkZW8gc3RyZWFtIGFzc2lnbmVkLCBhdHRhY2ggaXRcbiAgICBpZiAodGhpcy5fdmlkZW9TdHJlYW0pIHtcbiAgICAgIHRoaXMuX3ZpZGVvQ29udGFpbmVyLnNyY09iamVjdCA9IHRoaXMuX3ZpZGVvU3RyZWFtO1xuICAgIH1cbiAgICB0aGlzLnNldFZpZGVvU3RhdGVDaGFuZ2VIYW5kbGVyKG9udmlkZW9zdHJlYW1zdGF0ZWNoYW5nZWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogQXNzaWduIGEgY2FsbGJhY2sgaGFuZGxlciBmb3Igd2hlbiB0aGUgdmlkZW8gc3RyZWFtIHN0YXRlIGNoYW5nZXNcbiAgICogQHBhcmFtIHtSYXZpU3RyZWFtQ29udHJvbGxlcn52aWRlb1N0YXRlQ2hhbmdlQ2FsbGJhY2t9IG9udmlkZW9zdHJlYW1zdGF0ZWNoYW5nZWQgQ2FsbGJhY2sgdG8gY2F0Y2ggY2hhbmdlcyBvZiB0aGUgdmlkZW8gc3RyZWFtIGNoYW5nZSBzdGF0ZXMuXG4gICAqL1xuICBzZXRWaWRlb1N0YXRlQ2hhbmdlSGFuZGxlcihvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkOiBGdW5jdGlvbikge1xuICAgIGlmIChvbnZpZGVvc3RyZWFtc3RhdGVjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkID0gb252aWRlb3N0cmVhbXN0YXRlY2hhbmdlZDtcbiAgICB9IFxuICB9XG5cbiAgLyoqXG4gICAqIFRlbGwgdGhlIFJBVkkgc2VydmVyIHRvIGluY2x1ZGUgdGhlIHZpZGVvIFwiZGFzaGJvYXJkXCIgYXMgcGFydCBvZiB0aGUgdmlkZW8gc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBvciBmYWxzZSwgdG8gc2hvdyBvciBub3Qgc2hvdyB0aGUgZGFzaGJvYXJkLlxuICAgKi9cbiAgc2hvd1ZpZGVvRGFzaGJvYXJkKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9jb21tYW5kQ29udHJvbGxlci5xdWV1ZUNvbW1hbmQoXCJ2aWRlby5zaG93RGFzaGJvYXJkXCIsIHtcImVuYWJsZWRcIjogZW5hYmxlZH0sIG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBUZWxsIHRoZSBSQVZJIHNlcnZlciB0byBpbmNsdWRlIGEgXCJyZW1vdGUgY3Vyc29yXCIgYXMgcGFydCBvZiB0aGUgdmlkZW8gc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBvciBmYWxzZSwgdG8gc2hvdyBvciBub3Qgc2hvdyB0aGUgcmVtb3RlIGN1cnNvci5cbiAgICovXG4gIHNob3dWaWRlb0N1cnNvcihlbmFibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fY29tbWFuZENvbnRyb2xsZXIucXVldWVDb21tYW5kKFwidmlkZW8uc2hvd0N1cnNvclwiLCB7XCJlbmFibGVkXCI6IGVuYWJsZWR9LCBudWxsKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIElmIHRoZSBzdHJlYW0gY29udHJvbGxlciBpcyBhd2FyZSBvZiBhbiBhdWRpbyBzdHJlYW0gY29taW5nIGZyb20gdGhlIFJBVkkgc2VydmVyLCBcbiAgICogcmV0dXJuIGl0LiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gYXVkaW8gc3RyZWFtIGF2YWlsYWJsZS5cbiAgICogQHJldHVybnMge01lZGlhU3RyZWFtfVxuICAgKi9cbiAgZ2V0QXVkaW9TdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1ZGlvU3RyZWFtO1xuICB9XG4gIFxuICAvKipcbiAgICogU2V0IGFuIGF1ZGlvIHN0cmVhbSBmb3IgdGhpcyBzdHJlYW0gY29udHJvbGxlci4gSWYgdGhlcmUgaXMgYWxzbyBhbiBhdWRpbyBjb250YWluZXJcbiAgICogc2V0LCB0aGlzIHdpbGwgYXR0YWNoIHRoZSBzdHJlYW0gdG8gdGhhdCBhdWRpbyBjb250YWluZXIgYXMgd2VsbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRBdWRpb1N0cmVhbShhdWRpb1N0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICB0aGlzLl9hdWRpb1N0cmVhbSA9IGF1ZGlvU3RyZWFtO1xuICAgIGlmICh0aGlzLl9hdWRpb0NvbnRhaW5lcikge1xuICAgICAgdGhpcy5fYXVkaW9Db250YWluZXIuc3JjT2JqZWN0ID0gdGhpcy5fYXVkaW9TdHJlYW07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgRE9NIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBwbGF5IGluY29taW5nIFJBVkkgYXVkaW9cbiAgICogQHBhcmFtIHtFbGVtZW50fSBhdWRpb0VsZW1lbnQgUmVmZXJlbmNlIHRvIHRoZSBKYXZhU2NyaXB0IERPTSBlbGVtZW50IGluIHdoaWNoIHRvIHBsYXkgYXVkaW9cbiAgICogc2VudCBmcm9tIHRoZSByZW1vdGUgUkFWSSBzZXJ2ZXIuIFxuICAgKiBJdCBpcyBleHBlY3RlZCB0aGF0IHRoaXMgZWxlbWVudCBpcyBhbiBcImF1ZGlvXCIgZWxlbWVudC4gV2hlbiBhbiBhdWRpbyB0cmFjayBpcyBvYnRhaW5lZFxuICAgKiBmcm9tIHRoZSBSYXZpV2ViUlRDSW1wbGVtZW50YXRpb24sIHRoaXMgZWxlbWVudCdzIHNyY09iamVjdCB3aWxsIGJlIHNldCBhY2NvcmRpbmdseS5cbiAgICovXG4gIHNldEF1ZGlvQ29udGFpbmVyKGF1ZGlvRWxlbWVudDogSFRNTEF1ZGlvRWxlbWVudCkge1xuICAgIHRoaXMuX2F1ZGlvQ29udGFpbmVyID0gYXVkaW9FbGVtZW50O1xuICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBiZWVuIGFuIGF1ZGlvIHN0cmVhbSBhc3NpZ25lZCwgYXR0YWNoIGl0XG4gICAgaWYgKHRoaXMuX2F1ZGlvU3RyZWFtKSB7XG4gICAgICB0aGlzLl9hdWRpb0NvbnRhaW5lci5zcmNPYmplY3QgPSB0aGlzLl9hdWRpb1N0cmVhbTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdHJlYW0gdGhhdCBzaG91bGQgYmUgdXNlZCB0byBzZW5kIFJBVkkgYXVkaW8uXG4gICAqIFxuICAgKiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiBgYGBcbiAgICogICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlLCB2aWRlbzogZmFsc2UgfSlcbiAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgKiAgICAgc3RyZWFtQ29udHJvbGxlci5zZXRJbnB1dEF1ZGlvKHN0cmVhbSk7XG4gICAqICAgfSlcbiAgICogIFxuICAgKmBgYFxuICAgKiBJZiB0aGVyZSBpcyBhIGNhbGxiYWNrIGFzc2lnbmVkIHZpYSBzZXRJbnB1dEF1ZGlvQ2hhbmdlSGFuZGxlcigpLFxuICAgKiBpdCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgc3RyZWFtIGlzIHNldC5cbiAgICogXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbSBUaGUgYXVkaW8gc3RyZWFtIGJlaW5nIHVzZWQgdG8gY2FwdHVyZSBsb2NhbCBtZWRpYS5cbiAgICogR2VuZXJhbGx5IHRoaXMgd2lsbCBiZSByZXR1cm5lZCBmcm9tIGdldFVzZXJNZWRpYSgpICBcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1N0ZXJlbyAtIENhbiBiZSB0cnVlIHRvIGluZGljYXRlIHRoYXQgdGhlIHN0cmVhbSBpcyBzdGVyZW8uXG4gICAqIFRoZSBkZWZhdWx0IGlzIGZhbHNlLlxuICAgKi9cbiAgc2V0SW5wdXRBdWRpbyhzdHJlYW06IE1lZGlhU3RyZWFtLCBpc1N0ZXJlbyA9IGZhbHNlKSB7XG4gICAgdGhpcy5faW5wdXRBdWRpb1N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9pc1N0ZXJlbyA9IGlzU3RlcmVvO1xuICAgIGlmICh0aGlzLl9vbklucHV0QXVkaW9DaGFuZ2VkKSB0aGlzLl9vbklucHV0QXVkaW9DaGFuZ2VkKHN0cmVhbSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBpbnB1dCBhdWRpbyBzdHJlYW0gaXMgY2hhbmdlZFxuICAgKiB2aWEgc2V0SW5wdXRBdWRpbygpIFxuICAgKiBAY2FsbGJhY2sgUmF2aVN0cmVhbUNvbnRyb2xsZXJ+aW5wdXRBdWRpb0NoYW5nZUNhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW0gVGhlIG5ldyBzdHJlYW1cbiAgICovXG4gIC8qKlxuICAgKiBBc3NpZ24gYSBjYWxsYmFjayBoYW5kbGVyIGZvciB3aGVuIHRoZSBpbnB1dCBhdWRpbyBzdHJlYW0gZ2V0cyBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7UmF2aVN0cmVhbUNvbnRyb2xsZXJ+aW5wdXRBdWRpb0NoYW5nZUNhbGxiYWNrfSBvbmlucHV0YXVkaW9jaGFuZ2VkIENhbGxiYWNrIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgaW5wdXQgYXVkaW8gY2hhbmdlc1xuICAgKi9cbiAgc2V0SW5wdXRBdWRpb0NoYW5nZUhhbmRsZXIob25pbnB1dGF1ZGlvY2hhbmdlZDogRnVuY3Rpb24pIHtcbiAgICBpZiAob25pbnB1dGF1ZGlvY2hhbmdlZCkge1xuICAgICAgdGhpcy5fb25JbnB1dEF1ZGlvQ2hhbmdlZCA9IG9uaW5wdXRhdWRpb2NoYW5nZWQ7XG4gICAgfSBcbiAgfVxuICBcblxuICBzZXRJbnB1dFZpZGVvKHN0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICB0aGlzLl9pbnB1dFZpZGVvU3RyZWFtID0gc3RyZWFtO1xuICAgIGlmICh0aGlzLl9vbklucHV0VmlkZW9DaGFuZ2VkKSB0aGlzLl9vbklucHV0VmlkZW9DaGFuZ2VkKHN0cmVhbSk7XG4gIH1cblxuICBzZXRJbnB1dFZpZGVvQ2hhbmdlSGFuZGxlcihvbmlucHV0dmlkZW9jaGFuZ2VkOiBGdW5jdGlvbikge1xuICAgIGlmIChvbmlucHV0dmlkZW9jaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9vbklucHV0VmlkZW9DaGFuZ2VkID0gb25pbnB1dHZpZGVvY2hhbmdlZDtcbiAgICB9IFxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBpbmNvbWluZyBhdWRpbyBzdHJlYW0gc3VwcG9ydHMgc3RlcmVvIGlucHV0LFxuICAgKiBhcyBzcGVjaWZpZWQgYnkgc2V0SW5wdXRBdWRpby5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhpcyBpbnB1dCBhdWRpbyB0cmFjayBzdXBwb3J0cyBzdGVyZW8gaW5wdXRcbiAgICovXG4gIGlzU3RlcmVvSW5wdXQoKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgc3RhdGUgb2YgcGxheSBpcyB0aGF0IHRoZXJlIGlzIHRvbyBtdWNoIGNvbmZ1c2lvbiBpbiB0cnlpbmcgdG9cbiAgICAvLyBjb21wdXRlIHRoaXMgZnJvbSB0aGUgc3RyZWFtIHRyYWNrczpcbiAgICAvLyBUaGUgYnJvd3NlcidzIGdldFVzZXJNZWRpYSBmYWxzZWx5IHJlcG9ydHMgYSBjaGFubmVsQ291bnQgb2YgMiwgc28gd2Ugd291bGRcbiAgICAvLyBmYWxzZWx5IHJlcG9ydCBzdGVyZW8uXG4gICAgLy8gVGhlIE5vZGVKUyB3cnRjIHBhY2thZ2UgaGFzIGEgTWVkaWFTdHJlYW0gdGhhdCBkb2Vzbid0IHN1cHBvcnQgZ2V0U2V0dGluZ3NcbiAgICAvLyBhdCBhbGwsIHNvIHdlIHdvdWxkIGZhbHNlbHkgcmVwb3J0IG1vbm8uXG4gICAgcmV0dXJuIHRoaXMuX2lzU3RlcmVvO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCB0aGUgY29udmVyc2F0aW9uIGJ5IHN0b3BwaW5nIGFueSBpbmNvbWluZyB2aWRlb1xuICAgKiBhbmQgcmVtb3RlIGF1ZGlvIHN0cmVhbXMgYW5kIFxuICAgKiByZXNldCB0aGUgc291cmNlIG9iamVjdHMgb2YgdGhlaXIgY29udGFpbmVycy5cbiAgICogTm90ZSB0aGF0IHRoaXMgZG9lcyBOT1Qgc3RvcCBhbnkgbG9jYWwgYXVkaW8gc3RyZWFtcyB0aGF0XG4gICAqIG1pZ2h0IGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGVlckNvbm5lY3Rpb24gLS0gaXQgbGVhdmVzXG4gICAqIGhhbmRsaW5nIG9mIHRoYXQgbG9jYWwgYXVkaW8gc3RyZWFtIHRvIHRoZSBpbXBsZW1lbnRpbmcgY2xpZW50LlxuICAgKiBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdG9wKCkge1xuICAgIFJhdmlVdGlscy5sb2coXCJzdG9wcGluZyBzdHJlYW1zXCIsIFwiUmF2aVN0cmVhbUNvbnRyb2xsZXJcIik7XG5cbiAgICBpZiAodGhpcy5fdmlkZW9Db250YWluZXIgJiYgdGhpcy5fdmlkZW9Db250YWluZXIuc3JjT2JqZWN0KSB7XG4gICAgICBsZXQgc3JjT2JqZWN0ID0gPE1lZGlhU3RyZWFtPiB0aGlzLl92aWRlb0NvbnRhaW5lci5zcmNPYmplY3Q7XG4gICAgICBsZXQgdHJhY2tzID0gc3JjT2JqZWN0LmdldFRyYWNrcygpO1xuICAgICAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgIHRoaXMuX3ZpZGVvQ29udGFpbmVyLnNyY09iamVjdCA9IG51bGw7XG4gICAgICB0aGlzLl9vblZpZGVvU3RyZWFtU3RhdGVDaGFuZ2VkKFwib3ZlclwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5fYXVkaW9TdHJlYW0pIHtcbiAgICAgIHRoaXMuX2F1ZGlvU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgIHRoaXMuX2F1ZGlvU3RyZWFtID0gbnVsbDtcbiAgICB9XG4gICAgXG4gIH1cblxufVxuIiwidmFyIERFQlVHID0gdHJ1ZTtcblxuLyoqIFxuICpcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBDb2xsZWN0aW9uIG9mIHN0YXRpYyB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJhdmlVdGlscyB7XG5cblxuICAvKipcbiAgICogU2ltcGxlIFVVSUQgaW1wbGVtZW50YXRpb24uXG4gICAqIFRha2VuIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA1MDc0LzUxNTU4NFxuICAgKiBTdHJpY3RseSBzcGVha2luZywgaXQncyBub3QgYSByZWFsIFVVSUQsIGJ1dCBpdCBnaXZlcyB1cyB3aGF0IHdlIG5lZWRcbiAgICogZm9yIFJBVkkgaGFuZGxpbmcuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlVVVJRCgpOiBzdHJpbmcge1xuICAgIGZ1bmN0aW9uIHM0KCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gIH1cbiAgXG4gIFxuICAvKipcbiAgICogV3JhcHMgY29uc29sZS5sb2cgc3VjaCB0aGF0IHdlIHdpbGwgb25seSBvdXRwdXQgYSBtZXNzYWdlIHRvXG4gICAqIGNvbnNvbGUubG9nIGlmIHRoZSBjb25zdGFudCBERUJVRyAoY3VycmVudGx5LCB0aGlzIGlzIHNpbXBseSBkZWZpbmVkXG4gICAqIGFzIGEgZ2xvYmFsIHZhcmlhYmxlIGluaGVyaXRlZCBieSB0aGUgcmF2aS5qcyBmaWxlLCB3aGljaCBpcyBhIGxpdHRsZVxuICAgKiBhd2Z1bCkgaXMgc2V0IHRvIGB0cnVlYC4gKERlZmF1bHRzIHRvIHRydWUuKVxuICAgKiBUaGlzIG1ldGhvZCBkaXNwYXRjaGVzIGEgXCJsb2dnZXJcIiBldmVudCBvbiB0aGUgZG9jdW1lbnQgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBkbyBzb21ldGhpbmcgZWxzZSB3aXRoIHRoZSBtZXNzYWdlLiBJdCB3aWxsIGFsd2F5c1xuICAgKiBkaXNwYXRjaCB0aGlzIGV2ZW50IHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3QgaXQncyBpbiBERUJVRyBtb2RlLFxuICAgKiBiZWNhdXNlIHByZXN1bWFibHkgaWYgeW91J3JlIGxpc3RlbmluZyBmb3IgdGhlIGV2ZW50IGl0J3MgYmVjYXVzZSB5b3VcbiAgICogd2FudCB0byBnZXQgbWVzc2FnZXMuXG4gICAqL1xuICBzdGF0aWMgbG9nKG1lc3NhZ2U6IHN0cmluZywgY2xhc3NuYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIGNsYXNzbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIG1lc3NhZ2UgPSBjbGFzc25hbWUgKyBcIjogXCIgKyBtZXNzYWdlO1xuICAgIGlmIChERUJVRykge1xuICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbG9nZ2VyJywge2RldGFpbDogbWVzc2FnZX0pKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFkZGl0aW9uYWxseSwgYW4gZXJyb3Igd2FzIGVuY291bnRlcmVkIHRyeWluZyB0byBsb2cgdGhhdC5cIilcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgY29uc29sZS5sb2cgc3VjaCB0aGF0IHdlIHdpbGwgQUxXQVlTIG91dHB1dCBhIG1lc3NhZ2UsIGFuZFxuICAgKiB0aGF0IG1lc3NhZ2Ugd2lsbCBiZSBpbiByZWQuXG4gICAqIFRoaXMgbWV0aG9kIGRpc3BhdGNoZXMgYW4gXCJlcnJsb2dnZXJcIiBldmVudCBvbiB0aGUgZG9jdW1lbnQgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBkbyBzb21ldGhpbmcgZWxzZSB3aXRoIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgc3RhdGljIGVycihtZXNzYWdlOiBzdHJpbmcsIGNsYXNzbmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBjbGFzc25hbWUgIT09ICd1bmRlZmluZWQnKSBtZXNzYWdlID0gY2xhc3NuYW1lICsgXCI6IFwiICsgbWVzc2FnZTtcbiAgICBjb25zb2xlLmxvZygnJWMgJXMnLCAnY29sb3I6ICNGQjBBMUMnLCBtZXNzYWdlKTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2VycmxvZ2dlcicsIHtkZXRhaWw6IG1lc3NhZ2V9KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC8vIFJldHVybiBKU09OLnN0cmluZ2lmeShpdGVtKSBpZiBwb3NzaWJsZSwgZWxzZSBpdGVtXG4gICAqL1xuICBzdGF0aWMgc2FmZWx5UHJpbnRhYmxlKGl0ZW06IGFueSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogRmlndXJlcyBvdXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgYSBET00gZWxlbWVudC5cbiAgICovXG4gIHN0YXRpYyBnZXRFbGVtZW50Q1NTU2l6ZShlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBpZiAoIWdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgdmFyIHcgPSBwYXJzZUludChjcy5nZXRQcm9wZXJ0eVZhbHVlKFwid2lkdGhcIiksIDEwKTtcbiAgICB2YXIgaCA9IHBhcnNlSW50KGNzLmdldFByb3BlcnR5VmFsdWUoXCJoZWlnaHRcIiksIDEwKTtcbiAgICByZXR1cm4ge3dpZHRoOiB3LCBoZWlnaHQ6IGh9XG4gIH1cbiAgXG4gIFxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBcImRlYnVnXCIgbW9kZS4gSW4gZGVidWcgbW9kZSwgbW9zdCBldmVyeXRoaW5nIGdldHNcbiAgICogcHJpbnRlZCB0byB0aGUgSlMgY29uc29sZS4gKFNlZSBhbHNvIFJhdmlVdGlscy5qcylcbiAgICogY29ubmVjdHMgdG8gdGhlIHNwZWNpZmllZCBXZWJTb2NrZXQgYWRkcmVzcy5cbiAgICogQHBhcmFtIHtib29sZWFufSBkZWJ1ZyBXaGV0aGVyIG9yIG5vdCB0byBwdXQgdGhlIGxvZ2dlciBpbnRvIGRlYnVnIG1vZGUuXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBzZXREZWJ1ZyhkZWJ1ZzogYm9vbGVhbikge1xuICAgIERFQlVHID0gZGVidWc7XG4gIH1cblxufVxuIiwiLyoqXG4gKiBUaGlzIHV0aWxpdHkgTW9kdWxlIGNvbnRhaW5zIGNvZGUgcmVsYXRlZCB0byBsb2dnaW5nIGZyb20gd2l0aGluIEFQSSBmdW5jdGlvbnMuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG4vKipcbiAqIFVzZWQgZm9yIGRldGVybWluaW5nIHdoYXQgZGF0YSB0aGUgSGlnaCBGaWRlbGl0eSBBdWRpbyBDbGllbnQgQVBJIHNob3VsZCBwcmludCB0byB0aGUgY29uc29sZS4gXG4gKi9cbmV4cG9ydCBlbnVtIEhpRmlMb2dMZXZlbCB7XG4gICAgTm9uZSA9IFwiTm9uZVwiLFxuICAgIEVycm9yID0gXCJFcnJvclwiLFxuICAgIFdhcm4gPSBcIldhcm5cIixcbiAgICBEZWJ1ZyA9IFwiRGVidWdcIixcbn1cblxuLyoqXG4gKiBBIHdyYXBwZXIgZm9yIEFQSS1pbnRlcm5hbCBgY29uc29sZS4qKClgIGNhbGxzLCBnYXRlZCBieSB0aGUgdXNlcidzIGN1cnJlbnQgbG9nIGxldmVsLlxuICovXG5leHBvcnQgY2xhc3MgSGlGaUxvZ2dlciB7XG4gICAgc3RhdGljIGxvZ0xldmVsOiBIaUZpTG9nTGV2ZWwgPSBIaUZpTG9nTGV2ZWwuRXJyb3I7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbG9nTGV2ZWwgVGhlIGluaXRpYWwgTG9nIExldmVsIGZvciBvdXIgTG9nZ2VyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZ0xldmVsPzogSGlGaUxvZ0xldmVsKSB7XG4gICAgICAgIGxvZ0xldmVsID0gbG9nTGV2ZWwgPyBsb2dMZXZlbCA6IEhpRmlMb2dMZXZlbC5EZWJ1ZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IEhpRmkgTG9nIExldmVsLlxuICAgICAqIEBwYXJhbSBuZXdMb2dMZXZlbCBUaGUgbmV3IExvZyBMZXZlbCBmb3Igb3VyIExvZ2dlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0SGlGaUxvZ0xldmVsKG5ld0xvZ0xldmVsOiBIaUZpTG9nTGV2ZWwpOiB2b2lkIHtcbiAgICAgICAgSGlGaUxvZ2dlci5sb2dMZXZlbCA9IG5ld0xvZ0xldmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBMb2dnZXIncyBsb2cgbGV2ZWwgaXMgYERlYnVnYCwgd2lsbCBwcmludCBhIGRlYnVnIGxvZyB0byB0aGUgbG9ncy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2cuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXNzYWdlIHdhcyBvdXRwdXQgdG8gdGhlIGNvbnNvbGU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBsb2cobWVzc2FnZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChIaUZpTG9nZ2VyLmxvZ0xldmVsID09PSBIaUZpTG9nTGV2ZWwuRGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSBzYW1lIHRoaW5nIGFzIHtAbGluayBsb2d9LlxuICAgICAqIEBwYXJhbSBtZXNzYWdlXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXNzYWdlIHdhcyBvdXRwdXQgdG8gdGhlIGNvbnNvbGU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBkZWJ1ZyhtZXNzYWdlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBMb2dnZXIncyBsb2cgbGV2ZWwgaXMgYERlYnVnYCBvciBgV2FybmAsIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGxvZyB0byB0aGUgbG9ncy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2cuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXNzYWdlIHdhcyBvdXRwdXQgdG8gdGhlIGNvbnNvbGU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyB3YXJuKG1lc3NhZ2U6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoSGlGaUxvZ2dlci5sb2dMZXZlbCA9PT0gSGlGaUxvZ0xldmVsLkRlYnVnIHx8IEhpRmlMb2dnZXIubG9nTGV2ZWwgPT09IEhpRmlMb2dMZXZlbC5XYXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBMb2dnZXIncyBsb2cgbGV2ZWwgaXMgYERlYnVnYCBvciBgV2FybmAgb3IgYEVycm9yYCwgd2lsbCBwcmludCBhbiBlcnJvciBsb2cgdG8gdGhlIGxvZ3MuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWVzc2FnZSB3YXMgb3V0cHV0IHRvIHRoZSBjb25zb2xlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZXJyb3IobWVzc2FnZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChIaUZpTG9nZ2VyLmxvZ0xldmVsID09PSBIaUZpTG9nTGV2ZWwuRGVidWcgfHwgSGlGaUxvZ2dlci5sb2dMZXZlbCA9PT0gSGlGaUxvZ0xldmVsLldhcm4gfHwgSGlGaUxvZ2dlci5sb2dMZXZlbCA9PT0gSGlGaUxvZ0xldmVsLkVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqIFRoaXMgTW9kdWxlIGNvbnRhaW5zIGEgbnVtYmVyIG9mIHVzZWZ1bCB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IEFQSSB1c2VycyBjYW4gdXNlIGluIHRoZWlyIGFwcGxpY2F0aW9ucyBpZiB0aGV5IHdpc2guXG4gKiBTb21lIG9mIHRoZW0gYXJlIGFsc28gdXNlZCBpbnRlcm5hbGx5IGluIEFQSSBjb2RlLlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cblxuaW1wb3J0IHsgSGlGaUxvZ2dlciB9IGZyb20gXCIuL0hpRmlMb2dnZXJcIjtcblxuZnVuY3Rpb24gZHluYW1pY1JlcXVpcmUobW9kOiBhbnksIHJlcXVpcmVTdHJpbmc6IHN0cmluZyk6IGFueSB7XG4gICAgcmV0dXJuIG1vZC5yZXF1aXJlKHJlcXVpcmVTdHJpbmcpO1xufVxuXG5sZXQgbm93OmFueTtcbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBub2RlIGNvbnRleHRcbiAgICB0cnkge1xuICAgICAgICBub3cgPSBkeW5hbWljUmVxdWlyZShtb2R1bGUsICdwZXJmX2hvb2tzJykucGVyZm9ybWFuY2Uubm93OyAvLyBVc2VkIHdpdGggYHByZWNpc2VJbnRlcnZhbCgpYC5cbiAgICB9IGNhdGNoIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBIaUZpVXRpbGl0aWVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTIE9iamVjdCBjb250YWluaW5nIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gcGFzc2VkIG9iamVjdHMuXG4gICAgICogXG4gICAgICogVGhpcyBmdW5jdGlvbiB3YXMgYWRhcHRlZCBmcm9tIFt0aGlzIHZlcnkgaGVscGZ1bCBkb2N1bWVudCBvbiBHb01ha2VUaGluZ3Nde0BsaW5rIGh0dHBzOi8vZ29tYWtldGhpbmdzLmNvbS9nZXR0aW5nLXRoZS1kaWZmZXJlbmNlcy1iZXR3ZWVuLXR3by1vYmplY3RzLXdpdGgtdmFuaWxsYS1qcy99LlxuICAgICAqIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAgICogXG4gICAgICogQHBhcmFtIG9iajEgXG4gICAgICogQHBhcmFtIG9iajIgXG4gICAgICovXG4gICAgc3RhdGljIHJlY3Vyc2l2ZWx5RGlmZk9iamVjdHMob2JqMTogYW55LCBvYmoyOiBhbnkpOiBhbnkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgYW4gb2JqZWN0IHRvIGNvbXBhcmUgaXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKCFvYmoyIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmoyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVmFyaWFibGVzXG4gICAgICAgIC8vXG4gICAgICAgIGxldCBkaWZmczogYW55ID0ge307XG4gICAgICAgIGxldCBrZXk7XG5cbiAgICAgICAgbGV0IGRvQXJyYXlzTWF0Y2ggPSAoYXJyMTogQXJyYXk8YW55PiwgYXJyMjogQXJyYXk8YW55PikgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFycmF5cyBhcmUgdGhlIHNhbWUgbGVuZ3RoXG4gICAgICAgICAgICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbGwgaXRlbXMgZXhpc3QgYW5kIGFyZSBpbiB0aGUgc2FtZSBvcmRlclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ29tcGFyZSB0d28gaXRlbXMgYW5kIHB1c2ggbm9uLW1hdGNoZXMgdG8gb2JqZWN0XG4gICAgICAgIGxldCBjb21wYXJlID0gKGl0ZW0xOiBhbnksIGl0ZW0yOiBhbnksIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIG9iamVjdCB0eXBlXG4gICAgICAgICAgICBsZXQgdHlwZTEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlbTEpO1xuICAgICAgICAgICAgbGV0IHR5cGUyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZW0yKTtcblxuICAgICAgICAgICAgLy8gSWYgdHlwZTIgaXMgdW5kZWZpbmVkIGl0IGhhcyBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgIGlmICh0eXBlMiA9PT0gJ1tvYmplY3QgVW5kZWZpbmVkXScpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGl0ZW1zIGFyZSBkaWZmZXJlbnQgdHlwZXNcbiAgICAgICAgICAgIGlmICh0eXBlMSAhPT0gdHlwZTIpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gaXRlbTI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhbiBvYmplY3QsIGNvbXBhcmUgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgIGlmICh0eXBlMSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JqRGlmZiA9IEhpRmlVdGlsaXRpZXMucmVjdXJzaXZlbHlEaWZmT2JqZWN0cyhpdGVtMSwgaXRlbTIpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvYmpEaWZmKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZzW2tleV0gPSBvYmpEaWZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGFuIGFycmF5LCBjb21wYXJlXG4gICAgICAgICAgICBpZiAodHlwZTEgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRvQXJyYXlzTWF0Y2goaXRlbTEsIGl0ZW0yKSkge1xuICAgICAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gaXRlbTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRWxzZSBpZiBpdCdzIGEgZnVuY3Rpb24sIGNvbnZlcnQgdG8gYSBzdHJpbmcgYW5kIGNvbXBhcmVcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwganVzdCBjb21wYXJlXG4gICAgICAgICAgICBpZiAodHlwZTEgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbTEudG9TdHJpbmcoKSAhPT0gaXRlbTIudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBkaWZmc1trZXldID0gaXRlbTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbTEgIT09IGl0ZW0yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZzW2tleV0gPSBpdGVtMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSBmaXJzdCBvYmplY3RcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqMSkge1xuICAgICAgICAgICAgaWYgKG9iajEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbXBhcmUob2JqMVtrZXldLCBvYmoyW2tleV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIHNlY29uZCBvYmplY3QgYW5kIGZpbmQgbWlzc2luZyBpdGVtc1xuICAgICAgICBmb3IgKGtleSBpbiBvYmoyKSB7XG4gICAgICAgICAgICBpZiAob2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmoxW2tleV0gJiYgb2JqMVtrZXldICE9PSBvYmoyW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZnNba2V5XSA9IG9iajJba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIG9iamVjdCBvZiBkaWZmZXJlbmNlc1xuICAgICAgICByZXR1cm4gZGlmZnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBcImJlc3RcIiBhdWRpbyBjb25zdHJhaW50cyBzdXBwb3J0ZWQgYnkgdGhlIGNsaWVudC4gSW4gdGhpcyBjYXNlLCBcImJlc3RcIiBpcyBkZWZpbmVkIGFzIFwidGhlIGNvbnN0cmFpbnRzIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSBoaWdoZXN0LXF1YWxpdHkgYXVkaW8uXCJcbiAgICAgKiBUaGF0IG1lYW5zIGRpc2FibGluZyBFY2hvIENhbmNlbGxhdGlvbiwgZGlzYWJsaW5nIE5vaXNlIFN1cHByZXNzaW9uLCBhbmQgZGlzYWJsaW5nIEF1dG9tYXRpYyBHYWluIENvbnRyb2wuXG4gICAgICovXG4gICAgc3RhdGljIGdldEJlc3RBdWRpb0NvbnN0cmFpbnRzKCk6IGFueSB7XG4gICAgICAgIGxldCBhdWRpb0NvbnN0cmFpbnRzOiBhbnkgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIChuYXZpZ2F0b3IpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuZWNob0NhbmNlbGxhdGlvbikge1xuICAgICAgICAgICAgYXVkaW9Db25zdHJhaW50cy5lY2hvQ2FuY2VsbGF0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIChuYXZpZ2F0b3IpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkubm9pc2VTdXBwcmVzc2lvbikge1xuICAgICAgICAgICAgYXVkaW9Db25zdHJhaW50cy5ub2lzZVN1cHByZXNzaW9uID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIChuYXZpZ2F0b3IpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuYXV0b0dhaW5Db250cm9sKSB7XG4gICAgICAgICAgICBhdWRpb0NvbnN0cmFpbnRzLmF1dG9HYWluQ29udHJvbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF1ZGlvQ29uc3RyYWludHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYHByZWNpc2VJbnRlcnZhbCgpYCBpcyBhIHZlcnNpb24gb2YgYHNldEludGVydmFsKClgIGZvciBOb2RlSlMgdGhhdCBkb2VzIG5vdCBzcGluIENQVXMgbm9yIGRyaWZ0LlxuICAgICAqIFRoZSByZXR1cm5lZCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhIGBjbGVhcigpYCBtZXRob2RzIHRoYXQgc3RvcHMgdGhlIGludGVydmFsLlxuICAgICAqIEluIHRoZSBicm93c2VyIGNvbnRleHQsIGBwcmVjaXNlSW50ZXJ2YWwoKWAgaXMgc2ltcGx5IGEgd3JhcHBlciBmb3IgYHNldEludGVydmFsKClgLlxuICAgICAqIFxuICAgICAqIFdlIGRvIHRocmVlIHRoaW5nczpcbiAgICAgKiAxLiBLZWVwIGEgcnVubmluZyBjb3VudGVyIG9mIHdoZW4gdGhlIG5leHQgY2FsbCBzaG91bGQgYmUsIHRvIGF2b2lkIGRyaWZ0LlxuICAgICAqIDIuIENvbXB1dGUgdGhlIHRpbWUgdG8gdGhlIG5leHQgY2FsbCBhbmQgZ2l2ZSB0aGF0IHRvIGBzZXRUaW1lb3V0KClgLlxuICAgICAqIDMuIE91ciBhdmVyYWdlIGVycm9yIHdpdGggdGhlIGFib3ZlIGlzIGFib3V0IDFtcyAoc28gaGFsZiB0aGUgaW50ZXJ2YWxzIGFyZSBvZmYgYnkgbW9yZSkuXG4gICAgICogU28gaW4gIzIsIHNob290IGZvciAyIG1zIGxlc3MgdGhhbiB0aGF0LCBhbmQgc3BpbiB3aXRoIHNldEltbWVkaWF0ZSAoYWxsb3dpbmcgb3RoZXIgc3R1ZmYgdG8gcnVuKSB1bnRpbCB3ZSd2ZSByZWFjaGVkIHRoZSBleHBlY3RlZCB0aW1lLlxuICAgICAqIFxuICAgICAqIEZvciBhIDEwbXMgaW50ZXJ2YWwsIHdlIG1lYXN1cmVkIGFuICoqYXZlcmFnZSoqIGVycm9yIHBlciBpbnRlcnZhbCBvZjpcbiAgICAgKiAtIGAxLjY3IG1zYCBmb3IgYHNldEludGVydmFsKClgIChzbyBTT01FVEhJTkcgaXMgdGlja2luZyBhdCA2MCBIeikuXG4gICAgICogLSBgfjEgbXNgIGZvciB0aGlzIGNvZGUgV0lUSE9VVCAjMywgdXNpbmcgYERhdGUuZ2V0VGltZSgpYFxuICAgICAqIC0gYH4xIG1zYCBmb3IgdGhpcyBjb2RlIFdJVEhPVVQgIzMsIHVzaW5nIGBwZXJmX2hvb2tzLnBlcmZvcm1hbmNlLm5vdygpYFxuICAgICAqIC0gYDAuODYgbXNgIGZvciB0aGlzIGNvZGUgdXNpbmcgYERhdGUuZ2V0VGltZSgpYFxuICAgICAqIC0gYDAuMDMgbXNgIGZvciB0aGlzIGNvZGUgdXNpbmcgYHBlcmZfaG9va3MucGVyZm9ybWFuY2Uubm93KClgXG4gICAgICogXG4gICAgICogXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgcHJlY2lzZSBpbnRlcnZhbCBleHBpcmVzLlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbE1TIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuIGVhY2ggaW50ZXJ2YWwuXG4gICAgICovXG4gICAgc3RhdGljIHByZWNpc2VJbnRlcnZhbChjYWxsYmFjazogRnVuY3Rpb24sIGludGVydmFsTVM6IG51bWJlcik6IGFueSB7XG4gICAgICAgIGlmICghbm93KSB7XG4gICAgICAgICAgICBIaUZpTG9nZ2VyLndhcm4oYFxcYHByZWNpc2VJbnRlcnZhbCgpXFxgIGlzIGEgd3JhcHBlciBmb3IgXFxgc2V0SW50ZXJ2YWwoKVxcYCBpbiB0aGUgYnJvd3NlciBjb250ZXh0IWApO1xuICAgICAgICAgICAgcmV0dXJuIHNldEludGVydmFsKGNhbGxiYWNrLCBpbnRlcnZhbE1TKTsgICAgXG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgbGV0IG5leHRUaWNrID0gbm93KCk7XG4gICAgICAgIGxldCBjbGVhcjphbnkgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIGxldCB3cmFwcGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRoaXNUaWNrID0gbm93KCk7XG4gICAgICAgICAgICBpZiAodGhpc1RpY2sgPCBuZXh0VGljaykge1xuICAgICAgICAgICAgICAgIGNsZWFyID0gY2xlYXJJbW1lZGlhdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVvdXQgPSBzZXRJbW1lZGlhdGUod3JhcHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0VGljayArPSBpbnRlcnZhbE1TO1xuICAgICAgICAgICAgY2xlYXIgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCh3cmFwcGVyLCBuZXh0VGljayAtIHRoaXNUaWNrIC0gMik7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgdGltZW91dDphbnkgPSBzZXRUaW1lb3V0KHdyYXBwZXIpO1xuICAgICAgICByZXR1cm4geyBjbGVhcjogKCkgPT4gY2xlYXIodGltZW91dCkgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2hlY2tCcm93c2VyQ29tcGF0aWJpbGl0eSgpOiBCb29sZWFuIHtcbiAgICAgICAgbGV0IHJlcXVpcmVkRmVhdHVyZXM6IEFycmF5PHN0cmluZz4gPSBbXG4gICAgICAgICAgICAvLyBOYXZpZ2F0b3IgbWVkaWFEZXZpY2VzXG4gICAgICAgICAgICBcIm5hdmlnYXRvclwiLCAvLyBGb3VuZCBvbiBzb3VyY2UgY29kZSBIaUZpTWl4ZXJTZXNzaW9uLnRzLCBSYXZpU3RyZWFtQ29udHJvbGxlci50c1xuICAgICAgICAgICAgXCJuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYVwiLCAvLyBGb3VuZCBvbiBzb3VyY2UgY29kZSBIaUZpTWl4ZXJTZXNzaW9uLnRzIChsbi41OTApXG4gICAgICAgICAgICBcIm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHNcIiwgLy8gRm91bmQgb24gc291cmNlIGNvZGUgSGlGaVV0aWxpdGllcyAobG4uIDEzMCwgMTM0LCAxMzgpXG4gICAgICAgICAgICAvLyBXZWJSVENcbiAgICAgICAgICAgIFwid2luZG93Lk1lZGlhU3RyZWFtXCIsIC8vIEZvdW5kIG9uIHNvdXJjZSBjb2RlIEhpRmlDb21tdW5pY2F0b3IudHMsIEhpRmlNaXhlclNlc3Npb24udHMsIFJhdmlTZXNzaW9uLnRzLCBSYXZpU3RyZWFtQ29udHJvbGxlci50c1xuICAgICAgICAgICAgXCJ3aW5kb3cuUlRDRGF0YUNoYW5uZWxcIiwgLy8gRm91bmQgb24gc291cmNlIGNvZGUgUmF2aUNvbW1hbmRDb250cm9sbGVyLnRzIChsbi4xNTEpXG4gICAgICAgICAgICBcIndpbmRvdy5SVENQZWVyQ29ubmVjdGlvblwiLCAvLyBGb3VuZCBvbiBzb3VyY2UgY29kZSBSYXZpU2Vzc2lvbi50cyAobG4uNjAzKVxuICAgICAgICAgICAgXCJ3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uXCIgLy8gRm91bmQgb24gc291cmNlIGNvZGUgUmF2aVNlc3Npb24udHMgKGxuLjYwNClcbiAgICAgICAgXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVpcmVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGV2YWwocmVxdWlyZWRGZWF0dXJlc1tpXSkpID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihcIkhpRmkgQXVkaW8gQVBJOiBUaGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0OiBcIiArIHJlcXVpcmVkRmVhdHVyZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZEZlYXR1cmVzW2ldID09PSBcIm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgSGlGaUxvZ2dlci5lcnJvcihcIkhpRmkgQXVkaW8gQVBJOiBZb3VyIGJyb3dzZXIgbWF5IGJlIHByZXZlbnRpbmcgYWNjZXNzIHRvIHRoaXMgZmVhdHVyZSBpZiB5b3UgYXJlIHJ1bm5pbmcgaW4gYW4gaW5zZWN1cmUgY29udGV4dCwgaS5lLiBhbiBgaHR0cGAgc2VydmVyLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBub25hbih2OiBudW1iZXIsIGlmbmFuOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gKGlzTmFOKHYpID8gaWZuYW4gOiB2KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xhbXAodjogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICAvLyBpZiB2IGlzIE5hbiByZXR1cm5zIE5hblxuICAgICAgICByZXR1cm4gKHYgPiBtYXggPyBtYXggOiAodiA8IG1pbiA/IG1pbiA6IHYpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xhbXBOb25hbih2OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgaWZuYW46IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAodiA+IG1heCA/IG1heCA6ICh2IDwgbWluID8gbWluIDogSGlGaVV0aWxpdGllcy5ub25hbih2LCBpZm5hbikpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xhbXBOb3JtYWxpemVkKHY6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIC8vIGlmIHYgaXMgTmFuIHJldHVybnMgTmFuXG4gICAgICAgIHJldHVybiAodiA+IDEuMCA/IDEuMCA6ICh2IDwgLTEuMCA/IC0xLjAgOiB2KSk7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd3cyBkb2VzIG5vdCB3b3JrIGluIHRoZSBicm93c2VyLiBCcm93c2VyIGNsaWVudHMgbXVzdCB1c2UgdGhlIG5hdGl2ZSAnICtcbiAgICAgICdXZWJTb2NrZXQgb2JqZWN0J1xuICApO1xufTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdGlmKF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0pIHtcblx0XHRyZXR1cm4gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmhtZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlID0gT2JqZWN0LmNyZWF0ZShtb2R1bGUpO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsICdleHBvcnRzJywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0c2V0OiAoKSA9PiB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VTIE1vZHVsZXMgbWF5IG5vdCBhc3NpZ24gbW9kdWxlLmV4cG9ydHMgb3IgZXhwb3J0cy4qLCBVc2UgRVNNIGV4cG9ydCBzeW50YXgsIGluc3RlYWQ6ICcgKyBtb2R1bGUuaWQpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvLyBtb2R1bGUgZXhwb3J0cyBtdXN0IGJlIHJldHVybmVkIGZyb20gcnVudGltZSBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG5yZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2luZGV4LnRzXCIpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==